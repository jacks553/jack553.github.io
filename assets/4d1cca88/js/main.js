/*!
 * jQuery JavaScript Library v3.4.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2019-05-01T21:04Z
 ../../../_/default.htm
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol ../../../_/default.htm
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.4.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code, options ) {
		DOMEval( code, { nonce: options && options.nonce } );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.4
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2019-04-08
 ../../../_/default.htm
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) &&

				// Support: IE 8 only
				// Exclude object elements
				(nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 && rdescend.test( selector ) ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 ../../../_/default.htm
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 ../../../_/default.htm
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 ../../../_/default.htm
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 ../../../_/default.htm
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 ../../../_/default.htm
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 ../../../_/default.htm
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 ../../../_/default.htm
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 ../../../_/default.htm
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 ../../../_/default.htm
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 ../../../_/default.htm
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 ../../../_/default.htm
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 ../../../_/default.htm
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = (elem.ownerDocument || elem).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 ../../../_/default.htm
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- ../../../_/default.htm

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- ../../../_/default.htm

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- ../../../_/default.htm

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- ../../../_/default.htm
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- ../../../_/default.htm

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 ../../../_/default.htm
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 ../../../_/default.htm
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			../../../_/default.htm
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff ../../../default.htm first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only ../../../_/default.htm ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 ../../../_/default.htm
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( typeof elem.contentDocument !== "undefined" ) {
			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 ../../../_/default.htm
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress ../../../_/default.htm ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial ../../../default.htm 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() ../../../default.htm initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit ../../../default.htm scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 ../../../_/default.htm
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len ../../../_/default.htm

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable ../../../_/default.htm

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "../../../default.htm" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "../../../true/default.htm" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								} );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth ../../../default.htm 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	// Support: IE 9-11 only
	// Also use offsetWidth/offsetHeight for when box sizing is unreliable
	// We use getClientRects() to check for hidden/disconnected.
	// In those cases, the computed value can be trusted to be border-box
	if ( ( !support.boxSizingReliable() && isBorderBox ||
		val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) ../../../default.htm 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func ../../../_/default.htm

			anim.done( function() {

			/* eslint-enable no-loop-func ../../../_/default.htm

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining ../../../default.htm animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" ../../../_/default.htm

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" ../../../_/default.htm

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign ../../../_/default.htm

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign ../../../_/default.htm
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 ../../../_/default.htm
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 ../../../_/default.htm
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "../../../_/default.htm".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 ../../../_/default.htm
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 ../../../_/default.htm
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		../../../_/default.htm

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url, options ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 ../../../_/default.htm
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

/**
 * sifter.js
 * Copyright (c) 2013 Brian Reavis & contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 * @author Brian Reavis <brian@thirdroute.com>
 ../../../_/default.htm

(function(root, factory) {
	if (typeof define === 'function' && define.amd) {
		define('sifter', factory);
	} else if (typeof exports === 'object') {
		module.exports = factory();
	} else {
		root.Sifter = factory();
	}
}(this, function() {

	/**
	 * Textually searches arrays and hashes of objects
	 * by property (or multiple properties). Designed
	 * specifically for autocomplete.
	 *
	 * @constructor
	 * @param {array|object} items
	 * @param {object} items
	 ../../../_/default.htm
	var Sifter = function(items, settings) {
		this.items = items;
		this.settings = settings || {diacritics: true};
	};

	/**
	 * Splits a search string into an array of individual
	 * regexps to be used to match results.
	 *
	 * @param {string} query
	 * @returns {array}
	 ../../../_/default.htm
	Sifter.prototype.tokenize = function(query) {
		query = trim(String(query || '').toLowerCase());
		if (!query || !query.length) return [];

		var i, n, regex, letter;
		var tokens = [];
		var words = query.split(/ +/);

		for (i = 0, n = words.length; i < n; i++) {
			regex = escape_regex(words[i]);
			if (this.settings.diacritics) {
				for (letter in DIACRITICS) {
					if (DIACRITICS.hasOwnProperty(letter)) {
						regex = regex.replace(new RegExp(letter, 'g'), DIACRITICS[letter]);
					}
				}
			}
			tokens.push({
				string : words[i],
				regex  : new RegExp(regex, 'i')
			});
		}

		return tokens;
	};

	/**
	 * Iterates over arrays and hashes.
	 *
	 * ```
	 * this.iterator(this.items, function(item, id) {
	 *    // invoked for each item
	 * });
	 * ```
	 *
	 * @param {array|object} object
	 ../../../_/default.htm
	Sifter.prototype.iterator = function(object, callback) {
		var iterator;
		if (is_array(object)) {
			iterator = Array.prototype.forEach || function(callback) {
				for (var i = 0, n = this.length; i < n; i++) {
					callback(this[i], i, this);
				}
			};
		} else {
			iterator = function(callback) {
				for (var key in this) {
					if (this.hasOwnProperty(key)) {
						callback(this[key], key, this);
					}
				}
			};
		}

		iterator.apply(object, [callback]);
	};

	/**
	 * Returns a function to be used to score individual results.
	 *
	 * Good matches will have a higher score than poor matches.
	 * If an item is not a match, 0 will be returned by the function.
	 *
	 * @param {object|string} search
	 * @param {object} options (optional)
	 * @returns {function}
	 ../../../_/default.htm
	Sifter.prototype.getScoreFunction = function(search, options) {
		var self, fields, tokens, token_count, nesting;

		self        = this;
		search      = self.prepareSearch(search, options);
		tokens      = search.tokens;
		fields      = search.options.fields;
		token_count = tokens.length;
		nesting     = search.options.nesting;

		/**
		 * Calculates how close of a match the
		 * given value is against a search token.
		 *
		 * @param {mixed} value
		 * @param {object} token
		 * @return {number}
		 ../../../_/default.htm
		var scoreValue = function(value, token) {
			var score, pos;

			if (!value) return 0;
			value = String(value || '');
			pos = value.search(token.regex);
			if (pos === -1) return 0;
			score = token.string.length ../../../default.htm value.length;
			if (pos === 0) score += 0.5;
			return score;
		};

		/**
		 * Calculates the score of an object
		 * against the search query.
		 *
		 * @param {object} token
		 * @param {object} data
		 * @return {number}
		 ../../../_/default.htm
		var scoreObject = (function() {
			var field_count = fields.length;
			if (!field_count) {
				return function() { return 0; };
			}
			if (field_count === 1) {
				return function(token, data) {
					return scoreValue(getattr(data, fields[0], nesting), token);
				};
			}
			return function(token, data) {
				for (var i = 0, sum = 0; i < field_count; i++) {
					sum += scoreValue(getattr(data, fields[i], nesting), token);
				}
				return sum ../../../default.htm field_count;
			};
		})();

		if (!token_count) {
			return function() { return 0; };
		}
		if (token_count === 1) {
			return function(data) {
				return scoreObject(tokens[0], data);
			};
		}

		if (search.options.conjunction === 'and') {
			return function(data) {
				var score;
				for (var i = 0, sum = 0; i < token_count; i++) {
					score = scoreObject(tokens[i], data);
					if (score <= 0) return 0;
					sum += score;
				}
				return sum ../../../default.htm token_count;
			};
		} else {
			return function(data) {
				for (var i = 0, sum = 0; i < token_count; i++) {
					sum += scoreObject(tokens[i], data);
				}
				return sum ../../../default.htm token_count;
			};
		}
	};

	/**
	 * Returns a function that can be used to compare two
	 * results, for sorting purposes. If no sorting should
	 * be performed, `null` will be returned.
	 *
	 * @param {string|object} search
	 * @param {object} options
	 * @return function(a,b)
	 ../../../_/default.htm
	Sifter.prototype.getSortFunction = function(search, options) {
		var i, n, self, field, fields, fields_count, multiplier, multipliers, get_field, implicit_score, sort;

		self   = this;
		search = self.prepareSearch(search, options);
		sort   = (!search.query && options.sort_empty) || options.sort;

		/**
		 * Fetches the specified sort field value
		 * from a search result item.
		 *
		 * @param  {string} name
		 * @param  {object} result
		 * @return {mixed}
		 ../../../_/default.htm
		get_field = function(name, result) {
			if (name === '$score') return result.score;
			return getattr(self.items[result.id], name, options.nesting);
		};

		// parse options
		fields = [];
		if (sort) {
			for (i = 0, n = sort.length; i < n; i++) {
				if (search.query || sort[i].field !== '$score') {
					fields.push(sort[i]);
				}
			}
		}

		// the "$score" field is implied to be the primary
		// sort field, unless it's manually specified
		if (search.query) {
			implicit_score = true;
			for (i = 0, n = fields.length; i < n; i++) {
				if (fields[i].field === '$score') {
					implicit_score = false;
					break;
				}
			}
			if (implicit_score) {
				fields.unshift({field: '$score', direction: 'desc'});
			}
		} else {
			for (i = 0, n = fields.length; i < n; i++) {
				if (fields[i].field === '$score') {
					fields.splice(i, 1);
					break;
				}
			}
		}

		multipliers = [];
		for (i = 0, n = fields.length; i < n; i++) {
			multipliers.push(fields[i].direction === 'desc' ? -1 : 1);
		}

		// build function
		fields_count = fields.length;
		if (!fields_count) {
			return null;
		} else if (fields_count === 1) {
			field = fields[0].field;
			multiplier = multipliers[0];
			return function(a, b) {
				return multiplier * cmp(
					get_field(field, a),
					get_field(field, b)
				);
			};
		} else {
			return function(a, b) {
				var i, result, a_value, b_value, field;
				for (i = 0; i < fields_count; i++) {
					field = fields[i].field;
					result = multipliers[i] * cmp(
						get_field(field, a),
						get_field(field, b)
					);
					if (result) return result;
				}
				return 0;
			};
		}
	};

	/**
	 * Parses a search query and returns an object
	 * with tokens and fields ready to be populated
	 * with results.
	 *
	 * @param {string} query
	 * @param {object} options
	 * @returns {object}
	 ../../../_/default.htm
	Sifter.prototype.prepareSearch = function(query, options) {
		if (typeof query === 'object') return query;

		options = extend({}, options);

		var option_fields     = options.fields;
		var option_sort       = options.sort;
		var option_sort_empty = options.sort_empty;

		if (option_fields && !is_array(option_fields)) options.fields = [option_fields];
		if (option_sort && !is_array(option_sort)) options.sort = [option_sort];
		if (option_sort_empty && !is_array(option_sort_empty)) options.sort_empty = [option_sort_empty];

		return {
			options : options,
			query   : String(query || '').toLowerCase(),
			tokens  : this.tokenize(query),
			total   : 0,
			items   : []
		};
	};

	/**
	 * Searches through all items and returns a sorted array of matches.
	 *
	 * The `options` parameter can contain:
	 *
	 *   - fields {string|array}
	 *   - sort {array}
	 *   - score {function}
	 *   - filter {bool}
	 *   - limit {integer}
	 *
	 * Returns an object containing:
	 *
	 *   - options {object}
	 *   - query {string}
	 *   - tokens {array}
	 *   - total {int}
	 *   - items {array}
	 *
	 * @param {string} query
	 * @param {object} options
	 * @returns {object}
	 ../../../_/default.htm
	Sifter.prototype.search = function(query, options) {
		var self = this, value, score, search, calculateScore;
		var fn_sort;
		var fn_score;

		search  = this.prepareSearch(query, options);
		options = search.options;
		query   = search.query;

		// generate result scoring function
		fn_score = options.score || self.getScoreFunction(search);

		// perform search and sort
		if (query.length) {
			self.iterator(self.items, function(item, id) {
				score = fn_score(item);
				if (options.filter === false || score > 0) {
					search.items.push({'score': score, 'id': id});
				}
			});
		} else {
			self.iterator(self.items, function(item, id) {
				search.items.push({'score': 1, 'id': id});
			});
		}

		fn_sort = self.getSortFunction(search, options);
		if (fn_sort) search.items.sort(fn_sort);

		// apply limits
		search.total = search.items.length;
		if (typeof options.limit === 'number') {
			search.items = search.items.slice(0, options.limit);
		}

		return search;
	};

	// utilities
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	var cmp = function(a, b) {
		if (typeof a === 'number' && typeof b === 'number') {
			return a > b ? 1 : (a < b ? -1 : 0);
		}
		a = asciifold(String(a || ''));
		b = asciifold(String(b || ''));
		if (a > b) return 1;
		if (b > a) return -1;
		return 0;
	};

	var extend = function(a, b) {
		var i, n, k, object;
		for (i = 1, n = arguments.length; i < n; i++) {
			object = arguments[i];
			if (!object) continue;
			for (k in object) {
				if (object.hasOwnProperty(k)) {
					a[k] = object[k];
				}
			}
		}
		return a;
	};

	/**
	 * A property getter resolving dot-notation
	 * @param  {Object}  obj     The root object to fetch property on
	 * @param  {String}  name    The optionally dotted property name to fetch
	 * @param  {Boolean} nesting Handle nesting or not
	 * @return {Object}          The resolved property value
	 ../../../_/default.htm
	var getattr = function(obj, name, nesting) {
	    if (!obj || !name) return;
	    if (!nesting) return obj[name];
	    var names = name.split(".");
	    while(names.length && (obj = obj[names.shift()]));
	    return obj;
	};

	var trim = function(str) {
		return (str + '').replace(/^\s+|\s+$|/g, '');
	};

	var escape_regex = function(str) {
		return (str + '').replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
	};

	var is_array = Array.isArray || (typeof $ !== 'undefined' && $.isArray) || function(object) {
		return Object.prototype.toString.call(object) === '[object Array]';
	};

	var DIACRITICS = {
		'a': '[aḀḁĂăÂâǍǎȺⱥȦȧẠạÄäÀàÁáĀāÃãÅåąĄÃąĄ]',
		'b': '[b␢βΒB฿𐌁ᛒ]',
		'c': '[cĆćĈĉČčĊċC̄c̄ÇçḈḉȻȼƇƈɕᴄＣｃ]',
		'd': '[dĎďḊḋḐḑḌḍḒḓḎḏĐđD̦d̦ƉɖƊɗƋƌᵭᶁᶑȡᴅＤｄð]',
		'e': '[eÉéÈèÊêḘḙĚěĔĕẼẽḚḛẺẻĖėËëĒēȨȩĘęᶒɆɇȄȅẾếỀềỄễỂểḜḝḖḗḔḕȆȇẸẹỆệⱸᴇＥｅɘǝƏƐε]',
		'f': '[fƑƒḞḟ]',
		'g': '[gɢ₲ǤǥĜĝĞğĢģƓɠĠġ]',
		'h': '[hĤĥĦħḨḩẖẖḤḥḢḣɦʰǶƕ]',
		'i': '[iÍíÌìĬĭÎîǏǐÏïḮḯĨĩĮįĪīỈỉȈȉȊȋỊịḬḭƗɨɨ̆ᵻᶖİiIıɪＩｉ]',
		'j': '[jȷĴĵɈɉʝɟʲ]',
		'k': '[kƘƙꝀꝁḰḱǨǩḲḳḴḵκϰ₭]',
		'l': '[lŁłĽľĻļĹĺḶḷḸḹḼḽḺḻĿŀȽƚⱠⱡⱢɫɬᶅɭȴʟＬｌ]',
		'n': '[nŃńǸǹŇňÑñṄṅŅņṆṇṊṋṈṉN̈n̈ƝɲȠƞᵰᶇɳȵɴＮｎŊŋ]',
		'o': '[oØøÖöÓóÒòÔôǑǒŐőŎŏȮȯỌọƟɵƠơỎỏŌōÕõǪǫȌȍՕօ]',
		'p': '[pṔṕṖṗⱣᵽƤƥᵱ]',
		'q': '[qꝖꝗʠɊɋꝘꝙq̃]',
		'r': '[rŔŕɌɍŘřŖŗṘṙȐȑȒȓṚṛⱤɽ]',
		's': '[sŚśṠṡṢṣꞨꞩŜŝŠšŞşȘșS̈s̈]',
		't': '[tŤťṪṫŢţṬṭƮʈȚțṰṱṮṯƬƭ]',
		'u': '[uŬŭɄʉỤụÜüÚúÙùÛûǓǔŰűŬŭƯưỦủŪūŨũŲųȔȕ∪]',
		'v': '[vṼṽṾṿƲʋꝞꝟⱱʋ]',
		'w': '[wẂẃẀẁŴŵẄẅẆẇẈẉ]',
		'x': '[xẌẍẊẋχ]',
		'y': '[yÝýỲỳŶŷŸÿỸỹẎẏỴỵɎɏƳƴ]',
		'z': '[zŹźẐẑŽžŻżẒẓẔẕƵƶ]'
	};

	var asciifold = (function() {
		var i, n, k, chunk;
		var foreignletters = '';
		var lookup = {};
		for (k in DIACRITICS) {
			if (DIACRITICS.hasOwnProperty(k)) {
				chunk = DIACRITICS[k].substring(2, DIACRITICS[k].length - 1);
				foreignletters += chunk;
				for (i = 0, n = chunk.length; i < n; i++) {
					lookup[chunk.charAt(i)] = k;
				}
			}
		}
		var regexp = new RegExp('[' +  foreignletters + ']', 'g');
		return function(str) {
			return str.replace(regexp, function(foreignletter) {
				return lookup[foreignletter];
			}).toLowerCase();
		};
	})();


	// export
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	return Sifter;
}));



/**
 * microplugin.js
 * Copyright (c) 2013 Brian Reavis & contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 * @author Brian Reavis <brian@thirdroute.com>
 ../../../_/default.htm

(function(root, factory) {
	if (typeof define === 'function' && define.amd) {
		define('microplugin', factory);
	} else if (typeof exports === 'object') {
		module.exports = factory();
	} else {
		root.MicroPlugin = factory();
	}
}(this, function() {
	var MicroPlugin = {};

	MicroPlugin.mixin = function(Interface) {
		Interface.plugins = {};

		/**
		 * Initializes the listed plugins (with options).
		 * Acceptable formats:
		 *
		 * List (without options):
		 *   ['a', 'b', 'c']
		 *
		 * List (with options):
		 *   [{'name': 'a', options: {}}, {'name': 'b', options: {}}]
		 *
		 * Hash (with options):
		 *   {'a': { ... }, 'b': { ... }, 'c': { ... }}
		 *
		 * @param {mixed} plugins
		 ../../../_/default.htm
		Interface.prototype.initializePlugins = function(plugins) {
			var i, n, key;
			var self  = this;
			var queue = [];

			self.plugins = {
				names     : [],
				settings  : {},
				requested : {},
				loaded    : {}
			};

			if (utils.isArray(plugins)) {
				for (i = 0, n = plugins.length; i < n; i++) {
					if (typeof plugins[i] === 'string') {
						queue.push(plugins[i]);
					} else {
						self.plugins.settings[plugins[i].name] = plugins[i].options;
						queue.push(plugins[i].name);
					}
				}
			} else if (plugins) {
				for (key in plugins) {
					if (plugins.hasOwnProperty(key)) {
						self.plugins.settings[key] = plugins[key];
						queue.push(key);
					}
				}
			}

			while (queue.length) {
				self.require(queue.shift());
			}
		};

		Interface.prototype.loadPlugin = function(name) {
			var self    = this;
			var plugins = self.plugins;
			var plugin  = Interface.plugins[name];

			if (!Interface.plugins.hasOwnProperty(name)) {
				throw new Error('Unable to find "' +  name + '" plugin');
			}

			plugins.requested[name] = true;
			plugins.loaded[name] = plugin.fn.apply(self, [self.plugins.settings[name] || {}]);
			plugins.names.push(name);
		};

		/**
		 * Initializes a plugin.
		 *
		 * @param {string} name
		 ../../../_/default.htm
		Interface.prototype.require = function(name) {
			var self = this;
			var plugins = self.plugins;

			if (!self.plugins.loaded.hasOwnProperty(name)) {
				if (plugins.requested[name]) {
					throw new Error('Plugin has circular dependency ("' + name + '")');
				}
				self.loadPlugin(name);
			}

			return plugins.loaded[name];
		};

		/**
		 * Registers a plugin.
		 *
		 * @param {string} name
		 * @param {function} fn
		 ../../../_/default.htm
		Interface.define = function(name, fn) {
			Interface.plugins[name] = {
				'name' : name,
				'fn'   : fn
			};
		};
	};

	var utils = {
		isArray: Array.isArray || function(vArg) {
			return Object.prototype.toString.call(vArg) === '[object Array]';
		}
	};

	return MicroPlugin;
}));

/**
 * selectize.js (v0.12.6)
 * Copyright (c) 2013–2015 Brian Reavis & contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 * @author Brian Reavis <brian@thirdroute.com>
 ../../../_/default.htm

/*jshint curly:false ../../../_/default.htm
/*jshint browser:true ../../../_/default.htm

(function(root, factory) {
	if (typeof define === 'function' && define.amd) {
		define('selectize', ['jquery','sifter','microplugin'], factory);
	} else if (typeof exports === 'object') {
		module.exports = factory(require('jquery'), require('sifter'), require('microplugin'));
	} else {
		root.Selectize = factory(root.jQuery, root.Sifter, root.MicroPlugin);
	}
}(this, function($, Sifter, MicroPlugin) {
	'use strict';

	var highlight = function($element, pattern) {
		if (typeof pattern === 'string' && !pattern.length) return;
		var regex = (typeof pattern === 'string') ? new RegExp(pattern, 'i') : pattern;
	
		var highlight = function(node) {
			var skip = 0;
			// Wrap matching part of text node with highlighting <span>, e.g.
			// Soccer  ->  <span class="highlight">Soc</span>cer  for regex = /soc/i
			if (node.nodeType === 3) {
				var pos = node.data.search(regex);
				if (pos >= 0 && node.data.length > 0) {
					var match = node.data.match(regex);
					var spannode = document.createElement('span');
					spannode.className = 'highlight';
					var middlebit = node.splitText(pos);
					var endbit = middlebit.splitText(match[0].length);
					var middleclone = middlebit.cloneNode(true);
					spannode.appendChild(middleclone);
					middlebit.parentNode.replaceChild(spannode, middlebit);
					skip = 1;
				}
			} 
			// Recurse element node, looking for child text nodes to highlight, unless element 
			// is childless, <script>, <style>, or already highlighted: <span class="hightlight">
			else if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName) && ( node.className !== 'highlight' || node.tagName !== 'SPAN' )) {
				for (var i = 0; i < node.childNodes.length; ++i) {
					i += highlight(node.childNodes[i]);
				}
			}
			return skip;
		};
	
		return $element.each(function() {
			highlight(this);
		});
	};
	
	/**
	 * removeHighlight fn copied from highlight v5 and
	 * edited to remove with() and pass js strict mode
	 ../../../_/default.htm
	$.fn.removeHighlight = function() {
		return this.find("span.highlight").each(function() {
			this.parentNode.firstChild.nodeName;
			var parent = this.parentNode;
			parent.replaceChild(this.firstChild, this);
			parent.normalize();
		}).end();
	};
	
	
	var MicroEvent = function() {};
	MicroEvent.prototype = {
		on: function(event, fct){
			this._events = this._events || {};
			this._events[event] = this._events[event] || [];
			this._events[event].push(fct);
		},
		off: function(event, fct){
			var n = arguments.length;
			if (n === 0) return delete this._events;
			if (n === 1) return delete this._events[event];
	
			this._events = this._events || {};
			if (event in this._events === false) return;
			this._events[event].splice(this._events[event].indexOf(fct), 1);
		},
		trigger: function(event /* , args... */){
			this._events = this._events || {};
			if (event in this._events === false) return;
			for (var i = 0; i < this._events[event].length; i++){
				this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
			}
		}
	};
	
	/**
	 * Mixin will delegate all MicroEvent.js function in the destination object.
	 *
	 * - MicroEvent.mixin(Foobar) will make Foobar able to use MicroEvent
	 *
	 * @param {object} the object which will support MicroEvent
	 ../../../_/default.htm
	MicroEvent.mixin = function(destObject){
		var props = ['on', 'off', 'trigger'];
		for (var i = 0; i < props.length; i++){
			destObject.prototype[props[i]] = MicroEvent.prototype[props[i]];
		}
	};
	
	var IS_MAC        = /Mac/.test(navigator.userAgent);
	
	var KEY_A         = 65;
	var KEY_COMMA     = 188;
	var KEY_RETURN    = 13;
	var KEY_ESC       = 27;
	var KEY_LEFT      = 37;
	var KEY_UP        = 38;
	var KEY_P         = 80;
	var KEY_RIGHT     = 39;
	var KEY_DOWN      = 40;
	var KEY_N         = 78;
	var KEY_BACKSPACE = 8;
	var KEY_DELETE    = 46;
	var KEY_SHIFT     = 16;
	var KEY_CMD       = IS_MAC ? 91 : 17;
	var KEY_CTRL      = IS_MAC ? 18 : 17;
	var KEY_TAB       = 9;
	
	var TAG_SELECT    = 1;
	var TAG_INPUT     = 2;
	
	// for now, android support in general is too spotty to support validity
	var SUPPORTS_VALIDITY_API = !/android/i.test(window.navigator.userAgent) && !!document.createElement('input').validity;
	
	
	var isset = function(object) {
		return typeof object !== 'undefined';
	};
	
	/**
	 * Converts a scalar to its best string representation
	 * for hash keys and HTML attribute values.
	 *
	 * Transformations:
	 *   'str'     -> 'str'
	 *   null      -> ''
	 *   undefined -> ''
	 *   true      -> '1'
	 *   false     -> '0'
	 *   0         -> '0'
	 *   1         -> '1'
	 *
	 * @param {string} value
	 * @returns {string|null}
	 ../../../_/default.htm
	var hash_key = function(value) {
		if (typeof value === 'undefined' || value === null) return null;
		if (typeof value === 'boolean') return value ? '1' : '0';
		return value + '';
	};
	
	/**
	 * Escapes a string for use within HTML.
	 *
	 * @param {string} str
	 * @returns {string}
	 ../../../_/default.htm
	var escape_html = function(str) {
		return (str + '')
			.replace(/&/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/"/g, '&quot;');
	};
	
	/**
	 * Escapes "$" characters in replacement strings.
	 *
	 * @param {string} str
	 * @returns {string}
	 ../../../_/default.htm
	var escape_replace = function(str) {
		return (str + '').replace(/\$/g, '$$$$');
	};
	
	var hook = {};
	
	/**
	 * Wraps `method` on `self` so that `fn`
	 * is invoked before the original method.
	 *
	 * @param {object} self
	 * @param {string} method
	 * @param {function} fn
	 ../../../_/default.htm
	hook.before = function(self, method, fn) {
		var original = self[method];
		self[method] = function() {
			fn.apply(self, arguments);
			return original.apply(self, arguments);
		};
	};
	
	/**
	 * Wraps `method` on `self` so that `fn`
	 * is invoked after the original method.
	 *
	 * @param {object} self
	 * @param {string} method
	 * @param {function} fn
	 ../../../_/default.htm
	hook.after = function(self, method, fn) {
		var original = self[method];
		self[method] = function() {
			var result = original.apply(self, arguments);
			fn.apply(self, arguments);
			return result;
		};
	};
	
	/**
	 * Wraps `fn` so that it can only be invoked once.
	 *
	 * @param {function} fn
	 * @returns {function}
	 ../../../_/default.htm
	var once = function(fn) {
		var called = false;
		return function() {
			if (called) return;
			called = true;
			fn.apply(this, arguments);
		};
	};
	
	/**
	 * Wraps `fn` so that it can only be called once
	 * every `delay` milliseconds (invoked on the falling edge).
	 *
	 * @param {function} fn
	 * @param {int} delay
	 * @returns {function}
	 ../../../_/default.htm
	var debounce = function(fn, delay) {
		var timeout;
		return function() {
			var self = this;
			var args = arguments;
			window.clearTimeout(timeout);
			timeout = window.setTimeout(function() {
				fn.apply(self, args);
			}, delay);
		};
	};
	
	/**
	 * Debounce all fired events types listed in `types`
	 * while executing the provided `fn`.
	 *
	 * @param {object} self
	 * @param {array} types
	 * @param {function} fn
	 ../../../_/default.htm
	var debounce_events = function(self, types, fn) {
		var type;
		var trigger = self.trigger;
		var event_args = {};
	
		// override trigger method
		self.trigger = function() {
			var type = arguments[0];
			if (types.indexOf(type) !== -1) {
				event_args[type] = arguments;
			} else {
				return trigger.apply(self, arguments);
			}
		};
	
		// invoke provided function
		fn.apply(self, []);
		self.trigger = trigger;
	
		// trigger queued events
		for (type in event_args) {
			if (event_args.hasOwnProperty(type)) {
				trigger.apply(self, event_args[type]);
			}
		}
	};
	
	/**
	 * A workaround for http://bugs.jquery.com/ticket/6696
	 *
	 * @param {object} $parent - Parent element to listen on.
	 * @param {string} event - Event name.
	 * @param {string} selector - Descendant selector to filter by.
	 * @param {function} fn - Event handler.
	 ../../../_/default.htm
	var watchChildEvent = function($parent, event, selector, fn) {
		$parent.on(event, selector, function(e) {
			var child = e.target;
			while (child && child.parentNode !== $parent[0]) {
				child = child.parentNode;
			}
			e.currentTarget = child;
			return fn.apply(this, [e]);
		});
	};
	
	/**
	 * Determines the current selection within a text input control.
	 * Returns an object containing:
	 *   - start
	 *   - length
	 *
	 * @param {object} input
	 * @returns {object}
	 ../../../_/default.htm
	var getSelection = function(input) {
		var result = {};
		if ('selectionStart' in input) {
			result.start = input.selectionStart;
			result.length = input.selectionEnd - result.start;
		} else if (document.selection) {
			input.focus();
			var sel = document.selection.createRange();
			var selLen = document.selection.createRange().text.length;
			sel.moveStart('character', -input.value.length);
			result.start = sel.text.length - selLen;
			result.length = selLen;
		}
		return result;
	};
	
	/**
	 * Copies CSS properties from one element to another.
	 *
	 * @param {object} $from
	 * @param {object} $to
	 * @param {array} properties
	 ../../../_/default.htm
	var transferStyles = function($from, $to, properties) {
		var i, n, styles = {};
		if (properties) {
			for (i = 0, n = properties.length; i < n; i++) {
				styles[properties[i]] = $from.css(properties[i]);
			}
		} else {
			styles = $from.css();
		}
		$to.css(styles);
	};
	
	/**
	 * Measures the width of a string within a
	 * parent element (in pixels).
	 *
	 * @param {string} str
	 * @param {object} $parent
	 * @returns {int}
	 ../../../_/default.htm
	var measureString = function(str, $parent) {
		if (!str) {
			return 0;
		}
	
		if (!Selectize.$testInput) {
			Selectize.$testInput = $('<span ../../../default.htm>').css({
				position: 'absolute',
				top: -99999,
				left: -99999,
				width: 'auto',
				padding: 0,
				whiteSpace: 'pre'
			}).appendTo('body');
		}
	
		Selectize.$testInput.text(str);
	
		transferStyles($parent, Selectize.$testInput, [
			'letterSpacing',
			'fontSize',
			'fontFamily',
			'fontWeight',
			'textTransform'
		]);
	
		return Selectize.$testInput.width();
	};
	
	/**
	 * Sets up an input to grow horizontally as the user
	 * types. If the value is changed manually, you can
	 * trigger the "update" handler to resize:
	 *
	 * $input.trigger('update');
	 *
	 * @param {object} $input
	 ../../../_/default.htm
	var autoGrow = function($input) {
		var currentWidth = null;
	
		var update = function(e, options) {
			var value, keyCode, printable, placeholder, width;
			var shift, character, selection;
			e = e || window.event || {};
			options = options || {};
	
			if (e.metaKey || e.altKey) return;
			if (!options.force && $input.data('grow') === false) return;
	
			value = $input.val();
			if (e.type && e.type.toLowerCase() === 'keydown') {
				keyCode = e.keyCode;
				printable = (
					(keyCode >= 48 && keyCode <= 57)  || // 0-9
					(keyCode >= 65 && keyCode <= 90)   || // a-z
					(keyCode >= 96 && keyCode <= 111)  || // numpad 0-9, numeric operators
					(keyCode >= 186 && keyCode <= 222) || // semicolon, equal, comma, dash, etc.
					keyCode === 32 // space
				);
	
				if (keyCode === KEY_DELETE || keyCode === KEY_BACKSPACE) {
					selection = getSelection($input[0]);
					if (selection.length) {
						value = value.substring(0, selection.start) + value.substring(selection.start + selection.length);
					} else if (keyCode === KEY_BACKSPACE && selection.start) {
						value = value.substring(0, selection.start - 1) + value.substring(selection.start + 1);
					} else if (keyCode === KEY_DELETE && typeof selection.start !== 'undefined') {
						value = value.substring(0, selection.start) + value.substring(selection.start + 1);
					}
				} else if (printable) {
					shift = e.shiftKey;
					character = String.fromCharCode(e.keyCode);
					if (shift) character = character.toUpperCase();
					else character = character.toLowerCase();
					value += character;
				}
			}
	
			placeholder = $input.attr('placeholder');
			if (!value && placeholder) {
				value = placeholder;
			}
	
			width = measureString(value, $input) + 4;
			if (width !== currentWidth) {
				currentWidth = width;
				$input.width(width);
				$input.triggerHandler('resize');
			}
		};
	
		$input.on('keydown keyup update blur', update);
		update();
	};
	
	var domToString = function(d) {
		var tmp = document.createElement('div');
	
		tmp.appendChild(d.cloneNode(true));
	
		return tmp.innerHTML;
	};
	
	var logError = function(message, options){
		if(!options) options = {};
		var component = "Selectize";
	
		console.error(component + ": " + message)
	
		if(options.explanation){
			// console.group is undefined in <IE11
			if(console.group) console.group();
			console.error(options.explanation);
			if(console.group) console.groupEnd();
		}
	}
	
	
	var Selectize = function($input, settings) {
		var key, i, n, dir, input, self = this;
		input = $input[0];
		input.selectize = self;
	
		// detect rtl environment
		var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);
		dir = computedStyle ? computedStyle.getPropertyValue('direction') : input.currentStyle && input.currentStyle.direction;
		dir = dir || $input.parents('[dir]:first').attr('dir') || '';
	
		// setup default state
		$.extend(self, {
			order            : 0,
			settings         : settings,
			$input           : $input,
			tabIndex         : $input.attr('tabindex') || '',
			tagType          : input.tagName.toLowerCase() === 'select' ? TAG_SELECT : TAG_INPUT,
			rtl              : /rtl/i.test(dir),
	
			eventNS          : '.selectize' + (++Selectize.count),
			highlightedValue : null,
			isBlurring       : false,
			isOpen           : false,
			isDisabled       : false,
			isRequired       : $input.is('[required]'),
			isInvalid        : false,
			isLocked         : false,
			isFocused        : false,
			isInputHidden    : false,
			isSetup          : false,
			isShiftDown      : false,
			isCmdDown        : false,
			isCtrlDown       : false,
			ignoreFocus      : false,
			ignoreBlur       : false,
			ignoreHover      : false,
			hasOptions       : false,
			currentResults   : null,
			lastValue        : '',
			caretPos         : 0,
			loading          : 0,
			loadedSearches   : {},
	
			$activeOption    : null,
			$activeItems     : [],
	
			optgroups        : {},
			options          : {},
			userOptions      : {},
			items            : [],
			renderCache      : {},
			onSearchChange   : settings.loadThrottle === null ? self.onSearchChange : debounce(self.onSearchChange, settings.loadThrottle)
		});
	
		// search system
		self.sifter = new Sifter(this.options, {diacritics: settings.diacritics});
	
		// build options table
		if (self.settings.options) {
			for (i = 0, n = self.settings.options.length; i < n; i++) {
				self.registerOption(self.settings.options[i]);
			}
			delete self.settings.options;
		}
	
		// build optgroup table
		if (self.settings.optgroups) {
			for (i = 0, n = self.settings.optgroups.length; i < n; i++) {
				self.registerOptionGroup(self.settings.optgroups[i]);
			}
			delete self.settings.optgroups;
		}
	
		// option-dependent defaults
		self.settings.mode = self.settings.mode || (self.settings.maxItems === 1 ? 'single' : 'multi');
		if (typeof self.settings.hideSelected !== 'boolean') {
			self.settings.hideSelected = self.settings.mode === 'multi';
		}
	
		self.initializePlugins(self.settings.plugins);
		self.setupCallbacks();
		self.setupTemplates();
		self.setup();
	};
	
	// mixins
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	MicroEvent.mixin(Selectize);
	
	if(typeof MicroPlugin !== "undefined"){
		MicroPlugin.mixin(Selectize);
	}else{
		logError("Dependency MicroPlugin is missing",
			{explanation:
				"Make sure you either: (1) are using the \"standalone\" "+
				"version of Selectize, or (2) require MicroPlugin before you "+
				"load Selectize."}
		);
	}
	
	
	// methods
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	$.extend(Selectize.prototype, {
	
		/**
		 * Creates all elements and sets up event bindings.
		 ../../../_/default.htm
		setup: function() {
			var self      = this;
			var settings  = self.settings;
			var eventNS   = self.eventNS;
			var $window   = $(window);
			var $document = $(document);
			var $input    = self.$input;
	
			var $wrapper;
			var $control;
			var $control_input;
			var $dropdown;
			var $dropdown_content;
			var $dropdown_parent;
			var inputMode;
			var timeout_blur;
			var timeout_focus;
			var classes;
			var classes_plugins;
			var inputId;
	
			inputMode         = self.settings.mode;
			classes           = $input.attr('class') || '';
	
			$wrapper          = $('<div>').addClass(settings.wrapperClass).addClass(classes).addClass(inputMode);
			$control          = $('<div>').addClass(settings.inputClass).addClass('items').appendTo($wrapper);
			$control_input    = $('<input type="text" autocomplete="off" ../../../default.htm>').appendTo($control).attr('tabindex', $input.is(':disabled') ? '-1' : self.tabIndex);
			$dropdown_parent  = $(settings.dropdownParent || $wrapper);
			$dropdown         = $('<div>').addClass(settings.dropdownClass).addClass(inputMode).hide().appendTo($dropdown_parent);
			$dropdown_content = $('<div>').addClass(settings.dropdownContentClass).appendTo($dropdown);
	
			if(inputId = $input.attr('id')) {
				$control_input.attr('id', inputId + '-selectized');
				$("label[for='"+inputId+"']").attr('for', inputId + '-selectized');
			}
	
			if(self.settings.copyClassesToDropdown) {
				$dropdown.addClass(classes);
			}
	
			$wrapper.css({
				width: $input[0].style.width
			});
	
			if (self.plugins.names.length) {
				classes_plugins = 'plugin-' + self.plugins.names.join(' plugin-');
				$wrapper.addClass(classes_plugins);
				$dropdown.addClass(classes_plugins);
			}
	
			if ((settings.maxItems === null || settings.maxItems > 1) && self.tagType === TAG_SELECT) {
				$input.attr('multiple', 'multiple');
			}
	
			if (self.settings.placeholder) {
				$control_input.attr('placeholder', settings.placeholder);
			}
	
			// if splitOn was not passed in, construct it from the delimiter to allow pasting universally
			if (!self.settings.splitOn && self.settings.delimiter) {
				var delimiterEscaped = self.settings.delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
				self.settings.splitOn = new RegExp('\\s*' + delimiterEscaped + '+\\s*');
			}
	
			if ($input.attr('autocorrect')) {
				$control_input.attr('autocorrect', $input.attr('autocorrect'));
			}
	
			if ($input.attr('autocapitalize')) {
				$control_input.attr('autocapitalize', $input.attr('autocapitalize'));
			}
			$control_input[0].type = $input[0].type;
	
			self.$wrapper          = $wrapper;
			self.$control          = $control;
			self.$control_input    = $control_input;
			self.$dropdown         = $dropdown;
			self.$dropdown_content = $dropdown_content;
	
			$dropdown.on('mouseenter mousedown click', '[data-disabled]>[data-selectable]', function(e) { e.stopImmediatePropagation(); });
			$dropdown.on('mouseenter', '[data-selectable]', function() { return self.onOptionHover.apply(self, arguments); });
			$dropdown.on('mousedown click', '[data-selectable]', function() { return self.onOptionSelect.apply(self, arguments); });
			watchChildEvent($control, 'mousedown', '*:not(input)', function() { return self.onItemSelect.apply(self, arguments); });
			autoGrow($control_input);
	
			$control.on({
				mousedown : function() { return self.onMouseDown.apply(self, arguments); },
				click     : function() { return self.onClick.apply(self, arguments); }
			});
	
			$control_input.on({
				mousedown : function(e) { e.stopPropagation(); },
				keydown   : function() { return self.onKeyDown.apply(self, arguments); },
				keyup     : function() { return self.onKeyUp.apply(self, arguments); },
				keypress  : function() { return self.onKeyPress.apply(self, arguments); },
				resize    : function() { self.positionDropdown.apply(self, []); },
				blur      : function() { return self.onBlur.apply(self, arguments); },
				focus     : function() { self.ignoreBlur = false; return self.onFocus.apply(self, arguments); },
				paste     : function() { return self.onPaste.apply(self, arguments); }
			});
	
			$document.on('keydown' + eventNS, function(e) {
				self.isCmdDown = e[IS_MAC ? 'metaKey' : 'ctrlKey'];
				self.isCtrlDown = e[IS_MAC ? 'altKey' : 'ctrlKey'];
				self.isShiftDown = e.shiftKey;
			});
	
			$document.on('keyup' + eventNS, function(e) {
				if (e.keyCode === KEY_CTRL) self.isCtrlDown = false;
				if (e.keyCode === KEY_SHIFT) self.isShiftDown = false;
				if (e.keyCode === KEY_CMD) self.isCmdDown = false;
			});
	
			$document.on('mousedown' + eventNS, function(e) {
				if (self.isFocused) {
					// prevent events on the dropdown scrollbar from causing the control to blur
					if (e.target === self.$dropdown[0] || e.target.parentNode === self.$dropdown[0]) {
						return false;
					}
					// blur on click outside
					if (!self.$control.has(e.target).length && e.target !== self.$control[0]) {
						self.blur(e.target);
					}
				}
			});
	
			$window.on(['scroll' + eventNS, 'resize' + eventNS].join(' '), function() {
				if (self.isOpen) {
					self.positionDropdown.apply(self, arguments);
				}
			});
			$window.on('mousemove' + eventNS, function() {
				self.ignoreHover = false;
			});
	
			// store original children and tab index so that they can be
			// restored when the destroy() method is called.
			this.revertSettings = {
				$children : $input.children().detach(),
				tabindex  : $input.attr('tabindex')
			};
	
			$input.attr('tabindex', -1).hide().after(self.$wrapper);
	
			if ($.isArray(settings.items)) {
				self.setValue(settings.items);
				delete settings.items;
			}
	
			// feature detect for the validation API
			if (SUPPORTS_VALIDITY_API) {
				$input.on('invalid' + eventNS, function(e) {
					e.preventDefault();
					self.isInvalid = true;
					self.refreshState();
				});
			}
	
			self.updateOriginalInput();
			self.refreshItems();
			self.refreshState();
			self.updatePlaceholder();
			self.isSetup = true;
	
			if ($input.is(':disabled')) {
				self.disable();
			}
	
			self.on('change', this.onChange);
	
			$input.data('selectize', self);
			$input.addClass('selectized');
			self.trigger('initialize');
	
			// preload options
			if (settings.preload === true) {
				self.onSearchChange('');
			}
	
		},
	
		/**
		 * Sets up default rendering functions.
		 ../../../_/default.htm
		setupTemplates: function() {
			var self = this;
			var field_label = self.settings.labelField;
			var field_optgroup = self.settings.optgroupLabelField;
	
			var templates = {
				'optgroup': function(data) {
					return '<div class="optgroup">' + data.html + '</div>';
				},
				'optgroup_header': function(data, escape) {
					return '<div class="optgroup-header">' + escape(data[field_optgroup]) + '</div>';
				},
				'option': function(data, escape) {
					return '<div class="option">' + escape(data[field_label]) + '</div>';
				},
				'item': function(data, escape) {
					return '<div class="item">' + escape(data[field_label]) + '</div>';
				},
				'option_create': function(data, escape) {
					return '<div class="create">Add <strong>' + escape(data.input) + '</strong>&hellip;</div>';
				}
			};
	
			self.settings.render = $.extend({}, templates, self.settings.render);
		},
	
		/**
		 * Maps fired events to callbacks provided
		 * in the settings used when creating the control.
		 ../../../_/default.htm
		setupCallbacks: function() {
			var key, fn, callbacks = {
				'initialize'      : 'onInitialize',
				'change'          : 'onChange',
				'item_add'        : 'onItemAdd',
				'item_remove'     : 'onItemRemove',
				'clear'           : 'onClear',
				'option_add'      : 'onOptionAdd',
				'option_remove'   : 'onOptionRemove',
				'option_clear'    : 'onOptionClear',
				'optgroup_add'    : 'onOptionGroupAdd',
				'optgroup_remove' : 'onOptionGroupRemove',
				'optgroup_clear'  : 'onOptionGroupClear',
				'dropdown_open'   : 'onDropdownOpen',
				'dropdown_close'  : 'onDropdownClose',
				'type'            : 'onType',
				'load'            : 'onLoad',
				'focus'           : 'onFocus',
				'blur'            : 'onBlur'
			};
	
			for (key in callbacks) {
				if (callbacks.hasOwnProperty(key)) {
					fn = this.settings[callbacks[key]];
					if (fn) this.on(key, fn);
				}
			}
		},
	
		/**
		 * Triggered when the main control element
		 * has a click event.
		 *
		 * @param {object} e
		 * @return {boolean}
		 ../../../_/default.htm
		onClick: function(e) {
			var self = this;
	
			// necessary for mobile webkit devices (manual focus triggering
			// is ignored unless invoked within a click event)
	    // also necessary to reopen a dropdown that has been closed by
	    // closeAfterSelect
			if (!self.isFocused || !self.isOpen) {
				self.focus();
				e.preventDefault();
			}
		},
	
		/**
		 * Triggered when the main control element
		 * has a mouse down event.
		 *
		 * @param {object} e
		 * @return {boolean}
		 ../../../_/default.htm
		onMouseDown: function(e) {
			var self = this;
			var defaultPrevented = e.isDefaultPrevented();
			var $target = $(e.target);
	
			if (self.isFocused) {
				// retain focus by preventing native handling. if the
				// event target is the input it should not be modified.
				// otherwise, text selection within the input won't work.
				if (e.target !== self.$control_input[0]) {
					if (self.settings.mode === 'single') {
						// toggle dropdown
						self.isOpen ? self.close() : self.open();
					} else if (!defaultPrevented) {
						self.setActiveItem(null);
					}
					return false;
				}
			} else {
				// give control focus
				if (!defaultPrevented) {
					window.setTimeout(function() {
						self.focus();
					}, 0);
				}
			}
		},
	
		/**
		 * Triggered when the value of the control has been changed.
		 * This should propagate the event to the original DOM
		 * input ../../../default.htm select element.
		 ../../../_/default.htm
		onChange: function() {
			this.$input.trigger('change');
		},
	
		/**
		 * Triggered on <input> paste.
		 *
		 * @param {object} e
		 * @returns {boolean}
		 ../../../_/default.htm
		onPaste: function(e) {
			var self = this;
	
			if (self.isFull() || self.isInputHidden || self.isLocked) {
				e.preventDefault();
				return;
			}
	
			// If a regex or string is included, this will split the pasted
			// input and create Items for each separate value
			if (self.settings.splitOn) {
	
				// Wait for pasted text to be recognized in value
				setTimeout(function() {
					var pastedText = self.$control_input.val();
					if(!pastedText.match(self.settings.splitOn)){ return }
	
					var splitInput = $.trim(pastedText).split(self.settings.splitOn);
					for (var i = 0, n = splitInput.length; i < n; i++) {
						self.createItem(splitInput[i]);
					}
				}, 0);
			}
		},
	
		/**
		 * Triggered on <input> keypress.
		 *
		 * @param {object} e
		 * @returns {boolean}
		 ../../../_/default.htm
		onKeyPress: function(e) {
			if (this.isLocked) return e && e.preventDefault();
			var character = String.fromCharCode(e.keyCode || e.which);
			if (this.settings.create && this.settings.mode === 'multi' && character === this.settings.delimiter) {
				this.createItem();
				e.preventDefault();
				return false;
			}
		},
	
		/**
		 * Triggered on <input> keydown.
		 *
		 * @param {object} e
		 * @returns {boolean}
		 ../../../_/default.htm
		onKeyDown: function(e) {
			var isInput = e.target === this.$control_input[0];
			var self = this;
	
			if (self.isLocked) {
				if (e.keyCode !== KEY_TAB) {
					e.preventDefault();
				}
				return;
			}
	
			switch (e.keyCode) {
				case KEY_A:
					if (self.isCmdDown) {
						self.selectAll();
						return;
					}
					break;
				case KEY_ESC:
					if (self.isOpen) {
						e.preventDefault();
						e.stopPropagation();
						self.close();
					}
					return;
				case KEY_N:
					if (!e.ctrlKey || e.altKey) break;
				case KEY_DOWN:
					if (!self.isOpen && self.hasOptions) {
						self.open();
					} else if (self.$activeOption) {
						self.ignoreHover = true;
						var $next = self.getAdjacentOption(self.$activeOption, 1);
						if ($next.length) self.setActiveOption($next, true, true);
					}
					e.preventDefault();
					return;
				case KEY_P:
					if (!e.ctrlKey || e.altKey) break;
				case KEY_UP:
					if (self.$activeOption) {
						self.ignoreHover = true;
						var $prev = self.getAdjacentOption(self.$activeOption, -1);
						if ($prev.length) self.setActiveOption($prev, true, true);
					}
					e.preventDefault();
					return;
				case KEY_RETURN:
					if (self.isOpen && self.$activeOption) {
						self.onOptionSelect({currentTarget: self.$activeOption});
						e.preventDefault();
					}
					return;
				case KEY_LEFT:
					self.advanceSelection(-1, e);
					return;
				case KEY_RIGHT:
					self.advanceSelection(1, e);
					return;
				case KEY_TAB:
					if (self.settings.selectOnTab && self.isOpen && self.$activeOption) {
						self.onOptionSelect({currentTarget: self.$activeOption});
	
						// Default behaviour is to jump to the next field, we only want this
						// if the current field doesn't accept any more entries
						if (!self.isFull()) {
							e.preventDefault();
						}
					}
					if (self.settings.create && self.createItem()) {
						e.preventDefault();
					}
					return;
				case KEY_BACKSPACE:
				case KEY_DELETE:
					self.deleteSelection(e);
					return;
			}
	
			if ((self.isFull() || self.isInputHidden) && !(IS_MAC ? e.metaKey : e.ctrlKey)) {
				e.preventDefault();
				return;
			}
		},
	
		/**
		 * Triggered on <input> keyup.
		 *
		 * @param {object} e
		 * @returns {boolean}
		 ../../../_/default.htm
		onKeyUp: function(e) {
			var self = this;
	
			if (self.isLocked) return e && e.preventDefault();
			var value = self.$control_input.val() || '';
			if (self.lastValue !== value) {
				self.lastValue = value;
				self.onSearchChange(value);
				self.refreshOptions();
				self.trigger('type', value);
			}
		},
	
		/**
		 * Invokes the user-provide option provider ../../../default.htm loader.
		 *
		 * Note: this function is debounced in the Selectize
		 * constructor (by `settings.loadThrottle` milliseconds)
		 *
		 * @param {string} value
		 ../../../_/default.htm
		onSearchChange: function(value) {
			var self = this;
			var fn = self.settings.load;
			if (!fn) return;
			if (self.loadedSearches.hasOwnProperty(value)) return;
			self.loadedSearches[value] = true;
			self.load(function(callback) {
				fn.apply(self, [value, callback]);
			});
		},
	
		/**
		 * Triggered on <input> focus.
		 *
		 * @param {object} e (optional)
		 * @returns {boolean}
		 ../../../_/default.htm
		onFocus: function(e) {
			var self = this;
			var wasFocused = self.isFocused;
	
			if (self.isDisabled) {
				self.blur();
				e && e.preventDefault();
				return false;
			}
	
			if (self.ignoreFocus) return;
			self.isFocused = true;
			if (self.settings.preload === 'focus') self.onSearchChange('');
	
			if (!wasFocused) self.trigger('focus');
	
			if (!self.$activeItems.length) {
				self.showInput();
				self.setActiveItem(null);
				self.refreshOptions(!!self.settings.openOnFocus);
			}
	
			self.refreshState();
		},
	
		/**
		 * Triggered on <input> blur.
		 *
		 * @param {object} e
		 * @param {Element} dest
		 ../../../_/default.htm
		onBlur: function(e, dest) {
			var self = this;
			if (!self.isFocused) return;
			self.isFocused = false;
	
			if (self.ignoreFocus) {
				return;
			} else if (!self.ignoreBlur && document.activeElement === self.$dropdown_content[0]) {
				// necessary to prevent IE closing the dropdown when the scrollbar is clicked
				self.ignoreBlur = true;
				self.onFocus(e);
				return;
			}
	
			var deactivate = function() {
				self.close();
				self.setTextboxValue('');
				self.setActiveItem(null);
				self.setActiveOption(null);
				self.setCaret(self.items.length);
				self.refreshState();
	
				// IE11 bug: element still marked as active
				dest && dest.focus && dest.focus();
	
				self.isBlurring = false;
				self.ignoreFocus = false;
				self.trigger('blur');
			};
	
			self.isBlurring = true;
			self.ignoreFocus = true;
			if (self.settings.create && self.settings.createOnBlur) {
				self.createItem(null, false, deactivate);
			} else {
				deactivate();
			}
		},
	
		/**
		 * Triggered when the user rolls over
		 * an option in the autocomplete dropdown menu.
		 *
		 * @param {object} e
		 * @returns {boolean}
		 ../../../_/default.htm
		onOptionHover: function(e) {
			if (this.ignoreHover) return;
			this.setActiveOption(e.currentTarget, false);
		},
	
		/**
		 * Triggered when the user clicks on an option
		 * in the autocomplete dropdown menu.
		 *
		 * @param {object} e
		 * @returns {boolean}
		 ../../../_/default.htm
		onOptionSelect: function(e) {
			var value, $target, $option, self = this;
	
			if (e.preventDefault) {
				e.preventDefault();
				e.stopPropagation();
			}
	
			$target = $(e.currentTarget);
			if ($target.hasClass('create')) {
				self.createItem(null, function() {
					if (self.settings.closeAfterSelect) {
						self.close();
					}
				});
			} else {
				value = $target.attr('data-value');
				if (typeof value !== 'undefined') {
					self.lastQuery = null;
					self.setTextboxValue('');
					self.addItem(value);
					if (self.settings.closeAfterSelect) {
						self.close();
					} else if (!self.settings.hideSelected && e.type && /mouse/.test(e.type)) {
						self.setActiveOption(self.getOption(value));
					}
				}
			}
		},
	
		/**
		 * Triggered when the user clicks on an item
		 * that has been selected.
		 *
		 * @param {object} e
		 * @returns {boolean}
		 ../../../_/default.htm
		onItemSelect: function(e) {
			var self = this;
	
			if (self.isLocked) return;
			if (self.settings.mode === 'multi') {
				e.preventDefault();
				self.setActiveItem(e.currentTarget, e);
			}
		},
	
		/**
		 * Invokes the provided method that provides
		 * results to a callback---which are then added
		 * as options to the control.
		 *
		 * @param {function} fn
		 ../../../_/default.htm
		load: function(fn) {
			var self = this;
			var $wrapper = self.$wrapper.addClass(self.settings.loadingClass);
	
			self.loading++;
			fn.apply(self, [function(results) {
				self.loading = Math.max(self.loading - 1, 0);
				if (results && results.length) {
					self.addOption(results);
					self.refreshOptions(self.isFocused && !self.isInputHidden);
				}
				if (!self.loading) {
					$wrapper.removeClass(self.settings.loadingClass);
				}
				self.trigger('load', results);
			}]);
		},
	
		/**
		 * Sets the input field of the control to the specified value.
		 *
		 * @param {string} value
		 ../../../_/default.htm
		setTextboxValue: function(value) {
			var $input = this.$control_input;
			var changed = $input.val() !== value;
			if (changed) {
				$input.val(value).triggerHandler('update');
				this.lastValue = value;
			}
		},
	
		/**
		 * Returns the value of the control. If multiple items
		 * can be selected (e.g. <select multiple>), this returns
		 * an array. If only one item can be selected, this
		 * returns a string.
		 *
		 * @returns {mixed}
		 ../../../_/default.htm
		getValue: function() {
			if (this.tagType === TAG_SELECT && this.$input.attr('multiple')) {
				return this.items;
			} else {
				return this.items.join(this.settings.delimiter);
			}
		},
	
		/**
		 * Resets the selected items to the given value.
		 *
		 * @param {mixed} value
		 ../../../_/default.htm
		setValue: function(value, silent) {
			var events = silent ? [] : ['change'];
	
			debounce_events(this, events, function() {
				this.clear(silent);
				this.addItems(value, silent);
			});
		},
	
		/**
		 * Sets the selected item.
		 *
		 * @param {object} $item
		 * @param {object} e (optional)
		 ../../../_/default.htm
		setActiveItem: function($item, e) {
			var self = this;
			var eventName;
			var i, idx, begin, end, item, swap;
			var $last;
	
			if (self.settings.mode === 'single') return;
			$item = $($item);
	
			// clear the active selection
			if (!$item.length) {
				$(self.$activeItems).removeClass('active');
				self.$activeItems = [];
				if (self.isFocused) {
					self.showInput();
				}
				return;
			}
	
			// modify selection
			eventName = e && e.type.toLowerCase();
	
			if (eventName === 'mousedown' && self.isShiftDown && self.$activeItems.length) {
				$last = self.$control.children('.active:last');
				begin = Array.prototype.indexOf.apply(self.$control[0].childNodes, [$last[0]]);
				end   = Array.prototype.indexOf.apply(self.$control[0].childNodes, [$item[0]]);
				if (begin > end) {
					swap  = begin;
					begin = end;
					end   = swap;
				}
				for (i = begin; i <= end; i++) {
					item = self.$control[0].childNodes[i];
					if (self.$activeItems.indexOf(item) === -1) {
						$(item).addClass('active');
						self.$activeItems.push(item);
					}
				}
				e.preventDefault();
			} else if ((eventName === 'mousedown' && self.isCtrlDown) || (eventName === 'keydown' && this.isShiftDown)) {
				if ($item.hasClass('active')) {
					idx = self.$activeItems.indexOf($item[0]);
					self.$activeItems.splice(idx, 1);
					$item.removeClass('active');
				} else {
					self.$activeItems.push($item.addClass('active')[0]);
				}
			} else {
				$(self.$activeItems).removeClass('active');
				self.$activeItems = [$item.addClass('active')[0]];
			}
	
			// ensure control has focus
			self.hideInput();
			if (!this.isFocused) {
				self.focus();
			}
		},
	
		/**
		 * Sets the selected item in the dropdown menu
		 * of available options.
		 *
		 * @param {object} $object
		 * @param {boolean} scroll
		 * @param {boolean} animate
		 ../../../_/default.htm
		setActiveOption: function($option, scroll, animate) {
			var height_menu, height_item, y;
			var scroll_top, scroll_bottom;
			var self = this;
	
			if (self.$activeOption) self.$activeOption.removeClass('active');
			self.$activeOption = null;
	
			$option = $($option);
			if (!$option.length) return;
	
			self.$activeOption = $option.addClass('active');
	
			if (scroll || !isset(scroll)) {
	
				height_menu   = self.$dropdown_content.height();
				height_item   = self.$activeOption.outerHeight(true);
				scroll        = self.$dropdown_content.scrollTop() || 0;
				y             = self.$activeOption.offset().top - self.$dropdown_content.offset().top + scroll;
				scroll_top    = y;
				scroll_bottom = y - height_menu + height_item;
	
				if (y + height_item > height_menu + scroll) {
					self.$dropdown_content.stop().animate({scrollTop: scroll_bottom}, animate ? self.settings.scrollDuration : 0);
				} else if (y < scroll) {
					self.$dropdown_content.stop().animate({scrollTop: scroll_top}, animate ? self.settings.scrollDuration : 0);
				}
	
			}
		},
	
		/**
		 * Selects all items (CTRL + A).
		 ../../../_/default.htm
		selectAll: function() {
			var self = this;
			if (self.settings.mode === 'single') return;
	
			self.$activeItems = Array.prototype.slice.apply(self.$control.children(':not(input)').addClass('active'));
			if (self.$activeItems.length) {
				self.hideInput();
				self.close();
			}
			self.focus();
		},
	
		/**
		 * Hides the input element out of view, while
		 * retaining its focus.
		 ../../../_/default.htm
		hideInput: function() {
			var self = this;
	
			self.setTextboxValue('');
			self.$control_input.css({opacity: 0, position: 'absolute', left: self.rtl ? 10000 : -10000});
			self.isInputHidden = true;
		},
	
		/**
		 * Restores input visibility.
		 ../../../_/default.htm
		showInput: function() {
			this.$control_input.css({opacity: 1, position: 'relative', left: 0});
			this.isInputHidden = false;
		},
	
		/**
		 * Gives the control focus.
		 ../../../_/default.htm
		focus: function() {
			var self = this;
			if (self.isDisabled) return;
	
			self.ignoreFocus = true;
			self.$control_input[0].focus();
			window.setTimeout(function() {
				self.ignoreFocus = false;
				self.onFocus();
			}, 0);
		},
	
		/**
		 * Forces the control out of focus.
		 *
		 * @param {Element} dest
		 ../../../_/default.htm
		blur: function(dest) {
			this.$control_input[0].blur();
			this.onBlur(null, dest);
		},
	
		/**
		 * Returns a function that scores an object
		 * to show how good of a match it is to the
		 * provided query.
		 *
		 * @param {string} query
		 * @param {object} options
		 * @return {function}
		 ../../../_/default.htm
		getScoreFunction: function(query) {
			return this.sifter.getScoreFunction(query, this.getSearchOptions());
		},
	
		/**
		 * Returns search options for sifter (the system
		 * for scoring and sorting results).
		 *
		 * @see https://github.com/brianreavis/sifter.js
		 * @return {object}
		 ../../../_/default.htm
		getSearchOptions: function() {
			var settings = this.settings;
			var sort = settings.sortField;
			if (typeof sort === 'string') {
				sort = [{field: sort}];
			}
	
			return {
				fields      : settings.searchField,
				conjunction : settings.searchConjunction,
				sort        : sort,
				nesting     : settings.nesting
			};
		},
	
		/**
		 * Searches through available options and returns
		 * a sorted array of matches.
		 *
		 * Returns an object containing:
		 *
		 *   - query {string}
		 *   - tokens {array}
		 *   - total {int}
		 *   - items {array}
		 *
		 * @param {string} query
		 * @returns {object}
		 ../../../_/default.htm
		search: function(query) {
			var i, value, score, result, calculateScore;
			var self     = this;
			var settings = self.settings;
			var options  = this.getSearchOptions();
	
			// validate user-provided result scoring function
			if (settings.score) {
				calculateScore = self.settings.score.apply(this, [query]);
				if (typeof calculateScore !== 'function') {
					throw new Error('Selectize "score" setting must be a function that returns a function');
				}
			}
	
			// perform search
			if (query !== self.lastQuery) {
				self.lastQuery = query;
				result = self.sifter.search(query, $.extend(options, {score: calculateScore}));
				self.currentResults = result;
			} else {
				result = $.extend(true, {}, self.currentResults);
			}
	
			// filter out selected items
			if (settings.hideSelected) {
				for (i = result.items.length - 1; i >= 0; i--) {
					if (self.items.indexOf(hash_key(result.items[i].id)) !== -1) {
						result.items.splice(i, 1);
					}
				}
			}
	
			return result;
		},
	
		/**
		 * Refreshes the list of available options shown
		 * in the autocomplete dropdown menu.
		 *
		 * @param {boolean} triggerDropdown
		 ../../../_/default.htm
		refreshOptions: function(triggerDropdown) {
			var i, j, k, n, groups, groups_order, option, option_html, optgroup, optgroups, html, html_children, has_create_option;
			var $active, $active_before, $create;
	
			if (typeof triggerDropdown === 'undefined') {
				triggerDropdown = true;
			}
	
			var self              = this;
			var query             = $.trim(self.$control_input.val());
			var results           = self.search(query);
			var $dropdown_content = self.$dropdown_content;
			var active_before     = self.$activeOption && hash_key(self.$activeOption.attr('data-value'));
	
			// build markup
			n = results.items.length;
			if (typeof self.settings.maxOptions === 'number') {
				n = Math.min(n, self.settings.maxOptions);
			}
	
			// render and group available options individually
			groups = {};
			groups_order = [];
	
			for (i = 0; i < n; i++) {
				option      = self.options[results.items[i].id];
				option_html = self.render('option', option);
				optgroup    = option[self.settings.optgroupField] || '';
				optgroups   = $.isArray(optgroup) ? optgroup : [optgroup];
	
				for (j = 0, k = optgroups && optgroups.length; j < k; j++) {
					optgroup = optgroups[j];
					if (!self.optgroups.hasOwnProperty(optgroup)) {
						optgroup = '';
					}
					if (!groups.hasOwnProperty(optgroup)) {
						groups[optgroup] = document.createDocumentFragment();
						groups_order.push(optgroup);
					}
					groups[optgroup].appendChild(option_html);
				}
			}
	
			// sort optgroups
			if (this.settings.lockOptgroupOrder) {
				groups_order.sort(function(a, b) {
					var a_order = self.optgroups[a].$order || 0;
					var b_order = self.optgroups[b].$order || 0;
					return a_order - b_order;
				});
			}
	
			// render optgroup headers & join groups
			html = document.createDocumentFragment();
			for (i = 0, n = groups_order.length; i < n; i++) {
				optgroup = groups_order[i];
				if (self.optgroups.hasOwnProperty(optgroup) && groups[optgroup].childNodes.length) {
					// render the optgroup header and options within it,
					// then pass it to the wrapper template
					html_children = document.createDocumentFragment();
					html_children.appendChild(self.render('optgroup_header', self.optgroups[optgroup]));
					html_children.appendChild(groups[optgroup]);
	
					html.appendChild(self.render('optgroup', $.extend({}, self.optgroups[optgroup], {
						html: domToString(html_children),
						dom:  html_children
					})));
				} else {
					html.appendChild(groups[optgroup]);
				}
			}
	
			$dropdown_content.html(html);
	
			// highlight matching terms inline
			if (self.settings.highlight) {
				$dropdown_content.removeHighlight();
				if (results.query.length && results.tokens.length) {
					for (i = 0, n = results.tokens.length; i < n; i++) {
						highlight($dropdown_content, results.tokens[i].regex);
					}
				}
			}
	
			// add "selected" class to selected options
			if (!self.settings.hideSelected) {
				for (i = 0, n = self.items.length; i < n; i++) {
					self.getOption(self.items[i]).addClass('selected');
				}
			}
	
			// add create option
			has_create_option = self.canCreate(query);
			if (has_create_option) {
				$dropdown_content.prepend(self.render('option_create', {input: query}));
				$create = $($dropdown_content[0].childNodes[0]);
			}
	
			// activate
			self.hasOptions = results.items.length > 0 || has_create_option;
			if (self.hasOptions) {
				if (results.items.length > 0) {
					$active_before = active_before && self.getOption(active_before);
					if ($active_before && $active_before.length) {
						$active = $active_before;
					} else if (self.settings.mode === 'single' && self.items.length) {
						$active = self.getOption(self.items[0]);
					}
					if (!$active || !$active.length) {
						if ($create && !self.settings.addPrecedence) {
							$active = self.getAdjacentOption($create, 1);
						} else {
							$active = $dropdown_content.find('[data-selectable]:first');
						}
					}
				} else {
					$active = $create;
				}
				self.setActiveOption($active);
				if (triggerDropdown && !self.isOpen) { self.open(); }
			} else {
				self.setActiveOption(null);
				if (triggerDropdown && self.isOpen) { self.close(); }
			}
		},
	
		/**
		 * Adds an available option. If it already exists,
		 * nothing will happen. Note: this does not refresh
		 * the options list dropdown (use `refreshOptions`
		 * for that).
		 *
		 * Usage:
		 *
		 *   this.addOption(data)
		 *
		 * @param {object|array} data
		 ../../../_/default.htm
		addOption: function(data) {
			var i, n, value, self = this;
	
			if ($.isArray(data)) {
				for (i = 0, n = data.length; i < n; i++) {
					self.addOption(data[i]);
				}
				return;
			}
	
			if (value = self.registerOption(data)) {
				self.userOptions[value] = true;
				self.lastQuery = null;
				self.trigger('option_add', value, data);
			}
		},
	
		/**
		 * Registers an option to the pool of options.
		 *
		 * @param {object} data
		 * @return {boolean|string}
		 ../../../_/default.htm
		registerOption: function(data) {
			var key = hash_key(data[this.settings.valueField]);
			if (typeof key === 'undefined' || key === null || this.options.hasOwnProperty(key)) return false;
			data.$order = data.$order || ++this.order;
			this.options[key] = data;
			return key;
		},
	
		/**
		 * Registers an option group to the pool of option groups.
		 *
		 * @param {object} data
		 * @return {boolean|string}
		 ../../../_/default.htm
		registerOptionGroup: function(data) {
			var key = hash_key(data[this.settings.optgroupValueField]);
			if (!key) return false;
	
			data.$order = data.$order || ++this.order;
			this.optgroups[key] = data;
			return key;
		},
	
		/**
		 * Registers a new optgroup for options
		 * to be bucketed into.
		 *
		 * @param {string} id
		 * @param {object} data
		 ../../../_/default.htm
		addOptionGroup: function(id, data) {
			data[this.settings.optgroupValueField] = id;
			if (id = this.registerOptionGroup(data)) {
				this.trigger('optgroup_add', id, data);
			}
		},
	
		/**
		 * Removes an existing option group.
		 *
		 * @param {string} id
		 ../../../_/default.htm
		removeOptionGroup: function(id) {
			if (this.optgroups.hasOwnProperty(id)) {
				delete this.optgroups[id];
				this.renderCache = {};
				this.trigger('optgroup_remove', id);
			}
		},
	
		/**
		 * Clears all existing option groups.
		 ../../../_/default.htm
		clearOptionGroups: function() {
			this.optgroups = {};
			this.renderCache = {};
			this.trigger('optgroup_clear');
		},
	
		/**
		 * Updates an option available for selection. If
		 * it is visible in the selected items or options
		 * dropdown, it will be re-rendered automatically.
		 *
		 * @param {string} value
		 * @param {object} data
		 ../../../_/default.htm
		updateOption: function(value, data) {
			var self = this;
			var $item, $item_new;
			var value_new, index_item, cache_items, cache_options, order_old;
	
			value     = hash_key(value);
			value_new = hash_key(data[self.settings.valueField]);
	
			// sanity checks
			if (value === null) return;
			if (!self.options.hasOwnProperty(value)) return;
			if (typeof value_new !== 'string') throw new Error('Value must be set in option data');
	
			order_old = self.options[value].$order;
	
			// update references
			if (value_new !== value) {
				delete self.options[value];
				index_item = self.items.indexOf(value);
				if (index_item !== -1) {
					self.items.splice(index_item, 1, value_new);
				}
			}
			data.$order = data.$order || order_old;
			self.options[value_new] = data;
	
			// invalidate render cache
			cache_items = self.renderCache['item'];
			cache_options = self.renderCache['option'];
	
			if (cache_items) {
				delete cache_items[value];
				delete cache_items[value_new];
			}
			if (cache_options) {
				delete cache_options[value];
				delete cache_options[value_new];
			}
	
			// update the item if it's selected
			if (self.items.indexOf(value_new) !== -1) {
				$item = self.getItem(value);
				$item_new = $(self.render('item', data));
				if ($item.hasClass('active')) $item_new.addClass('active');
				$item.replaceWith($item_new);
			}
	
			// invalidate last query because we might have updated the sortField
			self.lastQuery = null;
	
			// update dropdown contents
			if (self.isOpen) {
				self.refreshOptions(false);
			}
		},
	
		/**
		 * Removes a single option.
		 *
		 * @param {string} value
		 * @param {boolean} silent
		 ../../../_/default.htm
		removeOption: function(value, silent) {
			var self = this;
			value = hash_key(value);
	
			var cache_items = self.renderCache['item'];
			var cache_options = self.renderCache['option'];
			if (cache_items) delete cache_items[value];
			if (cache_options) delete cache_options[value];
	
			delete self.userOptions[value];
			delete self.options[value];
			self.lastQuery = null;
			self.trigger('option_remove', value);
			self.removeItem(value, silent);
		},
	
		/**
		 * Clears all options.
		 ../../../_/default.htm
		clearOptions: function() {
			var self = this;
	
			self.loadedSearches = {};
			self.userOptions = {};
			self.renderCache = {};
			var options = self.options;
			$.each(self.options, function(key, value) {
				if(self.items.indexOf(key) == -1) {
					delete options[key];
				}
			});
			self.options = self.sifter.items = options;
			self.lastQuery = null;
			self.trigger('option_clear');
		},
	
		/**
		 * Returns the jQuery element of the option
		 * matching the given value.
		 *
		 * @param {string} value
		 * @returns {object}
		 ../../../_/default.htm
		getOption: function(value) {
			return this.getElementWithValue(value, this.$dropdown_content.find('[data-selectable]'));
		},
	
		/**
		 * Returns the jQuery element of the next or
		 * previous selectable option.
		 *
		 * @param {object} $option
		 * @param {int} direction  can be 1 for next or -1 for previous
		 * @return {object}
		 ../../../_/default.htm
		getAdjacentOption: function($option, direction) {
			var $options = this.$dropdown.find('[data-selectable]');
			var index    = $options.index($option) + direction;
	
			return index >= 0 && index < $options.length ? $options.eq(index) : $();
		},
	
		/**
		 * Finds the first element with a "data-value" attribute
		 * that matches the given value.
		 *
		 * @param {mixed} value
		 * @param {object} $els
		 * @return {object}
		 ../../../_/default.htm
		getElementWithValue: function(value, $els) {
			value = hash_key(value);
	
			if (typeof value !== 'undefined' && value !== null) {
				for (var i = 0, n = $els.length; i < n; i++) {
					if ($els[i].getAttribute('data-value') === value) {
						return $($els[i]);
					}
				}
			}
	
			return $();
		},
	
		/**
		 * Returns the jQuery element of the item
		 * matching the given value.
		 *
		 * @param {string} value
		 * @returns {object}
		 ../../../_/default.htm
		getItem: function(value) {
			return this.getElementWithValue(value, this.$control.children());
		},
	
		/**
		 * "Selects" multiple items at once. Adds them to the list
		 * at the current caret position.
		 *
		 * @param {string} value
		 * @param {boolean} silent
		 ../../../_/default.htm
		addItems: function(values, silent) {
			this.buffer = document.createDocumentFragment();
	
			var childNodes = this.$control[0].childNodes;
			for (var i = 0; i < childNodes.length; i++) {
				this.buffer.appendChild(childNodes[i]);
			}
	
			var items = $.isArray(values) ? values : [values];
			for (var i = 0, n = items.length; i < n; i++) {
				this.isPending = (i < n - 1);
				this.addItem(items[i], silent);
			}
	
			var control = this.$control[0];
			control.insertBefore(this.buffer, control.firstChild);
	
			this.buffer = null;
		},
	
		/**
		 * "Selects" an item. Adds it to the list
		 * at the current caret position.
		 *
		 * @param {string} value
		 * @param {boolean} silent
		 ../../../_/default.htm
		addItem: function(value, silent) {
			var events = silent ? [] : ['change'];
	
			debounce_events(this, events, function() {
				var $item, $option, $options;
				var self = this;
				var inputMode = self.settings.mode;
				var i, active, value_next, wasFull;
				value = hash_key(value);
	
				if (self.items.indexOf(value) !== -1) {
					if (inputMode === 'single') self.close();
					return;
				}
	
				if (!self.options.hasOwnProperty(value)) return;
				if (inputMode === 'single') self.clear(silent);
				if (inputMode === 'multi' && self.isFull()) return;
	
				$item = $(self.render('item', self.options[value]));
				wasFull = self.isFull();
				self.items.splice(self.caretPos, 0, value);
				self.insertAtCaret($item);
				if (!self.isPending || (!wasFull && self.isFull())) {
					self.refreshState();
				}
	
				if (self.isSetup) {
					$options = self.$dropdown_content.find('[data-selectable]');
	
					// update menu ../../../default.htm remove the option (if this is not one item being added as part of series)
					if (!self.isPending) {
						$option = self.getOption(value);
						value_next = self.getAdjacentOption($option, 1).attr('data-value');
						self.refreshOptions(self.isFocused && inputMode !== 'single');
						if (value_next) {
							self.setActiveOption(self.getOption(value_next));
						}
					}
	
					// hide the menu if the maximum number of items have been selected or no options are left
					if (!$options.length || self.isFull()) {
						self.close();
					} else if (!self.isPending) {
						self.positionDropdown();
					}
	
					self.updatePlaceholder();
					self.trigger('item_add', value, $item);
	
					if (!self.isPending) {
						self.updateOriginalInput({silent: silent});
					}
				}
			});
		},
	
		/**
		 * Removes the selected item matching
		 * the provided value.
		 *
		 * @param {string} value
		 ../../../_/default.htm
		removeItem: function(value, silent) {
			var self = this;
			var $item, i, idx;
	
			$item = (value instanceof $) ? value : self.getItem(value);
			value = hash_key($item.attr('data-value'));
			i = self.items.indexOf(value);
	
			if (i !== -1) {
				$item.remove();
				if ($item.hasClass('active')) {
					idx = self.$activeItems.indexOf($item[0]);
					self.$activeItems.splice(idx, 1);
				}
	
				self.items.splice(i, 1);
				self.lastQuery = null;
				if (!self.settings.persist && self.userOptions.hasOwnProperty(value)) {
					self.removeOption(value, silent);
				}
	
				if (i < self.caretPos) {
					self.setCaret(self.caretPos - 1);
				}
	
				self.refreshState();
				self.updatePlaceholder();
				self.updateOriginalInput({silent: silent});
				self.positionDropdown();
				self.trigger('item_remove', value, $item);
			}
		},
	
		/**
		 * Invokes the `create` method provided in the
		 * selectize options that should provide the data
		 * for the new item, given the user input.
		 *
		 * Once this completes, it will be added
		 * to the item list.
		 *
		 * @param {string} value
		 * @param {boolean} [triggerDropdown]
		 * @param {function} [callback]
		 * @return {boolean}
		 ../../../_/default.htm
		createItem: function(input, triggerDropdown) {
			var self  = this;
			var caret = self.caretPos;
			input = input || $.trim(self.$control_input.val() || '');
	
			var callback = arguments[arguments.length - 1];
			if (typeof callback !== 'function') callback = function() {};
	
			if (typeof triggerDropdown !== 'boolean') {
				triggerDropdown = true;
			}
	
			if (!self.canCreate(input)) {
				callback();
				return false;
			}
	
			self.lock();
	
			var setup = (typeof self.settings.create === 'function') ? this.settings.create : function(input) {
				var data = {};
				data[self.settings.labelField] = input;
				data[self.settings.valueField] = input;
				return data;
			};
	
			var create = once(function(data) {
				self.unlock();
	
				if (!data || typeof data !== 'object') return callback();
				var value = hash_key(data[self.settings.valueField]);
				if (typeof value !== 'string') return callback();
	
				self.setTextboxValue('');
				self.addOption(data);
				self.setCaret(caret);
				self.addItem(value);
				self.refreshOptions(triggerDropdown && self.settings.mode !== 'single');
				callback(data);
			});
	
			var output = setup.apply(this, [input, create]);
			if (typeof output !== 'undefined') {
				create(output);
			}
	
			return true;
		},
	
		/**
		 * Re-renders the selected item lists.
		 ../../../_/default.htm
		refreshItems: function() {
			this.lastQuery = null;
	
			if (this.isSetup) {
				this.addItem(this.items);
			}
	
			this.refreshState();
			this.updateOriginalInput();
		},
	
		/**
		 * Updates all state-dependent attributes
		 * and CSS classes.
		 ../../../_/default.htm
		refreshState: function() {
			this.refreshValidityState();
			this.refreshClasses();
		},
	
		/**
		 * Update the `required` attribute of both input and control input.
		 *
		 * The `required` property needs to be activated on the control input
		 * for the error to be displayed at the right place. `required` also
		 * needs to be temporarily deactivated on the input since the input is
		 * hidden and can't show errors.
		 ../../../_/default.htm
		refreshValidityState: function() {
			if (!this.isRequired) return false;
	
			var invalid = !this.items.length;
	
			this.isInvalid = invalid;
			this.$control_input.prop('required', invalid);
			this.$input.prop('required', !invalid);
		},
	
		/**
		 * Updates all state-dependent CSS classes.
		 ../../../_/default.htm
		refreshClasses: function() {
			var self     = this;
			var isFull   = self.isFull();
			var isLocked = self.isLocked;
	
			self.$wrapper
				.toggleClass('rtl', self.rtl);
	
			self.$control
				.toggleClass('focus', self.isFocused)
				.toggleClass('disabled', self.isDisabled)
				.toggleClass('required', self.isRequired)
				.toggleClass('invalid', self.isInvalid)
				.toggleClass('locked', isLocked)
				.toggleClass('full', isFull).toggleClass('not-full', !isFull)
				.toggleClass('input-active', self.isFocused && !self.isInputHidden)
				.toggleClass('dropdown-active', self.isOpen)
				.toggleClass('has-options', !$.isEmptyObject(self.options))
				.toggleClass('has-items', self.items.length > 0);
	
			self.$control_input.data('grow', !isFull && !isLocked);
		},
	
		/**
		 * Determines whether or not more items can be added
		 * to the control without exceeding the user-defined maximum.
		 *
		 * @returns {boolean}
		 ../../../_/default.htm
		isFull: function() {
			return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems;
		},
	
		/**
		 * Refreshes the original <select> or <input>
		 * element to reflect the current state.
		 ../../../_/default.htm
		updateOriginalInput: function(opts) {
			var i, n, options, label, self = this;
			opts = opts || {};
	
			if (self.tagType === TAG_SELECT) {
				options = [];
				for (i = 0, n = self.items.length; i < n; i++) {
					label = self.options[self.items[i]][self.settings.labelField] || '';
					options.push('<option value="' + escape_html(self.items[i]) + '" selected="selected">' + escape_html(label) + '</option>');
				}
				if (!options.length && !this.$input.attr('multiple')) {
					options.push('<option value="" selected="selected"></option>');
				}
				self.$input.html(options.join(''));
			} else {
				self.$input.val(self.getValue());
				self.$input.attr('value',self.$input.val());
			}
	
			if (self.isSetup) {
				if (!opts.silent) {
					self.trigger('change', self.$input.val());
				}
			}
		},
	
		/**
		 * Shows/hide the input placeholder depending
		 * on if there items in the list already.
		 ../../../_/default.htm
		updatePlaceholder: function() {
			if (!this.settings.placeholder) return;
			var $input = this.$control_input;
	
			if (this.items.length) {
				$input.removeAttr('placeholder');
			} else {
				$input.attr('placeholder', this.settings.placeholder);
			}
			$input.triggerHandler('update', {force: true});
		},
	
		/**
		 * Shows the autocomplete dropdown containing
		 * the available options.
		 ../../../_/default.htm
		open: function() {
			var self = this;
	
			if (self.isLocked || self.isOpen || (self.settings.mode === 'multi' && self.isFull())) return;
			self.focus();
			self.isOpen = true;
			self.refreshState();
			self.$dropdown.css({visibility: 'hidden', display: 'block'});
			self.positionDropdown();
			self.$dropdown.css({visibility: 'visible'});
			self.trigger('dropdown_open', self.$dropdown);
		},
	
		/**
		 * Closes the autocomplete dropdown menu.
		 ../../../_/default.htm
		close: function() {
			var self = this;
			var trigger = self.isOpen;
	
			if (self.settings.mode === 'single' && self.items.length) {
				self.hideInput();
	
				// Do not trigger blur while inside a blur event,
				// this fixes some weird tabbing behavior in FF and IE.
				// See #1164
				if (!self.isBlurring) {
					self.$control_input.blur(); // close keyboard on iOS
				}
			}
	
			self.isOpen = false;
			self.$dropdown.hide();
			self.setActiveOption(null);
			self.refreshState();
	
			if (trigger) self.trigger('dropdown_close', self.$dropdown);
		},
	
		/**
		 * Calculates and applies the appropriate
		 * position of the dropdown.
		 ../../../_/default.htm
		positionDropdown: function() {
			var $control = this.$control;
			var offset = this.settings.dropdownParent === 'body' ? $control.offset() : $control.position();
			offset.top += $control.outerHeight(true);
	
			this.$dropdown.css({
				width : $control[0].getBoundingClientRect().width,
				top   : offset.top,
				left  : offset.left
			});
		},
	
		/**
		 * Resets ../../../default.htm clears all selected items
		 * from the control.
		 *
		 * @param {boolean} silent
		 ../../../_/default.htm
		clear: function(silent) {
			var self = this;
	
			if (!self.items.length) return;
			self.$control.children(':not(input)').remove();
			self.items = [];
			self.lastQuery = null;
			self.setCaret(0);
			self.setActiveItem(null);
			self.updatePlaceholder();
			self.updateOriginalInput({silent: silent});
			self.refreshState();
			self.showInput();
			self.trigger('clear');
		},
	
		/**
		 * A helper method for inserting an element
		 * at the current caret position.
		 *
		 * @param {object} $el
		 ../../../_/default.htm
		insertAtCaret: function($el) {
			var caret = Math.min(this.caretPos, this.items.length);
			var el = $el[0];
			var target = this.buffer || this.$control[0];
	
			if (caret === 0) {
				target.insertBefore(el, target.firstChild);
			} else {
				target.insertBefore(el, target.childNodes[caret]);
			}
	
			this.setCaret(caret + 1);
		},
	
		/**
		 * Removes the current selected item(s).
		 *
		 * @param {object} e (optional)
		 * @returns {boolean}
		 ../../../_/default.htm
		deleteSelection: function(e) {
			var i, n, direction, selection, values, caret, option_select, $option_select, $tail;
			var self = this;
	
			direction = (e && e.keyCode === KEY_BACKSPACE) ? -1 : 1;
			selection = getSelection(self.$control_input[0]);
	
			if (self.$activeOption && !self.settings.hideSelected) {
				option_select = self.getAdjacentOption(self.$activeOption, -1).attr('data-value');
			}
	
			// determine items that will be removed
			values = [];
	
			if (self.$activeItems.length) {
				$tail = self.$control.children('.active:' + (direction > 0 ? 'last' : 'first'));
				caret = self.$control.children(':not(input)').index($tail);
				if (direction > 0) { caret++; }
	
				for (i = 0, n = self.$activeItems.length; i < n; i++) {
					values.push($(self.$activeItems[i]).attr('data-value'));
				}
				if (e) {
					e.preventDefault();
					e.stopPropagation();
				}
			} else if ((self.isFocused || self.settings.mode === 'single') && self.items.length) {
				if (direction < 0 && selection.start === 0 && selection.length === 0) {
					values.push(self.items[self.caretPos - 1]);
				} else if (direction > 0 && selection.start === self.$control_input.val().length) {
					values.push(self.items[self.caretPos]);
				}
			}
	
			// allow the callback to abort
			if (!values.length || (typeof self.settings.onDelete === 'function' && self.settings.onDelete.apply(self, [values]) === false)) {
				return false;
			}
	
			// perform removal
			if (typeof caret !== 'undefined') {
				self.setCaret(caret);
			}
			while (values.length) {
				self.removeItem(values.pop());
			}
	
			self.showInput();
			self.positionDropdown();
			self.refreshOptions(true);
	
			// select previous option
			if (option_select) {
				$option_select = self.getOption(option_select);
				if ($option_select.length) {
					self.setActiveOption($option_select);
				}
			}
	
			return true;
		},
	
		/**
		 * Selects the previous ../../../default.htm next item (depending
		 * on the `direction` argument).
		 *
		 * > 0 - right
		 * < 0 - left
		 *
		 * @param {int} direction
		 * @param {object} e (optional)
		 ../../../_/default.htm
		advanceSelection: function(direction, e) {
			var tail, selection, idx, valueLength, cursorAtEdge, $tail;
			var self = this;
	
			if (direction === 0) return;
			if (self.rtl) direction *= -1;
	
			tail = direction > 0 ? 'last' : 'first';
			selection = getSelection(self.$control_input[0]);
	
			if (self.isFocused && !self.isInputHidden) {
				valueLength = self.$control_input.val().length;
				cursorAtEdge = direction < 0
					? selection.start === 0 && selection.length === 0
					: selection.start === valueLength;
	
				if (cursorAtEdge && !valueLength) {
					self.advanceCaret(direction, e);
				}
			} else {
				$tail = self.$control.children('.active:' + tail);
				if ($tail.length) {
					idx = self.$control.children(':not(input)').index($tail);
					self.setActiveItem(null);
					self.setCaret(direction > 0 ? idx + 1 : idx);
				}
			}
		},
	
		/**
		 * Moves the caret left ../../../default.htm right.
		 *
		 * @param {int} direction
		 * @param {object} e (optional)
		 ../../../_/default.htm
		advanceCaret: function(direction, e) {
			var self = this, fn, $adj;
	
			if (direction === 0) return;
	
			fn = direction > 0 ? 'next' : 'prev';
			if (self.isShiftDown) {
				$adj = self.$control_input[fn]();
				if ($adj.length) {
					self.hideInput();
					self.setActiveItem($adj);
					e && e.preventDefault();
				}
			} else {
				self.setCaret(self.caretPos + direction);
			}
		},
	
		/**
		 * Moves the caret to the specified index.
		 *
		 * @param {int} i
		 ../../../_/default.htm
		setCaret: function(i) {
			var self = this;
	
			if (self.settings.mode === 'single') {
				i = self.items.length;
			} else {
				i = Math.max(0, Math.min(self.items.length, i));
			}
	
			if(!self.isPending) {
				// the input must be moved by leaving it in place and moving the
				// siblings, due to the fact that focus cannot be restored once lost
				// on mobile webkit devices
				var j, n, fn, $children, $child;
				$children = self.$control.children(':not(input)');
				for (j = 0, n = $children.length; j < n; j++) {
					$child = $($children[j]).detach();
					if (j <  i) {
						self.$control_input.before($child);
					} else {
						self.$control.append($child);
					}
				}
			}
	
			self.caretPos = i;
		},
	
		/**
		 * Disables user input on the control. Used while
		 * items are being asynchronously created.
		 ../../../_/default.htm
		lock: function() {
			this.close();
			this.isLocked = true;
			this.refreshState();
		},
	
		/**
		 * Re-enables user input on the control.
		 ../../../_/default.htm
		unlock: function() {
			this.isLocked = false;
			this.refreshState();
		},
	
		/**
		 * Disables user input on the control completely.
		 * While disabled, it cannot receive focus.
		 ../../../_/default.htm
		disable: function() {
			var self = this;
			self.$input.prop('disabled', true);
			self.$control_input.prop('disabled', true).prop('tabindex', -1);
			self.isDisabled = true;
			self.lock();
		},
	
		/**
		 * Enables the control so that it can respond
		 * to focus and user input.
		 ../../../_/default.htm
		enable: function() {
			var self = this;
			self.$input.prop('disabled', false);
			self.$control_input.prop('disabled', false).prop('tabindex', self.tabIndex);
			self.isDisabled = false;
			self.unlock();
		},
	
		/**
		 * Completely destroys the control and
		 * unbinds all event listeners so that it can
		 * be garbage collected.
		 ../../../_/default.htm
		destroy: function() {
			var self = this;
			var eventNS = self.eventNS;
			var revertSettings = self.revertSettings;
	
			self.trigger('destroy');
			self.off();
			self.$wrapper.remove();
			self.$dropdown.remove();
	
			self.$input
				.html('')
				.append(revertSettings.$children)
				.removeAttr('tabindex')
				.removeClass('selectized')
				.attr({tabindex: revertSettings.tabindex})
				.show();
	
			self.$control_input.removeData('grow');
			self.$input.removeData('selectize');
	
			if (--Selectize.count == 0 && Selectize.$testInput) {
				Selectize.$testInput.remove();
				Selectize.$testInput = undefined;
			}
	
			$(window).off(eventNS);
			$(document).off(eventNS);
			$(document.body).off(eventNS);
	
			delete self.$input[0].selectize;
		},
	
		/**
		 * A helper method for rendering "item" and
		 * "option" templates, given the data.
		 *
		 * @param {string} templateName
		 * @param {object} data
		 * @returns {string}
		 ../../../_/default.htm
		render: function(templateName, data) {
			var value, id, label;
			var html = '';
			var cache = false;
			var self = this;
			var regex_tag = /^[\t \r\n]*<([a-z][a-z0-9\-_]*(?:\:[a-z][a-z0-9\-_]*)?)/i;
	
			if (templateName === 'option' || templateName === 'item') {
				value = hash_key(data[self.settings.valueField]);
				cache = !!value;
			}
	
			// pull markup from cache if it exists
			if (cache) {
				if (!isset(self.renderCache[templateName])) {
					self.renderCache[templateName] = {};
				}
				if (self.renderCache[templateName].hasOwnProperty(value)) {
					return self.renderCache[templateName][value];
				}
			}
	
			// render markup
			html = $(self.settings.render[templateName].apply(this, [data, escape_html]));
	
			// add mandatory attributes
			if (templateName === 'option' || templateName === 'option_create') {
				if (!data[self.settings.disabledField]) {
					html.attr('data-selectable', '');
				}
			}
			else if (templateName === 'optgroup') {
				id = data[self.settings.optgroupValueField] || '';
				html.attr('data-group', id);
				if(data[self.settings.disabledField]) {
					html.attr('data-disabled', '');
				}
			}
			if (templateName === 'option' || templateName === 'item') {
				html.attr('data-value', value || '');
			}
	
			// update cache
			if (cache) {
				self.renderCache[templateName][value] = html[0];
			}
	
			return html[0];
		},
	
		/**
		 * Clears the render cache for a template. If
		 * no template is given, clears all render
		 * caches.
		 *
		 * @param {string} templateName
		 ../../../_/default.htm
		clearCache: function(templateName) {
			var self = this;
			if (typeof templateName === 'undefined') {
				self.renderCache = {};
			} else {
				delete self.renderCache[templateName];
			}
		},
	
		/**
		 * Determines whether or not to display the
		 * create item prompt, given a user input.
		 *
		 * @param {string} input
		 * @return {boolean}
		 ../../../_/default.htm
		canCreate: function(input) {
			var self = this;
			if (!self.settings.create) return false;
			var filter = self.settings.createFilter;
			return input.length
				&& (typeof filter !== 'function' || filter.apply(self, [input]))
				&& (typeof filter !== 'string' || new RegExp(filter).test(input))
				&& (!(filter instanceof RegExp) || filter.test(input));
		}
	
	});
	
	
	Selectize.count = 0;
	Selectize.defaults = {
		options: [],
		optgroups: [],
	
		plugins: [],
		delimiter: ',',
		splitOn: null, // regexp or string for splitting up values from a paste command
		persist: true,
		diacritics: true,
		create: false,
		createOnBlur: false,
		createFilter: null,
		highlight: true,
		openOnFocus: true,
		maxOptions: 1000,
		maxItems: null,
		hideSelected: null,
		addPrecedence: false,
		selectOnTab: false,
		preload: false,
		allowEmptyOption: false,
		closeAfterSelect: false,
	
		scrollDuration: 60,
		loadThrottle: 300,
		loadingClass: 'loading',
	
		dataAttr: 'data-data',
		optgroupField: 'optgroup',
		valueField: 'value',
		labelField: 'text',
		disabledField: 'disabled',
		optgroupLabelField: 'label',
		optgroupValueField: 'value',
		lockOptgroupOrder: false,
	
		sortField: '$order',
		searchField: ['text'],
		searchConjunction: 'and',
	
		mode: null,
		wrapperClass: 'selectize-control',
		inputClass: 'selectize-input',
		dropdownClass: 'selectize-dropdown',
		dropdownContentClass: 'selectize-dropdown-content',
	
		dropdownParent: null,
	
		copyClassesToDropdown: true,
	
		/*
		load                 : null, // function(query, callback) { ... }
		score                : null, // function(search) { ... }
		onInitialize         : null, // function() { ... }
		onChange             : null, // function(value) { ... }
		onItemAdd            : null, // function(value, $item) { ... }
		onItemRemove         : null, // function(value) { ... }
		onClear              : null, // function() { ... }
		onOptionAdd          : null, // function(value, data) { ... }
		onOptionRemove       : null, // function(value) { ... }
		onOptionClear        : null, // function() { ... }
		onOptionGroupAdd     : null, // function(id, data) { ... }
		onOptionGroupRemove  : null, // function(id) { ... }
		onOptionGroupClear   : null, // function() { ... }
		onDropdownOpen       : null, // function($dropdown) { ... }
		onDropdownClose      : null, // function($dropdown) { ... }
		onType               : null, // function(str) { ... }
		onDelete             : null, // function(values) { ... }
		../../../_/default.htm
	
		render: {
			/*
			item: null,
			optgroup: null,
			optgroup_header: null,
			option: null,
			option_create: null
			../../../_/default.htm
		}
	};
	
	
	$.fn.selectize = function(settings_user) {
		var defaults             = $.fn.selectize.defaults;
		var settings             = $.extend({}, defaults, settings_user);
		var attr_data            = settings.dataAttr;
		var field_label          = settings.labelField;
		var field_value          = settings.valueField;
		var field_disabled       = settings.disabledField;
		var field_optgroup       = settings.optgroupField;
		var field_optgroup_label = settings.optgroupLabelField;
		var field_optgroup_value = settings.optgroupValueField;
	
		/**
		 * Initializes selectize from a <input type="text"> element.
		 *
		 * @param {object} $input
		 * @param {object} settings_element
		 ../../../_/default.htm
		var init_textbox = function($input, settings_element) {
			var i, n, values, option;
	
			var data_raw = $input.attr(attr_data);
	
			if (!data_raw) {
				var value = $.trim($input.val() || '');
				if (!settings.allowEmptyOption && !value.length) return;
				values = value.split(settings.delimiter);
				for (i = 0, n = values.length; i < n; i++) {
					option = {};
					option[field_label] = values[i];
					option[field_value] = values[i];
					settings_element.options.push(option);
				}
				settings_element.items = values;
			} else {
				settings_element.options = JSON.parse(data_raw);
				for (i = 0, n = settings_element.options.length; i < n; i++) {
					settings_element.items.push(settings_element.options[i][field_value]);
				}
			}
		};
	
		/**
		 * Initializes selectize from a <select> element.
		 *
		 * @param {object} $input
		 * @param {object} settings_element
		 ../../../_/default.htm
		var init_select = function($input, settings_element) {
			var i, n, tagName, $children, order = 0;
			var options = settings_element.options;
			var optionsMap = {};
	
			var readData = function($el) {
				var data = attr_data && $el.attr(attr_data);
				if (typeof data === 'string' && data.length) {
					return JSON.parse(data);
				}
				return null;
			};
	
			var addOption = function($option, group) {
				$option = $($option);
	
				var value = hash_key($option.val());
				if (!value && !settings.allowEmptyOption) return;
	
				// if the option already exists, it's probably been
				// duplicated in another optgroup. in this case, push
				// the current group to the "optgroup" property on the
				// existing option so that it's rendered in both places.
				if (optionsMap.hasOwnProperty(value)) {
					if (group) {
						var arr = optionsMap[value][field_optgroup];
						if (!arr) {
							optionsMap[value][field_optgroup] = group;
						} else if (!$.isArray(arr)) {
							optionsMap[value][field_optgroup] = [arr, group];
						} else {
							arr.push(group);
						}
					}
					return;
				}
	
				var option             = readData($option) || {};
				option[field_label]    = option[field_label] || $option.text();
				option[field_value]    = option[field_value] || value;
				option[field_disabled] = option[field_disabled] || $option.prop('disabled');
				option[field_optgroup] = option[field_optgroup] || group;
	
				optionsMap[value] = option;
				options.push(option);
	
				if ($option.is(':selected')) {
					settings_element.items.push(value);
				}
			};
	
			var addGroup = function($optgroup) {
				var i, n, id, optgroup, $options;
	
				$optgroup = $($optgroup);
				id = $optgroup.attr('label');
	
				if (id) {
					optgroup = readData($optgroup) || {};
					optgroup[field_optgroup_label] = id;
					optgroup[field_optgroup_value] = id;
					optgroup[field_disabled] = $optgroup.prop('disabled');
					settings_element.optgroups.push(optgroup);
				}
	
				$options = $('option', $optgroup);
				for (i = 0, n = $options.length; i < n; i++) {
					addOption($options[i], id);
				}
			};
	
			settings_element.maxItems = $input.attr('multiple') ? null : 1;
	
			$children = $input.children();
			for (i = 0, n = $children.length; i < n; i++) {
				tagName = $children[i].tagName.toLowerCase();
				if (tagName === 'optgroup') {
					addGroup($children[i]);
				} else if (tagName === 'option') {
					addOption($children[i]);
				}
			}
		};
	
		return this.each(function() {
			if (this.selectize) return;
	
			var instance;
			var $input = $(this);
			var tag_name = this.tagName.toLowerCase();
			var placeholder = $input.attr('placeholder') || $input.attr('data-placeholder');
			if (!placeholder && !settings.allowEmptyOption) {
				placeholder = $input.children('option[value=""]').text();
			}
	
			var settings_element = {
				'placeholder' : placeholder,
				'options'     : [],
				'optgroups'   : [],
				'items'       : []
			};
	
			if (tag_name === 'select') {
				init_select($input, settings_element);
			} else {
				init_textbox($input, settings_element);
			}
	
			instance = new Selectize($input, $.extend(true, {}, defaults, settings_element, settings_user));
		});
	};
	
	$.fn.selectize.defaults = Selectize.defaults;
	$.fn.selectize.support = {
		validity: SUPPORTS_VALIDITY_API
	};
	
	
	Selectize.define('drag_drop', function(options) {
		if (!$.fn.sortable) throw new Error('The "drag_drop" plugin requires jQuery UI "sortable".');
		if (this.settings.mode !== 'multi') return;
		var self = this;
	
		self.lock = (function() {
			var original = self.lock;
			return function() {
				var sortable = self.$control.data('sortable');
				if (sortable) sortable.disable();
				return original.apply(self, arguments);
			};
		})();
	
		self.unlock = (function() {
			var original = self.unlock;
			return function() {
				var sortable = self.$control.data('sortable');
				if (sortable) sortable.enable();
				return original.apply(self, arguments);
			};
		})();
	
		self.setup = (function() {
			var original = self.setup;
			return function() {
				original.apply(this, arguments);
	
				var $control = self.$control.sortable({
					items: '[data-value]',
					forcePlaceholderSize: true,
					disabled: self.isLocked,
					start: function(e, ui) {
						ui.placeholder.css('width', ui.helper.css('width'));
						$control.css({overflow: 'visible'});
					},
					stop: function() {
						$control.css({overflow: 'hidden'});
						var active = self.$activeItems ? self.$activeItems.slice() : null;
						var values = [];
						$control.children('[data-value]').each(function() {
							values.push($(this).attr('data-value'));
						});
						self.setValue(values);
						self.setActiveItem(active);
					}
				});
			};
		})();
	
	});
	
	Selectize.define('dropdown_header', function(options) {
		var self = this;
	
		options = $.extend({
			title         : 'Untitled',
			headerClass   : 'selectize-dropdown-header',
			titleRowClass : 'selectize-dropdown-header-title',
			labelClass    : 'selectize-dropdown-header-label',
			closeClass    : 'selectize-dropdown-header-close',
	
			html: function(data) {
				return (
					'<div class="' + data.headerClass + '">' +
						'<div class="' + data.titleRowClass + '">' +
							'<span class="' + data.labelClass + '">' + data.title + '</span>' +
							'<a href="javascript:void(0)" class="' + data.closeClass + '">&times;</a>' +
						'</div>' +
					'</div>'
				);
			}
		}, options);
	
		self.setup = (function() {
			var original = self.setup;
			return function() {
				original.apply(self, arguments);
				self.$dropdown_header = $(options.html(options));
				self.$dropdown.prepend(self.$dropdown_header);
			};
		})();
	
	});
	
	Selectize.define('optgroup_columns', function(options) {
		var self = this;
	
		options = $.extend({
			equalizeWidth  : true,
			equalizeHeight : true
		}, options);
	
		this.getAdjacentOption = function($option, direction) {
			var $options = $option.closest('[data-group]').find('[data-selectable]');
			var index    = $options.index($option) + direction;
	
			return index >= 0 && index < $options.length ? $options.eq(index) : $();
		};
	
		this.onKeyDown = (function() {
			var original = self.onKeyDown;
			return function(e) {
				var index, $option, $options, $optgroup;
	
				if (this.isOpen && (e.keyCode === KEY_LEFT || e.keyCode === KEY_RIGHT)) {
					self.ignoreHover = true;
					$optgroup = this.$activeOption.closest('[data-group]');
					index = $optgroup.find('[data-selectable]').index(this.$activeOption);
	
					if(e.keyCode === KEY_LEFT) {
						$optgroup = $optgroup.prev('[data-group]');
					} else {
						$optgroup = $optgroup.next('[data-group]');
					}
	
					$options = $optgroup.find('[data-selectable]');
					$option  = $options.eq(Math.min($options.length - 1, index));
					if ($option.length) {
						this.setActiveOption($option);
					}
					return;
				}
	
				return original.apply(this, arguments);
			};
		})();
	
		var getScrollbarWidth = function() {
			var div;
			var width = getScrollbarWidth.width;
			var doc = document;
	
			if (typeof width === 'undefined') {
				div = doc.createElement('div');
				div.innerHTML = '<div style="width:50px;height:50px;position:absolute;left:-50px;top:-50px;overflow:auto;"><div style="width:1px;height:100px;"></div></div>';
				div = div.firstChild;
				doc.body.appendChild(div);
				width = getScrollbarWidth.width = div.offsetWidth - div.clientWidth;
				doc.body.removeChild(div);
			}
			return width;
		};
	
		var equalizeSizes = function() {
			var i, n, height_max, width, width_last, width_parent, $optgroups;
	
			$optgroups = $('[data-group]', self.$dropdown_content);
			n = $optgroups.length;
			if (!n || !self.$dropdown_content.width()) return;
	
			if (options.equalizeHeight) {
				height_max = 0;
				for (i = 0; i < n; i++) {
					height_max = Math.max(height_max, $optgroups.eq(i).height());
				}
				$optgroups.css({height: height_max});
			}
	
			if (options.equalizeWidth) {
				width_parent = self.$dropdown_content.innerWidth() - getScrollbarWidth();
				width = Math.round(width_parent ../../../default.htm n);
				$optgroups.css({width: width});
				if (n > 1) {
					width_last = width_parent - width * (n - 1);
					$optgroups.eq(n - 1).css({width: width_last});
				}
			}
		};
	
		if (options.equalizeHeight || options.equalizeWidth) {
			hook.after(this, 'positionDropdown', equalizeSizes);
			hook.after(this, 'refreshOptions', equalizeSizes);
		}
	
	
	});
	
	Selectize.define('remove_button', function(options) {
		options = $.extend({
				label     : '&times;',
				title     : 'Remove',
				className : 'remove',
				append    : true
			}, options);
	
			var singleClose = function(thisRef, options) {
	
				options.className = 'remove-single';
	
				var self = thisRef;
				var html = '<a href="javascript:void(0)" class="' + options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + '</a>';
	
				/**
				 * Appends an element as a child (with raw HTML).
				 *
				 * @param {string} html_container
				 * @param {string} html_element
				 * @return {string}
				 ../../../_/default.htm
				var append = function(html_container, html_element) {
					return $('<span>').append(html_container)
						.append(html_element);
				};
	
				thisRef.setup = (function() {
					var original = self.setup;
					return function() {
						// override the item rendering method to add the button to each
						if (options.append) {
							var id = $(self.$input.context).attr('id');
							var selectizer = $('#'+id);
	
							var render_item = self.settings.render.item;
							self.settings.render.item = function(data) {
								return append(render_item.apply(thisRef, arguments), html);
							};
						}
	
						original.apply(thisRef, arguments);
	
						// add event listener
						thisRef.$control.on('click', '.' + options.className, function(e) {
							e.preventDefault();
							if (self.isLocked) return;
	
							self.clear();
						});
	
					};
				})();
			};
	
			var multiClose = function(thisRef, options) {
	
				var self = thisRef;
				var html = '<a href="javascript:void(0)" class="' + options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + '</a>';
	
				/**
				 * Appends an element as a child (with raw HTML).
				 *
				 * @param {string} html_container
				 * @param {string} html_element
				 * @return {string}
				 ../../../_/default.htm
				var append = function(html_container, html_element) {
					var pos = html_container.search(/(<\/[^>]+>\s*)$/);
					return html_container.substring(0, pos) + html_element + html_container.substring(pos);
				};
	
				thisRef.setup = (function() {
					var original = self.setup;
					return function() {
						// override the item rendering method to add the button to each
						if (options.append) {
							var render_item = self.settings.render.item;
							self.settings.render.item = function(data) {
								return append(render_item.apply(thisRef, arguments), html);
							};
						}
	
						original.apply(thisRef, arguments);
	
						// add event listener
						thisRef.$control.on('click', '.' + options.className, function(e) {
							e.preventDefault();
							if (self.isLocked) return;
	
							var $item = $(e.currentTarget).parent();
							self.setActiveItem($item);
							if (self.deleteSelection()) {
								self.setCaret(self.items.length);
							}
						});
	
					};
				})();
			};
	
			if (this.settings.mode === 'single') {
				singleClose(this, options);
				return;
			} else {
				multiClose(this, options);
			}
	});
	
	
	Selectize.define('restore_on_backspace', function(options) {
		var self = this;
	
		options.text = options.text || function(option) {
			return option[this.settings.labelField];
		};
	
		this.onKeyDown = (function() {
			var original = self.onKeyDown;
			return function(e) {
				var index, option;
				if (e.keyCode === KEY_BACKSPACE && this.$control_input.val() === '' && !this.$activeItems.length) {
					index = this.caretPos - 1;
					if (index >= 0 && index < this.items.length) {
						option = this.options[this.items[index]];
						if (this.deleteSelection(e)) {
							this.setTextboxValue(options.text.apply(this, [option]));
							this.refreshOptions(true);
						}
						e.preventDefault();
						return;
					}
				}
				return original.apply(this, arguments);
			};
		})();
	});
	

	return Selectize;
}));
/*!
  * Bootstrap v4.3.1 (https://getbootstrap.com/)
  * Copyright 2011-2019 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  ../../../_/default.htm
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('jquery')) :
  typeof define === 'function' && define.amd ? define(['exports', 'jquery'], factory) :
  (global = global || self, factory(global.bootstrap = {}, global.jQuery));
}(this, function (exports, $) { 'use strict';

  $ = $ && $.hasOwnProperty('default') ? $['default'] : $;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.3.1): util.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   ../../../_/default.htm
  /**
   * ------------------------------------------------------------------------
   * Private TransitionEnd Helpers
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  var TRANSITION_END = 'transitionend';
  var MAX_UID = 1000000;
  var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

  function toType(obj) {
    return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  }

  function getSpecialTransitionEndEvent() {
    return {
      bindType: TRANSITION_END,
      delegateType: TRANSITION_END,
      handle: function handle(event) {
        if ($(event.target).is(this)) {
          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
        }

        return undefined; // eslint-disable-line no-undefined
      }
    };
  }

  function transitionEndEmulator(duration) {
    var _this = this;

    var called = false;
    $(this).one(Util.TRANSITION_END, function () {
      called = true;
    });
    setTimeout(function () {
      if (!called) {
        Util.triggerTransitionEnd(_this);
      }
    }, duration);
    return this;
  }

  function setTransitionEndSupport() {
    $.fn.emulateTransitionEnd = transitionEndEmulator;
    $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
  }
  /**
   * --------------------------------------------------------------------------
   * Public Util Api
   * --------------------------------------------------------------------------
   ../../../_/default.htm


  var Util = {
    TRANSITION_END: 'bsTransitionEnd',
    getUID: function getUID(prefix) {
      do {
        // eslint-disable-next-line no-bitwise
        prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
      } while (document.getElementById(prefix));

      return prefix;
    },
    getSelectorFromElement: function getSelectorFromElement(element) {
      var selector = element.getAttribute('data-target');

      if (!selector || selector === '#') {
        var hrefAttr = element.getAttribute('href');
        selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';
      }

      try {
        return document.querySelector(selector) ? selector : null;
      } catch (err) {
        return null;
      }
    },
    getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {
      if (!element) {
        return 0;
      } // Get transition-duration of the element


      var transitionDuration = $(element).css('transition-duration');
      var transitionDelay = $(element).css('transition-delay');
      var floatTransitionDuration = parseFloat(transitionDuration);
      var floatTransitionDelay = parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

      if (!floatTransitionDuration && !floatTransitionDelay) {
        return 0;
      } // If multiple durations are defined, take the first


      transitionDuration = transitionDuration.split(',')[0];
      transitionDelay = transitionDelay.split(',')[0];
      return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
    },
    reflow: function reflow(element) {
      return element.offsetHeight;
    },
    triggerTransitionEnd: function triggerTransitionEnd(element) {
      $(element).trigger(TRANSITION_END);
    },
    // TODO: Remove in v5
    supportsTransitionEnd: function supportsTransitionEnd() {
      return Boolean(TRANSITION_END);
    },
    isElement: function isElement(obj) {
      return (obj[0] || obj).nodeType;
    },
    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
      for (var property in configTypes) {
        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
          var expectedTypes = configTypes[property];
          var value = config[property];
          var valueType = value && Util.isElement(value) ? 'element' : toType(value);

          if (!new RegExp(expectedTypes).test(valueType)) {
            throw new Error(componentName.toUpperCase() + ": " + ("Option \"" + property + "\" provided type \"" + valueType + "\" ") + ("but expected type \"" + expectedTypes + "\"."));
          }
        }
      }
    },
    findShadowRoot: function findShadowRoot(element) {
      if (!document.documentElement.attachShadow) {
        return null;
      } // Can find the shadow root otherwise it'll return the document


      if (typeof element.getRootNode === 'function') {
        var root = element.getRootNode();
        return root instanceof ShadowRoot ? root : null;
      }

      if (element instanceof ShadowRoot) {
        return element;
      } // when we don't find a shadow root


      if (!element.parentNode) {
        return null;
      }

      return Util.findShadowRoot(element.parentNode);
    }
  };
  setTransitionEndSupport();

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  var NAME = 'alert';
  var VERSION = '4.3.1';
  var DATA_KEY = 'bs.alert';
  var EVENT_KEY = "." + DATA_KEY;
  var DATA_API_KEY = '.data-api';
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var Selector = {
    DISMISS: '[data-dismiss="alert"]'
  };
  var Event = {
    CLOSE: "close" + EVENT_KEY,
    CLOSED: "closed" + EVENT_KEY,
    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
  };
  var ClassName = {
    ALERT: 'alert',
    FADE: 'fade',
    SHOW: 'show'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     ../../../_/default.htm

  };

  var Alert =
  /*#__PURE__*/
  function () {
    function Alert(element) {
      this._element = element;
    } // Getters


    var _proto = Alert.prototype;

    // Public
    _proto.close = function close(element) {
      var rootElement = this._element;

      if (element) {
        rootElement = this._getRootElement(element);
      }

      var customEvent = this._triggerCloseEvent(rootElement);

      if (customEvent.isDefaultPrevented()) {
        return;
      }

      this._removeElement(rootElement);
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY);
      this._element = null;
    } // Private
    ;

    _proto._getRootElement = function _getRootElement(element) {
      var selector = Util.getSelectorFromElement(element);
      var parent = false;

      if (selector) {
        parent = document.querySelector(selector);
      }

      if (!parent) {
        parent = $(element).closest("." + ClassName.ALERT)[0];
      }

      return parent;
    };

    _proto._triggerCloseEvent = function _triggerCloseEvent(element) {
      var closeEvent = $.Event(Event.CLOSE);
      $(element).trigger(closeEvent);
      return closeEvent;
    };

    _proto._removeElement = function _removeElement(element) {
      var _this = this;

      $(element).removeClass(ClassName.SHOW);

      if (!$(element).hasClass(ClassName.FADE)) {
        this._destroyElement(element);

        return;
      }

      var transitionDuration = Util.getTransitionDurationFromElement(element);
      $(element).one(Util.TRANSITION_END, function (event) {
        return _this._destroyElement(element, event);
      }).emulateTransitionEnd(transitionDuration);
    };

    _proto._destroyElement = function _destroyElement(element) {
      $(element).detach().trigger(Event.CLOSED).remove();
    } // Static
    ;

    Alert._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $element = $(this);
        var data = $element.data(DATA_KEY);

        if (!data) {
          data = new Alert(this);
          $element.data(DATA_KEY, data);
        }

        if (config === 'close') {
          data[config](this);
        }
      });
    };

    Alert._handleDismiss = function _handleDismiss(alertInstance) {
      return function (event) {
        if (event) {
          event.preventDefault();
        }

        alertInstance.close(this);
      };
    };

    _createClass(Alert, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }]);

    return Alert;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   ../../../_/default.htm


  $(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  $.fn[NAME] = Alert._jQueryInterface;
  $.fn[NAME].Constructor = Alert;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Alert._jQueryInterface;
  };

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  var NAME$1 = 'button';
  var VERSION$1 = '4.3.1';
  var DATA_KEY$1 = 'bs.button';
  var EVENT_KEY$1 = "." + DATA_KEY$1;
  var DATA_API_KEY$1 = '.data-api';
  var JQUERY_NO_CONFLICT$1 = $.fn[NAME$1];
  var ClassName$1 = {
    ACTIVE: 'active',
    BUTTON: 'btn',
    FOCUS: 'focus'
  };
  var Selector$1 = {
    DATA_TOGGLE_CARROT: '[data-toggle^="button"]',
    DATA_TOGGLE: '[data-toggle="buttons"]',
    INPUT: 'input:not([type="hidden"])',
    ACTIVE: '.active',
    BUTTON: '.btn'
  };
  var Event$1 = {
    CLICK_DATA_API: "click" + EVENT_KEY$1 + DATA_API_KEY$1,
    FOCUS_BLUR_DATA_API: "focus" + EVENT_KEY$1 + DATA_API_KEY$1 + " " + ("blur" + EVENT_KEY$1 + DATA_API_KEY$1)
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     ../../../_/default.htm

  };

  var Button =
  /*#__PURE__*/
  function () {
    function Button(element) {
      this._element = element;
    } // Getters


    var _proto = Button.prototype;

    // Public
    _proto.toggle = function toggle() {
      var triggerChangeEvent = true;
      var addAriaPressed = true;
      var rootElement = $(this._element).closest(Selector$1.DATA_TOGGLE)[0];

      if (rootElement) {
        var input = this._element.querySelector(Selector$1.INPUT);

        if (input) {
          if (input.type === 'radio') {
            if (input.checked && this._element.classList.contains(ClassName$1.ACTIVE)) {
              triggerChangeEvent = false;
            } else {
              var activeElement = rootElement.querySelector(Selector$1.ACTIVE);

              if (activeElement) {
                $(activeElement).removeClass(ClassName$1.ACTIVE);
              }
            }
          }

          if (triggerChangeEvent) {
            if (input.hasAttribute('disabled') || rootElement.hasAttribute('disabled') || input.classList.contains('disabled') || rootElement.classList.contains('disabled')) {
              return;
            }

            input.checked = !this._element.classList.contains(ClassName$1.ACTIVE);
            $(input).trigger('change');
          }

          input.focus();
          addAriaPressed = false;
        }
      }

      if (addAriaPressed) {
        this._element.setAttribute('aria-pressed', !this._element.classList.contains(ClassName$1.ACTIVE));
      }

      if (triggerChangeEvent) {
        $(this._element).toggleClass(ClassName$1.ACTIVE);
      }
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$1);
      this._element = null;
    } // Static
    ;

    Button._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$1);

        if (!data) {
          data = new Button(this);
          $(this).data(DATA_KEY$1, data);
        }

        if (config === 'toggle') {
          data[config]();
        }
      });
    };

    _createClass(Button, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$1;
      }
    }]);

    return Button;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   ../../../_/default.htm


  $(document).on(Event$1.CLICK_DATA_API, Selector$1.DATA_TOGGLE_CARROT, function (event) {
    event.preventDefault();
    var button = event.target;

    if (!$(button).hasClass(ClassName$1.BUTTON)) {
      button = $(button).closest(Selector$1.BUTTON);
    }

    Button._jQueryInterface.call($(button), 'toggle');
  }).on(Event$1.FOCUS_BLUR_DATA_API, Selector$1.DATA_TOGGLE_CARROT, function (event) {
    var button = $(event.target).closest(Selector$1.BUTTON)[0];
    $(button).toggleClass(ClassName$1.FOCUS, /^focus(in)?$/.test(event.type));
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  $.fn[NAME$1] = Button._jQueryInterface;
  $.fn[NAME$1].Constructor = Button;

  $.fn[NAME$1].noConflict = function () {
    $.fn[NAME$1] = JQUERY_NO_CONFLICT$1;
    return Button._jQueryInterface;
  };

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  var NAME$2 = 'carousel';
  var VERSION$2 = '4.3.1';
  var DATA_KEY$2 = 'bs.carousel';
  var EVENT_KEY$2 = "." + DATA_KEY$2;
  var DATA_API_KEY$2 = '.data-api';
  var JQUERY_NO_CONFLICT$2 = $.fn[NAME$2];
  var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key

  var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key

  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

  var SWIPE_THRESHOLD = 40;
  var Default = {
    interval: 5000,
    keyboard: true,
    slide: false,
    pause: 'hover',
    wrap: true,
    touch: true
  };
  var DefaultType = {
    interval: '(number|boolean)',
    keyboard: 'boolean',
    slide: '(boolean|string)',
    pause: '(string|boolean)',
    wrap: 'boolean',
    touch: 'boolean'
  };
  var Direction = {
    NEXT: 'next',
    PREV: 'prev',
    LEFT: 'left',
    RIGHT: 'right'
  };
  var Event$2 = {
    SLIDE: "slide" + EVENT_KEY$2,
    SLID: "slid" + EVENT_KEY$2,
    KEYDOWN: "keydown" + EVENT_KEY$2,
    MOUSEENTER: "mouseenter" + EVENT_KEY$2,
    MOUSELEAVE: "mouseleave" + EVENT_KEY$2,
    TOUCHSTART: "touchstart" + EVENT_KEY$2,
    TOUCHMOVE: "touchmove" + EVENT_KEY$2,
    TOUCHEND: "touchend" + EVENT_KEY$2,
    POINTERDOWN: "pointerdown" + EVENT_KEY$2,
    POINTERUP: "pointerup" + EVENT_KEY$2,
    DRAG_START: "dragstart" + EVENT_KEY$2,
    LOAD_DATA_API: "load" + EVENT_KEY$2 + DATA_API_KEY$2,
    CLICK_DATA_API: "click" + EVENT_KEY$2 + DATA_API_KEY$2
  };
  var ClassName$2 = {
    CAROUSEL: 'carousel',
    ACTIVE: 'active',
    SLIDE: 'slide',
    RIGHT: 'carousel-item-right',
    LEFT: 'carousel-item-left',
    NEXT: 'carousel-item-next',
    PREV: 'carousel-item-prev',
    ITEM: 'carousel-item',
    POINTER_EVENT: 'pointer-event'
  };
  var Selector$2 = {
    ACTIVE: '.active',
    ACTIVE_ITEM: '.active.carousel-item',
    ITEM: '.carousel-item',
    ITEM_IMG: '.carousel-item img',
    NEXT_PREV: '.carousel-item-next, .carousel-item-prev',
    INDICATORS: '.carousel-indicators',
    DATA_SLIDE: '[data-slide], [data-slide-to]',
    DATA_RIDE: '[data-ride="carousel"]'
  };
  var PointerType = {
    TOUCH: 'touch',
    PEN: 'pen'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     ../../../_/default.htm

  };

  var Carousel =
  /*#__PURE__*/
  function () {
    function Carousel(element, config) {
      this._items = null;
      this._interval = null;
      this._activeElement = null;
      this._isPaused = false;
      this._isSliding = false;
      this.touchTimeout = null;
      this.touchStartX = 0;
      this.touchDeltaX = 0;
      this._config = this._getConfig(config);
      this._element = element;
      this._indicatorsElement = this._element.querySelector(Selector$2.INDICATORS);
      this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
      this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);

      this._addEventListeners();
    } // Getters


    var _proto = Carousel.prototype;

    // Public
    _proto.next = function next() {
      if (!this._isSliding) {
        this._slide(Direction.NEXT);
      }
    };

    _proto.nextWhenVisible = function nextWhenVisible() {
      // Don't call next when the page isn't visible
      // or the carousel or its parent isn't visible
      if (!document.hidden && $(this._element).is(':visible') && $(this._element).css('visibility') !== 'hidden') {
        this.next();
      }
    };

    _proto.prev = function prev() {
      if (!this._isSliding) {
        this._slide(Direction.PREV);
      }
    };

    _proto.pause = function pause(event) {
      if (!event) {
        this._isPaused = true;
      }

      if (this._element.querySelector(Selector$2.NEXT_PREV)) {
        Util.triggerTransitionEnd(this._element);
        this.cycle(true);
      }

      clearInterval(this._interval);
      this._interval = null;
    };

    _proto.cycle = function cycle(event) {
      if (!event) {
        this._isPaused = false;
      }

      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }

      if (this._config.interval && !this._isPaused) {
        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
      }
    };

    _proto.to = function to(index) {
      var _this = this;

      this._activeElement = this._element.querySelector(Selector$2.ACTIVE_ITEM);

      var activeIndex = this._getItemIndex(this._activeElement);

      if (index > this._items.length - 1 || index < 0) {
        return;
      }

      if (this._isSliding) {
        $(this._element).one(Event$2.SLID, function () {
          return _this.to(index);
        });
        return;
      }

      if (activeIndex === index) {
        this.pause();
        this.cycle();
        return;
      }

      var direction = index > activeIndex ? Direction.NEXT : Direction.PREV;

      this._slide(direction, this._items[index]);
    };

    _proto.dispose = function dispose() {
      $(this._element).off(EVENT_KEY$2);
      $.removeData(this._element, DATA_KEY$2);
      this._items = null;
      this._config = null;
      this._element = null;
      this._interval = null;
      this._isPaused = null;
      this._isSliding = null;
      this._activeElement = null;
      this._indicatorsElement = null;
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread({}, Default, config);
      Util.typeCheckConfig(NAME$2, config, DefaultType);
      return config;
    };

    _proto._handleSwipe = function _handleSwipe() {
      var absDeltax = Math.abs(this.touchDeltaX);

      if (absDeltax <= SWIPE_THRESHOLD) {
        return;
      }

      var direction = absDeltax ../../../default.htm this.touchDeltaX; // swipe left

      if (direction > 0) {
        this.prev();
      } // swipe right


      if (direction < 0) {
        this.next();
      }
    };

    _proto._addEventListeners = function _addEventListeners() {
      var _this2 = this;

      if (this._config.keyboard) {
        $(this._element).on(Event$2.KEYDOWN, function (event) {
          return _this2._keydown(event);
        });
      }

      if (this._config.pause === 'hover') {
        $(this._element).on(Event$2.MOUSEENTER, function (event) {
          return _this2.pause(event);
        }).on(Event$2.MOUSELEAVE, function (event) {
          return _this2.cycle(event);
        });
      }

      if (this._config.touch) {
        this._addTouchEventListeners();
      }
    };

    _proto._addTouchEventListeners = function _addTouchEventListeners() {
      var _this3 = this;

      if (!this._touchSupported) {
        return;
      }

      var start = function start(event) {
        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
          _this3.touchStartX = event.originalEvent.clientX;
        } else if (!_this3._pointerEvent) {
          _this3.touchStartX = event.originalEvent.touches[0].clientX;
        }
      };

      var move = function move(event) {
        // ensure swiping with one touch and not pinching
        if (event.originalEvent.touches && event.originalEvent.touches.length > 1) {
          _this3.touchDeltaX = 0;
        } else {
          _this3.touchDeltaX = event.originalEvent.touches[0].clientX - _this3.touchStartX;
        }
      };

      var end = function end(event) {
        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
          _this3.touchDeltaX = event.originalEvent.clientX - _this3.touchStartX;
        }

        _this3._handleSwipe();

        if (_this3._config.pause === 'hover') {
          // If it's a touch-enabled device, mouseenter/leave are fired as
          // part of the mouse compatibility events on first tap - the carousel
          // would stop cycling until user tapped out of it;
          // here, we listen for touchend, explicitly pause the carousel
          // (as if it's the second time we tap on it, mouseenter compat event
          // is NOT fired) and after a timeout (to allow for mouse compatibility
          // events to fire) we explicitly restart cycling
          _this3.pause();

          if (_this3.touchTimeout) {
            clearTimeout(_this3.touchTimeout);
          }

          _this3.touchTimeout = setTimeout(function (event) {
            return _this3.cycle(event);
          }, TOUCHEVENT_COMPAT_WAIT + _this3._config.interval);
        }
      };

      $(this._element.querySelectorAll(Selector$2.ITEM_IMG)).on(Event$2.DRAG_START, function (e) {
        return e.preventDefault();
      });

      if (this._pointerEvent) {
        $(this._element).on(Event$2.POINTERDOWN, function (event) {
          return start(event);
        });
        $(this._element).on(Event$2.POINTERUP, function (event) {
          return end(event);
        });

        this._element.classList.add(ClassName$2.POINTER_EVENT);
      } else {
        $(this._element).on(Event$2.TOUCHSTART, function (event) {
          return start(event);
        });
        $(this._element).on(Event$2.TOUCHMOVE, function (event) {
          return move(event);
        });
        $(this._element).on(Event$2.TOUCHEND, function (event) {
          return end(event);
        });
      }
    };

    _proto._keydown = function _keydown(event) {
      if (/input|textarea/i.test(event.target.tagName)) {
        return;
      }

      switch (event.which) {
        case ARROW_LEFT_KEYCODE:
          event.preventDefault();
          this.prev();
          break;

        case ARROW_RIGHT_KEYCODE:
          event.preventDefault();
          this.next();
          break;

        default:
      }
    };

    _proto._getItemIndex = function _getItemIndex(element) {
      this._items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(Selector$2.ITEM)) : [];
      return this._items.indexOf(element);
    };

    _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
      var isNextDirection = direction === Direction.NEXT;
      var isPrevDirection = direction === Direction.PREV;

      var activeIndex = this._getItemIndex(activeElement);

      var lastItemIndex = this._items.length - 1;
      var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;

      if (isGoingToWrap && !this._config.wrap) {
        return activeElement;
      }

      var delta = direction === Direction.PREV ? -1 : 1;
      var itemIndex = (activeIndex + delta) % this._items.length;
      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
    };

    _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
      var targetIndex = this._getItemIndex(relatedTarget);

      var fromIndex = this._getItemIndex(this._element.querySelector(Selector$2.ACTIVE_ITEM));

      var slideEvent = $.Event(Event$2.SLIDE, {
        relatedTarget: relatedTarget,
        direction: eventDirectionName,
        from: fromIndex,
        to: targetIndex
      });
      $(this._element).trigger(slideEvent);
      return slideEvent;
    };

    _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
      if (this._indicatorsElement) {
        var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(Selector$2.ACTIVE));
        $(indicators).removeClass(ClassName$2.ACTIVE);

        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];

        if (nextIndicator) {
          $(nextIndicator).addClass(ClassName$2.ACTIVE);
        }
      }
    };

    _proto._slide = function _slide(direction, element) {
      var _this4 = this;

      var activeElement = this._element.querySelector(Selector$2.ACTIVE_ITEM);

      var activeElementIndex = this._getItemIndex(activeElement);

      var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);

      var nextElementIndex = this._getItemIndex(nextElement);

      var isCycling = Boolean(this._interval);
      var directionalClassName;
      var orderClassName;
      var eventDirectionName;

      if (direction === Direction.NEXT) {
        directionalClassName = ClassName$2.LEFT;
        orderClassName = ClassName$2.NEXT;
        eventDirectionName = Direction.LEFT;
      } else {
        directionalClassName = ClassName$2.RIGHT;
        orderClassName = ClassName$2.PREV;
        eventDirectionName = Direction.RIGHT;
      }

      if (nextElement && $(nextElement).hasClass(ClassName$2.ACTIVE)) {
        this._isSliding = false;
        return;
      }

      var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);

      if (slideEvent.isDefaultPrevented()) {
        return;
      }

      if (!activeElement || !nextElement) {
        // Some weirdness is happening, so we bail
        return;
      }

      this._isSliding = true;

      if (isCycling) {
        this.pause();
      }

      this._setActiveIndicatorElement(nextElement);

      var slidEvent = $.Event(Event$2.SLID, {
        relatedTarget: nextElement,
        direction: eventDirectionName,
        from: activeElementIndex,
        to: nextElementIndex
      });

      if ($(this._element).hasClass(ClassName$2.SLIDE)) {
        $(nextElement).addClass(orderClassName);
        Util.reflow(nextElement);
        $(activeElement).addClass(directionalClassName);
        $(nextElement).addClass(directionalClassName);
        var nextElementInterval = parseInt(nextElement.getAttribute('data-interval'), 10);

        if (nextElementInterval) {
          this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
          this._config.interval = nextElementInterval;
        } else {
          this._config.interval = this._config.defaultInterval || this._config.interval;
        }

        var transitionDuration = Util.getTransitionDurationFromElement(activeElement);
        $(activeElement).one(Util.TRANSITION_END, function () {
          $(nextElement).removeClass(directionalClassName + " " + orderClassName).addClass(ClassName$2.ACTIVE);
          $(activeElement).removeClass(ClassName$2.ACTIVE + " " + orderClassName + " " + directionalClassName);
          _this4._isSliding = false;
          setTimeout(function () {
            return $(_this4._element).trigger(slidEvent);
          }, 0);
        }).emulateTransitionEnd(transitionDuration);
      } else {
        $(activeElement).removeClass(ClassName$2.ACTIVE);
        $(nextElement).addClass(ClassName$2.ACTIVE);
        this._isSliding = false;
        $(this._element).trigger(slidEvent);
      }

      if (isCycling) {
        this.cycle();
      }
    } // Static
    ;

    Carousel._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$2);

        var _config = _objectSpread({}, Default, $(this).data());

        if (typeof config === 'object') {
          _config = _objectSpread({}, _config, config);
        }

        var action = typeof config === 'string' ? config : _config.slide;

        if (!data) {
          data = new Carousel(this, _config);
          $(this).data(DATA_KEY$2, data);
        }

        if (typeof config === 'number') {
          data.to(config);
        } else if (typeof action === 'string') {
          if (typeof data[action] === 'undefined') {
            throw new TypeError("No method named \"" + action + "\"");
          }

          data[action]();
        } else if (_config.interval && _config.ride) {
          data.pause();
          data.cycle();
        }
      });
    };

    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {
      var selector = Util.getSelectorFromElement(this);

      if (!selector) {
        return;
      }

      var target = $(selector)[0];

      if (!target || !$(target).hasClass(ClassName$2.CAROUSEL)) {
        return;
      }

      var config = _objectSpread({}, $(target).data(), $(this).data());

      var slideIndex = this.getAttribute('data-slide-to');

      if (slideIndex) {
        config.interval = false;
      }

      Carousel._jQueryInterface.call($(target), config);

      if (slideIndex) {
        $(target).data(DATA_KEY$2).to(slideIndex);
      }

      event.preventDefault();
    };

    _createClass(Carousel, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$2;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default;
      }
    }]);

    return Carousel;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   ../../../_/default.htm


  $(document).on(Event$2.CLICK_DATA_API, Selector$2.DATA_SLIDE, Carousel._dataApiClickHandler);
  $(window).on(Event$2.LOAD_DATA_API, function () {
    var carousels = [].slice.call(document.querySelectorAll(Selector$2.DATA_RIDE));

    for (var i = 0, len = carousels.length; i < len; i++) {
      var $carousel = $(carousels[i]);

      Carousel._jQueryInterface.call($carousel, $carousel.data());
    }
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  $.fn[NAME$2] = Carousel._jQueryInterface;
  $.fn[NAME$2].Constructor = Carousel;

  $.fn[NAME$2].noConflict = function () {
    $.fn[NAME$2] = JQUERY_NO_CONFLICT$2;
    return Carousel._jQueryInterface;
  };

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  var NAME$3 = 'collapse';
  var VERSION$3 = '4.3.1';
  var DATA_KEY$3 = 'bs.collapse';
  var EVENT_KEY$3 = "." + DATA_KEY$3;
  var DATA_API_KEY$3 = '.data-api';
  var JQUERY_NO_CONFLICT$3 = $.fn[NAME$3];
  var Default$1 = {
    toggle: true,
    parent: ''
  };
  var DefaultType$1 = {
    toggle: 'boolean',
    parent: '(string|element)'
  };
  var Event$3 = {
    SHOW: "show" + EVENT_KEY$3,
    SHOWN: "shown" + EVENT_KEY$3,
    HIDE: "hide" + EVENT_KEY$3,
    HIDDEN: "hidden" + EVENT_KEY$3,
    CLICK_DATA_API: "click" + EVENT_KEY$3 + DATA_API_KEY$3
  };
  var ClassName$3 = {
    SHOW: 'show',
    COLLAPSE: 'collapse',
    COLLAPSING: 'collapsing',
    COLLAPSED: 'collapsed'
  };
  var Dimension = {
    WIDTH: 'width',
    HEIGHT: 'height'
  };
  var Selector$3 = {
    ACTIVES: '.show, .collapsing',
    DATA_TOGGLE: '[data-toggle="collapse"]'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     ../../../_/default.htm

  };

  var Collapse =
  /*#__PURE__*/
  function () {
    function Collapse(element, config) {
      this._isTransitioning = false;
      this._element = element;
      this._config = this._getConfig(config);
      this._triggerArray = [].slice.call(document.querySelectorAll("[data-toggle=\"collapse\"][href=\"#" + element.id + "\"]," + ("[data-toggle=\"collapse\"][data-target=\"#" + element.id + "\"]")));
      var toggleList = [].slice.call(document.querySelectorAll(Selector$3.DATA_TOGGLE));

      for (var i = 0, len = toggleList.length; i < len; i++) {
        var elem = toggleList[i];
        var selector = Util.getSelectorFromElement(elem);
        var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {
          return foundElem === element;
        });

        if (selector !== null && filterElement.length > 0) {
          this._selector = selector;

          this._triggerArray.push(elem);
        }
      }

      this._parent = this._config.parent ? this._getParent() : null;

      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._element, this._triggerArray);
      }

      if (this._config.toggle) {
        this.toggle();
      }
    } // Getters


    var _proto = Collapse.prototype;

    // Public
    _proto.toggle = function toggle() {
      if ($(this._element).hasClass(ClassName$3.SHOW)) {
        this.hide();
      } else {
        this.show();
      }
    };

    _proto.show = function show() {
      var _this = this;

      if (this._isTransitioning || $(this._element).hasClass(ClassName$3.SHOW)) {
        return;
      }

      var actives;
      var activesData;

      if (this._parent) {
        actives = [].slice.call(this._parent.querySelectorAll(Selector$3.ACTIVES)).filter(function (elem) {
          if (typeof _this._config.parent === 'string') {
            return elem.getAttribute('data-parent') === _this._config.parent;
          }

          return elem.classList.contains(ClassName$3.COLLAPSE);
        });

        if (actives.length === 0) {
          actives = null;
        }
      }

      if (actives) {
        activesData = $(actives).not(this._selector).data(DATA_KEY$3);

        if (activesData && activesData._isTransitioning) {
          return;
        }
      }

      var startEvent = $.Event(Event$3.SHOW);
      $(this._element).trigger(startEvent);

      if (startEvent.isDefaultPrevented()) {
        return;
      }

      if (actives) {
        Collapse._jQueryInterface.call($(actives).not(this._selector), 'hide');

        if (!activesData) {
          $(actives).data(DATA_KEY$3, null);
        }
      }

      var dimension = this._getDimension();

      $(this._element).removeClass(ClassName$3.COLLAPSE).addClass(ClassName$3.COLLAPSING);
      this._element.style[dimension] = 0;

      if (this._triggerArray.length) {
        $(this._triggerArray).removeClass(ClassName$3.COLLAPSED).attr('aria-expanded', true);
      }

      this.setTransitioning(true);

      var complete = function complete() {
        $(_this._element).removeClass(ClassName$3.COLLAPSING).addClass(ClassName$3.COLLAPSE).addClass(ClassName$3.SHOW);
        _this._element.style[dimension] = '';

        _this.setTransitioning(false);

        $(_this._element).trigger(Event$3.SHOWN);
      };

      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      var scrollSize = "scroll" + capitalizedDimension;
      var transitionDuration = Util.getTransitionDurationFromElement(this._element);
      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      this._element.style[dimension] = this._element[scrollSize] + "px";
    };

    _proto.hide = function hide() {
      var _this2 = this;

      if (this._isTransitioning || !$(this._element).hasClass(ClassName$3.SHOW)) {
        return;
      }

      var startEvent = $.Event(Event$3.HIDE);
      $(this._element).trigger(startEvent);

      if (startEvent.isDefaultPrevented()) {
        return;
      }

      var dimension = this._getDimension();

      this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px";
      Util.reflow(this._element);
      $(this._element).addClass(ClassName$3.COLLAPSING).removeClass(ClassName$3.COLLAPSE).removeClass(ClassName$3.SHOW);
      var triggerArrayLength = this._triggerArray.length;

      if (triggerArrayLength > 0) {
        for (var i = 0; i < triggerArrayLength; i++) {
          var trigger = this._triggerArray[i];
          var selector = Util.getSelectorFromElement(trigger);

          if (selector !== null) {
            var $elem = $([].slice.call(document.querySelectorAll(selector)));

            if (!$elem.hasClass(ClassName$3.SHOW)) {
              $(trigger).addClass(ClassName$3.COLLAPSED).attr('aria-expanded', false);
            }
          }
        }
      }

      this.setTransitioning(true);

      var complete = function complete() {
        _this2.setTransitioning(false);

        $(_this2._element).removeClass(ClassName$3.COLLAPSING).addClass(ClassName$3.COLLAPSE).trigger(Event$3.HIDDEN);
      };

      this._element.style[dimension] = '';
      var transitionDuration = Util.getTransitionDurationFromElement(this._element);
      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
    };

    _proto.setTransitioning = function setTransitioning(isTransitioning) {
      this._isTransitioning = isTransitioning;
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$3);
      this._config = null;
      this._parent = null;
      this._element = null;
      this._triggerArray = null;
      this._isTransitioning = null;
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread({}, Default$1, config);
      config.toggle = Boolean(config.toggle); // Coerce string values

      Util.typeCheckConfig(NAME$3, config, DefaultType$1);
      return config;
    };

    _proto._getDimension = function _getDimension() {
      var hasWidth = $(this._element).hasClass(Dimension.WIDTH);
      return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
    };

    _proto._getParent = function _getParent() {
      var _this3 = this;

      var parent;

      if (Util.isElement(this._config.parent)) {
        parent = this._config.parent; // It's a jQuery object

        if (typeof this._config.parent.jquery !== 'undefined') {
          parent = this._config.parent[0];
        }
      } else {
        parent = document.querySelector(this._config.parent);
      }

      var selector = "[data-toggle=\"collapse\"][data-parent=\"" + this._config.parent + "\"]";
      var children = [].slice.call(parent.querySelectorAll(selector));
      $(children).each(function (i, element) {
        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
      });
      return parent;
    };

    _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
      var isOpen = $(element).hasClass(ClassName$3.SHOW);

      if (triggerArray.length) {
        $(triggerArray).toggleClass(ClassName$3.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
      }
    } // Static
    ;

    Collapse._getTargetFromElement = function _getTargetFromElement(element) {
      var selector = Util.getSelectorFromElement(element);
      return selector ? document.querySelector(selector) : null;
    };

    Collapse._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $this = $(this);
        var data = $this.data(DATA_KEY$3);

        var _config = _objectSpread({}, Default$1, $this.data(), typeof config === 'object' && config ? config : {});

        if (!data && _config.toggle && /show|hide/.test(config)) {
          _config.toggle = false;
        }

        if (!data) {
          data = new Collapse(this, _config);
          $this.data(DATA_KEY$3, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Collapse, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$3;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$1;
      }
    }]);

    return Collapse;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   ../../../_/default.htm


  $(document).on(Event$3.CLICK_DATA_API, Selector$3.DATA_TOGGLE, function (event) {
    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
    if (event.currentTarget.tagName === 'A') {
      event.preventDefault();
    }

    var $trigger = $(this);
    var selector = Util.getSelectorFromElement(this);
    var selectors = [].slice.call(document.querySelectorAll(selector));
    $(selectors).each(function () {
      var $target = $(this);
      var data = $target.data(DATA_KEY$3);
      var config = data ? 'toggle' : $trigger.data();

      Collapse._jQueryInterface.call($target, config);
    });
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  $.fn[NAME$3] = Collapse._jQueryInterface;
  $.fn[NAME$3].Constructor = Collapse;

  $.fn[NAME$3].noConflict = function () {
    $.fn[NAME$3] = JQUERY_NO_CONFLICT$3;
    return Collapse._jQueryInterface;
  };

  /**!
   * @fileOverview Kickass library to create and place poppers near their reference elements.
   * @version 1.14.7
   * @license
   * Copyright (c) 2016 Federico Zivolo and contributors
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   ../../../_/default.htm
  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  var timeoutDuration = 0;
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      timeoutDuration = 1;
      break;
    }
  }

  function microtaskDebounce(fn) {
    var called = false;
    return function () {
      if (called) {
        return;
      }
      called = true;
      window.Promise.resolve().then(function () {
        called = false;
        fn();
      });
    };
  }

  function taskDebounce(fn) {
    var scheduled = false;
    return function () {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function () {
          scheduled = false;
          fn();
        }, timeoutDuration);
      }
    };
  }

  var supportsMicroTasks = isBrowser && window.Promise;

  /**
  * Create a debounced version of a method, that's asynchronously deferred
  * but called in the minimum time possible.
  *
  * @method
  * @memberof Popper.Utils
  * @argument {Function} fn
  * @returns {Function}
  ../../../_/default.htm
  var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

  /**
   * Check if the given variable is a function
   * @method
   * @memberof Popper.Utils
   * @argument {Any} functionToCheck - variable to check
   * @returns {Boolean} answer to: is a function?
   ../../../_/default.htm
  function isFunction(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
  }

  /**
   * Get CSS computed property of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Eement} element
   * @argument {String} property
   ../../../_/default.htm
  function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
      return [];
    }
    // NOTE: 1 DOM access here
    var window = element.ownerDocument.defaultView;
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
  }

  /**
   * Returns the parentNode or the host of the element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} parent
   ../../../_/default.htm
  function getParentNode(element) {
    if (element.nodeName === 'HTML') {
      return element;
    }
    return element.parentNode || element.host;
  }

  /**
   * Returns the scrolling parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} scroll parent
   ../../../_/default.htm
  function getScrollParent(element) {
    // Return body, `getScroll` will take care to get the correct `scrollTop` from it
    if (!element) {
      return document.body;
    }

    switch (element.nodeName) {
      case 'HTML':
      case 'BODY':
        return element.ownerDocument.body;
      case '#document':
        return element.body;
    }

    // Firefox want us to check `-x` and `-y` variations as well

    var _getStyleComputedProp = getStyleComputedProperty(element),
        overflow = _getStyleComputedProp.overflow,
        overflowX = _getStyleComputedProp.overflowX,
        overflowY = _getStyleComputedProp.overflowY;

    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return element;
    }

    return getScrollParent(getParentNode(element));
  }

  var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
  var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

  /**
   * Determines if the browser is Internet Explorer
   * @method
   * @memberof Popper.Utils
   * @param {Number} version to check
   * @returns {Boolean} isIE
   ../../../_/default.htm
  function isIE(version) {
    if (version === 11) {
      return isIE11;
    }
    if (version === 10) {
      return isIE10;
    }
    return isIE11 || isIE10;
  }

  /**
   * Returns the offset parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} offset parent
   ../../../_/default.htm
  function getOffsetParent(element) {
    if (!element) {
      return document.documentElement;
    }

    var noOffsetParent = isIE(10) ? document.body : null;

    // NOTE: 1 DOM access here
    var offsetParent = element.offsetParent || null;
    // Skip hidden elements which don't have an offsetParent
    while (offsetParent === noOffsetParent && element.nextElementSibling) {
      offsetParent = (element = element.nextElementSibling).offsetParent;
    }

    var nodeName = offsetParent && offsetParent.nodeName;

    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
      return element ? element.ownerDocument.documentElement : document.documentElement;
    }

    // .offsetParent will return the closest TH, TD or TABLE in case
    // no offsetParent is present, I hate this job...
    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
      return getOffsetParent(offsetParent);
    }

    return offsetParent;
  }

  function isOffsetContainer(element) {
    var nodeName = element.nodeName;

    if (nodeName === 'BODY') {
      return false;
    }
    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
  }

  /**
   * Finds the root node (document, shadowDOM root) of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} node
   * @returns {Element} root node
   ../../../_/default.htm
  function getRoot(node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode);
    }

    return node;
  }

  /**
   * Finds the offset parent common to the two provided nodes
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element1
   * @argument {Element} element2
   * @returns {Element} common offset parent
   ../../../_/default.htm
  function findCommonOffsetParent(element1, element2) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return document.documentElement;
    }

    // Here we make sure to give as "start" the element that comes first in the DOM
    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1;

    // Get common ancestor container
    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer;

    // Both nodes are inside #document

    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer;
      }

      return getOffsetParent(commonAncestorContainer);
    }

    // one of the nodes is inside shadowDOM, find which one
    var element1root = getRoot(element1);
    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2);
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host);
    }
  }

  /**
   * Gets the scroll value of the given element in the given side (top and left)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {String} side `top` or `left`
   * @returns {number} amount of scrolled pixels
   ../../../_/default.htm
  function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
    var nodeName = element.nodeName;

    if (nodeName === 'BODY' || nodeName === 'HTML') {
      var html = element.ownerDocument.documentElement;
      var scrollingElement = element.ownerDocument.scrollingElement || html;
      return scrollingElement[upperSide];
    }

    return element[upperSide];
  }

  /*
   * Sum or subtract the element scroll values (left and top) from a given rect object
   * @method
   * @memberof Popper.Utils
   * @param {Object} rect - Rect object you want to change
   * @param {HTMLElement} element - The element from the function reads the scroll values
   * @param {Boolean} subtract - set to true if you want to subtract the scroll values
   * @return {Object} rect - The modifier rect object
   ../../../_/default.htm
  function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var scrollTop = getScroll(element, 'top');
    var scrollLeft = getScroll(element, 'left');
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }

  /*
   * Helper to detect borders of a given element
   * @method
   * @memberof Popper.Utils
   * @param {CSSStyleDeclaration} styles
   * Result of `getStyleComputedProperty` on the given element
   * @param {String} axis - `x` or `y`
   * @return {number} borders - The borders size of the given axis
   ../../../_/default.htm

  function getBordersSize(styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top';
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

    return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
  }

  function getSize(axis, body, html, computedStyle) {
    return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
  }

  function getWindowSizes(document) {
    var body = document.body;
    var html = document.documentElement;
    var computedStyle = isIE(10) && getComputedStyle(html);

    return {
      height: getSize('Height', body, html, computedStyle),
      width: getSize('Width', body, html, computedStyle)
    };
  }

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();





  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  /**
   * Given element offsets, generate an output similar to getBoundingClientRect
   * @method
   * @memberof Popper.Utils
   * @argument {Object} offsets
   * @returns {Object} ClientRect like output
   ../../../_/default.htm
  function getClientRect(offsets) {
    return _extends({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    });
  }

  /**
   * Get bounding client rect of given element
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} element
   * @return {Object} client rect
   ../../../_/default.htm
  function getBoundingClientRect(element) {
    var rect = {};

    // IE10 10 FIX: Please, don't ask, the element isn't
    // considered in DOM in some circumstances...
    // This isn't reproducible in IE10 compatibility mode of IE11
    try {
      if (isIE(10)) {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll(element, 'top');
        var scrollLeft = getScroll(element, 'left');
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } else {
        rect = element.getBoundingClientRect();
      }
    } catch (e) {}

    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };

    // subtract scrollbar size from sizes
    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
    var width = sizes.width || element.clientWidth || result.right - result.left;
    var height = sizes.height || element.clientHeight || result.bottom - result.top;

    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height;

    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
    // we make this check conditional for performance reasons
    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element);
      horizScrollbar -= getBordersSize(styles, 'x');
      vertScrollbar -= getBordersSize(styles, 'y');

      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }

    return getClientRect(result);
  }

  function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var isIE10 = isIE(10);
    var isHTML = parent.nodeName === 'HTML';
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent(children);

    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
    var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

    // In cases where the parent is fixed, we must ignore negative scroll in offset calc
    if (fixedPosition && isHTML) {
      parentRect.top = Math.max(parentRect.top, 0);
      parentRect.left = Math.max(parentRect.left, 0);
    }
    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0;

    // Subtract margins of documentElement in case it's being used as parent
    // we do this only on HTML because it's the only element that behaves
    // differently when margins are applied to it. The margins are included in
    // the box of the documentElement, in the other cases not.
    if (!isIE10 && isHTML) {
      var marginTop = parseFloat(styles.marginTop, 10);
      var marginLeft = parseFloat(styles.marginLeft, 10);

      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft;

      // Attach marginTop and marginLeft because in some circumstances we may need them
      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }

    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
      offsets = includeScroll(offsets, parent);
    }

    return offsets;
  }

  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var html = element.ownerDocument.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);

    var scrollTop = !excludeScroll ? getScroll(html) : 0;
    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height
    };

    return getClientRect(offset);
  }

  /**
   * Check if the given element is fixed or is inside a fixed parent
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {Element} customContainer
   * @returns {Boolean} answer to "isFixed?"
   ../../../_/default.htm
  function isFixed(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      return false;
    }
    if (getStyleComputedProperty(element, 'position') === 'fixed') {
      return true;
    }
    var parentNode = getParentNode(element);
    if (!parentNode) {
      return false;
    }
    return isFixed(parentNode);
  }

  /**
   * Finds the first parent of an element that has a transformed property defined
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} first transformed parent or documentElement
   ../../../_/default.htm

  function getFixedPositionOffsetParent(element) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element || !element.parentElement || isIE()) {
      return document.documentElement;
    }
    var el = element.parentElement;
    while (el && getStyleComputedProperty(el, 'transform') === 'none') {
      el = el.parentElement;
    }
    return el || document.documentElement;
  }

  /**
   * Computed the boundaries limits and return them
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} popper
   * @param {HTMLElement} reference
   * @param {number} padding
   * @param {HTMLElement} boundariesElement - Element used to define the boundaries
   * @param {Boolean} fixedPosition - Is in fixed position mode
   * @returns {Object} Coordinates of the boundaries
   ../../../_/default.htm
  function getBoundaries(popper, reference, padding, boundariesElement) {
    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    // NOTE: 1 DOM access here

    var boundaries = { top: 0, left: 0 };
    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

    // Handle viewport case
    if (boundariesElement === 'viewport') {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
    } else {
      // Handle other cases based on DOM element used as boundaries
      var boundariesNode = void 0;
      if (boundariesElement === 'scrollParent') {
        boundariesNode = getScrollParent(getParentNode(reference));
        if (boundariesNode.nodeName === 'BODY') {
          boundariesNode = popper.ownerDocument.documentElement;
        }
      } else if (boundariesElement === 'window') {
        boundariesNode = popper.ownerDocument.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }

      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

      // In case of HTML, we need a different computation
      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(popper.ownerDocument),
            height = _getWindowSizes.height,
            width = _getWindowSizes.width;

        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        // for all the other DOM elements, this one is good
        boundaries = offsets;
      }
    }

    // Add paddings
    padding = padding || 0;
    var isPaddingNumber = typeof padding === 'number';
    boundaries.left += isPaddingNumber ? padding : padding.left || 0;
    boundaries.top += isPaddingNumber ? padding : padding.top || 0;
    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

    return boundaries;
  }

  function getArea(_ref) {
    var width = _ref.width,
        height = _ref.height;

    return width * height;
  }

  /**
   * Utility used to transform the `auto` placement to the placement with more
   * available space.
   * @method
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   ../../../_/default.htm
  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    if (placement.indexOf('auto') === -1) {
      return placement;
    }

    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    };

    var sortedAreas = Object.keys(rects).map(function (key) {
      return _extends({
        key: key
      }, rects[key], {
        area: getArea(rects[key])
      });
    }).sort(function (a, b) {
      return b.area - a.area;
    });

    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });

    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

    var variation = placement.split('-')[1];

    return computedPlacement + (variation ? '-' + variation : '');
  }

  /**
   * Get offsets to the reference element
   * @method
   * @memberof Popper.Utils
   * @param {Object} state
   * @param {Element} popper - the popper element
   * @param {Element} reference - the reference element (the popper will be relative to this)
   * @param {Element} fixedPosition - is in fixed position mode
   * @returns {Object} An object containing the offsets which will be applied to the popper
   ../../../_/default.htm
  function getReferenceOffsets(state, popper, reference) {
    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
  }

  /**
   * Get the outer sizes of the given element (offset size + margins)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Object} object containing width and height properties
   ../../../_/default.htm
  function getOuterSizes(element) {
    var window = element.ownerDocument.defaultView;
    var styles = window.getComputedStyle(element);
    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };
    return result;
  }

  /**
   * Get the opposite placement of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement
   * @returns {String} flipped placement
   ../../../_/default.htm
  function getOppositePlacement(placement) {
    var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }

  /**
   * Get offsets to the popper
   * @method
   * @memberof Popper.Utils
   * @param {Object} position - CSS position the Popper will get applied
   * @param {HTMLElement} popper - the popper element
   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
   * @param {String} placement - one of the valid placement options
   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
   ../../../_/default.htm
  function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split('-')[0];

    // Get popper node sizes
    var popperRect = getOuterSizes(popper);

    // Add position, width and height to our offsets object
    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    };

    // depending by the popper placement we have to compute its offsets slightly differently
    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
    var mainSide = isHoriz ? 'top' : 'left';
    var secondarySide = isHoriz ? 'left' : 'top';
    var measurement = isHoriz ? 'height' : 'width';
    var secondaryMeasurement = !isHoriz ? 'height' : 'width';

    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] ../../../default.htm 2 - popperRect[measurement] ../../../default.htm 2;
    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
    }

    return popperOffsets;
  }

  /**
   * Mimics the `find` method of Array
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   ../../../_/default.htm
  function find(arr, check) {
    // use native find if supported
    if (Array.prototype.find) {
      return arr.find(check);
    }

    // use `filter` to obtain the same behavior of `find`
    return arr.filter(check)[0];
  }

  /**
   * Return the index of the matching object
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   ../../../_/default.htm
  function findIndex(arr, prop, value) {
    // use native findIndex if supported
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value;
      });
    }

    // use `find` + `indexOf` if `findIndex` isn't supported
    var match = find(arr, function (obj) {
      return obj[prop] === value;
    });
    return arr.indexOf(match);
  }

  /**
   * Loop trough the list of modifiers and run them in order,
   * each of them will then edit the data object.
   * @method
   * @memberof Popper.Utils
   * @param {dataObject} data
   * @param {Array} modifiers
   * @param {String} ends - Optional modifier name used as stopper
   * @returns {dataObject}
   ../../../_/default.htm
  function runModifiers(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

    modifiersToRun.forEach(function (modifier) {
      if (modifier['function']) {
        // eslint-disable-line dot-notation
        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
      }
      var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
      if (modifier.enabled && isFunction(fn)) {
        // Add properties to offsets to make them a complete clientRect object
        // we do this before each modifier to make sure the previous one doesn't
        // mess with these values
        data.offsets.popper = getClientRect(data.offsets.popper);
        data.offsets.reference = getClientRect(data.offsets.reference);

        data = fn(data, modifier);
      }
    });

    return data;
  }

  /**
   * Updates the position of the popper, computing the new offsets and applying
   * the new style.<br ../../../default.htm>
   * Prefer `scheduleUpdate` over `update` because of performance reasons.
   * @method
   * @memberof Popper
   ../../../_/default.htm
  function update() {
    // if popper is destroyed, don't perform any further update
    if (this.state.isDestroyed) {
      return;
    }

    var data = {
      instance: this,
      styles: {},
      arrowStyles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    };

    // compute reference element offsets
    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

    // store the computed placement inside `originalPlacement`
    data.originalPlacement = data.placement;

    data.positionFixed = this.options.positionFixed;

    // compute the popper offsets
    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

    // run the modifiers
    data = runModifiers(this.modifiers, data);

    // the first `update` will call `onCreate` callback
    // the other ones will call `onUpdate` callback
    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }

  /**
   * Helper used to know if the given modifier is enabled.
   * @method
   * @memberof Popper.Utils
   * @returns {Boolean}
   ../../../_/default.htm
  function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function (_ref) {
      var name = _ref.name,
          enabled = _ref.enabled;
      return enabled && name === modifierName;
    });
  }

  /**
   * Get the prefixed supported property name
   * @method
   * @memberof Popper.Utils
   * @argument {String} property (camelCase)
   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
   ../../../_/default.htm
  function getSupportedPropertyName(property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

    for (var i = 0; i < prefixes.length; i++) {
      var prefix = prefixes[i];
      var toCheck = prefix ? '' + prefix + upperProp : property;
      if (typeof document.body.style[toCheck] !== 'undefined') {
        return toCheck;
      }
    }
    return null;
  }

  /**
   * Destroys the popper.
   * @method
   * @memberof Popper
   ../../../_/default.htm
  function destroy() {
    this.state.isDestroyed = true;

    // touch DOM only if `applyStyle` modifier is enabled
    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
      this.popper.removeAttribute('x-placement');
      this.popper.style.position = '';
      this.popper.style.top = '';
      this.popper.style.left = '';
      this.popper.style.right = '';
      this.popper.style.bottom = '';
      this.popper.style.willChange = '';
      this.popper.style[getSupportedPropertyName('transform')] = '';
    }

    this.disableEventListeners();

    // remove the popper if user explicity asked for the deletion on destroy
    // do not use `remove` because IE11 doesn't support it
    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }
    return this;
  }

  /**
   * Get the window associated with the element
   * @argument {Element} element
   * @returns {Window}
   ../../../_/default.htm
  function getWindow(element) {
    var ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }

  function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY';
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
    target.addEventListener(event, callback, { passive: true });

    if (!isBody) {
      attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
    }
    scrollParents.push(target);
  }

  /**
   * Setup needed event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   ../../../_/default.htm
  function setupEventListeners(reference, options, state, updateBound) {
    // Resize event listener on window
    state.updateBound = updateBound;
    getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

    // Scroll event listener on scroll parents
    var scrollElement = getScrollParent(reference);
    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;

    return state;
  }

  /**
   * It will add resize/scroll events and start recalculating
   * position of the popper element when they are triggered.
   * @method
   * @memberof Popper
   ../../../_/default.htm
  function enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
  }

  /**
   * Remove event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   ../../../_/default.htm
  function removeEventListeners(reference, state) {
    // Remove resize event listener on window
    getWindow(reference).removeEventListener('resize', state.updateBound);

    // Remove scroll event listener on scroll parents
    state.scrollParents.forEach(function (target) {
      target.removeEventListener('scroll', state.updateBound);
    });

    // Reset state
    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }

  /**
   * It will remove resize/scroll events and won't recalculate popper position
   * when they are triggered. It also won't trigger `onUpdate` callback anymore,
   * unless you call `update` method manually.
   * @method
   * @memberof Popper
   ../../../_/default.htm
  function disableEventListeners() {
    if (this.state.eventsEnabled) {
      cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners(this.reference, this.state);
    }
  }

  /**
   * Tells if a given input is a number
   * @method
   * @memberof Popper.Utils
   * @param {*} input to check
   * @return {Boolean}
   ../../../_/default.htm
  function isNumeric(n) {
    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
  }

  /**
   * Set the style to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the style to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   ../../../_/default.htm
  function setStyles(element, styles) {
    Object.keys(styles).forEach(function (prop) {
      var unit = '';
      // add unit if the value is numeric and is one of the following
      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
        unit = 'px';
      }
      element.style[prop] = styles[prop] + unit;
    });
  }

  /**
   * Set the attributes to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the attributes to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   ../../../_/default.htm
  function setAttributes(element, attributes) {
    Object.keys(attributes).forEach(function (prop) {
      var value = attributes[prop];
      if (value !== false) {
        element.setAttribute(prop, attributes[prop]);
      } else {
        element.removeAttribute(prop);
      }
    });
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} data.styles - List of style properties - values to apply to popper element
   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The same data object
   ../../../_/default.htm
  function applyStyle(data) {
    // any property present in `data.styles` will be applied to the popper,
    // in this way we can make the 3rd party modifiers add custom styles to it
    // Be aware, modifiers could override the properties defined in the previous
    // lines of this modifier!
    setStyles(data.instance.popper, data.styles);

    // any property present in `data.attributes` will be applied to the popper,
    // they will be set as HTML attributes of the element
    setAttributes(data.instance.popper, data.attributes);

    // if arrowElement is defined and arrowStyles has some properties
    if (data.arrowElement && Object.keys(data.arrowStyles).length) {
      setStyles(data.arrowElement, data.arrowStyles);
    }

    return data;
  }

  /**
   * Set the x-placement attribute before everything else because it could be used
   * to add margins to the popper margins needs to be calculated to get the
   * correct popper offsets.
   * @method
   * @memberof Popper.modifiers
   * @param {HTMLElement} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper
   * @param {Object} options - Popper.js options
   ../../../_/default.htm
  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    // compute reference element offsets
    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

    popper.setAttribute('x-placement', placement);

    // Apply `position` to popper before anything else because
    // without the position applied we can't guarantee correct computations
    setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

    return options;
  }

  /**
   * @function
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Boolean} shouldRound - If the offsets should be rounded at all
   * @returns {Object} The popper's position offsets rounded
   *
   * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
   * good as it can be within reason.
   * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
   *
   * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
   * as well on High DPI screens).
   *
   * Firefox prefers no rounding for positioning and does not have blurriness on
   * high DPI screens.
   *
   * Only horizontal placement and left/right values need to be considered.
   ../../../_/default.htm
  function getRoundedOffsets(data, shouldRound) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var round = Math.round,
        floor = Math.floor;

    var noRound = function noRound(v) {
      return v;
    };

    var referenceWidth = round(reference.width);
    var popperWidth = round(popper.width);

    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
    var isVariation = data.placement.indexOf('-') !== -1;
    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
    var verticalToInteger = !shouldRound ? noRound : round;

    return {
      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
      top: verticalToInteger(popper.top),
      bottom: verticalToInteger(popper.bottom),
      right: horizontalToInteger(popper.right)
    };
  }

  var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   ../../../_/default.htm
  function computeStyle(data, options) {
    var x = options.x,
        y = options.y;
    var popper = data.offsets.popper;

    // Remove this legacy support in Popper.js v2

    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'applyStyle';
    }).gpuAcceleration;
    if (legacyGpuAccelerationOption !== undefined) {
      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
    }
    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent);

    // Styles
    var styles = {
      position: popper.position
    };

    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

    var sideA = x === 'bottom' ? 'top' : 'bottom';
    var sideB = y === 'right' ? 'left' : 'right';

    // if gpuAcceleration is set to `true` and transform is supported,
    //  we use `translate3d` to apply the position to the popper we
    // automatically use the supported prefixed version if needed
    var prefixedProperty = getSupportedPropertyName('transform');

    // now, let's make a step back and look at this code closely (wtf?)
    // If the content of the popper grows once it's been positioned, it
    // may happen that the popper gets misplaced because of the new content
    // overflowing its reference element
    // To avoid this problem, we provide two options (x and y), which allow
    // the consumer to define the offset origin.
    // If we position a popper on top of a reference element, we can set
    // `x` to `top` to make the popper grow towards its top instead of
    // its bottom.
    var left = void 0,
        top = void 0;
    if (sideA === 'bottom') {
      // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
      // and not the bottom of the html element
      if (offsetParent.nodeName === 'HTML') {
        top = -offsetParent.clientHeight + offsets.bottom;
      } else {
        top = -offsetParentRect.height + offsets.bottom;
      }
    } else {
      top = offsets.top;
    }
    if (sideB === 'right') {
      if (offsetParent.nodeName === 'HTML') {
        left = -offsetParent.clientWidth + offsets.right;
      } else {
        left = -offsetParentRect.width + offsets.right;
      }
    } else {
      left = offsets.left;
    }
    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = 'transform';
    } else {
      // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
      var invertTop = sideA === 'bottom' ? -1 : 1;
      var invertLeft = sideB === 'right' ? -1 : 1;
      styles[sideA] = top * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = sideA + ', ' + sideB;
    }

    // Attributes
    var attributes = {
      'x-placement': data.placement
    };

    // Update `data` attributes, styles and arrowStyles
    data.attributes = _extends({}, attributes, data.attributes);
    data.styles = _extends({}, styles, data.styles);
    data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

    return data;
  }

  /**
   * Helper used to know if the given modifier depends from another one.<br ../../../default.htm>
   * It checks if the needed modifier is listed and enabled.
   * @method
   * @memberof Popper.Utils
   * @param {Array} modifiers - list of modifiers
   * @param {String} requestingName - name of requesting modifier
   * @param {String} requestedName - name of requested modifier
   * @returns {Boolean}
   ../../../_/default.htm
  function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function (_ref) {
      var name = _ref.name;
      return name === requestingName;
    });

    var isRequired = !!requesting && modifiers.some(function (modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });

    if (!isRequired) {
      var _requesting = '`' + requestingName + '`';
      var requested = '`' + requestedName + '`';
      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
    }
    return isRequired;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   ../../../_/default.htm
  function arrow(data, options) {
    var _data$offsets$arrow;

    // arrow depends on keepTogether in order to work
    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
      return data;
    }

    var arrowElement = options.element;

    // if arrowElement is a string, suppose it's a CSS selector
    if (typeof arrowElement === 'string') {
      arrowElement = data.instance.popper.querySelector(arrowElement);

      // if arrowElement is not found, don't run the modifier
      if (!arrowElement) {
        return data;
      }
    } else {
      // if the arrowElement isn't a query selector we must check that the
      // provided DOM node is child of its popper node
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn('WARNING: `arrow.element` must be child of its popper element!');
        return data;
      }
    }

    var placement = data.placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var isVertical = ['left', 'right'].indexOf(placement) !== -1;

    var len = isVertical ? 'height' : 'width';
    var sideCapitalized = isVertical ? 'Top' : 'Left';
    var side = sideCapitalized.toLowerCase();
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowElementSize = getOuterSizes(arrowElement)[len];

    //
    // extends keepTogether behavior making sure the popper and its
    // reference have enough pixels in conjunction
    //

    // top/left side
    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    }
    // bottom/right side
    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }
    data.offsets.popper = getClientRect(data.offsets.popper);

    // compute center of the popper
    var center = reference[side] + reference[len] ../../../default.htm 2 - arrowElementSize ../../../default.htm 2;

    // Compute the sideValue using the updated popper offsets
    // take popper margin in account because we don't have this info available
    var css = getStyleComputedProperty(data.instance.popper);
    var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
    var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

    // prevent arrowElement from being placed not contiguously to its popper
    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

    data.arrowElement = arrowElement;
    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

    return data;
  }

  /**
   * Get the opposite placement variation of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement variation
   * @returns {String} flipped placement variation
   ../../../_/default.htm
  function getOppositeVariation(variation) {
    if (variation === 'end') {
      return 'start';
    } else if (variation === 'start') {
      return 'end';
    }
    return variation;
  }

  /**
   * List of accepted placements to use as values of the `placement` option.<br ../../../default.htm>
   * Valid placements are:
   * - `auto`
   * - `top`
   * - `right`
   * - `bottom`
   * - `left`
   *
   * Each placement can have a variation from this list:
   * - `-start`
   * - `-end`
   *
   * Variations are interpreted easily if you think of them as the left to right
   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
   * is right.<br ../../../default.htm>
   * Vertically (`left` and `right`), `start` is top and `end` is bottom.
   *
   * Some valid examples are:
   * - `top-end` (on top of reference, right aligned)
   * - `right-start` (on right of reference, top aligned)
   * - `bottom` (on bottom, centered)
   * - `auto-end` (on the side with more space available, alignment depends by placement)
   *
   * @static
   * @type {Array}
   * @enum {String}
   * @readonly
   * @method placements
   * @memberof Popper
   ../../../_/default.htm
  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

  // Get rid of `auto` `auto-start` and `auto-end`
  var validPlacements = placements.slice(3);

  /**
   * Given an initial placement, returns all the subsequent placements
   * clockwise (or counter-clockwise).
   *
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement - A valid placement (it accepts variations)
   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
   * @returns {Array} placements including their variations
   ../../../_/default.htm
  function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
  }

  var BEHAVIORS = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
  };

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   ../../../_/default.htm
  function flip(data, options) {
    // if `inner` modifier is enabled, we can't use the `flip` modifier
    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
      return data;
    }

    if (data.flipped && data.placement === data.originalPlacement) {
      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
      return data;
    }

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';

    var flipOrder = [];

    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite];
        break;
      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement);
        break;
      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true);
        break;
      default:
        flipOrder = options.behavior;
    }

    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }

      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);

      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference;

      // using floor because the reference offsets may contain decimals we are not going to consider here
      var floor = Math.floor;
      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

      // flip the variation if required
      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
      var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        // this boolean to detect any flip loop
        data.flipped = true;

        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }

        if (flippedVariation) {
          variation = getOppositeVariation(variation);
        }

        data.placement = placement + (variation ? '-' + variation : '');

        // this object contains `position`, we want to preserve it along with
        // any additional property we may add in the future
        data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

        data = runModifiers(data.instance.modifiers, data, 'flip');
      }
    });
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   ../../../_/default.htm
  function keepTogether(data) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var placement = data.placement.split('-')[0];
    var floor = Math.floor;
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var side = isVertical ? 'right' : 'bottom';
    var opSide = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }
    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }

    return data;
  }

  /**
   * Converts a string containing value + unit into a px value number
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} str - Value + unit string
   * @argument {String} measurement - `height` or `width`
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @returns {Number|String}
   * Value in pixels, or original string if no values were extracted
   ../../../_/default.htm
  function toValue(str, measurement, popperOffsets, referenceOffsets) {
    // separate value from unit
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2];

    // If it's not a number it's an operator, I guess
    if (!value) {
      return str;
    }

    if (unit.indexOf('%') === 0) {
      var element = void 0;
      switch (unit) {
        case '%p':
          element = popperOffsets;
          break;
        case '%':
        case '%r':
        default:
          element = referenceOffsets;
      }

      var rect = getClientRect(element);
      return rect[measurement] ../../../default.htm 100 * value;
    } else if (unit === 'vh' || unit === 'vw') {
      // if is a vh or vw, we calculate the size based on the viewport
      var size = void 0;
      if (unit === 'vh') {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      }
      return size ../../../default.htm 100 * value;
    } else {
      // if is an explicit pixel unit, we get rid of the unit and keep the value
      // if is an implicit unit, it's px, and we return just the value
      return value;
    }
  }

  /**
   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} offset
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @argument {String} basePlacement
   * @returns {Array} a two cells array with x and y offsets in numbers
   ../../../_/default.htm
  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0];

    // Use height if placement is left or right and index is 0 otherwise use width
    // in this way the first offset will use an axis and the second one
    // will use the other one
    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

    // Split the offset string to obtain a list of values and operands
    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim();
    });

    // Detect if the offset string contains a pair of values or a single one
    // they could be separated by comma or space
    var divider = fragments.indexOf(find(fragments, function (frag) {
      return frag.search(/,|\s/) !== -1;
    }));

    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    }

    // If divider is found, we divide the list of values and operands to divide
    // them by ofset X and Y.
    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

    // Convert the values with units to absolute pixels to allow our computations
    ops = ops.map(function (op, index) {
      // Most of the units rely on the orientation of the popper
      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
      var mergeWithPrevious = false;
      return op
      // This aggregates any `+` or `-` sign that aren't considered operators
      // e.g.: 10 + +5 => [10, +, +5]
      .reduce(function (a, b) {
        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
          a[a.length - 1] = b;
          mergeWithPrevious = true;
          return a;
        } else if (mergeWithPrevious) {
          a[a.length - 1] += b;
          mergeWithPrevious = false;
          return a;
        } else {
          return a.concat(b);
        }
      }, [])
      // Here we convert the string values into number values (in px)
      .map(function (str) {
        return toValue(str, measurement, popperOffsets, referenceOffsets);
      });
    });

    // Loop trough the offsets arrays and execute the operations
    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
        }
      });
    });
    return offsets;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @argument {Number|String} options.offset=0
   * The offset value as described in the modifier description
   * @returns {Object} The data object, properly modified
   ../../../_/default.htm
  function offset(data, _ref) {
    var offset = _ref.offset;
    var placement = data.placement,
        _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var basePlacement = placement.split('-')[0];

    var offsets = void 0;
    if (isNumeric(+offset)) {
      offsets = [+offset, 0];
    } else {
      offsets = parseOffset(offset, popper, reference, basePlacement);
    }

    if (basePlacement === 'left') {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === 'right') {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === 'top') {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === 'bottom') {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }

    data.popper = popper;
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   ../../../_/default.htm
  function preventOverflow(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

    // If offsetParent is the reference element, we really want to
    // go one step up and use the next offsetParent as reference to
    // avoid to make this modifier completely useless and look like broken
    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent(boundariesElement);
    }

    // NOTE: DOM access here
    // resets the popper's position so that the document size can be calculated excluding
    // the size of the popper element itself
    var transformProp = getSupportedPropertyName('transform');
    var popperStyles = data.instance.popper.style; // assignment to help minification
    var top = popperStyles.top,
        left = popperStyles.left,
        transform = popperStyles[transformProp];

    popperStyles.top = '';
    popperStyles.left = '';
    popperStyles[transformProp] = '';

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

    // NOTE: DOM access here
    // restores the original style properties after the offsets have been computed
    popperStyles.top = top;
    popperStyles.left = left;
    popperStyles[transformProp] = transform;

    options.boundaries = boundaries;

    var order = options.priority;
    var popper = data.offsets.popper;

    var check = {
      primary: function primary(placement) {
        var value = popper[placement];
        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement]);
        }
        return defineProperty({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === 'right' ? 'left' : 'top';
        var value = popper[mainSide];
        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
        }
        return defineProperty({}, mainSide, value);
      }
    };

    order.forEach(function (placement) {
      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
      popper = _extends({}, popper, check[side](placement));
    });

    data.offsets.popper = popper;

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   ../../../_/default.htm
  function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftvariation = placement.split('-')[1];

    // if shift shiftvariation is specified, run the modifier
    if (shiftvariation) {
      var _data$offsets = data.offsets,
          reference = _data$offsets.reference,
          popper = _data$offsets.popper;

      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
      var side = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';

      var shiftOffsets = {
        start: defineProperty({}, side, reference[side]),
        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
      };

      data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
    }

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   ../../../_/default.htm
  function hide(data) {
    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
      return data;
    }

    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'preventOverflow';
    }).boundaries;

    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === true) {
        return data;
      }

      data.hide = true;
      data.attributes['x-out-of-boundaries'] = '';
    } else {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === false) {
        return data;
      }

      data.hide = false;
      data.attributes['x-out-of-boundaries'] = false;
    }

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   ../../../_/default.htm
  function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);

    return data;
  }

  /**
   * Modifier function, each modifier can have a function of this type assigned
   * to its `fn` property.<br ../../../default.htm>
   * These functions will be called on each update, this means that you must
   * make sure they are performant enough to avoid performance bottlenecks.
   *
   * @function ModifierFn
   * @argument {dataObject} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {dataObject} The data object, properly modified
   ../../../_/default.htm

  /**
   * Modifiers are plugins used to alter the behavior of your poppers.<br ../../../default.htm>
   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
   * needed by the library.
   *
   * Usually you don't want to override the `order`, `fn` and `onLoad` props.
   * All the other properties are configurations that could be tweaked.
   * @namespace modifiers
   ../../../_/default.htm
  var modifiers = {
    /**
     * Modifier used to shift the popper on the start or end of its reference
     * element.<br ../../../default.htm>
     * It will read the variation of the `placement` property.<br ../../../default.htm>
     * It can be one either `-end` or `-start`.
     * @memberof modifiers
     * @inner
     ../../../_/default.htm
    shift: {
      /** @prop {number} order=100 - Index used to define the order of execution ../../../_/default.htm
      order: 100,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not ../../../_/default.htm
      enabled: true,
      /** @prop {ModifierFn} ../../../_/default.htm
      fn: shift
    },

    /**
     * The `offset` modifier can shift your popper on both its axis.
     *
     * It accepts the following units:
     * - `px` or unit-less, interpreted as pixels
     * - `%` or `%r`, percentage relative to the length of the reference element
     * - `%p`, percentage relative to the length of the popper element
     * - `vw`, CSS viewport width unit
     * - `vh`, CSS viewport height unit
     *
     * For length is intended the main axis relative to the placement of the popper.<br ../../../default.htm>
     * This means that if the placement is `top` or `bottom`, the length will be the
     * `width`. In case of `left` or `right`, it will be the `height`.
     *
     * You can provide a single value (as `Number` or `String`), or a pair of values
     * as `String` divided by a comma or one (or more) white spaces.<br ../../../default.htm>
     * The latter is a deprecated method because it leads to confusion and will be
     * removed in v2.<br ../../../default.htm>
     * Additionally, it accepts additions and subtractions between different units.
     * Note that multiplications and divisions aren't supported.
     *
     * Valid examples are:
     * ```
     * 10
     * '10%'
     * '10, 10'
     * '10%, 10'
     * '10 + 10%'
     * '10 - 5vh + 3%'
     * '-10px + 5vh, 5px - 6%'
     * ```
     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
     *
     * @memberof modifiers
     * @inner
     ../../../_/default.htm
    offset: {
      /** @prop {number} order=200 - Index used to define the order of execution ../../../_/default.htm
      order: 200,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not ../../../_/default.htm
      enabled: true,
      /** @prop {ModifierFn} ../../../_/default.htm
      fn: offset,
      /** @prop {Number|String} offset=0
       * The offset value as described in the modifier description
       ../../../_/default.htm
      offset: 0
    },

    /**
     * Modifier used to prevent the popper from being positioned outside the boundary.
     *
     * A scenario exists where the reference itself is not within the boundaries.<br ../../../default.htm>
     * We can say it has "escaped the boundaries" — or just "escaped".<br ../../../default.htm>
     * In this case we need to decide whether the popper should either:
     *
     * - detach from the reference and remain "trapped" in the boundaries, or
     * - if it should ignore the boundary and "escape with its reference"
     *
     * When `escapeWithReference` is set to`true` and reference is completely
     * outside its boundaries, the popper will overflow (or completely leave)
     * the boundaries in order to remain attached to the edge of the reference.
     *
     * @memberof modifiers
     * @inner
     ../../../_/default.htm
    preventOverflow: {
      /** @prop {number} order=300 - Index used to define the order of execution ../../../_/default.htm
      order: 300,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not ../../../_/default.htm
      enabled: true,
      /** @prop {ModifierFn} ../../../_/default.htm
      fn: preventOverflow,
      /**
       * @prop {Array} [priority=['left','right','top','bottom']]
       * Popper will try to prevent overflow following these priorities by default,
       * then, it could overflow on the left and on top of the `boundariesElement`
       ../../../_/default.htm
      priority: ['left', 'right', 'top', 'bottom'],
      /**
       * @prop {number} padding=5
       * Amount of pixel used to define a minimum distance between the boundaries
       * and the popper. This makes sure the popper always has a little padding
       * between the edges of its container
       ../../../_/default.htm
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='scrollParent'
       * Boundaries used by the modifier. Can be `scrollParent`, `window`,
       * `viewport` or any DOM element.
       ../../../_/default.htm
      boundariesElement: 'scrollParent'
    },

    /**
     * Modifier used to make sure the reference and its popper stay near each other
     * without leaving any gap between the two. Especially useful when the arrow is
     * enabled and you want to ensure that it points to its reference element.
     * It cares only about the first axis. You can still have poppers with margin
     * between the popper and its reference element.
     * @memberof modifiers
     * @inner
     ../../../_/default.htm
    keepTogether: {
      /** @prop {number} order=400 - Index used to define the order of execution ../../../_/default.htm
      order: 400,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not ../../../_/default.htm
      enabled: true,
      /** @prop {ModifierFn} ../../../_/default.htm
      fn: keepTogether
    },

    /**
     * This modifier is used to move the `arrowElement` of the popper to make
     * sure it is positioned between the reference element and its popper element.
     * It will read the outer size of the `arrowElement` node to detect how many
     * pixels of conjunction are needed.
     *
     * It has no effect if no `arrowElement` is provided.
     * @memberof modifiers
     * @inner
     ../../../_/default.htm
    arrow: {
      /** @prop {number} order=500 - Index used to define the order of execution ../../../_/default.htm
      order: 500,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not ../../../_/default.htm
      enabled: true,
      /** @prop {ModifierFn} ../../../_/default.htm
      fn: arrow,
      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow ../../../_/default.htm
      element: '[x-arrow]'
    },

    /**
     * Modifier used to flip the popper's placement when it starts to overlap its
     * reference element.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     *
     * **NOTE:** this modifier will interrupt the current update cycle and will
     * restart it if it detects the need to flip the placement.
     * @memberof modifiers
     * @inner
     ../../../_/default.htm
    flip: {
      /** @prop {number} order=600 - Index used to define the order of execution ../../../_/default.htm
      order: 600,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not ../../../_/default.htm
      enabled: true,
      /** @prop {ModifierFn} ../../../_/default.htm
      fn: flip,
      /**
       * @prop {String|Array} behavior='flip'
       * The behavior used to change the popper's placement. It can be one of
       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
       * placements (with optional variations)
       ../../../_/default.htm
      behavior: 'flip',
      /**
       * @prop {number} padding=5
       * The popper will flip if it hits the edges of the `boundariesElement`
       ../../../_/default.htm
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='viewport'
       * The element which will define the boundaries of the popper position.
       * The popper will never be placed outside of the defined boundaries
       * (except if `keepTogether` is enabled)
       ../../../_/default.htm
      boundariesElement: 'viewport'
    },

    /**
     * Modifier used to make the popper flow toward the inner of the reference element.
     * By default, when this modifier is disabled, the popper will be placed outside
     * the reference element.
     * @memberof modifiers
     * @inner
     ../../../_/default.htm
    inner: {
      /** @prop {number} order=700 - Index used to define the order of execution ../../../_/default.htm
      order: 700,
      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not ../../../_/default.htm
      enabled: false,
      /** @prop {ModifierFn} ../../../_/default.htm
      fn: inner
    },

    /**
     * Modifier used to hide the popper when its reference element is outside of the
     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
     * be used to hide with a CSS selector the popper when its reference is
     * out of boundaries.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     * @memberof modifiers
     * @inner
     ../../../_/default.htm
    hide: {
      /** @prop {number} order=800 - Index used to define the order of execution ../../../_/default.htm
      order: 800,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not ../../../_/default.htm
      enabled: true,
      /** @prop {ModifierFn} ../../../_/default.htm
      fn: hide
    },

    /**
     * Computes the style that will be applied to the popper element to gets
     * properly positioned.
     *
     * Note that this modifier will not touch the DOM, it just prepares the styles
     * so that `applyStyle` modifier can apply it. This separation is useful
     * in case you need to replace `applyStyle` with a custom implementation.
     *
     * This modifier has `850` as `order` value to maintain backward compatibility
     * with previous versions of Popper.js. Expect the modifiers ordering method
     * to change in future major versions of the library.
     *
     * @memberof modifiers
     * @inner
     ../../../_/default.htm
    computeStyle: {
      /** @prop {number} order=850 - Index used to define the order of execution ../../../_/default.htm
      order: 850,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not ../../../_/default.htm
      enabled: true,
      /** @prop {ModifierFn} ../../../_/default.htm
      fn: computeStyle,
      /**
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       ../../../_/default.htm
      gpuAcceleration: true,
      /**
       * @prop {string} [x='bottom']
       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
       * Change this if your popper should grow in a direction different from `bottom`
       ../../../_/default.htm
      x: 'bottom',
      /**
       * @prop {string} [x='left']
       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
       * Change this if your popper should grow in a direction different from `right`
       ../../../_/default.htm
      y: 'right'
    },

    /**
     * Applies the computed styles to the popper element.
     *
     * All the DOM manipulations are limited to this modifier. This is useful in case
     * you want to integrate Popper.js inside a framework or view library and you
     * want to delegate all the DOM manipulations to it.
     *
     * Note that if you disable this modifier, you must make sure the popper element
     * has its position set to `absolute` before Popper.js can do its work!
     *
     * Just disable this modifier and define your own to achieve the desired effect.
     *
     * @memberof modifiers
     * @inner
     ../../../_/default.htm
    applyStyle: {
      /** @prop {number} order=900 - Index used to define the order of execution ../../../_/default.htm
      order: 900,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not ../../../_/default.htm
      enabled: true,
      /** @prop {ModifierFn} ../../../_/default.htm
      fn: applyStyle,
      /** @prop {Function} ../../../_/default.htm
      onLoad: applyStyleOnLoad,
      /**
       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       ../../../_/default.htm
      gpuAcceleration: undefined
    }
  };

  /**
   * The `dataObject` is an object containing all the information used by Popper.js.
   * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
   * @name dataObject
   * @property {Object} data.instance The Popper.js instance
   * @property {String} data.placement Placement applied to popper
   * @property {String} data.originalPlacement Placement originally defined on init
   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
   * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.boundaries Offsets of the popper boundaries
   * @property {Object} data.offsets The measurements of popper, reference and arrow elements
   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
   ../../../_/default.htm

  /**
   * Default options provided to Popper.js constructor.<br ../../../default.htm>
   * These can be overridden using the `options` argument of Popper.js.<br ../../../default.htm>
   * To override an option, simply pass an object with the same
   * structure of the `options` object, as the 3rd argument. For example:
   * ```
   * new Popper(ref, pop, {
   *   modifiers: {
   *     preventOverflow: { enabled: false }
   *   }
   * })
   * ```
   * @type {Object}
   * @static
   * @memberof Popper
   ../../../_/default.htm
  var Defaults = {
    /**
     * Popper's placement.
     * @prop {Popper.placements} placement='bottom'
     ../../../_/default.htm
    placement: 'bottom',

    /**
     * Set this to true if you want popper to position it self in 'fixed' mode
     * @prop {Boolean} positionFixed=false
     ../../../_/default.htm
    positionFixed: false,

    /**
     * Whether events (resize, scroll) are initially enabled.
     * @prop {Boolean} eventsEnabled=true
     ../../../_/default.htm
    eventsEnabled: true,

    /**
     * Set to true if you want to automatically remove the popper when
     * you call the `destroy` method.
     * @prop {Boolean} removeOnDestroy=false
     ../../../_/default.htm
    removeOnDestroy: false,

    /**
     * Callback called when the popper is created.<br ../../../default.htm>
     * By default, it is set to no-op.<br ../../../default.htm>
     * Access Popper.js instance with `data.instance`.
     * @prop {onCreate}
     ../../../_/default.htm
    onCreate: function onCreate() {},

    /**
     * Callback called when the popper is updated. This callback is not called
     * on the initialization/creation of the popper, but only on subsequent
     * updates.<br ../../../default.htm>
     * By default, it is set to no-op.<br ../../../default.htm>
     * Access Popper.js instance with `data.instance`.
     * @prop {onUpdate}
     ../../../_/default.htm
    onUpdate: function onUpdate() {},

    /**
     * List of modifiers used to modify the offsets before they are applied to the popper.
     * They provide most of the functionalities of Popper.js.
     * @prop {modifiers}
     ../../../_/default.htm
    modifiers: modifiers
  };

  /**
   * @callback onCreate
   * @param {dataObject} data
   ../../../_/default.htm

  /**
   * @callback onUpdate
   * @param {dataObject} data
   ../../../_/default.htm

  // Utils
  // Methods
  var Popper = function () {
    /**
     * Creates a new Popper.js instance.
     * @class Popper
     * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
     * @param {HTMLElement} popper - The HTML element used as the popper
     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
     * @return {Object} instance - The generated Popper.js instance
     ../../../_/default.htm
    function Popper(reference, popper) {
      var _this = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      classCallCheck(this, Popper);

      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update);
      };

      // make update() debounced, so that it only runs at most once-per-tick
      this.update = debounce(this.update.bind(this));

      // with {} we create a new object with the options inside it
      this.options = _extends({}, Popper.Defaults, options);

      // init state
      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      };

      // get reference and popper elements (allow jQuery wrappers)
      this.reference = reference && reference.jquery ? reference[0] : reference;
      this.popper = popper && popper.jquery ? popper[0] : popper;

      // Deep merge modifiers options
      this.options.modifiers = {};
      Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
        _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
      });

      // Refactoring modifiers' list (Object => Array)
      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
        return _extends({
          name: name
        }, _this.options.modifiers[name]);
      })
      // sort the modifiers by order
      .sort(function (a, b) {
        return a.order - b.order;
      });

      // modifiers have the ability to execute arbitrary code when Popper.js get inited
      // such code is executed in the same order of its modifier
      // they could add new properties to their options configuration
      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
        }
      });

      // fire the first update to position the popper in the right place
      this.update();

      var eventsEnabled = this.options.eventsEnabled;
      if (eventsEnabled) {
        // setup event listeners, they will take care of update the position in specific situations
        this.enableEventListeners();
      }

      this.state.eventsEnabled = eventsEnabled;
    }

    // We can't use class properties because they don't get listed in the
    // class prototype and break stuff like Sinon stubs


    createClass(Popper, [{
      key: 'update',
      value: function update$$1() {
        return update.call(this);
      }
    }, {
      key: 'destroy',
      value: function destroy$$1() {
        return destroy.call(this);
      }
    }, {
      key: 'enableEventListeners',
      value: function enableEventListeners$$1() {
        return enableEventListeners.call(this);
      }
    }, {
      key: 'disableEventListeners',
      value: function disableEventListeners$$1() {
        return disableEventListeners.call(this);
      }

      /**
       * Schedules an update. It will run on the next UI update available.
       * @method scheduleUpdate
       * @memberof Popper
       ../../../_/default.htm


      /**
       * Collection of utilities useful when writing custom modifiers.
       * Starting from version 1.7, this method is available only if you
       * include `popper-utils.js` before `popper.js`.
       *
       * **DEPRECATION**: This way to access PopperUtils is deprecated
       * and will be removed in v2! Use the PopperUtils module directly instead.
       * Due to the high instability of the methods contained in Utils, we can't
       * guarantee them to follow semver. Use them at your own risk!
       * @static
       * @private
       * @type {Object}
       * @deprecated since version 1.8
       * @member Utils
       * @memberof Popper
       ../../../_/default.htm

    }]);
    return Popper;
  }();

  /**
   * The `referenceObject` is an object that provides an interface compatible with Popper.js
   * and lets you use it as replacement of a real DOM node.<br ../../../default.htm>
   * You can use this method to position a popper relatively to a set of coordinates
   * in case you don't have a DOM node to use as reference.
   *
   * ```
   * new Popper(referenceObject, popperNode);
   * ```
   *
   * NB: This feature isn't supported in Internet Explorer 10.
   * @name referenceObject
   * @property {Function} data.getBoundingClientRect
   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
   * @property {number} data.clientWidth
   * An ES6 getter that will return the width of the virtual reference element.
   * @property {number} data.clientHeight
   * An ES6 getter that will return the height of the virtual reference element.
   ../../../_/default.htm


  Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
  Popper.placements = placements;
  Popper.Defaults = Defaults;

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  var NAME$4 = 'dropdown';
  var VERSION$4 = '4.3.1';
  var DATA_KEY$4 = 'bs.dropdown';
  var EVENT_KEY$4 = "." + DATA_KEY$4;
  var DATA_API_KEY$4 = '.data-api';
  var JQUERY_NO_CONFLICT$4 = $.fn[NAME$4];
  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

  var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key

  var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key

  var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key

  var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key

  var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)

  var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + "|" + ARROW_DOWN_KEYCODE + "|" + ESCAPE_KEYCODE);
  var Event$4 = {
    HIDE: "hide" + EVENT_KEY$4,
    HIDDEN: "hidden" + EVENT_KEY$4,
    SHOW: "show" + EVENT_KEY$4,
    SHOWN: "shown" + EVENT_KEY$4,
    CLICK: "click" + EVENT_KEY$4,
    CLICK_DATA_API: "click" + EVENT_KEY$4 + DATA_API_KEY$4,
    KEYDOWN_DATA_API: "keydown" + EVENT_KEY$4 + DATA_API_KEY$4,
    KEYUP_DATA_API: "keyup" + EVENT_KEY$4 + DATA_API_KEY$4
  };
  var ClassName$4 = {
    DISABLED: 'disabled',
    SHOW: 'show',
    DROPUP: 'dropup',
    DROPRIGHT: 'dropright',
    DROPLEFT: 'dropleft',
    MENURIGHT: 'dropdown-menu-right',
    MENULEFT: 'dropdown-menu-left',
    POSITION_STATIC: 'position-static'
  };
  var Selector$4 = {
    DATA_TOGGLE: '[data-toggle="dropdown"]',
    FORM_CHILD: '.dropdown form',
    MENU: '.dropdown-menu',
    NAVBAR_NAV: '.navbar-nav',
    VISIBLE_ITEMS: '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)'
  };
  var AttachmentMap = {
    TOP: 'top-start',
    TOPEND: 'top-end',
    BOTTOM: 'bottom-start',
    BOTTOMEND: 'bottom-end',
    RIGHT: 'right-start',
    RIGHTEND: 'right-end',
    LEFT: 'left-start',
    LEFTEND: 'left-end'
  };
  var Default$2 = {
    offset: 0,
    flip: true,
    boundary: 'scrollParent',
    reference: 'toggle',
    display: 'dynamic'
  };
  var DefaultType$2 = {
    offset: '(number|string|function)',
    flip: 'boolean',
    boundary: '(string|element)',
    reference: '(string|element)',
    display: 'string'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     ../../../_/default.htm

  };

  var Dropdown =
  /*#__PURE__*/
  function () {
    function Dropdown(element, config) {
      this._element = element;
      this._popper = null;
      this._config = this._getConfig(config);
      this._menu = this._getMenuElement();
      this._inNavbar = this._detectNavbar();

      this._addEventListeners();
    } // Getters


    var _proto = Dropdown.prototype;

    // Public
    _proto.toggle = function toggle() {
      if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED)) {
        return;
      }

      var parent = Dropdown._getParentFromElement(this._element);

      var isActive = $(this._menu).hasClass(ClassName$4.SHOW);

      Dropdown._clearMenus();

      if (isActive) {
        return;
      }

      var relatedTarget = {
        relatedTarget: this._element
      };
      var showEvent = $.Event(Event$4.SHOW, relatedTarget);
      $(parent).trigger(showEvent);

      if (showEvent.isDefaultPrevented()) {
        return;
      } // Disable totally Popper.js for Dropdown in Navbar


      if (!this._inNavbar) {
        /**
         * Check for Popper dependency
         * Popper - https://popper.js.org
         ../../../_/default.htm
        if (typeof Popper === 'undefined') {
          throw new TypeError('Bootstrap\'s dropdowns require Popper.js (https://popper.js.org/)');
        }

        var referenceElement = this._element;

        if (this._config.reference === 'parent') {
          referenceElement = parent;
        } else if (Util.isElement(this._config.reference)) {
          referenceElement = this._config.reference; // Check if it's jQuery element

          if (typeof this._config.reference.jquery !== 'undefined') {
            referenceElement = this._config.reference[0];
          }
        } // If boundary is not `scrollParent`, then set position to `static`
        // to allow the menu to "escape" the scroll parent's boundaries
        // https://github.com/twbs/bootstrap/issues/24251


        if (this._config.boundary !== 'scrollParent') {
          $(parent).addClass(ClassName$4.POSITION_STATIC);
        }

        this._popper = new Popper(referenceElement, this._menu, this._getPopperConfig());
      } // If this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children;
      // only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


      if ('ontouchstart' in document.documentElement && $(parent).closest(Selector$4.NAVBAR_NAV).length === 0) {
        $(document.body).children().on('mouseover', null, $.noop);
      }

      this._element.focus();

      this._element.setAttribute('aria-expanded', true);

      $(this._menu).toggleClass(ClassName$4.SHOW);
      $(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.SHOWN, relatedTarget));
    };

    _proto.show = function show() {
      if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED) || $(this._menu).hasClass(ClassName$4.SHOW)) {
        return;
      }

      var relatedTarget = {
        relatedTarget: this._element
      };
      var showEvent = $.Event(Event$4.SHOW, relatedTarget);

      var parent = Dropdown._getParentFromElement(this._element);

      $(parent).trigger(showEvent);

      if (showEvent.isDefaultPrevented()) {
        return;
      }

      $(this._menu).toggleClass(ClassName$4.SHOW);
      $(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.SHOWN, relatedTarget));
    };

    _proto.hide = function hide() {
      if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED) || !$(this._menu).hasClass(ClassName$4.SHOW)) {
        return;
      }

      var relatedTarget = {
        relatedTarget: this._element
      };
      var hideEvent = $.Event(Event$4.HIDE, relatedTarget);

      var parent = Dropdown._getParentFromElement(this._element);

      $(parent).trigger(hideEvent);

      if (hideEvent.isDefaultPrevented()) {
        return;
      }

      $(this._menu).toggleClass(ClassName$4.SHOW);
      $(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.HIDDEN, relatedTarget));
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$4);
      $(this._element).off(EVENT_KEY$4);
      this._element = null;
      this._menu = null;

      if (this._popper !== null) {
        this._popper.destroy();

        this._popper = null;
      }
    };

    _proto.update = function update() {
      this._inNavbar = this._detectNavbar();

      if (this._popper !== null) {
        this._popper.scheduleUpdate();
      }
    } // Private
    ;

    _proto._addEventListeners = function _addEventListeners() {
      var _this = this;

      $(this._element).on(Event$4.CLICK, function (event) {
        event.preventDefault();
        event.stopPropagation();

        _this.toggle();
      });
    };

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread({}, this.constructor.Default, $(this._element).data(), config);
      Util.typeCheckConfig(NAME$4, config, this.constructor.DefaultType);
      return config;
    };

    _proto._getMenuElement = function _getMenuElement() {
      if (!this._menu) {
        var parent = Dropdown._getParentFromElement(this._element);

        if (parent) {
          this._menu = parent.querySelector(Selector$4.MENU);
        }
      }

      return this._menu;
    };

    _proto._getPlacement = function _getPlacement() {
      var $parentDropdown = $(this._element.parentNode);
      var placement = AttachmentMap.BOTTOM; // Handle dropup

      if ($parentDropdown.hasClass(ClassName$4.DROPUP)) {
        placement = AttachmentMap.TOP;

        if ($(this._menu).hasClass(ClassName$4.MENURIGHT)) {
          placement = AttachmentMap.TOPEND;
        }
      } else if ($parentDropdown.hasClass(ClassName$4.DROPRIGHT)) {
        placement = AttachmentMap.RIGHT;
      } else if ($parentDropdown.hasClass(ClassName$4.DROPLEFT)) {
        placement = AttachmentMap.LEFT;
      } else if ($(this._menu).hasClass(ClassName$4.MENURIGHT)) {
        placement = AttachmentMap.BOTTOMEND;
      }

      return placement;
    };

    _proto._detectNavbar = function _detectNavbar() {
      return $(this._element).closest('.navbar').length > 0;
    };

    _proto._getOffset = function _getOffset() {
      var _this2 = this;

      var offset = {};

      if (typeof this._config.offset === 'function') {
        offset.fn = function (data) {
          data.offsets = _objectSpread({}, data.offsets, _this2._config.offset(data.offsets, _this2._element) || {});
          return data;
        };
      } else {
        offset.offset = this._config.offset;
      }

      return offset;
    };

    _proto._getPopperConfig = function _getPopperConfig() {
      var popperConfig = {
        placement: this._getPlacement(),
        modifiers: {
          offset: this._getOffset(),
          flip: {
            enabled: this._config.flip
          },
          preventOverflow: {
            boundariesElement: this._config.boundary
          }
        } // Disable Popper.js if we have a static display

      };

      if (this._config.display === 'static') {
        popperConfig.modifiers.applyStyle = {
          enabled: false
        };
      }

      return popperConfig;
    } // Static
    ;

    Dropdown._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$4);

        var _config = typeof config === 'object' ? config : null;

        if (!data) {
          data = new Dropdown(this, _config);
          $(this).data(DATA_KEY$4, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    Dropdown._clearMenus = function _clearMenus(event) {
      if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {
        return;
      }

      var toggles = [].slice.call(document.querySelectorAll(Selector$4.DATA_TOGGLE));

      for (var i = 0, len = toggles.length; i < len; i++) {
        var parent = Dropdown._getParentFromElement(toggles[i]);

        var context = $(toggles[i]).data(DATA_KEY$4);
        var relatedTarget = {
          relatedTarget: toggles[i]
        };

        if (event && event.type === 'click') {
          relatedTarget.clickEvent = event;
        }

        if (!context) {
          continue;
        }

        var dropdownMenu = context._menu;

        if (!$(parent).hasClass(ClassName$4.SHOW)) {
          continue;
        }

        if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $.contains(parent, event.target)) {
          continue;
        }

        var hideEvent = $.Event(Event$4.HIDE, relatedTarget);
        $(parent).trigger(hideEvent);

        if (hideEvent.isDefaultPrevented()) {
          continue;
        } // If this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support


        if ('ontouchstart' in document.documentElement) {
          $(document.body).children().off('mouseover', null, $.noop);
        }

        toggles[i].setAttribute('aria-expanded', 'false');
        $(dropdownMenu).removeClass(ClassName$4.SHOW);
        $(parent).removeClass(ClassName$4.SHOW).trigger($.Event(Event$4.HIDDEN, relatedTarget));
      }
    };

    Dropdown._getParentFromElement = function _getParentFromElement(element) {
      var parent;
      var selector = Util.getSelectorFromElement(element);

      if (selector) {
        parent = document.querySelector(selector);
      }

      return parent || element.parentNode;
    } // eslint-disable-next-line complexity
    ;

    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
      // If not input/textarea:
      //  - And not a key in REGEXP_KEYDOWN => not a dropdown command
      // If input/textarea:
      //  - If space key => not a dropdown command
      //  - If key is other than escape
      //    - If key is not up or down => not a dropdown command
      //    - If trigger inside the menu => not a dropdown command
      if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $(event.target).closest(Selector$4.MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {
        return;
      }

      event.preventDefault();
      event.stopPropagation();

      if (this.disabled || $(this).hasClass(ClassName$4.DISABLED)) {
        return;
      }

      var parent = Dropdown._getParentFromElement(this);

      var isActive = $(parent).hasClass(ClassName$4.SHOW);

      if (!isActive || isActive && (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {
        if (event.which === ESCAPE_KEYCODE) {
          var toggle = parent.querySelector(Selector$4.DATA_TOGGLE);
          $(toggle).trigger('focus');
        }

        $(this).trigger('click');
        return;
      }

      var items = [].slice.call(parent.querySelectorAll(Selector$4.VISIBLE_ITEMS));

      if (items.length === 0) {
        return;
      }

      var index = items.indexOf(event.target);

      if (event.which === ARROW_UP_KEYCODE && index > 0) {
        // Up
        index--;
      }

      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {
        // Down
        index++;
      }

      if (index < 0) {
        index = 0;
      }

      items[index].focus();
    };

    _createClass(Dropdown, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$4;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$2;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$2;
      }
    }]);

    return Dropdown;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   ../../../_/default.htm


  $(document).on(Event$4.KEYDOWN_DATA_API, Selector$4.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event$4.KEYDOWN_DATA_API, Selector$4.MENU, Dropdown._dataApiKeydownHandler).on(Event$4.CLICK_DATA_API + " " + Event$4.KEYUP_DATA_API, Dropdown._clearMenus).on(Event$4.CLICK_DATA_API, Selector$4.DATA_TOGGLE, function (event) {
    event.preventDefault();
    event.stopPropagation();

    Dropdown._jQueryInterface.call($(this), 'toggle');
  }).on(Event$4.CLICK_DATA_API, Selector$4.FORM_CHILD, function (e) {
    e.stopPropagation();
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  $.fn[NAME$4] = Dropdown._jQueryInterface;
  $.fn[NAME$4].Constructor = Dropdown;

  $.fn[NAME$4].noConflict = function () {
    $.fn[NAME$4] = JQUERY_NO_CONFLICT$4;
    return Dropdown._jQueryInterface;
  };

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  var NAME$5 = 'modal';
  var VERSION$5 = '4.3.1';
  var DATA_KEY$5 = 'bs.modal';
  var EVENT_KEY$5 = "." + DATA_KEY$5;
  var DATA_API_KEY$5 = '.data-api';
  var JQUERY_NO_CONFLICT$5 = $.fn[NAME$5];
  var ESCAPE_KEYCODE$1 = 27; // KeyboardEvent.which value for Escape (Esc) key

  var Default$3 = {
    backdrop: true,
    keyboard: true,
    focus: true,
    show: true
  };
  var DefaultType$3 = {
    backdrop: '(boolean|string)',
    keyboard: 'boolean',
    focus: 'boolean',
    show: 'boolean'
  };
  var Event$5 = {
    HIDE: "hide" + EVENT_KEY$5,
    HIDDEN: "hidden" + EVENT_KEY$5,
    SHOW: "show" + EVENT_KEY$5,
    SHOWN: "shown" + EVENT_KEY$5,
    FOCUSIN: "focusin" + EVENT_KEY$5,
    RESIZE: "resize" + EVENT_KEY$5,
    CLICK_DISMISS: "click.dismiss" + EVENT_KEY$5,
    KEYDOWN_DISMISS: "keydown.dismiss" + EVENT_KEY$5,
    MOUSEUP_DISMISS: "mouseup.dismiss" + EVENT_KEY$5,
    MOUSEDOWN_DISMISS: "mousedown.dismiss" + EVENT_KEY$5,
    CLICK_DATA_API: "click" + EVENT_KEY$5 + DATA_API_KEY$5
  };
  var ClassName$5 = {
    SCROLLABLE: 'modal-dialog-scrollable',
    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
    BACKDROP: 'modal-backdrop',
    OPEN: 'modal-open',
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector$5 = {
    DIALOG: '.modal-dialog',
    MODAL_BODY: '.modal-body',
    DATA_TOGGLE: '[data-toggle="modal"]',
    DATA_DISMISS: '[data-dismiss="modal"]',
    FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
    STICKY_CONTENT: '.sticky-top'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     ../../../_/default.htm

  };

  var Modal =
  /*#__PURE__*/
  function () {
    function Modal(element, config) {
      this._config = this._getConfig(config);
      this._element = element;
      this._dialog = element.querySelector(Selector$5.DIALOG);
      this._backdrop = null;
      this._isShown = false;
      this._isBodyOverflowing = false;
      this._ignoreBackdropClick = false;
      this._isTransitioning = false;
      this._scrollbarWidth = 0;
    } // Getters


    var _proto = Modal.prototype;

    // Public
    _proto.toggle = function toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    };

    _proto.show = function show(relatedTarget) {
      var _this = this;

      if (this._isShown || this._isTransitioning) {
        return;
      }

      if ($(this._element).hasClass(ClassName$5.FADE)) {
        this._isTransitioning = true;
      }

      var showEvent = $.Event(Event$5.SHOW, {
        relatedTarget: relatedTarget
      });
      $(this._element).trigger(showEvent);

      if (this._isShown || showEvent.isDefaultPrevented()) {
        return;
      }

      this._isShown = true;

      this._checkScrollbar();

      this._setScrollbar();

      this._adjustDialog();

      this._setEscapeEvent();

      this._setResizeEvent();

      $(this._element).on(Event$5.CLICK_DISMISS, Selector$5.DATA_DISMISS, function (event) {
        return _this.hide(event);
      });
      $(this._dialog).on(Event$5.MOUSEDOWN_DISMISS, function () {
        $(_this._element).one(Event$5.MOUSEUP_DISMISS, function (event) {
          if ($(event.target).is(_this._element)) {
            _this._ignoreBackdropClick = true;
          }
        });
      });

      this._showBackdrop(function () {
        return _this._showElement(relatedTarget);
      });
    };

    _proto.hide = function hide(event) {
      var _this2 = this;

      if (event) {
        event.preventDefault();
      }

      if (!this._isShown || this._isTransitioning) {
        return;
      }

      var hideEvent = $.Event(Event$5.HIDE);
      $(this._element).trigger(hideEvent);

      if (!this._isShown || hideEvent.isDefaultPrevented()) {
        return;
      }

      this._isShown = false;
      var transition = $(this._element).hasClass(ClassName$5.FADE);

      if (transition) {
        this._isTransitioning = true;
      }

      this._setEscapeEvent();

      this._setResizeEvent();

      $(document).off(Event$5.FOCUSIN);
      $(this._element).removeClass(ClassName$5.SHOW);
      $(this._element).off(Event$5.CLICK_DISMISS);
      $(this._dialog).off(Event$5.MOUSEDOWN_DISMISS);

      if (transition) {
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $(this._element).one(Util.TRANSITION_END, function (event) {
          return _this2._hideModal(event);
        }).emulateTransitionEnd(transitionDuration);
      } else {
        this._hideModal();
      }
    };

    _proto.dispose = function dispose() {
      [window, this._element, this._dialog].forEach(function (htmlElement) {
        return $(htmlElement).off(EVENT_KEY$5);
      });
      /**
       * `document` has 2 events `Event.FOCUSIN` and `Event.CLICK_DATA_API`
       * Do not move `document` in `htmlElements` array
       * It will remove `Event.CLICK_DATA_API` event that should remain
       ../../../_/default.htm

      $(document).off(Event$5.FOCUSIN);
      $.removeData(this._element, DATA_KEY$5);
      this._config = null;
      this._element = null;
      this._dialog = null;
      this._backdrop = null;
      this._isShown = null;
      this._isBodyOverflowing = null;
      this._ignoreBackdropClick = null;
      this._isTransitioning = null;
      this._scrollbarWidth = null;
    };

    _proto.handleUpdate = function handleUpdate() {
      this._adjustDialog();
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread({}, Default$3, config);
      Util.typeCheckConfig(NAME$5, config, DefaultType$3);
      return config;
    };

    _proto._showElement = function _showElement(relatedTarget) {
      var _this3 = this;

      var transition = $(this._element).hasClass(ClassName$5.FADE);

      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
        // Don't move modal's DOM position
        document.body.appendChild(this._element);
      }

      this._element.style.display = 'block';

      this._element.removeAttribute('aria-hidden');

      this._element.setAttribute('aria-modal', true);

      if ($(this._dialog).hasClass(ClassName$5.SCROLLABLE)) {
        this._dialog.querySelector(Selector$5.MODAL_BODY).scrollTop = 0;
      } else {
        this._element.scrollTop = 0;
      }

      if (transition) {
        Util.reflow(this._element);
      }

      $(this._element).addClass(ClassName$5.SHOW);

      if (this._config.focus) {
        this._enforceFocus();
      }

      var shownEvent = $.Event(Event$5.SHOWN, {
        relatedTarget: relatedTarget
      });

      var transitionComplete = function transitionComplete() {
        if (_this3._config.focus) {
          _this3._element.focus();
        }

        _this3._isTransitioning = false;
        $(_this3._element).trigger(shownEvent);
      };

      if (transition) {
        var transitionDuration = Util.getTransitionDurationFromElement(this._dialog);
        $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
      } else {
        transitionComplete();
      }
    };

    _proto._enforceFocus = function _enforceFocus() {
      var _this4 = this;

      $(document).off(Event$5.FOCUSIN) // Guard against infinite focus loop
      .on(Event$5.FOCUSIN, function (event) {
        if (document !== event.target && _this4._element !== event.target && $(_this4._element).has(event.target).length === 0) {
          _this4._element.focus();
        }
      });
    };

    _proto._setEscapeEvent = function _setEscapeEvent() {
      var _this5 = this;

      if (this._isShown && this._config.keyboard) {
        $(this._element).on(Event$5.KEYDOWN_DISMISS, function (event) {
          if (event.which === ESCAPE_KEYCODE$1) {
            event.preventDefault();

            _this5.hide();
          }
        });
      } else if (!this._isShown) {
        $(this._element).off(Event$5.KEYDOWN_DISMISS);
      }
    };

    _proto._setResizeEvent = function _setResizeEvent() {
      var _this6 = this;

      if (this._isShown) {
        $(window).on(Event$5.RESIZE, function (event) {
          return _this6.handleUpdate(event);
        });
      } else {
        $(window).off(Event$5.RESIZE);
      }
    };

    _proto._hideModal = function _hideModal() {
      var _this7 = this;

      this._element.style.display = 'none';

      this._element.setAttribute('aria-hidden', true);

      this._element.removeAttribute('aria-modal');

      this._isTransitioning = false;

      this._showBackdrop(function () {
        $(document.body).removeClass(ClassName$5.OPEN);

        _this7._resetAdjustments();

        _this7._resetScrollbar();

        $(_this7._element).trigger(Event$5.HIDDEN);
      });
    };

    _proto._removeBackdrop = function _removeBackdrop() {
      if (this._backdrop) {
        $(this._backdrop).remove();
        this._backdrop = null;
      }
    };

    _proto._showBackdrop = function _showBackdrop(callback) {
      var _this8 = this;

      var animate = $(this._element).hasClass(ClassName$5.FADE) ? ClassName$5.FADE : '';

      if (this._isShown && this._config.backdrop) {
        this._backdrop = document.createElement('div');
        this._backdrop.className = ClassName$5.BACKDROP;

        if (animate) {
          this._backdrop.classList.add(animate);
        }

        $(this._backdrop).appendTo(document.body);
        $(this._element).on(Event$5.CLICK_DISMISS, function (event) {
          if (_this8._ignoreBackdropClick) {
            _this8._ignoreBackdropClick = false;
            return;
          }

          if (event.target !== event.currentTarget) {
            return;
          }

          if (_this8._config.backdrop === 'static') {
            _this8._element.focus();
          } else {
            _this8.hide();
          }
        });

        if (animate) {
          Util.reflow(this._backdrop);
        }

        $(this._backdrop).addClass(ClassName$5.SHOW);

        if (!callback) {
          return;
        }

        if (!animate) {
          callback();
          return;
        }

        var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
        $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
      } else if (!this._isShown && this._backdrop) {
        $(this._backdrop).removeClass(ClassName$5.SHOW);

        var callbackRemove = function callbackRemove() {
          _this8._removeBackdrop();

          if (callback) {
            callback();
          }
        };

        if ($(this._element).hasClass(ClassName$5.FADE)) {
          var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);

          $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);
        } else {
          callbackRemove();
        }
      } else if (callback) {
        callback();
      }
    } // ----------------------------------------------------------------------
    // the following methods are used to handle overflowing modals
    // todo (fat): these should probably be refactored out of modal.js
    // ----------------------------------------------------------------------
    ;

    _proto._adjustDialog = function _adjustDialog() {
      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

      if (!this._isBodyOverflowing && isModalOverflowing) {
        this._element.style.paddingLeft = this._scrollbarWidth + "px";
      }

      if (this._isBodyOverflowing && !isModalOverflowing) {
        this._element.style.paddingRight = this._scrollbarWidth + "px";
      }
    };

    _proto._resetAdjustments = function _resetAdjustments() {
      this._element.style.paddingLeft = '';
      this._element.style.paddingRight = '';
    };

    _proto._checkScrollbar = function _checkScrollbar() {
      var rect = document.body.getBoundingClientRect();
      this._isBodyOverflowing = rect.left + rect.right < window.innerWidth;
      this._scrollbarWidth = this._getScrollbarWidth();
    };

    _proto._setScrollbar = function _setScrollbar() {
      var _this9 = this;

      if (this._isBodyOverflowing) {
        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set
        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
        var fixedContent = [].slice.call(document.querySelectorAll(Selector$5.FIXED_CONTENT));
        var stickyContent = [].slice.call(document.querySelectorAll(Selector$5.STICKY_CONTENT)); // Adjust fixed content padding

        $(fixedContent).each(function (index, element) {
          var actualPadding = element.style.paddingRight;
          var calculatedPadding = $(element).css('padding-right');
          $(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this9._scrollbarWidth + "px");
        }); // Adjust sticky content margin

        $(stickyContent).each(function (index, element) {
          var actualMargin = element.style.marginRight;
          var calculatedMargin = $(element).css('margin-right');
          $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this9._scrollbarWidth + "px");
        }); // Adjust body padding

        var actualPadding = document.body.style.paddingRight;
        var calculatedPadding = $(document.body).css('padding-right');
        $(document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + "px");
      }

      $(document.body).addClass(ClassName$5.OPEN);
    };

    _proto._resetScrollbar = function _resetScrollbar() {
      // Restore fixed content padding
      var fixedContent = [].slice.call(document.querySelectorAll(Selector$5.FIXED_CONTENT));
      $(fixedContent).each(function (index, element) {
        var padding = $(element).data('padding-right');
        $(element).removeData('padding-right');
        element.style.paddingRight = padding ? padding : '';
      }); // Restore sticky content

      var elements = [].slice.call(document.querySelectorAll("" + Selector$5.STICKY_CONTENT));
      $(elements).each(function (index, element) {
        var margin = $(element).data('margin-right');

        if (typeof margin !== 'undefined') {
          $(element).css('margin-right', margin).removeData('margin-right');
        }
      }); // Restore body padding

      var padding = $(document.body).data('padding-right');
      $(document.body).removeData('padding-right');
      document.body.style.paddingRight = padding ? padding : '';
    };

    _proto._getScrollbarWidth = function _getScrollbarWidth() {
      // thx d.walsh
      var scrollDiv = document.createElement('div');
      scrollDiv.className = ClassName$5.SCROLLBAR_MEASURER;
      document.body.appendChild(scrollDiv);
      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return scrollbarWidth;
    } // Static
    ;

    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$5);

        var _config = _objectSpread({}, Default$3, $(this).data(), typeof config === 'object' && config ? config : {});

        if (!data) {
          data = new Modal(this, _config);
          $(this).data(DATA_KEY$5, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config](relatedTarget);
        } else if (_config.show) {
          data.show(relatedTarget);
        }
      });
    };

    _createClass(Modal, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$5;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$3;
      }
    }]);

    return Modal;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   ../../../_/default.htm


  $(document).on(Event$5.CLICK_DATA_API, Selector$5.DATA_TOGGLE, function (event) {
    var _this10 = this;

    var target;
    var selector = Util.getSelectorFromElement(this);

    if (selector) {
      target = document.querySelector(selector);
    }

    var config = $(target).data(DATA_KEY$5) ? 'toggle' : _objectSpread({}, $(target).data(), $(this).data());

    if (this.tagName === 'A' || this.tagName === 'AREA') {
      event.preventDefault();
    }

    var $target = $(target).one(Event$5.SHOW, function (showEvent) {
      if (showEvent.isDefaultPrevented()) {
        // Only register focus restorer if modal will actually get shown
        return;
      }

      $target.one(Event$5.HIDDEN, function () {
        if ($(_this10).is(':visible')) {
          _this10.focus();
        }
      });
    });

    Modal._jQueryInterface.call($(target), config, this);
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  $.fn[NAME$5] = Modal._jQueryInterface;
  $.fn[NAME$5].Constructor = Modal;

  $.fn[NAME$5].noConflict = function () {
    $.fn[NAME$5] = JQUERY_NO_CONFLICT$5;
    return Modal._jQueryInterface;
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.3.1): tools/sanitizer.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   ../../../_/default.htm
  var uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];
  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
  var DefaultWhitelist = {
    // Global attributes allowed on any supplied element below.
    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
    a: ['target', 'href', 'title', 'rel'],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ['src', 'alt', 'title', 'width', 'height'],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
    /**
     * A pattern that recognizes a commonly useful subset of URLs that are safe.
     *
     * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
     ../../../_/default.htm

  };
  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
  /**
   * A pattern that matches safe data URLs. Only matches image, video and audio types.
   *
   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
   ../../../_/default.htm

  var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;

  function allowedAttribute(attr, allowedAttributeList) {
    var attrName = attr.nodeName.toLowerCase();

    if (allowedAttributeList.indexOf(attrName) !== -1) {
      if (uriAttrs.indexOf(attrName) !== -1) {
        return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));
      }

      return true;
    }

    var regExp = allowedAttributeList.filter(function (attrRegex) {
      return attrRegex instanceof RegExp;
    }); // Check if a regular expression validates the attribute.

    for (var i = 0, l = regExp.length; i < l; i++) {
      if (attrName.match(regExp[i])) {
        return true;
      }
    }

    return false;
  }

  function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {
    if (unsafeHtml.length === 0) {
      return unsafeHtml;
    }

    if (sanitizeFn && typeof sanitizeFn === 'function') {
      return sanitizeFn(unsafeHtml);
    }

    var domParser = new window.DOMParser();
    var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
    var whitelistKeys = Object.keys(whiteList);
    var elements = [].slice.call(createdDocument.body.querySelectorAll('*'));

    var _loop = function _loop(i, len) {
      var el = elements[i];
      var elName = el.nodeName.toLowerCase();

      if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {
        el.parentNode.removeChild(el);
        return "continue";
      }

      var attributeList = [].slice.call(el.attributes);
      var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);
      attributeList.forEach(function (attr) {
        if (!allowedAttribute(attr, whitelistedAttributes)) {
          el.removeAttribute(attr.nodeName);
        }
      });
    };

    for (var i = 0, len = elements.length; i < len; i++) {
      var _ret = _loop(i, len);

      if (_ret === "continue") continue;
    }

    return createdDocument.body.innerHTML;
  }

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  var NAME$6 = 'tooltip';
  var VERSION$6 = '4.3.1';
  var DATA_KEY$6 = 'bs.tooltip';
  var EVENT_KEY$6 = "." + DATA_KEY$6;
  var JQUERY_NO_CONFLICT$6 = $.fn[NAME$6];
  var CLASS_PREFIX = 'bs-tooltip';
  var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", 'g');
  var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];
  var DefaultType$4 = {
    animation: 'boolean',
    template: 'string',
    title: '(string|element|function)',
    trigger: 'string',
    delay: '(number|object)',
    html: 'boolean',
    selector: '(string|boolean)',
    placement: '(string|function)',
    offset: '(number|string|function)',
    container: '(string|element|boolean)',
    fallbackPlacement: '(string|array)',
    boundary: '(string|element)',
    sanitize: 'boolean',
    sanitizeFn: '(null|function)',
    whiteList: 'object'
  };
  var AttachmentMap$1 = {
    AUTO: 'auto',
    TOP: 'top',
    RIGHT: 'right',
    BOTTOM: 'bottom',
    LEFT: 'left'
  };
  var Default$4 = {
    animation: true,
    template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    selector: false,
    placement: 'top',
    offset: 0,
    container: false,
    fallbackPlacement: 'flip',
    boundary: 'scrollParent',
    sanitize: true,
    sanitizeFn: null,
    whiteList: DefaultWhitelist
  };
  var HoverState = {
    SHOW: 'show',
    OUT: 'out'
  };
  var Event$6 = {
    HIDE: "hide" + EVENT_KEY$6,
    HIDDEN: "hidden" + EVENT_KEY$6,
    SHOW: "show" + EVENT_KEY$6,
    SHOWN: "shown" + EVENT_KEY$6,
    INSERTED: "inserted" + EVENT_KEY$6,
    CLICK: "click" + EVENT_KEY$6,
    FOCUSIN: "focusin" + EVENT_KEY$6,
    FOCUSOUT: "focusout" + EVENT_KEY$6,
    MOUSEENTER: "mouseenter" + EVENT_KEY$6,
    MOUSELEAVE: "mouseleave" + EVENT_KEY$6
  };
  var ClassName$6 = {
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector$6 = {
    TOOLTIP: '.tooltip',
    TOOLTIP_INNER: '.tooltip-inner',
    ARROW: '.arrow'
  };
  var Trigger = {
    HOVER: 'hover',
    FOCUS: 'focus',
    CLICK: 'click',
    MANUAL: 'manual'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     ../../../_/default.htm

  };

  var Tooltip =
  /*#__PURE__*/
  function () {
    function Tooltip(element, config) {
      /**
       * Check for Popper dependency
       * Popper - https://popper.js.org
       ../../../_/default.htm
      if (typeof Popper === 'undefined') {
        throw new TypeError('Bootstrap\'s tooltips require Popper.js (https://popper.js.org/)');
      } // private


      this._isEnabled = true;
      this._timeout = 0;
      this._hoverState = '';
      this._activeTrigger = {};
      this._popper = null; // Protected

      this.element = element;
      this.config = this._getConfig(config);
      this.tip = null;

      this._setListeners();
    } // Getters


    var _proto = Tooltip.prototype;

    // Public
    _proto.enable = function enable() {
      this._isEnabled = true;
    };

    _proto.disable = function disable() {
      this._isEnabled = false;
    };

    _proto.toggleEnabled = function toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    };

    _proto.toggle = function toggle(event) {
      if (!this._isEnabled) {
        return;
      }

      if (event) {
        var dataKey = this.constructor.DATA_KEY;
        var context = $(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $(event.currentTarget).data(dataKey, context);
        }

        context._activeTrigger.click = !context._activeTrigger.click;

        if (context._isWithActiveTrigger()) {
          context._enter(null, context);
        } else {
          context._leave(null, context);
        }
      } else {
        if ($(this.getTipElement()).hasClass(ClassName$6.SHOW)) {
          this._leave(null, this);

          return;
        }

        this._enter(null, this);
      }
    };

    _proto.dispose = function dispose() {
      clearTimeout(this._timeout);
      $.removeData(this.element, this.constructor.DATA_KEY);
      $(this.element).off(this.constructor.EVENT_KEY);
      $(this.element).closest('.modal').off('hide.bs.modal');

      if (this.tip) {
        $(this.tip).remove();
      }

      this._isEnabled = null;
      this._timeout = null;
      this._hoverState = null;
      this._activeTrigger = null;

      if (this._popper !== null) {
        this._popper.destroy();
      }

      this._popper = null;
      this.element = null;
      this.config = null;
      this.tip = null;
    };

    _proto.show = function show() {
      var _this = this;

      if ($(this.element).css('display') === 'none') {
        throw new Error('Please use show on visible elements');
      }

      var showEvent = $.Event(this.constructor.Event.SHOW);

      if (this.isWithContent() && this._isEnabled) {
        $(this.element).trigger(showEvent);
        var shadowRoot = Util.findShadowRoot(this.element);
        var isInTheDom = $.contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);

        if (showEvent.isDefaultPrevented() || !isInTheDom) {
          return;
        }

        var tip = this.getTipElement();
        var tipId = Util.getUID(this.constructor.NAME);
        tip.setAttribute('id', tipId);
        this.element.setAttribute('aria-describedby', tipId);
        this.setContent();

        if (this.config.animation) {
          $(tip).addClass(ClassName$6.FADE);
        }

        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;

        var attachment = this._getAttachment(placement);

        this.addAttachmentClass(attachment);

        var container = this._getContainer();

        $(tip).data(this.constructor.DATA_KEY, this);

        if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {
          $(tip).appendTo(container);
        }

        $(this.element).trigger(this.constructor.Event.INSERTED);
        this._popper = new Popper(this.element, tip, {
          placement: attachment,
          modifiers: {
            offset: this._getOffset(),
            flip: {
              behavior: this.config.fallbackPlacement
            },
            arrow: {
              element: Selector$6.ARROW
            },
            preventOverflow: {
              boundariesElement: this.config.boundary
            }
          },
          onCreate: function onCreate(data) {
            if (data.originalPlacement !== data.placement) {
              _this._handlePopperPlacementChange(data);
            }
          },
          onUpdate: function onUpdate(data) {
            return _this._handlePopperPlacementChange(data);
          }
        });
        $(tip).addClass(ClassName$6.SHOW); // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

        if ('ontouchstart' in document.documentElement) {
          $(document.body).children().on('mouseover', null, $.noop);
        }

        var complete = function complete() {
          if (_this.config.animation) {
            _this._fixTransition();
          }

          var prevHoverState = _this._hoverState;
          _this._hoverState = null;
          $(_this.element).trigger(_this.constructor.Event.SHOWN);

          if (prevHoverState === HoverState.OUT) {
            _this._leave(null, _this);
          }
        };

        if ($(this.tip).hasClass(ClassName$6.FADE)) {
          var transitionDuration = Util.getTransitionDurationFromElement(this.tip);
          $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }
      }
    };

    _proto.hide = function hide(callback) {
      var _this2 = this;

      var tip = this.getTipElement();
      var hideEvent = $.Event(this.constructor.Event.HIDE);

      var complete = function complete() {
        if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {
          tip.parentNode.removeChild(tip);
        }

        _this2._cleanTipClass();

        _this2.element.removeAttribute('aria-describedby');

        $(_this2.element).trigger(_this2.constructor.Event.HIDDEN);

        if (_this2._popper !== null) {
          _this2._popper.destroy();
        }

        if (callback) {
          callback();
        }
      };

      $(this.element).trigger(hideEvent);

      if (hideEvent.isDefaultPrevented()) {
        return;
      }

      $(tip).removeClass(ClassName$6.SHOW); // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support

      if ('ontouchstart' in document.documentElement) {
        $(document.body).children().off('mouseover', null, $.noop);
      }

      this._activeTrigger[Trigger.CLICK] = false;
      this._activeTrigger[Trigger.FOCUS] = false;
      this._activeTrigger[Trigger.HOVER] = false;

      if ($(this.tip).hasClass(ClassName$6.FADE)) {
        var transitionDuration = Util.getTransitionDurationFromElement(tip);
        $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }

      this._hoverState = '';
    };

    _proto.update = function update() {
      if (this._popper !== null) {
        this._popper.scheduleUpdate();
      }
    } // Protected
    ;

    _proto.isWithContent = function isWithContent() {
      return Boolean(this.getTitle());
    };

    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
      $(this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
    };

    _proto.getTipElement = function getTipElement() {
      this.tip = this.tip || $(this.config.template)[0];
      return this.tip;
    };

    _proto.setContent = function setContent() {
      var tip = this.getTipElement();
      this.setElementContent($(tip.querySelectorAll(Selector$6.TOOLTIP_INNER)), this.getTitle());
      $(tip).removeClass(ClassName$6.FADE + " " + ClassName$6.SHOW);
    };

    _proto.setElementContent = function setElementContent($element, content) {
      if (typeof content === 'object' && (content.nodeType || content.jquery)) {
        // Content is a DOM node or a jQuery
        if (this.config.html) {
          if (!$(content).parent().is($element)) {
            $element.empty().append(content);
          }
        } else {
          $element.text($(content).text());
        }

        return;
      }

      if (this.config.html) {
        if (this.config.sanitize) {
          content = sanitizeHtml(content, this.config.whiteList, this.config.sanitizeFn);
        }

        $element.html(content);
      } else {
        $element.text(content);
      }
    };

    _proto.getTitle = function getTitle() {
      var title = this.element.getAttribute('data-original-title');

      if (!title) {
        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
      }

      return title;
    } // Private
    ;

    _proto._getOffset = function _getOffset() {
      var _this3 = this;

      var offset = {};

      if (typeof this.config.offset === 'function') {
        offset.fn = function (data) {
          data.offsets = _objectSpread({}, data.offsets, _this3.config.offset(data.offsets, _this3.element) || {});
          return data;
        };
      } else {
        offset.offset = this.config.offset;
      }

      return offset;
    };

    _proto._getContainer = function _getContainer() {
      if (this.config.container === false) {
        return document.body;
      }

      if (Util.isElement(this.config.container)) {
        return $(this.config.container);
      }

      return $(document).find(this.config.container);
    };

    _proto._getAttachment = function _getAttachment(placement) {
      return AttachmentMap$1[placement.toUpperCase()];
    };

    _proto._setListeners = function _setListeners() {
      var _this4 = this;

      var triggers = this.config.trigger.split(' ');
      triggers.forEach(function (trigger) {
        if (trigger === 'click') {
          $(_this4.element).on(_this4.constructor.Event.CLICK, _this4.config.selector, function (event) {
            return _this4.toggle(event);
          });
        } else if (trigger !== Trigger.MANUAL) {
          var eventIn = trigger === Trigger.HOVER ? _this4.constructor.Event.MOUSEENTER : _this4.constructor.Event.FOCUSIN;
          var eventOut = trigger === Trigger.HOVER ? _this4.constructor.Event.MOUSELEAVE : _this4.constructor.Event.FOCUSOUT;
          $(_this4.element).on(eventIn, _this4.config.selector, function (event) {
            return _this4._enter(event);
          }).on(eventOut, _this4.config.selector, function (event) {
            return _this4._leave(event);
          });
        }
      });
      $(this.element).closest('.modal').on('hide.bs.modal', function () {
        if (_this4.element) {
          _this4.hide();
        }
      });

      if (this.config.selector) {
        this.config = _objectSpread({}, this.config, {
          trigger: 'manual',
          selector: ''
        });
      } else {
        this._fixTitle();
      }
    };

    _proto._fixTitle = function _fixTitle() {
      var titleType = typeof this.element.getAttribute('data-original-title');

      if (this.element.getAttribute('title') || titleType !== 'string') {
        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');
        this.element.setAttribute('title', '');
      }
    };

    _proto._enter = function _enter(event, context) {
      var dataKey = this.constructor.DATA_KEY;
      context = context || $(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
        $(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;
      }

      if ($(context.getTipElement()).hasClass(ClassName$6.SHOW) || context._hoverState === HoverState.SHOW) {
        context._hoverState = HoverState.SHOW;
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HoverState.SHOW;

      if (!context.config.delay || !context.config.delay.show) {
        context.show();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HoverState.SHOW) {
          context.show();
        }
      }, context.config.delay.show);
    };

    _proto._leave = function _leave(event, context) {
      var dataKey = this.constructor.DATA_KEY;
      context = context || $(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
        $(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;
      }

      if (context._isWithActiveTrigger()) {
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HoverState.OUT;

      if (!context.config.delay || !context.config.delay.hide) {
        context.hide();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HoverState.OUT) {
          context.hide();
        }
      }, context.config.delay.hide);
    };

    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
      for (var trigger in this._activeTrigger) {
        if (this._activeTrigger[trigger]) {
          return true;
        }
      }

      return false;
    };

    _proto._getConfig = function _getConfig(config) {
      var dataAttributes = $(this.element).data();
      Object.keys(dataAttributes).forEach(function (dataAttr) {
        if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {
          delete dataAttributes[dataAttr];
        }
      });
      config = _objectSpread({}, this.constructor.Default, dataAttributes, typeof config === 'object' && config ? config : {});

      if (typeof config.delay === 'number') {
        config.delay = {
          show: config.delay,
          hide: config.delay
        };
      }

      if (typeof config.title === 'number') {
        config.title = config.title.toString();
      }

      if (typeof config.content === 'number') {
        config.content = config.content.toString();
      }

      Util.typeCheckConfig(NAME$6, config, this.constructor.DefaultType);

      if (config.sanitize) {
        config.template = sanitizeHtml(config.template, config.whiteList, config.sanitizeFn);
      }

      return config;
    };

    _proto._getDelegateConfig = function _getDelegateConfig() {
      var config = {};

      if (this.config) {
        for (var key in this.config) {
          if (this.constructor.Default[key] !== this.config[key]) {
            config[key] = this.config[key];
          }
        }
      }

      return config;
    };

    _proto._cleanTipClass = function _cleanTipClass() {
      var $tip = $(this.getTipElement());
      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

      if (tabClass !== null && tabClass.length) {
        $tip.removeClass(tabClass.join(''));
      }
    };

    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {
      var popperInstance = popperData.instance;
      this.tip = popperInstance.popper;

      this._cleanTipClass();

      this.addAttachmentClass(this._getAttachment(popperData.placement));
    };

    _proto._fixTransition = function _fixTransition() {
      var tip = this.getTipElement();
      var initConfigAnimation = this.config.animation;

      if (tip.getAttribute('x-placement') !== null) {
        return;
      }

      $(tip).removeClass(ClassName$6.FADE);
      this.config.animation = false;
      this.hide();
      this.show();
      this.config.animation = initConfigAnimation;
    } // Static
    ;

    Tooltip._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$6);

        var _config = typeof config === 'object' && config;

        if (!data && /dispose|hide/.test(config)) {
          return;
        }

        if (!data) {
          data = new Tooltip(this, _config);
          $(this).data(DATA_KEY$6, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Tooltip, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$6;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$4;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$6;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return DATA_KEY$6;
      }
    }, {
      key: "Event",
      get: function get() {
        return Event$6;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return EVENT_KEY$6;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$4;
      }
    }]);

    return Tooltip;
  }();
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   ../../../_/default.htm


  $.fn[NAME$6] = Tooltip._jQueryInterface;
  $.fn[NAME$6].Constructor = Tooltip;

  $.fn[NAME$6].noConflict = function () {
    $.fn[NAME$6] = JQUERY_NO_CONFLICT$6;
    return Tooltip._jQueryInterface;
  };

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  var NAME$7 = 'popover';
  var VERSION$7 = '4.3.1';
  var DATA_KEY$7 = 'bs.popover';
  var EVENT_KEY$7 = "." + DATA_KEY$7;
  var JQUERY_NO_CONFLICT$7 = $.fn[NAME$7];
  var CLASS_PREFIX$1 = 'bs-popover';
  var BSCLS_PREFIX_REGEX$1 = new RegExp("(^|\\s)" + CLASS_PREFIX$1 + "\\S+", 'g');

  var Default$5 = _objectSpread({}, Tooltip.Default, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip">' + '<div class="arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div></div>'
  });

  var DefaultType$5 = _objectSpread({}, Tooltip.DefaultType, {
    content: '(string|element|function)'
  });

  var ClassName$7 = {
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector$7 = {
    TITLE: '.popover-header',
    CONTENT: '.popover-body'
  };
  var Event$7 = {
    HIDE: "hide" + EVENT_KEY$7,
    HIDDEN: "hidden" + EVENT_KEY$7,
    SHOW: "show" + EVENT_KEY$7,
    SHOWN: "shown" + EVENT_KEY$7,
    INSERTED: "inserted" + EVENT_KEY$7,
    CLICK: "click" + EVENT_KEY$7,
    FOCUSIN: "focusin" + EVENT_KEY$7,
    FOCUSOUT: "focusout" + EVENT_KEY$7,
    MOUSEENTER: "mouseenter" + EVENT_KEY$7,
    MOUSELEAVE: "mouseleave" + EVENT_KEY$7
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     ../../../_/default.htm

  };

  var Popover =
  /*#__PURE__*/
  function (_Tooltip) {
    _inheritsLoose(Popover, _Tooltip);

    function Popover() {
      return _Tooltip.apply(this, arguments) || this;
    }

    var _proto = Popover.prototype;

    // Overrides
    _proto.isWithContent = function isWithContent() {
      return this.getTitle() || this._getContent();
    };

    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
      $(this.getTipElement()).addClass(CLASS_PREFIX$1 + "-" + attachment);
    };

    _proto.getTipElement = function getTipElement() {
      this.tip = this.tip || $(this.config.template)[0];
      return this.tip;
    };

    _proto.setContent = function setContent() {
      var $tip = $(this.getTipElement()); // We use append for html objects to maintain js events

      this.setElementContent($tip.find(Selector$7.TITLE), this.getTitle());

      var content = this._getContent();

      if (typeof content === 'function') {
        content = content.call(this.element);
      }

      this.setElementContent($tip.find(Selector$7.CONTENT), content);
      $tip.removeClass(ClassName$7.FADE + " " + ClassName$7.SHOW);
    } // Private
    ;

    _proto._getContent = function _getContent() {
      return this.element.getAttribute('data-content') || this.config.content;
    };

    _proto._cleanTipClass = function _cleanTipClass() {
      var $tip = $(this.getTipElement());
      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX$1);

      if (tabClass !== null && tabClass.length > 0) {
        $tip.removeClass(tabClass.join(''));
      }
    } // Static
    ;

    Popover._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$7);

        var _config = typeof config === 'object' ? config : null;

        if (!data && /dispose|hide/.test(config)) {
          return;
        }

        if (!data) {
          data = new Popover(this, _config);
          $(this).data(DATA_KEY$7, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Popover, null, [{
      key: "VERSION",
      // Getters
      get: function get() {
        return VERSION$7;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$5;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$7;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return DATA_KEY$7;
      }
    }, {
      key: "Event",
      get: function get() {
        return Event$7;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return EVENT_KEY$7;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$5;
      }
    }]);

    return Popover;
  }(Tooltip);
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   ../../../_/default.htm


  $.fn[NAME$7] = Popover._jQueryInterface;
  $.fn[NAME$7].Constructor = Popover;

  $.fn[NAME$7].noConflict = function () {
    $.fn[NAME$7] = JQUERY_NO_CONFLICT$7;
    return Popover._jQueryInterface;
  };

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  var NAME$8 = 'scrollspy';
  var VERSION$8 = '4.3.1';
  var DATA_KEY$8 = 'bs.scrollspy';
  var EVENT_KEY$8 = "." + DATA_KEY$8;
  var DATA_API_KEY$6 = '.data-api';
  var JQUERY_NO_CONFLICT$8 = $.fn[NAME$8];
  var Default$6 = {
    offset: 10,
    method: 'auto',
    target: ''
  };
  var DefaultType$6 = {
    offset: 'number',
    method: 'string',
    target: '(string|element)'
  };
  var Event$8 = {
    ACTIVATE: "activate" + EVENT_KEY$8,
    SCROLL: "scroll" + EVENT_KEY$8,
    LOAD_DATA_API: "load" + EVENT_KEY$8 + DATA_API_KEY$6
  };
  var ClassName$8 = {
    DROPDOWN_ITEM: 'dropdown-item',
    DROPDOWN_MENU: 'dropdown-menu',
    ACTIVE: 'active'
  };
  var Selector$8 = {
    DATA_SPY: '[data-spy="scroll"]',
    ACTIVE: '.active',
    NAV_LIST_GROUP: '.nav, .list-group',
    NAV_LINKS: '.nav-link',
    NAV_ITEMS: '.nav-item',
    LIST_ITEMS: '.list-group-item',
    DROPDOWN: '.dropdown',
    DROPDOWN_ITEMS: '.dropdown-item',
    DROPDOWN_TOGGLE: '.dropdown-toggle'
  };
  var OffsetMethod = {
    OFFSET: 'offset',
    POSITION: 'position'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     ../../../_/default.htm

  };

  var ScrollSpy =
  /*#__PURE__*/
  function () {
    function ScrollSpy(element, config) {
      var _this = this;

      this._element = element;
      this._scrollElement = element.tagName === 'BODY' ? window : element;
      this._config = this._getConfig(config);
      this._selector = this._config.target + " " + Selector$8.NAV_LINKS + "," + (this._config.target + " " + Selector$8.LIST_ITEMS + ",") + (this._config.target + " " + Selector$8.DROPDOWN_ITEMS);
      this._offsets = [];
      this._targets = [];
      this._activeTarget = null;
      this._scrollHeight = 0;
      $(this._scrollElement).on(Event$8.SCROLL, function (event) {
        return _this._process(event);
      });
      this.refresh();

      this._process();
    } // Getters


    var _proto = ScrollSpy.prototype;

    // Public
    _proto.refresh = function refresh() {
      var _this2 = this;

      var autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;
      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
      var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;
      this._offsets = [];
      this._targets = [];
      this._scrollHeight = this._getScrollHeight();
      var targets = [].slice.call(document.querySelectorAll(this._selector));
      targets.map(function (element) {
        var target;
        var targetSelector = Util.getSelectorFromElement(element);

        if (targetSelector) {
          target = document.querySelector(targetSelector);
        }

        if (target) {
          var targetBCR = target.getBoundingClientRect();

          if (targetBCR.width || targetBCR.height) {
            // TODO (fat): remove sketch reliance on jQuery position/offset
            return [$(target)[offsetMethod]().top + offsetBase, targetSelector];
          }
        }

        return null;
      }).filter(function (item) {
        return item;
      }).sort(function (a, b) {
        return a[0] - b[0];
      }).forEach(function (item) {
        _this2._offsets.push(item[0]);

        _this2._targets.push(item[1]);
      });
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$8);
      $(this._scrollElement).off(EVENT_KEY$8);
      this._element = null;
      this._scrollElement = null;
      this._config = null;
      this._selector = null;
      this._offsets = null;
      this._targets = null;
      this._activeTarget = null;
      this._scrollHeight = null;
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread({}, Default$6, typeof config === 'object' && config ? config : {});

      if (typeof config.target !== 'string') {
        var id = $(config.target).attr('id');

        if (!id) {
          id = Util.getUID(NAME$8);
          $(config.target).attr('id', id);
        }

        config.target = "#" + id;
      }

      Util.typeCheckConfig(NAME$8, config, DefaultType$6);
      return config;
    };

    _proto._getScrollTop = function _getScrollTop() {
      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
    };

    _proto._getScrollHeight = function _getScrollHeight() {
      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    };

    _proto._getOffsetHeight = function _getOffsetHeight() {
      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
    };

    _proto._process = function _process() {
      var scrollTop = this._getScrollTop() + this._config.offset;

      var scrollHeight = this._getScrollHeight();

      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();

      if (this._scrollHeight !== scrollHeight) {
        this.refresh();
      }

      if (scrollTop >= maxScroll) {
        var target = this._targets[this._targets.length - 1];

        if (this._activeTarget !== target) {
          this._activate(target);
        }

        return;
      }

      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
        this._activeTarget = null;

        this._clear();

        return;
      }

      var offsetLength = this._offsets.length;

      for (var i = offsetLength; i--;) {
        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);

        if (isActiveTarget) {
          this._activate(this._targets[i]);
        }
      }
    };

    _proto._activate = function _activate(target) {
      this._activeTarget = target;

      this._clear();

      var queries = this._selector.split(',').map(function (selector) {
        return selector + "[data-target=\"" + target + "\"]," + selector + "[href=\"" + target + "\"]";
      });

      var $link = $([].slice.call(document.querySelectorAll(queries.join(','))));

      if ($link.hasClass(ClassName$8.DROPDOWN_ITEM)) {
        $link.closest(Selector$8.DROPDOWN).find(Selector$8.DROPDOWN_TOGGLE).addClass(ClassName$8.ACTIVE);
        $link.addClass(ClassName$8.ACTIVE);
      } else {
        // Set triggered link as active
        $link.addClass(ClassName$8.ACTIVE); // Set triggered links parents as active
        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor

        $link.parents(Selector$8.NAV_LIST_GROUP).prev(Selector$8.NAV_LINKS + ", " + Selector$8.LIST_ITEMS).addClass(ClassName$8.ACTIVE); // Handle special case when .nav-link is inside .nav-item

        $link.parents(Selector$8.NAV_LIST_GROUP).prev(Selector$8.NAV_ITEMS).children(Selector$8.NAV_LINKS).addClass(ClassName$8.ACTIVE);
      }

      $(this._scrollElement).trigger(Event$8.ACTIVATE, {
        relatedTarget: target
      });
    };

    _proto._clear = function _clear() {
      [].slice.call(document.querySelectorAll(this._selector)).filter(function (node) {
        return node.classList.contains(ClassName$8.ACTIVE);
      }).forEach(function (node) {
        return node.classList.remove(ClassName$8.ACTIVE);
      });
    } // Static
    ;

    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$8);

        var _config = typeof config === 'object' && config;

        if (!data) {
          data = new ScrollSpy(this, _config);
          $(this).data(DATA_KEY$8, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(ScrollSpy, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$8;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$6;
      }
    }]);

    return ScrollSpy;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   ../../../_/default.htm


  $(window).on(Event$8.LOAD_DATA_API, function () {
    var scrollSpys = [].slice.call(document.querySelectorAll(Selector$8.DATA_SPY));
    var scrollSpysLength = scrollSpys.length;

    for (var i = scrollSpysLength; i--;) {
      var $spy = $(scrollSpys[i]);

      ScrollSpy._jQueryInterface.call($spy, $spy.data());
    }
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  $.fn[NAME$8] = ScrollSpy._jQueryInterface;
  $.fn[NAME$8].Constructor = ScrollSpy;

  $.fn[NAME$8].noConflict = function () {
    $.fn[NAME$8] = JQUERY_NO_CONFLICT$8;
    return ScrollSpy._jQueryInterface;
  };

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  var NAME$9 = 'tab';
  var VERSION$9 = '4.3.1';
  var DATA_KEY$9 = 'bs.tab';
  var EVENT_KEY$9 = "." + DATA_KEY$9;
  var DATA_API_KEY$7 = '.data-api';
  var JQUERY_NO_CONFLICT$9 = $.fn[NAME$9];
  var Event$9 = {
    HIDE: "hide" + EVENT_KEY$9,
    HIDDEN: "hidden" + EVENT_KEY$9,
    SHOW: "show" + EVENT_KEY$9,
    SHOWN: "shown" + EVENT_KEY$9,
    CLICK_DATA_API: "click" + EVENT_KEY$9 + DATA_API_KEY$7
  };
  var ClassName$9 = {
    DROPDOWN_MENU: 'dropdown-menu',
    ACTIVE: 'active',
    DISABLED: 'disabled',
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector$9 = {
    DROPDOWN: '.dropdown',
    NAV_LIST_GROUP: '.nav, .list-group',
    ACTIVE: '.active',
    ACTIVE_UL: '> li > .active',
    DATA_TOGGLE: '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
    DROPDOWN_TOGGLE: '.dropdown-toggle',
    DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     ../../../_/default.htm

  };

  var Tab =
  /*#__PURE__*/
  function () {
    function Tab(element) {
      this._element = element;
    } // Getters


    var _proto = Tab.prototype;

    // Public
    _proto.show = function show() {
      var _this = this;

      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName$9.ACTIVE) || $(this._element).hasClass(ClassName$9.DISABLED)) {
        return;
      }

      var target;
      var previous;
      var listElement = $(this._element).closest(Selector$9.NAV_LIST_GROUP)[0];
      var selector = Util.getSelectorFromElement(this._element);

      if (listElement) {
        var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? Selector$9.ACTIVE_UL : Selector$9.ACTIVE;
        previous = $.makeArray($(listElement).find(itemSelector));
        previous = previous[previous.length - 1];
      }

      var hideEvent = $.Event(Event$9.HIDE, {
        relatedTarget: this._element
      });
      var showEvent = $.Event(Event$9.SHOW, {
        relatedTarget: previous
      });

      if (previous) {
        $(previous).trigger(hideEvent);
      }

      $(this._element).trigger(showEvent);

      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
        return;
      }

      if (selector) {
        target = document.querySelector(selector);
      }

      this._activate(this._element, listElement);

      var complete = function complete() {
        var hiddenEvent = $.Event(Event$9.HIDDEN, {
          relatedTarget: _this._element
        });
        var shownEvent = $.Event(Event$9.SHOWN, {
          relatedTarget: previous
        });
        $(previous).trigger(hiddenEvent);
        $(_this._element).trigger(shownEvent);
      };

      if (target) {
        this._activate(target, target.parentNode, complete);
      } else {
        complete();
      }
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$9);
      this._element = null;
    } // Private
    ;

    _proto._activate = function _activate(element, container, callback) {
      var _this2 = this;

      var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? $(container).find(Selector$9.ACTIVE_UL) : $(container).children(Selector$9.ACTIVE);
      var active = activeElements[0];
      var isTransitioning = callback && active && $(active).hasClass(ClassName$9.FADE);

      var complete = function complete() {
        return _this2._transitionComplete(element, active, callback);
      };

      if (active && isTransitioning) {
        var transitionDuration = Util.getTransitionDurationFromElement(active);
        $(active).removeClass(ClassName$9.SHOW).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }
    };

    _proto._transitionComplete = function _transitionComplete(element, active, callback) {
      if (active) {
        $(active).removeClass(ClassName$9.ACTIVE);
        var dropdownChild = $(active.parentNode).find(Selector$9.DROPDOWN_ACTIVE_CHILD)[0];

        if (dropdownChild) {
          $(dropdownChild).removeClass(ClassName$9.ACTIVE);
        }

        if (active.getAttribute('role') === 'tab') {
          active.setAttribute('aria-selected', false);
        }
      }

      $(element).addClass(ClassName$9.ACTIVE);

      if (element.getAttribute('role') === 'tab') {
        element.setAttribute('aria-selected', true);
      }

      Util.reflow(element);

      if (element.classList.contains(ClassName$9.FADE)) {
        element.classList.add(ClassName$9.SHOW);
      }

      if (element.parentNode && $(element.parentNode).hasClass(ClassName$9.DROPDOWN_MENU)) {
        var dropdownElement = $(element).closest(Selector$9.DROPDOWN)[0];

        if (dropdownElement) {
          var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(Selector$9.DROPDOWN_TOGGLE));
          $(dropdownToggleList).addClass(ClassName$9.ACTIVE);
        }

        element.setAttribute('aria-expanded', true);
      }

      if (callback) {
        callback();
      }
    } // Static
    ;

    Tab._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $this = $(this);
        var data = $this.data(DATA_KEY$9);

        if (!data) {
          data = new Tab(this);
          $this.data(DATA_KEY$9, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Tab, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$9;
      }
    }]);

    return Tab;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   ../../../_/default.htm


  $(document).on(Event$9.CLICK_DATA_API, Selector$9.DATA_TOGGLE, function (event) {
    event.preventDefault();

    Tab._jQueryInterface.call($(this), 'show');
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  $.fn[NAME$9] = Tab._jQueryInterface;
  $.fn[NAME$9].Constructor = Tab;

  $.fn[NAME$9].noConflict = function () {
    $.fn[NAME$9] = JQUERY_NO_CONFLICT$9;
    return Tab._jQueryInterface;
  };

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   ../../../_/default.htm

  var NAME$a = 'toast';
  var VERSION$a = '4.3.1';
  var DATA_KEY$a = 'bs.toast';
  var EVENT_KEY$a = "." + DATA_KEY$a;
  var JQUERY_NO_CONFLICT$a = $.fn[NAME$a];
  var Event$a = {
    CLICK_DISMISS: "click.dismiss" + EVENT_KEY$a,
    HIDE: "hide" + EVENT_KEY$a,
    HIDDEN: "hidden" + EVENT_KEY$a,
    SHOW: "show" + EVENT_KEY$a,
    SHOWN: "shown" + EVENT_KEY$a
  };
  var ClassName$a = {
    FADE: 'fade',
    HIDE: 'hide',
    SHOW: 'show',
    SHOWING: 'showing'
  };
  var DefaultType$7 = {
    animation: 'boolean',
    autohide: 'boolean',
    delay: 'number'
  };
  var Default$7 = {
    animation: true,
    autohide: true,
    delay: 500
  };
  var Selector$a = {
    DATA_DISMISS: '[data-dismiss="toast"]'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     ../../../_/default.htm

  };

  var Toast =
  /*#__PURE__*/
  function () {
    function Toast(element, config) {
      this._element = element;
      this._config = this._getConfig(config);
      this._timeout = null;

      this._setListeners();
    } // Getters


    var _proto = Toast.prototype;

    // Public
    _proto.show = function show() {
      var _this = this;

      $(this._element).trigger(Event$a.SHOW);

      if (this._config.animation) {
        this._element.classList.add(ClassName$a.FADE);
      }

      var complete = function complete() {
        _this._element.classList.remove(ClassName$a.SHOWING);

        _this._element.classList.add(ClassName$a.SHOW);

        $(_this._element).trigger(Event$a.SHOWN);

        if (_this._config.autohide) {
          _this.hide();
        }
      };

      this._element.classList.remove(ClassName$a.HIDE);

      this._element.classList.add(ClassName$a.SHOWING);

      if (this._config.animation) {
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }
    };

    _proto.hide = function hide(withoutTimeout) {
      var _this2 = this;

      if (!this._element.classList.contains(ClassName$a.SHOW)) {
        return;
      }

      $(this._element).trigger(Event$a.HIDE);

      if (withoutTimeout) {
        this._close();
      } else {
        this._timeout = setTimeout(function () {
          _this2._close();
        }, this._config.delay);
      }
    };

    _proto.dispose = function dispose() {
      clearTimeout(this._timeout);
      this._timeout = null;

      if (this._element.classList.contains(ClassName$a.SHOW)) {
        this._element.classList.remove(ClassName$a.SHOW);
      }

      $(this._element).off(Event$a.CLICK_DISMISS);
      $.removeData(this._element, DATA_KEY$a);
      this._element = null;
      this._config = null;
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread({}, Default$7, $(this._element).data(), typeof config === 'object' && config ? config : {});
      Util.typeCheckConfig(NAME$a, config, this.constructor.DefaultType);
      return config;
    };

    _proto._setListeners = function _setListeners() {
      var _this3 = this;

      $(this._element).on(Event$a.CLICK_DISMISS, Selector$a.DATA_DISMISS, function () {
        return _this3.hide(true);
      });
    };

    _proto._close = function _close() {
      var _this4 = this;

      var complete = function complete() {
        _this4._element.classList.add(ClassName$a.HIDE);

        $(_this4._element).trigger(Event$a.HIDDEN);
      };

      this._element.classList.remove(ClassName$a.SHOW);

      if (this._config.animation) {
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }
    } // Static
    ;

    Toast._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $element = $(this);
        var data = $element.data(DATA_KEY$a);

        var _config = typeof config === 'object' && config;

        if (!data) {
          data = new Toast(this, _config);
          $element.data(DATA_KEY$a, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config](this);
        }
      });
    };

    _createClass(Toast, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$a;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$7;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$7;
      }
    }]);

    return Toast;
  }();
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   ../../../_/default.htm


  $.fn[NAME$a] = Toast._jQueryInterface;
  $.fn[NAME$a].Constructor = Toast;

  $.fn[NAME$a].noConflict = function () {
    $.fn[NAME$a] = JQUERY_NO_CONFLICT$a;
    return Toast._jQueryInterface;
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.3.1): index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   ../../../_/default.htm

  (function () {
    if (typeof $ === 'undefined') {
      throw new TypeError('Bootstrap\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\'s JavaScript.');
    }

    var version = $.fn.jquery.split(' ')[0].split('.');
    var minMajor = 1;
    var ltMajor = 2;
    var minMinor = 9;
    var minPatch = 1;
    var maxMajor = 4;

    if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {
      throw new Error('Bootstrap\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');
    }
  })();

  exports.Util = Util;
  exports.Alert = Alert;
  exports.Button = Button;
  exports.Carousel = Carousel;
  exports.Collapse = Collapse;
  exports.Dropdown = Dropdown;
  exports.Modal = Modal;
  exports.Popover = Popover;
  exports.Scrollspy = ScrollSpy;
  exports.Tab = Tab;
  exports.Toast = Toast;
  exports.Tooltip = Tooltip;

  Object.defineProperty(exports, '__esModule', { value: true });

}));


/**
 * Yii JavaScript module.
 *
 * @link http://www.yiiframework.com/
 * @copyright Copyright (c) 2008 Yii Software LLC
 * @license http://www.yiiframework.com/license/
 * @author Qiang Xue <qiang.xue@gmail.com>
 * @since 2.0
 ../../../_/default.htm

/**
 * yii is the root module for all Yii JavaScript modules.
 * It implements a mechanism of organizing JavaScript code in modules through the function "yii.initModule()".
 *
 * Each module should be named as "../../../x.y.z", where "x" stands for the root module (for the Yii core code, this is "yii").
 *
 * A module may be structured as follows:
 *
 * ```javascript
 * window.yii.sample = (function($) {
 *     var pub = {
 *         // whether this module is currently active. If false, init() will not be called for this module
 *         // it will also not be called for all its child modules. If this property is undefined, it means true.
 *         isActive: true,
 *         init: function() {
 *             // ... module initialization code goes here ...
 *         },
 *
 *         // ... other public functions and properties go here ...
 *     };
 *
 *     // ... private functions and properties go here ...
 *
 *     return pub;
 * })(window.jQuery);
 * ```
 *
 * Using this structure, you can define public and private functions/properties for a module.
 * Private functions/properties are only visible within the module, while public functions/properties
 * may be accessed outside of the module. For example, you can access "yii.sample.isActive".
 *
 * You must call "yii.initModule()" once for the root module of all your modules.
 ../../../_/default.htm
window.yii = (function ($) {
    var pub = {
        /**
         * List of JS or CSS URLs that can be loaded multiple times via AJAX requests.
         * Each item may be represented as either an absolute URL or a relative one.
         * Each item may contain a wildcard matching character `*`, that means one or more
         * any characters on the position. For example:
         *  - `/css/*.css` will match any file ending with `.css` in the `css` directory of the current web site
         *  - `http*://cdn.example.com/*` will match any files on domain `cdn.example.com`, loaded with HTTP or HTTPS
         *  - `/js/myCustomScript.js?realm=*` will match file `/js/myCustomScript.js` with defined `realm` parameter
         ../../../_/default.htm
        reloadableScripts: [],
        /**
         * The selector for clickable elements that need to support confirmation and form submission.
         ../../../_/default.htm
        clickableSelector: 'a, button, input[type="submit"], input[type="button"], input[type="reset"], ' +
            'input[type="image"]',
        /**
         * The selector for changeable elements that need to support confirmation and form submission.
         ../../../_/default.htm
        changeableSelector: 'select, input, textarea',

        /**
         * @return string|undefined the CSRF parameter name. Undefined is returned if CSRF validation is not enabled.
         ../../../_/default.htm
        getCsrfParam: function () {
            return $('meta[name=csrf-param]').attr('content');
        },

        /**
         * @return string|undefined the CSRF token. Undefined is returned if CSRF validation is not enabled.
         ../../../_/default.htm
        getCsrfToken: function () {
            return $('meta[name=csrf-token]').attr('content');
        },

        /**
         * Sets the CSRF token in the meta elements.
         * This method is provided so that you can update the CSRF token with the latest one you obtain from the server.
         * @param name the CSRF token name
         * @param value the CSRF token value
         ../../../_/default.htm
        setCsrfToken: function (name, value) {
            $('meta[name=csrf-param]').attr('content', name);
            $('meta[name=csrf-token]').attr('content', value);
        },

        /**
         * Updates all form CSRF input fields with the latest CSRF token.
         * This method is provided to avoid cached forms containing outdated CSRF tokens.
         ../../../_/default.htm
        refreshCsrfToken: function () {
            var token = pub.getCsrfToken();
            if (token) {
                $('form input[name="' + pub.getCsrfParam() + '"]').val(token);
            }
        },

        /**
         * Displays a confirmation dialog.
         * The default implementation simply displays a js confirmation dialog.
         * You may override this by setting `yii.confirm`.
         * @param message the confirmation message.
         * @param ok a callback to be called when the user confirms the message
         * @param cancel a callback to be called when the user cancels the confirmation
         ../../../_/default.htm
        confirm: function (message, ok, cancel) {
            if (window.confirm(message)) {
                !ok || ok();
            } else {
                !cancel || cancel();
            }
        },

        /**
         * Handles the action triggered by user.
         * This method recognizes the `data-method` attribute of the element. If the attribute exists,
         * the method will submit the form containing this element. If there is no containing form, a form
         * will be created and submitted using the method given by this attribute value (e.g. "post", "put").
         * For hyperlinks, the form action will take the value of the "href" attribute of the link.
         * For other elements, either the containing form action or the current page URL will be used
         * as the form action URL.
         *
         * If the `data-method` attribute is not defined, the `href` attribute (if any) of the element
         * will be assigned to `window.location`.
         *
         * Starting from version 2.0.3, the `data-params` attribute is also recognized when you specify
         * `data-method`. The value of `data-params` should be a JSON representation of the data (name-value pairs)
         * that should be submitted as hidden inputs. For example, you may use the following code to generate
         * such a link:
         *
         * ```php
         * use yii\helpers\Html;
         * use yii\helpers\Json;
         *
         * echo Html::a('submit', ['site/foobar'], [
         *     'data' => [
         *         'method' => 'post',
         *         'params' => [
         *             'name1' => 'value1',
         *             'name2' => 'value2',
         *         ],
         *     ],
         * ]);
         * ```
         *
         * @param $e the jQuery representation of the element
         * @param event Related event
         ../../../_/default.htm
        handleAction: function ($e, event) {
            var $form = $e.attr('data-form') ? $('#' + $e.attr('data-form')) : $e.closest('form'),
                method = !$e.data('method') && $form ? $form.attr('method') : $e.data('method'),
                action = $e.attr('href'),
                isValidAction = action && action !== '#',
                params = $e.data('params'),
                areValidParams = params && $.isPlainObject(params),
                pjax = $e.data('pjax'),
                usePjax = pjax !== undefined && pjax !== 0 && $.support.pjax,
                pjaxContainer,
                pjaxOptions = {},
                conflictParams = ['submit', 'reset', 'elements', 'length', 'name', 'acceptCharset',
                    'action', 'enctype', 'method', 'target'];

            // Forms and their child elements should not use input names or ids that conflict with properties of a form,
            // such as submit, length, or method.
            $.each(conflictParams, function (index, param) {
                if (areValidParams && params.hasOwnProperty(param)) {
                    console.error("Parameter name '" + param + "' conflicts with a same named form property. " +
                        "Please use another name.");
                }
            });

            if (usePjax) {
                pjaxContainer = $e.data('pjax-container');
                if (pjaxContainer === undefined || !pjaxContainer.length) {
                    pjaxContainer = $e.closest('[data-pjax-container]').attr('id')
                        ? ('#' + $e.closest('[data-pjax-container]').attr('id'))
                        : '';
                }
                if (!pjaxContainer.length) {
                    pjaxContainer = 'body';
                }
                pjaxOptions = {
                    container: pjaxContainer,
                    push: !!$e.data('pjax-push-state'),
                    replace: !!$e.data('pjax-replace-state'),
                    scrollTo: $e.data('pjax-scrollto'),
                    pushRedirect: $e.data('pjax-push-redirect'),
                    replaceRedirect: $e.data('pjax-replace-redirect'),
                    skipOuterContainers: $e.data('pjax-skip-outer-containers'),
                    timeout: $e.data('pjax-timeout'),
                    originalEvent: event,
                    originalTarget: $e
                };
            }

            if (method === undefined) {
                if (isValidAction) {
                    usePjax ? $.pjax.click(event, pjaxOptions) : window.location.assign(action);
                } else if ($e.is(':submit') && $form.length) {
                    if (usePjax) {
                        $form.on('submit', function (e) {
                            $.pjax.submit(e, pjaxOptions);
                        });
                    }
                    $form.trigger('submit');
                }
                return;
            }

            var oldMethod,
                oldAction,
                newForm = !$form.length;
            if (!newForm) {
                oldMethod = $form.attr('method');
                $form.attr('method', method);
                if (isValidAction) {
                    oldAction = $form.attr('action');
                    $form.attr('action', action);
                }
            } else {
                if (!isValidAction) {
                    action = pub.getCurrentUrl();
                }
                $form = $('<form/>', {method: method, action: action});
                var target = $e.attr('target');
                if (target) {
                    $form.attr('target', target);
                }
                if (!/(get|post)/i.test(method)) {
                    $form.append($('<input/>', {name: '_method', value: method, type: 'hidden'}));
                    method = 'post';
                    $form.attr('method', method);
                }
                if (/post/i.test(method)) {
                    var csrfParam = pub.getCsrfParam();
                    if (csrfParam) {
                        $form.append($('<input/>', {name: csrfParam, value: pub.getCsrfToken(), type: 'hidden'}));
                    }
                }
                $form.hide().appendTo('body');
            }

            var activeFormData = $form.data('yiiActiveForm');
            if (activeFormData) {
                // Remember the element triggered the form submission. This is used by yii.activeForm.js.
                activeFormData.submitObject = $e;
            }

            if (areValidParams) {
                $.each(params, function (name, value) {
                    $form.append($('<input/>').attr({name: name, value: value, type: 'hidden'}));
                });
            }

            if (usePjax) {
                $form.on('submit', function (e) {
                    $.pjax.submit(e, pjaxOptions);
                });
            }

            $form.trigger('submit');

            $.when($form.data('yiiSubmitFinalizePromise')).done(function () {
                if (newForm) {
                    $form.remove();
                    return;
                }

                if (oldAction !== undefined) {
                    $form.attr('action', oldAction);
                }
                $form.attr('method', oldMethod);

                if (areValidParams) {
                    $.each(params, function (name) {
                        $('input[name="' + name + '"]', $form).remove();
                    });
                }
            });
        },

        getQueryParams: function (url) {
            var pos = url.indexOf('?');
            if (pos < 0) {
                return {};
            }

            var pairs = $.grep(url.substring(pos + 1).split('#')[0].split('&'), function (value) {
                return value !== '';
            });
            var params = {};

            for (var i = 0, len = pairs.length; i < len; i++) {
                var pair = pairs[i].split('=');
                var name = decodeURIComponent(pair[0].replace(/\+/g, '%20'));
                var value = pair.length > 1 ? decodeURIComponent(pair[1].replace(/\+/g, '%20')) : '';
                if (!name.length) {
                    continue;
                }
                if (params[name] === undefined) {
                    params[name] = value || '';
                } else {
                    if (!$.isArray(params[name])) {
                        params[name] = [params[name]];
                    }
                    params[name].push(value || '');
                }
            }

            return params;
        },

        initModule: function (module) {
            if (module.isActive !== undefined && !module.isActive) {
                return;
            }
            if ($.isFunction(module.init)) {
                module.init();
            }
            $.each(module, function () {
                if ($.isPlainObject(this)) {
                    pub.initModule(this);
                }
            });
        },

        init: function () {
            initCsrfHandler();
            initRedirectHandler();
            initAssetFilters();
            initDataMethods();
        },

        /**
         * Returns the URL of the current page without params and trailing slash. Separated and made public for testing.
         * @returns {string}
         ../../../_/default.htm
        getBaseCurrentUrl: function () {
            return window.location.protocol + '//' + window.location.host;
        },

        /**
         * Returns the URL of the current page. Used for testing, you can always call `window.location.href` manually
         * instead.
         * @returns {string}
         ../../../_/default.htm
        getCurrentUrl: function () {
            return window.location.href;
        }
    };

    function initCsrfHandler() {
        // automatically send CSRF token for all AJAX requests
        $.ajaxPrefilter(function (options, originalOptions, xhr) {
            if (!options.crossDomain && pub.getCsrfParam()) {
                xhr.setRequestHeader('X-CSRF-Token', pub.getCsrfToken());
            }
        });
        pub.refreshCsrfToken();
    }

    function initRedirectHandler() {
        // handle AJAX redirection
        $(document).ajaxComplete(function (event, xhr) {
            var url = xhr && xhr.getResponseHeader('X-Redirect');
            if (url) {
                window.location.assign(url);
            }
        });
    }

    function initAssetFilters() {
        /**
         * Used for storing loaded scripts and information about loading each script if it's in the process of loading.
         * A single script can have one of the following values:
         *
         * - `undefined` - script was not loaded at all before or was loaded with error last time.
         * - `true` (boolean) -  script was successfully loaded.
         * - object - script is currently loading.
         *
         * In case of a value being an object the properties are:
         * - `xhrList` - represents a queue of XHR requests sent to the same URL (related with this script) in the same
         * small period of time.
         * - `xhrDone` - boolean, acts like a locking mechanism. When one of the XHR requests in the queue is
         * successfully completed, it will abort the rest of concurrent requests to the same URL until cleanup is done
         * to prevent possible errors and race conditions.
         * @type {{}}
         ../../../_/default.htm
        var loadedScripts = {};

        $('script[src]').each(function () {
            var url = getAbsoluteUrl(this.src);
            loadedScripts[url] = true;
        });

        $.ajaxPrefilter('script', function (options, originalOptions, xhr) {
            if (options.dataType == 'jsonp') {
                return;
            }

            var url = getAbsoluteUrl(options.url),
                forbiddenRepeatedLoad = loadedScripts[url] === true && !isReloadableAsset(url),
                cleanupRunning = loadedScripts[url] !== undefined && loadedScripts[url]['xhrDone'] === true;

            if (forbiddenRepeatedLoad || cleanupRunning) {
                xhr.abort();
                return;
            }

            if (loadedScripts[url] === undefined || loadedScripts[url] === true) {
                loadedScripts[url] = {
                    xhrList: [],
                    xhrDone: false
                };
            }

            xhr.done(function (data, textStatus, jqXHR) {
                // If multiple requests were successfully loaded, perform cleanup only once
                if (loadedScripts[jqXHR.yiiUrl]['xhrDone'] === true) {
                    return;
                }

                loadedScripts[jqXHR.yiiUrl]['xhrDone'] = true;

                for (var i = 0, len = loadedScripts[jqXHR.yiiUrl]['xhrList'].length; i < len; i++) {
                    var singleXhr = loadedScripts[jqXHR.yiiUrl]['xhrList'][i];
                    if (singleXhr && singleXhr.readyState !== XMLHttpRequest.DONE) {
                        singleXhr.abort();
                    }
                }

                loadedScripts[jqXHR.yiiUrl] = true;
            }).fail(function (jqXHR, textStatus) {
                if (textStatus === 'abort') {
                    return;
                }

                delete loadedScripts[jqXHR.yiiUrl]['xhrList'][jqXHR.yiiIndex];

                var allFailed = true;
                for (var i = 0, len = loadedScripts[jqXHR.yiiUrl]['xhrList'].length; i < len; i++) {
                    if (loadedScripts[jqXHR.yiiUrl]['xhrList'][i]) {
                        allFailed = false;
                    }
                }

                if (allFailed) {
                    delete loadedScripts[jqXHR.yiiUrl];
                }
            });
            // Use prefix for custom XHR properties to avoid possible conflicts with existing properties
            xhr.yiiIndex = loadedScripts[url]['xhrList'].length;
            xhr.yiiUrl = url;

            loadedScripts[url]['xhrList'][xhr.yiiIndex] = xhr;
        });

        $(document).ajaxComplete(function () {
            var styleSheets = [];
            $('link[rel=stylesheet]').each(function () {
                var url = getAbsoluteUrl(this.href);
                if (isReloadableAsset(url)) {
                    return;
                }

                $.inArray(url, styleSheets) === -1 ? styleSheets.push(url) : $(this).remove();
            });
        });
    }

    function initDataMethods() {
        var handler = function (event) {
            var $this = $(this),
                method = $this.data('method'),
                message = $this.data('confirm'),
                form = $this.data('form');

            if (method === undefined && message === undefined && form === undefined) {
                return true;
            }

            if (message !== undefined && message !== false && message !== '') {
                $.proxy(pub.confirm, this)(message, function () {
                    pub.handleAction($this, event);
                });
            } else {
                pub.handleAction($this, event);
            }
            event.stopImmediatePropagation();
            return false;
        };

        // handle data-confirm and data-method for clickable and changeable elements
        $(document).on('click.yii', pub.clickableSelector, handler)
            .on('change.yii', pub.changeableSelector, handler);
    }

    function isReloadableAsset(url) {
        for (var i = 0; i < pub.reloadableScripts.length; i++) {
            var rule = getAbsoluteUrl(pub.reloadableScripts[i]);
            var match = new RegExp("^" + escapeRegExp(rule).split('\\*').join('.+') + "$").test(url);
            if (match === true) {
                return true;
            }
        }

        return false;
    }

    // http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
    function escapeRegExp(str) {
        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    }

    /**
     * Returns absolute URL based on the given URL
     * @param {string} url Initial URL
     * @returns {string}
     ../../../_/default.htm
    function getAbsoluteUrl(url) {
        return url.charAt(0) === '../../../default.htm' ? pub.getBaseCurrentUrl() + url : url;
    }

    return pub;
})(window.jQuery);

window.jQuery(function () {
    window.yii.initModule(window.yii);
});

/**
 * Yii validation module.
 *
 * This JavaScript module provides the validation methods for the built-in validators.
 *
 * @link http://www.yiiframework.com/
 * @copyright Copyright (c) 2008 Yii Software LLC
 * @license http://www.yiiframework.com/license/
 * @author Qiang Xue <qiang.xue@gmail.com>
 * @since 2.0
 ../../../_/default.htm

yii.validation = (function ($) {
    var pub = {
        isEmpty: function (value) {
            return value === null || value === undefined || ($.isArray(value) && value.length === 0) || value === '';
        },

        addMessage: function (messages, message, value) {
            messages.push(message.replace(/\{value\}/g, value));
        },

        required: function (value, messages, options) {
            var valid = false;
            if (options.requiredValue === undefined) {
                var isString = typeof value == 'string' || value instanceof String;
                if (options.strict && value !== undefined || !options.strict && !pub.isEmpty(isString ? $.trim(value) : value)) {
                    valid = true;
                }
            } else if (!options.strict && value == options.requiredValue || options.strict && value === options.requiredValue) {
                valid = true;
            }

            if (!valid) {
                pub.addMessage(messages, options.message, value);
            }
        },

        // "boolean" is a reserved keyword in older versions of ES so it's quoted for IE < 9 support
        'boolean': function (value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }
            var valid = !options.strict && (value == options.trueValue || value == options.falseValue)
                || options.strict && (value === options.trueValue || value === options.falseValue);

            if (!valid) {
                pub.addMessage(messages, options.message, value);
            }
        },

        string: function (value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }

            if (typeof value !== 'string') {
                pub.addMessage(messages, options.message, value);
                return;
            }

            if (options.is !== undefined && value.length != options.is) {
                pub.addMessage(messages, options.notEqual, value);
                return;
            }
            if (options.min !== undefined && value.length < options.min) {
                pub.addMessage(messages, options.tooShort, value);
            }
            if (options.max !== undefined && value.length > options.max) {
                pub.addMessage(messages, options.tooLong, value);
            }
        },

        file: function (attribute, messages, options) {
            var files = getUploadedFiles(attribute, messages, options);
            $.each(files, function (i, file) {
                validateFile(file, messages, options);
            });
        },

        image: function (attribute, messages, options, deferredList) {
            var files = getUploadedFiles(attribute, messages, options);
            $.each(files, function (i, file) {
                validateFile(file, messages, options);

                // Skip image validation if FileReader API is not available
                if (typeof FileReader === "undefined") {
                    return;
                }

                var deferred = $.Deferred();
                pub.validateImage(file, messages, options, deferred, new FileReader(), new Image());
                deferredList.push(deferred);
            });
        },

        validateImage: function (file, messages, options, deferred, fileReader, image) {
            image.onload = function() {
                validateImageSize(file, image, messages, options);
                deferred.resolve();
            };

            image.onerror = function () {
                messages.push(options.notImage.replace(/\{file\}/g, file.name));
                deferred.resolve();
            };

            fileReader.onload = function () {
                image.src = this.result;
            };

            // Resolve deferred if there was error while reading data
            fileReader.onerror = function () {
                deferred.resolve();
            };

            fileReader.readAsDataURL(file);
        },

        number: function (value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }

            if (typeof value === 'string' && !options.pattern.test(value)) {
                pub.addMessage(messages, options.message, value);
                return;
            }

            if (options.min !== undefined && value < options.min) {
                pub.addMessage(messages, options.tooSmall, value);
            }
            if (options.max !== undefined && value > options.max) {
                pub.addMessage(messages, options.tooBig, value);
            }
        },

        range: function (value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }

            if (!options.allowArray && $.isArray(value)) {
                pub.addMessage(messages, options.message, value);
                return;
            }

            var inArray = true;

            $.each($.isArray(value) ? value : [value], function (i, v) {
                if ($.inArray(v, options.range) == -1) {
                    inArray = false;
                    return false;
                } else {
                    return true;
                }
            });

            if (options.not === undefined) {
                options.not = false;
            }

            if (options.not === inArray) {
                pub.addMessage(messages, options.message, value);
            }
        },

        regularExpression: function (value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }

            if (!options.not && !options.pattern.test(value) || options.not && options.pattern.test(value)) {
                pub.addMessage(messages, options.message, value);
            }
        },

        email: function (value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }

            var valid = true,
                regexp = /^((?:"?([^"]*)"?\s)?)(?:\s+)?(?:(<?)((.+)@([^>]+))(>?))$/,
                matches = regexp.exec(value);

            if (matches === null) {
                valid = false;
            } else {
                var localPart = matches[5],
                    domain = matches[6];

                if (options.enableIDN) {
                    localPart = punycode.toASCII(localPart);
                    domain = punycode.toASCII(domain);

                    value = matches[1] + matches[3] + localPart + '@' + domain + matches[7];
                }

                if (localPart.length > 64) {
                    valid = false;
                } else if ((localPart + '@' + domain).length > 254) {
                    valid = false;
                } else {
                    valid = options.pattern.test(value) || (options.allowName && options.fullPattern.test(value));
                }
            }

            if (!valid) {
                pub.addMessage(messages, options.message, value);
            }
        },

        url: function (value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }

            if (options.defaultScheme && !/:\/\//.test(value)) {
                value = options.defaultScheme + '://' + value;
            }

            var valid = true;

            if (options.enableIDN) {
                var matches = /^([^:]+):\/\/([^\/]+)(.*)$/.exec(value);
                if (matches === null) {
                    valid = false;
                } else {
                    value = matches[1] + '://' + punycode.toASCII(matches[2]) + matches[3];
                }
            }

            if (!valid || !options.pattern.test(value)) {
                pub.addMessage(messages, options.message, value);
            }
        },

        trim: function ($form, attribute, options, value) {
            var $input = $form.find(attribute.input);
            if ($input.is(':checkbox, :radio')) {
                return value;
            }

            value = $input.val();
            if (!options.skipOnEmpty || !pub.isEmpty(value)) {
                value = $.trim(value);
                $input.val(value);
            }

            return value;
        },

        captcha: function (value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }

            // CAPTCHA may be updated via AJAX and the updated hash is stored in body data
            var hash = $('body').data(options.hashKey);
            hash = hash == null ? options.hash : hash[options.caseSensitive ? 0 : 1];
            var v = options.caseSensitive ? value : value.toLowerCase();
            for (var i = v.length - 1, h = 0; i >= 0; --i) {
                h += v.charCodeAt(i);
            }
            if (h != hash) {
                pub.addMessage(messages, options.message, value);
            }
        },

        compare: function (value, messages, options, $form) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }

            var compareValue,
                valid = true;
            if (options.compareAttribute === undefined) {
                compareValue = options.compareValue;
            } else {
                var $target = $('#' + options.compareAttribute);
                if (!$target.length) {
                    $target = $form.find('[name="' + options.compareAttributeName + '"]');
                }
                compareValue = $target.val();
            }

            if (options.type === 'number') {
                value = value ? parseFloat(value) : 0;
                compareValue = compareValue ? parseFloat(compareValue) : 0;
            }
            switch (options.operator) {
                case '==':
                    valid = value == compareValue;
                    break;
                case '===':
                    valid = value === compareValue;
                    break;
                case '!=':
                    valid = value != compareValue;
                    break;
                case '!==':
                    valid = value !== compareValue;
                    break;
                case '>':
                    valid = value > compareValue;
                    break;
                case '>=':
                    valid = value >= compareValue;
                    break;
                case '<':
                    valid = value < compareValue;
                    break;
                case '<=':
                    valid = value <= compareValue;
                    break;
                default:
                    valid = false;
                    break;
            }

            if (!valid) {
                pub.addMessage(messages, options.message, value);
            }
        },

        ip: function (value, messages, options) {
            if (options.skipOnEmpty && pub.isEmpty(value)) {
                return;
            }

            var negation = null,
                cidr = null,
                matches = new RegExp(options.ipParsePattern).exec(value);
            if (matches) {
                negation = matches[1] || null;
                value = matches[2];
                cidr = matches[4] || null;
            }

            if (options.subnet === true && cidr === null) {
                pub.addMessage(messages, options.messages.noSubnet, value);
                return;
            }
            if (options.subnet === false && cidr !== null) {
                pub.addMessage(messages, options.messages.hasSubnet, value);
                return;
            }
            if (options.negation === false && negation !== null) {
                pub.addMessage(messages, options.messages.message, value);
                return;
            }

            var ipVersion = value.indexOf(':') === -1 ? 4 : 6;
            if (ipVersion == 6) {
                if (!(new RegExp(options.ipv6Pattern)).test(value)) {
                    pub.addMessage(messages, options.messages.message, value);
                }
                if (!options.ipv6) {
                    pub.addMessage(messages, options.messages.ipv6NotAllowed, value);
                }
            } else {
                if (!(new RegExp(options.ipv4Pattern)).test(value)) {
                    pub.addMessage(messages, options.messages.message, value);
                }
                if (!options.ipv4) {
                    pub.addMessage(messages, options.messages.ipv4NotAllowed, value);
                }
            }
        }
    };

    function getUploadedFiles(attribute, messages, options) {
        // Skip validation if File API is not available
        if (typeof File === "undefined") {
            return [];
        }

        var fileInput = $(attribute.input, attribute.$form).get(0);

        // Skip validation if file input does not exist
        // (in case file inputs are added dynamically and no file input has been added to the form)
        if (typeof fileInput === "undefined") {
            return [];
        }

        var files = fileInput.files;
        if (!files) {
            messages.push(options.message);
            return [];
        }

        if (files.length === 0) {
            if (!options.skipOnEmpty) {
                messages.push(options.uploadRequired);
            }

            return [];
        }

        if (options.maxFiles && options.maxFiles < files.length) {
            messages.push(options.tooMany);
            return [];
        }

        return files;
    }

    function validateFile(file, messages, options) {
        if (options.extensions && options.extensions.length > 0) {
            var index = file.name.lastIndexOf('.');
            var ext = !~index ? '' : file.name.substr(index + 1, file.name.length).toLowerCase();

            if (!~options.extensions.indexOf(ext)) {
                messages.push(options.wrongExtension.replace(/\{file\}/g, file.name));
            }
        }

        if (options.mimeTypes && options.mimeTypes.length > 0) {
            if (!validateMimeType(options.mimeTypes, file.type)) {
                messages.push(options.wrongMimeType.replace(/\{file\}/g, file.name));
            }
        }

        if (options.maxSize && options.maxSize < file.size) {
            messages.push(options.tooBig.replace(/\{file\}/g, file.name));
        }

        if (options.minSize && options.minSize > file.size) {
            messages.push(options.tooSmall.replace(/\{file\}/g, file.name));
        }
    }

    function validateMimeType(mimeTypes, fileType) {
        for (var i = 0, len = mimeTypes.length; i < len; i++) {
            if (new RegExp(mimeTypes[i]).test(fileType)) {
                return true;
            }
        }

        return false;
    }

    function validateImageSize(file, image, messages, options) {
        if (options.minWidth && image.width < options.minWidth) {
            messages.push(options.underWidth.replace(/\{file\}/g, file.name));
        }

        if (options.maxWidth && image.width > options.maxWidth) {
            messages.push(options.overWidth.replace(/\{file\}/g, file.name));
        }

        if (options.minHeight && image.height < options.minHeight) {
            messages.push(options.underHeight.replace(/\{file\}/g, file.name));
        }

        if (options.maxHeight && image.height > options.maxHeight) {
            messages.push(options.overHeight.replace(/\{file\}/g, file.name));
        }
    }

    return pub;
})(jQuery);

/**
 * Yii form widget.
 *
 * This is the JavaScript widget used by the yii\widgets\ActiveForm widget.
 *
 * @link http://www.yiiframework.com/
 * @copyright Copyright (c) 2008 Yii Software LLC
 * @license http://www.yiiframework.com/license/
 * @author Qiang Xue <qiang.xue@gmail.com>
 * @since 2.0
 ../../../_/default.htm
(function ($) {

    $.fn.yiiActiveForm = function (method) {
        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            return methods.init.apply(this, arguments);
        } else {
            $.error('Method ' + method + ' does not exist on jQuery.yiiActiveForm');
            return false;
        }
    };

    var events = {
        /**
         * beforeValidate event is triggered before validating the whole form.
         * The signature of the event handler should be:
         *     function (event, messages, deferreds)
         * where
         *  - event: an Event object.
         *  - messages: an associative array with keys being attribute IDs and values being error message arrays
         *    for the corresponding attributes.
         *  - deferreds: an array of Deferred objects. You can use deferreds.add(callback) to add a new deferred validation.
         *
         * If the handler returns a boolean false, it will stop further form validation after this event. And as
         * a result, afterValidate event will not be triggered.
         ../../../_/default.htm
        beforeValidate: 'beforeValidate',
        /**
         * afterValidate event is triggered after validating the whole form.
         * The signature of the event handler should be:
         *     function (event, messages, errorAttributes)
         * where
         *  - event: an Event object.
         *  - messages: an associative array with keys being attribute IDs and values being error message arrays
         *    for the corresponding attributes.
         *  - errorAttributes: an array of attributes that have validation errors. Please refer to attributeDefaults for the structure of this parameter.
         ../../../_/default.htm
        afterValidate: 'afterValidate',
        /**
         * beforeValidateAttribute event is triggered before validating an attribute.
         * The signature of the event handler should be:
         *     function (event, attribute, messages, deferreds)
         * where
         *  - event: an Event object.
         *  - attribute: the attribute to be validated. Please refer to attributeDefaults for the structure of this parameter.
         *  - messages: an array to which you can add validation error messages for the specified attribute.
         *  - deferreds: an array of Deferred objects. You can use deferreds.add(callback) to add a new deferred validation.
         *
         * If the handler returns a boolean false, it will stop further validation of the specified attribute.
         * And as a result, afterValidateAttribute event will not be triggered.
         ../../../_/default.htm
        beforeValidateAttribute: 'beforeValidateAttribute',
        /**
         * afterValidateAttribute event is triggered after validating the whole form and each attribute.
         * The signature of the event handler should be:
         *     function (event, attribute, messages)
         * where
         *  - event: an Event object.
         *  - attribute: the attribute being validated. Please refer to attributeDefaults for the structure of this parameter.
         *  - messages: an array to which you can add additional validation error messages for the specified attribute.
         ../../../_/default.htm
        afterValidateAttribute: 'afterValidateAttribute',
        /**
         * beforeSubmit event is triggered before submitting the form after all validations have passed.
         * The signature of the event handler should be:
         *     function (event)
         * where event is an Event object.
         *
         * If the handler returns a boolean false, it will stop form submission.
         ../../../_/default.htm
        beforeSubmit: 'beforeSubmit',
        /**
         * ajaxBeforeSend event is triggered before sending an AJAX request for AJAX-based validation.
         * The signature of the event handler should be:
         *     function (event, jqXHR, settings)
         * where
         *  - event: an Event object.
         *  - jqXHR: a jqXHR object
         *  - settings: the settings for the AJAX request
         ../../../_/default.htm
        ajaxBeforeSend: 'ajaxBeforeSend',
        /**
         * ajaxComplete event is triggered after completing an AJAX request for AJAX-based validation.
         * The signature of the event handler should be:
         *     function (event, jqXHR, textStatus)
         * where
         *  - event: an Event object.
         *  - jqXHR: a jqXHR object
         *  - textStatus: the status of the request ("success", "notmodified", "error", "timeout", "abort", or "parsererror").
         ../../../_/default.htm
        ajaxComplete: 'ajaxComplete',
        /**
         * afterInit event is triggered after yii activeForm init.
         * The signature of the event handler should be:
         *     function (event)
         * where
         *  - event: an Event object.
         ../../../_/default.htm
        afterInit: 'afterInit'
    };

    // NOTE: If you change any of these defaults, make sure you update yii\widgets\ActiveForm::getClientOptions() as well
    var defaults = {
        // whether to encode the error summary
        encodeErrorSummary: true,
        // the jQuery selector for the error summary
        errorSummary: '.error-summary',
        // whether to perform validation before submitting the form.
        validateOnSubmit: true,
        // the container CSS class representing the corresponding attribute has validation error
        errorCssClass: 'has-error',
        // the container CSS class representing the corresponding attribute passes validation
        successCssClass: 'has-success',
        // the container CSS class representing the corresponding attribute is being validated
        validatingCssClass: 'validating',
        // the GET parameter name indicating an AJAX-based validation
        ajaxParam: 'ajax',
        // the type of data that you're expecting back from the server
        ajaxDataType: 'json',
        // the URL for performing AJAX-based validation. If not set, it will use the the form's action
        validationUrl: undefined,
        // whether to scroll to first visible error after validation.
        scrollToError: true,
        // offset in pixels that should be added when scrolling to the first error.
        scrollToErrorOffset: 0,
        // where to add validation class: container or input
        validationStateOn: 'container'
    };

    // NOTE: If you change any of these defaults, make sure you update yii\widgets\ActiveField::getClientOptions() as well
    var attributeDefaults = {
        // a unique ID identifying an attribute (e.g. "loginform-username") in a form
        id: undefined,
        // attribute name or expression (e.g. "[0]content" for tabular input)
        name: undefined,
        // the jQuery selector of the container of the input field
        container: undefined,
        // the jQuery selector of the input field under the context of the form
        input: undefined,
        // the jQuery selector of the error tag under the context of the container
        error: '.help-block',
        // whether to encode the error
        encodeError: true,
        // whether to perform validation when a change is detected on the input
        validateOnChange: true,
        // whether to perform validation when the input loses focus
        validateOnBlur: true,
        // whether to perform validation when the user is typing.
        validateOnType: false,
        // number of milliseconds that the validation should be delayed when a user is typing in the input field.
        validationDelay: 500,
        // whether to enable AJAX-based validation.
        enableAjaxValidation: false,
        // function (attribute, value, messages, deferred, $form), the client-side validation function.
        validate: undefined,
        // status of the input field, 0: empty, not entered before, 1: validated, 2: pending validation, 3: validating
        status: 0,
        // whether the validation is cancelled by beforeValidateAttribute event handler
        cancelled: false,
        // the value of the input
        value: undefined,
        // whether to update aria-invalid attribute after validation
        updateAriaInvalid: true
    };


    var submitDefer;

    var setSubmitFinalizeDefer = function($form) {
        submitDefer = $.Deferred();
        $form.data('yiiSubmitFinalizePromise', submitDefer.promise());
    };

    // finalize yii.js $form.submit
    var submitFinalize = function($form) {
        if(submitDefer) {
            submitDefer.resolve();
            submitDefer = undefined;
            $form.removeData('yiiSubmitFinalizePromise');
        }
    };


    var methods = {
        init: function (attributes, options) {
            return this.each(function () {
                var $form = $(this);
                if ($form.data('yiiActiveForm')) {
                    return;
                }

                var settings = $.extend({}, defaults, options || {});
                if (settings.validationUrl === undefined) {
                    settings.validationUrl = $form.attr('action');
                }

                $.each(attributes, function (i) {
                    attributes[i] = $.extend({value: getValue($form, this)}, attributeDefaults, this);
                    watchAttribute($form, attributes[i]);
                });

                $form.data('yiiActiveForm', {
                    settings: settings,
                    attributes: attributes,
                    submitting: false,
                    validated: false,
                    options: getFormOptions($form)
                });

                /**
                 * Clean up error status when the form is reset.
                 * Note that $form.on('reset', ...) does work because the "reset" event does not bubble on IE.
                 ../../../_/default.htm
                $form.on('reset.yiiActiveForm', methods.resetForm);

                if (settings.validateOnSubmit) {
                    $form.on('mouseup.yiiActiveForm keyup.yiiActiveForm', ':submit', function () {
                        $form.data('yiiActiveForm').submitObject = $(this);
                    });
                    $form.on('submit.yiiActiveForm', methods.submitForm);
                }
                var event = $.Event(events.afterInit);
                $form.trigger(event);
            });
        },

        // add a new attribute to the form dynamically.
        // please refer to attributeDefaults for the structure of attribute
        add: function (attribute) {
            var $form = $(this);
            attribute = $.extend({value: getValue($form, attribute)}, attributeDefaults, attribute);
            $form.data('yiiActiveForm').attributes.push(attribute);
            watchAttribute($form, attribute);
        },

        // remove the attribute with the specified ID from the form
        remove: function (id) {
            var $form = $(this),
                attributes = $form.data('yiiActiveForm').attributes,
                index = -1,
                attribute = undefined;
            $.each(attributes, function (i) {
                if (attributes[i]['id'] == id) {
                    index = i;
                    attribute = attributes[i];
                    return false;
                }
            });
            if (index >= 0) {
                attributes.splice(index, 1);
                unwatchAttribute($form, attribute);
            }

            return attribute;
        },

        // manually trigger the validation of the attribute with the specified ID
        validateAttribute: function (id) {
            var attribute = methods.find.call(this, id);
            if (attribute != undefined) {
                validateAttribute($(this), attribute, true);
            }
        },

        // find an attribute config based on the specified attribute ID
        find: function (id) {
            var attributes = $(this).data('yiiActiveForm').attributes,
                result = undefined;
            $.each(attributes, function (i) {
                if (attributes[i]['id'] == id) {
                    result = attributes[i];
                    return false;
                }
            });
            return result;
        },

        destroy: function () {
            return this.each(function () {
                $(this).off('.yiiActiveForm');
                $(this).removeData('yiiActiveForm');
            });
        },

        data: function () {
            return this.data('yiiActiveForm');
        },

        // validate all applicable inputs in the form
        validate: function (forceValidate) {
            if (forceValidate) {
                $(this).data('yiiActiveForm').submitting = true;
            }

            var $form = $(this),
                data = $form.data('yiiActiveForm'),
                needAjaxValidation = false,
                messages = {},
                deferreds = deferredArray(),
                submitting = data.submitting;

            if (submitting) {
                var event = $.Event(events.beforeValidate);
                $form.trigger(event, [messages, deferreds]);

                if (event.result === false) {
                    data.submitting = false;
                    submitFinalize($form);
                    return;
                }
            }

            // client-side validation
            $.each(data.attributes, function () {
                this.$form = $form;
                var $input = findInput($form, this);

                if ($input.is(":disabled")) {
                    return true;
                }
                // pass SELECT without options
                if ($input.length && $input[0].tagName.toLowerCase() === 'select') {
                    if (!$input[0].options.length) {
                        return true;
                    } else if (($input[0].options.length === 1) && ($input[0].options[0].value === '')) {
                        return true;
                    }
                }
                this.cancelled = false;
                // perform validation only if the form is being submitted or if an attribute is pending validation
                if (data.submitting || this.status === 2 || this.status === 3) {
                    var msg = messages[this.id];
                    if (msg === undefined) {
                        msg = [];
                        messages[this.id] = msg;
                    }

                    var event = $.Event(events.beforeValidateAttribute);
                    $form.trigger(event, [this, msg, deferreds]);
                    if (event.result !== false) {
                        if (this.validate) {
                            this.validate(this, getValue($form, this), msg, deferreds, $form);
                        }
                        if (this.enableAjaxValidation) {
                            needAjaxValidation = true;
                        }
                    } else {
                        this.cancelled = true;
                    }
                }
            });

            // ajax validation
            $.when.apply(this, deferreds).always(function() {
                // Remove empty message arrays
                for (var i in messages) {
                    if (0 === messages[i].length) {
                        delete messages[i];
                    }
                }
                if (needAjaxValidation && ($.isEmptyObject(messages) || data.submitting)) {
                    var $button = data.submitObject,
                        extData = '&' + data.settings.ajaxParam + '=' + $form.attr('id');
                    if ($button && $button.length && $button.attr('name')) {
                        extData += '&' + $button.attr('name') + '=' + $button.attr('value');
                    }
                    $.ajax({
                        url: data.settings.validationUrl,
                        type: $form.attr('method'),
                        data: $form.serialize() + extData,
                        dataType: data.settings.ajaxDataType,
                        complete: function (jqXHR, textStatus) {
                            $form.trigger(events.ajaxComplete, [jqXHR, textStatus]);
                        },
                        beforeSend: function (jqXHR, settings) {
                            $form.trigger(events.ajaxBeforeSend, [jqXHR, settings]);
                        },
                        success: function (msgs) {
                            if (msgs !== null && typeof msgs === 'object') {
                                $.each(data.attributes, function () {
                                    if (!this.enableAjaxValidation || this.cancelled) {
                                        delete msgs[this.id];
                                    }
                                });
                                updateInputs($form, $.extend(messages, msgs), submitting);
                            } else {
                                updateInputs($form, messages, submitting);
                            }
                        },
                        error: function () {
                            data.submitting = false;
                            submitFinalize($form);
                        }
                    });
                } else if (data.submitting) {
                    // delay callback so that the form can be submitted without problem
                    window.setTimeout(function () {
                        updateInputs($form, messages, submitting);
                    }, 200);
                } else {
                    updateInputs($form, messages, submitting);
                }
            });
        },

        submitForm: function () {
            var $form = $(this),
                data = $form.data('yiiActiveForm');
            if (data.validated) {
                // Second submit's call (from validate/updateInputs)
                data.submitting = false;
                var event = $.Event(events.beforeSubmit);
                $form.trigger(event);
                if (event.result === false) {
                    data.validated = false;
                    submitFinalize($form);
                    return false;
                }
                updateHiddenButton($form);
                return true;   // continue submitting the form since validation passes
            } else {
                // First submit's call (from yii.js/handleAction) - execute validating
                setSubmitFinalizeDefer($form);

                if (data.settings.timer !== undefined) {
                    clearTimeout(data.settings.timer);
                }
                data.submitting = true;
                methods.validate.call($form);
                return false;
            }
        },

        resetForm: function () {
            var $form = $(this);
            var data = $form.data('yiiActiveForm');
            // Because we bind directly to a form reset event instead of a reset button (that may not exist),
            // when this function is executed form input values have not been reset yet.
            // Therefore we do the actual reset work through setTimeout.
            window.setTimeout(function () {
                $.each(data.attributes, function () {
                    // Without setTimeout() we would get the input values that are not reset yet.
                    this.value = getValue($form, this);
                    this.status = 0;
                    var $container = $form.find(this.container),
                        $input = findInput($form, this),
                        $errorElement = data.settings.validationStateOn === 'input' ? $input : $container;

                    $errorElement.removeClass(
                      data.settings.validatingCssClass + ' ' +
                      data.settings.errorCssClass + ' ' +
                      data.settings.successCssClass
                    );
                    $container.find(this.error).html('');
                });
                $form.find(data.settings.errorSummary).hide().find('ul').html('');
            }, 1);
        },

        /**
         * Updates error messages, input containers, and optionally summary as well.
         * If an attribute is missing from messages, it is considered valid.
         * @param messages array the validation error messages, indexed by attribute IDs
         * @param summary whether to update summary as well.
         ../../../_/default.htm
        updateMessages: function (messages, summary) {
            var $form = $(this);
            var data = $form.data('yiiActiveForm');
            $.each(data.attributes, function () {
                updateInput($form, this, messages);
            });
            if (summary) {
                updateSummary($form, messages);
            }
        },

        /**
         * Updates error messages and input container of a single attribute.
         * If messages is empty, the attribute is considered valid.
         * @param id attribute ID
         * @param messages array with error messages
         ../../../_/default.htm
        updateAttribute: function(id, messages) {
            var attribute = methods.find.call(this, id);
            if (attribute != undefined) {
                var msg = {};
                msg[id] = messages;
                updateInput($(this), attribute, msg);
            }
        }
    };

    var watchAttribute = function ($form, attribute) {
        var $input = findInput($form, attribute);
        if (attribute.validateOnChange) {
            $input.on('change.yiiActiveForm', function () {
                validateAttribute($form, attribute, false);
            });
        }
        if (attribute.validateOnBlur) {
            $input.on('blur.yiiActiveForm', function () {
                if (attribute.status == 0 || attribute.status == 1) {
                    validateAttribute($form, attribute, true);
                }
            });
        }
        if (attribute.validateOnType) {
            $input.on('keyup.yiiActiveForm', function (e) {
                if ($.inArray(e.which, [16, 17, 18, 37, 38, 39, 40]) !== -1 ) {
                    return;
                }
                if (attribute.value !== getValue($form, attribute)) {
                    validateAttribute($form, attribute, false, attribute.validationDelay);
                }
            });
        }
    };

    var unwatchAttribute = function ($form, attribute) {
        findInput($form, attribute).off('.yiiActiveForm');
    };

    var validateAttribute = function ($form, attribute, forceValidate, validationDelay) {
        var data = $form.data('yiiActiveForm');

        if (forceValidate) {
            attribute.status = 2;
        }
        $.each(data.attributes, function () {
            if (!isEqual(this.value, getValue($form, this))) {
                this.status = 2;
                forceValidate = true;
            }
        });
        if (!forceValidate) {
            return;
        }

        if (data.settings.timer !== undefined) {
            clearTimeout(data.settings.timer);
        }
        data.settings.timer = window.setTimeout(function () {
            if (data.submitting || $form.is(':hidden')) {
                return;
            }
            $.each(data.attributes, function () {
                if (this.status === 2) {
                    this.status = 3;
                    $form.find(this.container).addClass(data.settings.validatingCssClass);
                }
            });
            methods.validate.call($form);
        }, validationDelay ? validationDelay : 200);
    };

    /**
     * Compares two value whatever it objects, arrays or simple types
     * @param val1
     * @param val2
     * @returns boolean
     ../../../_/default.htm
    var isEqual = function(val1, val2) {
        // objects
        if (val1 instanceof Object) {
            return isObjectsEqual(val1, val2)
        }

        // arrays
        if (Array.isArray(val1)) {
            return isArraysEqual(val1, val2);
        }

        // simple types
        return val1 === val2;
    };

    /**
     * Compares two objects
     * @param obj1
     * @param obj2
     * @returns boolean
     ../../../_/default.htm
    var isObjectsEqual = function(obj1, obj2) {
        if (!(obj1 instanceof Object) || !(obj2 instanceof Object)) {
            return false;
        }

        var keys1 = Object.keys(obj1);
        var keys2 = Object.keys(obj2);
        if (keys1.length !== keys2.length) {
            return false;
        }

        for (var i = 0; i < keys1.length; i += 1) {
            if (!obj2.hasOwnProperty(keys1[i])) {
                return false;
            }
            if (obj1[keys1[i]] !== obj2[keys1[i]]) {
                return false;
            }
        }

        return true;
    };

    /**
     * Compares two arrays
     * @param arr1
     * @param arr2
     * @returns boolean
     ../../../_/default.htm
    var isArraysEqual = function(arr1, arr2) {
        if (!Array.isArray(arr1) || !Array.isArray(arr2)) {
            return false;
        }

        if (arr1.length !== arr2.length) {
            return false;
        }
        for (var i = 0; i < arr1.length; i += 1) {
            if (arr1[i] !== arr2[i]) {
                return false;
            }
        }
        return true;
    };

    /**
     * Returns an array prototype with a shortcut method for adding a new deferred.
     * The context of the callback will be the deferred object so it can be resolved like ```this.resolve()```
     * @returns Array
     ../../../_/default.htm
    var deferredArray = function () {
        var array = [];
        array.add = function(callback) {
            this.push(new $.Deferred(callback));
        };
        return array;
    };

    var buttonOptions = ['action', 'target', 'method', 'enctype'];

    /**
     * Returns current form options
     * @param $form
     * @returns object Object with button of form options
     ../../../_/default.htm
    var getFormOptions = function ($form) {
        var attributes = {};
        for (var i = 0; i < buttonOptions.length; i++) {
            attributes[buttonOptions[i]] = $form.attr(buttonOptions[i]);
        }

        return attributes;
    };

    /**
     * Applies temporary form options related to submit button
     * @param $form the form jQuery object
     * @param $button the button jQuery object
     ../../../_/default.htm
    var applyButtonOptions = function ($form, $button) {
        for (var i = 0; i < buttonOptions.length; i++) {
            var value = $button.attr('form' + buttonOptions[i]);
            if (value) {
                $form.attr(buttonOptions[i], value);
            }
        }
    };

    /**
     * Restores original form options
     * @param $form the form jQuery object
     ../../../_/default.htm
    var restoreButtonOptions = function ($form) {
        var data = $form.data('yiiActiveForm');

        for (var i = 0; i < buttonOptions.length; i++) {
            $form.attr(buttonOptions[i], data.options[buttonOptions[i]] || null);
        }
    };

    /**
     * Updates the error messages and the input containers for all applicable attributes
     * @param $form the form jQuery object
     * @param messages array the validation error messages
     * @param submitting whether this method is called after validation triggered by form submission
     ../../../_/default.htm
    var updateInputs = function ($form, messages, submitting) {
        var data = $form.data('yiiActiveForm');

        if (data === undefined) {
            return false;
        }

        var errorAttributes = [], $input;
        $.each(data.attributes, function () {
            var hasError = (submitting && updateInput($form, this, messages)) || (!submitting && attrHasError($form, this, messages));
            $input = findInput($form, this);

            if (!$input.is(":disabled") && !this.cancelled && hasError) {
                errorAttributes.push(this);
            }
        });

        $form.trigger(events.afterValidate, [messages, errorAttributes]);

        if (submitting) {
            updateSummary($form, messages);
            if (errorAttributes.length) {
                if (data.settings.scrollToError) {
                    var top = $form.find($.map(errorAttributes, function(attribute) {
                        return attribute.input;
                    }).join(',')).first().closest(':visible').offset().top - data.settings.scrollToErrorOffset;
                    if (top < 0) {
                        top = 0;
                    } else if (top > $(document).height()) {
                        top = $(document).height();
                    }
                    var wtop = $(window).scrollTop();
                    if (top < wtop || top > wtop + $(window).height()) {
                        $(window).scrollTop(top);
                    }
                }
                data.submitting = false;
            } else {
                data.validated = true;
                if (data.submitObject) {
                    applyButtonOptions($form, data.submitObject);
                }
                $form.submit();
                if (data.submitObject) {
                    restoreButtonOptions($form);
                }
            }
        } else {
            $.each(data.attributes, function () {
                if (!this.cancelled && (this.status === 2 || this.status === 3)) {
                    updateInput($form, this, messages);
                }
            });
        }
        submitFinalize($form);
    };

    /**
     * Updates hidden field that represents clicked submit button.
     * @param $form the form jQuery object.
     ../../../_/default.htm
    var updateHiddenButton = function ($form) {
        var data = $form.data('yiiActiveForm');
        var $button = data.submitObject || $form.find(':submit:first');
        // TODO: if the submission is caused by "change" event, it will not work
        if ($button.length && $button.attr('type') == 'submit' && $button.attr('name')) {
            // simulate button input value
            var $hiddenButton = $('input[type="hidden"][name="' + $button.attr('name') + '"]', $form);
            if (!$hiddenButton.length) {
                $('<input>').attr({
                    type: 'hidden',
                    name: $button.attr('name'),
                    value: $button.attr('value')
                }).appendTo($form);
            } else {
                $hiddenButton.attr('value', $button.attr('value'));
            }
        }
    };

    /**
     * Updates the error message and the input container for a particular attribute.
     * @param $form the form jQuery object
     * @param attribute object the configuration for a particular attribute.
     * @param messages array the validation error messages
     * @return boolean whether there is a validation error for the specified attribute
     ../../../_/default.htm
    var updateInput = function ($form, attribute, messages) {
        var data = $form.data('yiiActiveForm'),
            $input = findInput($form, attribute),
            hasError = attrHasError($form, attribute, messages);

        if (!$.isArray(messages[attribute.id])) {
            messages[attribute.id] = [];
        }

        attribute.status = 1;
        if ($input.length) {
            var $container = $form.find(attribute.container);
            var $error = $container.find(attribute.error);
            updateAriaInvalid($form, attribute, hasError);

            var $errorElement = data.settings.validationStateOn === 'input' ? $input : $container;

            if (hasError) {
                if (attribute.encodeError) {
                    $error.text(messages[attribute.id][0]);
                } else {
                    $error.html(messages[attribute.id][0]);
                }
                $errorElement.removeClass(data.settings.validatingCssClass + ' ' + data.settings.successCssClass)
                  .addClass(data.settings.errorCssClass);
            } else {
                $error.empty();
                $errorElement.removeClass(data.settings.validatingCssClass + ' ' + data.settings.errorCssClass + ' ')
                  .addClass(data.settings.successCssClass);
            }
            attribute.value = getValue($form, attribute);
        }

        $form.trigger(events.afterValidateAttribute, [attribute, messages[attribute.id]]);

        return hasError;
    };

    /**
     * Checks if a particular attribute has an error
     * @param $form the form jQuery object
     * @param attribute object the configuration for a particular attribute.
     * @param messages array the validation error messages
     * @return boolean whether there is a validation error for the specified attribute
     ../../../_/default.htm
    var attrHasError = function ($form, attribute, messages) {
        var $input = findInput($form, attribute),
            hasError = false;

        if (!$.isArray(messages[attribute.id])) {
            messages[attribute.id] = [];
        }

        if ($input.length) {
            hasError = messages[attribute.id].length > 0;
        }

        return hasError;
    };

    /**
     * Updates the error summary.
     * @param $form the form jQuery object
     * @param messages array the validation error messages
     ../../../_/default.htm
    var updateSummary = function ($form, messages) {
        var data = $form.data('yiiActiveForm'),
            $summary = $form.find(data.settings.errorSummary),
            $ul = $summary.find('ul').empty();

        if ($summary.length && messages) {
            $.each(data.attributes, function () {
                if ($.isArray(messages[this.id]) && messages[this.id].length) {
                    var error = $('<li/>');
                    if (data.settings.encodeErrorSummary) {
                        error.text(messages[this.id][0]);
                    } else {
                        error.html(messages[this.id][0]);
                    }
                    $ul.append(error);
                }
            });
            $summary.toggle($ul.find('li').length > 0);
        }
    };

    var getValue = function ($form, attribute) {
        var $input = findInput($form, attribute);
        var type = $input.attr('type');
        if (type === 'checkbox' || type === 'radio') {
            var $realInput = $input.filter(':checked');
            if ($realInput.length > 1) {
                var values = [];
                $realInput.each(function(index) {
                    values.push($($realInput.get(index)).val());
                });
                return values;
            }

            if (!$realInput.length) {
                $realInput = $form.find('input[type=hidden][name="' + $input.attr('name') + '"]');
            }

            return $realInput.val();
        } else {
            return $input.val();
        }
    };

    var findInput = function ($form, attribute) {
        var $input = $form.find(attribute.input);
        if ($input.length && $input[0].tagName.toLowerCase() === 'div') {
            // checkbox list or radio list
            return $input.find('input');
        } else {
            return $input;
        }
    };

    var updateAriaInvalid = function ($form, attribute, hasError) {
        if (attribute.updateAriaInvalid) {
            $form.find(attribute.input).attr('aria-invalid', hasError ? 'true' : 'false');
        }
    }
})(window.jQuery);

/**
 * Yii auth choice widget.
 *
 * This is the JavaScript widget used by the yii\authclient\widgets\AuthChoice widget.
 *
 * @link http://www.yiiframework.com/
 * @copyright Copyright (c) 2008 Yii Software LLC
 * @license http://www.yiiframework.com/license/
 * @author Paul Klimov <klimov.paul@gmail.com>
 * @since 2.0
 ../../../_/default.htm
jQuery(function($) {
    $.fn.authchoice = function(options) {
        options = $.extend({
            triggerSelector: 'a.auth-link',
            popup: {
                resizable: 'yes',
                scrollbars: 'no',
                toolbar: 'no',
                menubar: 'no',
                location: 'no',
                directories: 'no',
                status: 'yes',
                width: 450,
                height: 380
            }
        }, options);

        return this.each(function() {
            var $container = $(this);

            $container.find(options.triggerSelector).on('click', function(e) {
                e.preventDefault();

                var authChoicePopup = $container.data('authChoicePopup');

                if (authChoicePopup) {
                    authChoicePopup.close();
                }

                var url = this.href;
                var popupOptions = $.extend({}, options.popup); // clone

                var localPopupWidth = this.getAttribute('data-popup-width');
                if (localPopupWidth) {
                    popupOptions.width = localPopupWidth;
                }
                var localPopupHeight = this.getAttribute('data-popup-height');
                if (localPopupWidth) {
                    popupOptions.height = localPopupHeight;
                }

                popupOptions.left = (window.screen.width - popupOptions.width) ../../../default.htm 2;
                popupOptions.top = (window.screen.height - popupOptions.height) ../../../default.htm 2;

                var popupFeatureParts = [];
                for (var propName in popupOptions) {
                    if (popupOptions.hasOwnProperty(propName)) {
                        popupFeatureParts.push(propName + '=' + popupOptions[propName]);
                    }
                }
                var popupFeature = popupFeatureParts.join(',');

                authChoicePopup = window.open(url, 'yii_auth_choice', popupFeature);
                authChoicePopup.focus();

                $container.data('authChoicePopup', authChoicePopup);
            });
        });
    };
});

(function ($) {
    'use strict';

    $.fn.multipleInput = function (method) {
        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            return methods.init.apply(this, arguments);
        } else {
            $.error('Method ' + method + ' does not exist on jQuery.multipleInput');
            return false;
        }
    };

    var events = {
        /**
         * afterAddRow event is triggered after widget's initialization.
         * The signature of the event handler should be:
         *     function (event)
         * where event is an Event object.
         *
         ../../../_/default.htm
        afterInit: 'afterInit',
        /**
         * afterAddRow event is triggered after successful adding new row.
         * The signature of the event handler should be:
         *     function (event, row)
         * where event is an Event object.
         *
         ../../../_/default.htm
        beforeAddRow: 'beforeAddRow',
        /**
         * afterAddRow event is triggered after successful adding new row.
         * The signature of the event handler should be:
         *     function (event, row)
         * where event is an Event object.
         *
         ../../../_/default.htm
        afterAddRow: 'afterAddRow',
        /**
         * beforeDeleteRow event is triggered before row will be removed.
         * The signature of the event handler should be:
         *     function (event, row)
         * where event is an Event object and row is html container of row for removal
         *
         * If the handler returns a boolean false, it will stop removal the row.
         ../../../_/default.htm
        beforeDeleteRow: 'beforeDeleteRow',

        /**
         * afterAddRow event is triggered after successful removal the row.
         * The signature of the event handler should be:
         *     function (event)
         * where event is an Event object.
         *
         ../../../_/default.htm
        afterDeleteRow: 'afterDeleteRow',

        /**
         * afterDropRow event is triggered after drop the row in sortable mode.
         * The signature of the event handler should be:
         *     function (event, row)
         * where event is an Event object and row is html container of dragged row
         ../../../_/default.htm
        afterDropRow: 'afterDropRow'
    };

    var defaultOptions = {
        /**
         * the ID of widget
         ../../../_/default.htm
        id: null,

        /**
         * the ID of related input in case of using widget for an active field
         ../../../_/default.htm
        inputId: null,

        /**
         * the template of row
         ../../../_/default.htm
        template: null,

        /**
         * array that collect js templates of widgets which uses in the columns
         ../../../_/default.htm
        jsTemplates: [],

        /**
         * array of scripts which need to execute before initialization
         ../../../_/default.htm
        jsInit: [],

        /**
         * how many row are allowed to render
         ../../../_/default.htm
        max: 1,

        /**
         * a minimum number of rows
         ../../../_/default.htm
        min: 1,

        /**
         * active form options of attributes
         ../../../_/default.htm
        attributes: {},

        /**
         * default prefix of a widget's placeholder
         ../../../_/default.htm
        indexPlaceholder: 'multiple_index',

        /**
         * whether need to show general error message or no
         ../../../_/default.htm
        showGeneralError: false,

        /**
         * if need to prepend new row, not append
         ../../../_/default.htm
        prepend: false
    };

    var isActiveFormEnabled = false;

    var methods = {
        init: function (options) {
            if (typeof options !== 'object') {
                console.error('Options must be an object');
                return;
            }

            var settings = $.extend(true, {}, defaultOptions, options || {}),
                $wrapper = $('#' + settings.id),
                form = $wrapper.closest('form'),
                inputId = settings.inputId;

            for (i in settings.jsInit) {
                window.eval(settings.jsInit[i]);
            }

            $wrapper.data('multipleInput', {
                settings: settings,
                currentIndex: 0
            });

            $wrapper.on('click.multipleInput', '.js-input-remove', function (e) {
                e.stopPropagation();
                removeInput($(this));
            });

            $wrapper.on('click.multipleInput', '.js-input-plus', function (e) {
                e.stopPropagation();
                addInput($(this));
            });

            $wrapper.on('click.multipleInput', '.js-input-clone', function (e) {
                e.stopPropagation();
                addInput($(this), getRowValues($(this)));
            });

            var i = 0,
                event = $.Event(events.afterInit);

            var intervalID = setInterval(function () {
                if (typeof form.data('yiiActiveForm') === 'object') {
                    var attribute = form.yiiActiveForm('find', inputId),
                        defaultAttributeOptions = {
                            enableAjaxValidation: false,
                            validateOnBlur: false,
                            validateOnChange: false,
                            validateOnType: false,
                            validationDelay: 500
                        };

                    // fetch default attribute options from active from attribute
                    if (typeof attribute === 'object') {
                        $.each(attribute, function (key, value) {
                            if (['id', 'input', 'container'].indexOf(key) === -1) {
                                defaultAttributeOptions[key] = value;
                            }
                        });

                        if (!settings.showGeneralError) {
                            form.yiiActiveForm('remove', inputId);
                        }
                    }

                    // append default options to option from settings
                    $.each(settings.attributes, function (attribute, attributeOptions) {
                        attributeOptions = $.extend({}, defaultAttributeOptions, attributeOptions);
                        settings.attributes[attribute] = attributeOptions;
                    });

                    $wrapper.data('multipleInput').settings = settings;

                    $wrapper.find('.multiple-input-list').find('input, select, textarea').each(function () {
                        addAttribute($(this));
                    });

                    $wrapper.data('multipleInput').currentIndex = getCurrentIndex($wrapper);
                    isActiveFormEnabled = true;

                    clearInterval(intervalID);
                    $wrapper.trigger(event);
                } else {
                    i++;
                }

                // wait for initialization of ActiveForm a second
                // If after a second system could not detect ActiveForm it means
                // that widget is used without ActiveForm and we should just complete initialization of the widget
                if (form.length === 0 || i > 10) {
                    $wrapper.data('multipleInput').currentIndex = getCurrentIndex($wrapper);
                    isActiveFormEnabled = false;

                    clearInterval(intervalID);
                    $wrapper.trigger(event);
                }
            }, 100);
        },

        add: function (values) {
            addInput($(this), values);
        },

        remove: function (index) {
            var row = null;
            if (index !== undefined) {
                row = $(this).find('.js-input-remove:eq(' + index + ')');
            } else {
                row = $(this).find('.js-input-remove').last();
            }

            removeInput(row);
        },

        clear: function () {
            $(this).find('.js-input-remove').each(function () {
                removeInput($(this));
            });
        },

        option: function(name, value) {
            value = value || null;

            var data = $(this).data('multipleInput'),
                settings = data.settings;
            if (value === null) {
                if (!settings.hasOwnProperty(name)) {
                    throw new Error('Option "' + name + '" does not exist');
                }
                return settings[name];
            } else if (settings.hasOwnProperty(name)) {
                settings[name] = value;
                data.settings = settings;
                $(this).data('multipleInput', data);
            }
        }
    };

    var addInput = function (btn, values) {
        var $wrapper  = $(btn).closest('.multiple-input').first(),
            data      = $wrapper.data('multipleInput'),
            settings  = data.settings,
            template  = settings.template,
            inputList = $wrapper.children('.multiple-input-list').first();

        if (settings.max !== null && getCurrentIndex($wrapper) >= settings.max) {
            return;
        }

        template = replaceAll('{' + settings.indexPlaceholder + '}', data.currentIndex, template);
        var $addedInput = $(template);
        var currentIndex = data.currentIndex;

        var beforeAddEvent = $.Event(events.beforeAddRow);
        $wrapper.trigger(beforeAddEvent, [$addedInput, currentIndex]);

        if (beforeAddEvent.result === false) {
            return;
        }


        if (settings.prepend) {
            $addedInput.hide().prependTo(inputList).fadeIn(300);
        } else {
            $addedInput.hide().appendTo(inputList).fadeIn(300);
        }

        if (values instanceof Object) {
            var tmp = [];
            for (var key in values) {
                if (values.hasOwnProperty(key)) {
                    tmp.push(values[key]);
                }
            }

            values = tmp;
        }

        var jsTemplate;

        for (var i in settings.jsTemplates) {
            jsTemplate = settings.jsTemplates[i];
            jsTemplate = replaceAll('{' + settings.indexPlaceholder + '}', data.currentIndex, jsTemplate);
            jsTemplate = replaceAll('%7B' + settings.indexPlaceholder + '%7D', data.currentIndex, jsTemplate);

            window.eval(jsTemplate);
        }

        var index = 0;

        $(template).find('input, select, textarea').each(function (k, v) {
            var ele = $(v),
                tag = v.tagName,
                id  = getInputId(ele),
                obj = $('#' + id);

            if (values) {
                var val = values[index];

                if (tag === 'INPUT' || tag === 'TEXTAREA') {
                    obj.val(val);
                } else if (tag === 'SELECT') {
                    if (val && val.indexOf('option') !== -1) {
                        obj.append(val);
                    } else {
                        var option = obj.find('option[value="' + val + '"]');
                        if (option.length) {
                            obj.val(val);
                        }
                    }
                }
            }

            if (isActiveFormEnabled) {
                addAttribute(ele);
            }

            index++;
        });

        $wrapper.data('multipleInput').currentIndex++;

        var afterAddEvent = $.Event(events.afterAddRow);
        $wrapper.trigger(afterAddEvent, [$addedInput, currentIndex]);
    };

    var removeInput = function ($btn) {
        var $wrapper  = $btn.closest('.multiple-input').first(),
            $toDelete = $btn.closest('.multiple-input-list__item'),
            data      = $wrapper.data('multipleInput'),
            settings  = data.settings;

        var currentIndex = getCurrentIndex($wrapper);
        if (currentIndex > settings.min) {
            var event = $.Event(events.beforeDeleteRow);
            $wrapper.trigger(event, [$toDelete, currentIndex]);

            if (event.result === false) {
                return;
            }

            if (isActiveFormEnabled) {
                $toDelete.find('input, select, textarea').each(function (index, ele) {
                    removeAttribute($(ele));
                });
            }

            $toDelete.fadeOut(300, function () {
                $(this).remove();

                event = $.Event(events.afterDeleteRow);
                $wrapper.trigger(event, [$toDelete, currentIndex]);
            });
        }
    };

    /**
     * Add an attribute to ActiveForm.
     *
     * @param input
     ../../../_/default.htm
    var addAttribute = function (input) {
        var id = getInputId(input);

        // skip if we could not get an ID of input
        if (id === null) {
            return;
        }

        var ele = $('#' + id),
            wrapper = ele.closest('.multiple-input').first(),
            form = ele.closest('form');


        // do not add attribute which are not the part of widget
        if (wrapper.length === 0) {
            return;
        }

        // check that input has been already added to the activeForm
        if (typeof form.yiiActiveForm('find', id) !== 'undefined') {
            return;
        }

        var data = wrapper.data('multipleInput'),
            attributeOptions = {};

        // try to find options for embedded attribute at first.
        // For example the id of new input is example-1-field-0.
        // We remove last index and check whether attribute with such id exists or not.
        var bareId = id.replace(/-\d+-([^\d]+)$/, '-$1');
        if (data.settings.attributes.hasOwnProperty(bareId)) {
            attributeOptions = data.settings.attributes[bareId];
        } else {
            // fallback in case of using flatten widget - just remove all digital indexes
            // and check whether attribute exists or not.
            bareId = replaceAll(/-\d-/, '-', bareId);
            bareId = replaceAll(/-\d/, '', bareId);
            if (data.settings.attributes.hasOwnProperty(bareId)) {
                attributeOptions = data.settings.attributes[bareId];
            }
        }

        form.yiiActiveForm('add', $.extend({}, attributeOptions, {
            'id': id,
            'input': '#' + id,
            'container': '.field-' + id
        }));
    };

    /**
     * Removes an attribute from ActiveForm.
     ../../../_/default.htm
    var removeAttribute = function (ele) {
        var id = getInputId(ele);

        if (id === null) {
            return;
        }

        var form = $('#' + id).closest('form');

        if (form.length !== 0) {
            form.yiiActiveForm('remove', id);
        }
    };

    var getInputId = function ($input) {
        var id = $input.attr('id');

        if (typeof id === 'undefined') {
            id = $input.data('id');
        }

        if (typeof id === 'undefined') {
            return null;
        }

        return id;
    };

    var getCurrentIndex = function($wrapper) {
        return $wrapper
            .find('.multiple-input-list .multiple-input-list__item')
            .filter(function(){
                return $(this).parents('.multiple-input').first().attr('id') === $wrapper.attr('id');
            }).length;
    };

    var getRowValues = function (element) {
        var values = {};
        element.closest('tr').find('td').each(function (index, value) {
            $(value).find('input, select, textarea').each(function (k, v) {
                var ele = $(v),
                    id = getInputId(ele),
                    obj = $('#' + id);
                values[id] = obj.val();
            });
        });
        return values;
    };

    var replaceAll = function (search, replace, subject) {
        if (!(subject instanceof String) && typeof subject !== 'string') {
            console.warn('Call replaceAll for non-string value: ' + subject);
            return subject;
        }

        return subject.split(search).join(replace);
    };
})(window.jQuery);

/*!
 * 
 *             SimpleBar.js - v2.4.3
 *             Scrollbars, simpler.
 *             https://grsmto.github.io/simplebar/
 *             
 *             Made by Adrien Grsmto from a fork by Jonathan Nicol
 *             Under MIT License
 *         
 ../../../_/default.htm
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.SimpleBar=e():t.SimpleBar=e()}(this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var i=n[r]={exports:{},id:r,loaded:!1};return t[r].call(i.exports,i,i.exports,e),i.loaded=!0,i.exports}var n={};return e.m=t,e.c=n,e.p="",e(0)}([function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{"default":t}}Object.defineProperty(e,"__esModule",{value:!0});var i=n(32),o=r(i),s=n(29),c=r(s),a=n(30),u=r(a),l=n(33),f=r(l),h=n(34),d=r(h),p=n(72),v=r(p),b=n(70),y=r(b),m=n(71),g=r(m);n(69);var E=function(){function t(e,n){(0,f.default)(this,t),this.el=e,this.flashTimeout,this.contentEl,this.scrollContentEl,this.dragOffset={x:0,y:0},this.isVisible={x:!0,y:!0},this.scrollOffsetAttr={x:"scrollLeft",y:"scrollTop"},this.sizeAttr={x:"offsetWidth",y:"offsetHeight"},this.scrollSizeAttr={x:"scrollWidth",y:"scrollHeight"},this.offsetAttr={x:"left",y:"top"},this.globalObserver,this.mutationObserver,this.resizeObserver,this.currentAxis,this.options=(0,u.default)({},t.defaultOptions,n),this.classNames=this.options.classNames,this.scrollbarWidth=(0,v.default)(),this.offsetSize=20,this.flashScrollbar=this.flashScrollbar.bind(this),this.onDragY=this.onDragY.bind(this),this.onDragX=this.onDragX.bind(this),this.onScrollY=this.onScrollY.bind(this),this.onScrollX=this.onScrollX.bind(this),this.drag=this.drag.bind(this),this.onEndDrag=this.onEndDrag.bind(this),this.onMouseEnter=this.onMouseEnter.bind(this),this.recalculate=(0,y.default)(this.recalculate,100,{leading:!0,trailing:!1}),this.init()}return(0,d.default)(t,[{key:"init",value:function(){this.el.SimpleBar=this,this.initDOM(),this.scrollbarX=this.trackX.querySelector("."+this.classNames.scrollbar),this.scrollbarY=this.trackY.querySelector("."+this.classNames.scrollbar),this.scrollContentEl.style.paddingRight=(this.scrollbarWidth||this.offsetSize)+"px",this.scrollContentEl.style.marginBottom="-"+(2*this.scrollbarWidth||this.offsetSize)+"px",this.contentEl.style.paddingBottom=(this.scrollbarWidth||this.offsetSize)+"px",0!==this.scrollbarWidth&&(this.contentEl.style.marginRight="-"+this.scrollbarWidth+"px"),this.recalculate(),this.initListeners()}},{key:"initDOM",value:function(){var t=this;if((0,c.default)(this.el.children).find(function(e){return e.classList.contains(t.classNames.scrollContent)}))this.trackX=this.el.querySelector("."+this.classNames.track+".horizontal"),this.trackY=this.el.querySelector("."+this.classNames.track+".vertical"),this.scrollContentEl=this.el.querySelector("."+this.classNames.scrollContent),this.contentEl=this.el.querySelector("."+this.classNames.content);else{for(this.scrollContentEl=document.createElement("div"),this.contentEl=document.createElement("div"),this.scrollContentEl.classList.add(this.classNames.scrollContent),this.contentEl.classList.add(this.classNames.content);this.el.firstChild;)this.contentEl.appendChild(this.el.firstChild);this.scrollContentEl.appendChild(this.contentEl),this.el.appendChild(this.scrollContentEl)}if(!this.trackX||!this.trackY){var e=document.createElement("div"),n=document.createElement("div");e.classList.add(this.classNames.track),n.classList.add(this.classNames.scrollbar),e.appendChild(n),this.trackX=e.cloneNode(!0),this.trackX.classList.add("horizontal"),this.trackY=e.cloneNode(!0),this.trackY.classList.add("vertical"),this.el.insertBefore(this.trackX,this.el.firstChild),this.el.insertBefore(this.trackY,this.el.firstChild)}this.el.setAttribute("data-simplebar","init")}},{key:"initListeners",value:function(){var t=this;this.options.autoHide&&this.el.addEventListener("mouseenter",this.onMouseEnter),this.scrollbarY.addEventListener("mousedown",this.onDragY),this.scrollbarX.addEventListener("mousedown",this.onDragX),this.scrollContentEl.addEventListener("scroll",this.onScrollY),this.contentEl.addEventListener("scroll",this.onScrollX),"undefined"!=typeof MutationObserver&&(this.mutationObserver=new MutationObserver(function(e){e.forEach(function(e){(t.isChildNode(e.target)||e.addedNodes.length)&&t.recalculate()})}),this.mutationObserver.observe(this.el,{attributes:!0,childList:!0,characterData:!0,subtree:!0})),this.resizeObserver=new g.default(this.recalculate.bind(this)),this.resizeObserver.observe(this.el)}},{key:"removeListeners",value:function(){this.options.autoHide&&this.el.removeEventListener("mouseenter",this.onMouseEnter),this.scrollbarX.removeEventListener("mousedown",this.onDragX),this.scrollbarY.removeEventListener("mousedown",this.onDragY),this.scrollContentEl.removeEventListener("scroll",this.onScrollY),this.contentEl.removeEventListener("scroll",this.onScrollX),this.mutationObserver.disconnect(),this.resizeObserver.disconnect()}},{key:"onDragX",value:function(t){this.onDrag(t,"x")}},{key:"onDragY",value:function(t){this.onDrag(t,"y")}},{key:"onDrag",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"y";t.preventDefault();var n="y"===e?this.scrollbarY:this.scrollbarX,r="y"===e?t.pageY:t.pageX;this.dragOffset[e]=r-n.getBoundingClientRect()[this.offsetAttr[e]],this.currentAxis=e,document.addEventListener("mousemove",this.drag),document.addEventListener("mouseup",this.onEndDrag)}},{key:"drag",value:function(t){var e=void 0,n=void 0,r=void 0;t.preventDefault(),"y"===this.currentAxis?(e=t.pageY,n=this.trackY,r=this.scrollContentEl):(e=t.pageX,n=this.trackX,r=this.contentEl);var i=e-n.getBoundingClientRect()[this.offsetAttr[this.currentAxis]]-this.dragOffset[this.currentAxis],o=i/n[this.sizeAttr[this.currentAxis]],s=o*this.contentEl[this.scrollSizeAttr[this.currentAxis]];r[this.scrollOffsetAttr[this.currentAxis]]=s}},{key:"onEndDrag",value:function(){document.removeEventListener("mousemove",this.drag),document.removeEventListener("mouseup",this.onEndDrag)}},{key:"resizeScrollbar",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"y",e=void 0,n=void 0,r=void 0,i=void 0,o=void 0;"x"===t?(e=this.trackX,n=this.scrollbarX,r=this.contentEl[this.scrollOffsetAttr[t]],i=this.contentSizeX,o=this.scrollbarXSize):(e=this.trackY,n=this.scrollbarY,r=this.scrollContentEl[this.scrollOffsetAttr[t]],i=this.contentSizeY,o=this.scrollbarYSize);var s=o/i,c=r/(i-o),a=Math.max(~~(s*(o-2))-2,this.options.scrollbarMinSize),u=~~((o-4-a)*c+2);this.isVisible[t]=o<i,this.isVisible[t]?(e.style.visibility="visible","x"===t?(n.style.left=u+"px",n.style.width=a+"px"):(n.style.top=u+"px",n.style.height=a+"px")):e.style.visibility="hidden"}},{key:"onScrollX",value:function(){this.flashScrollbar("x")}},{key:"onScrollY",value:function(){this.flashScrollbar("y")}},{key:"onMouseEnter",value:function(){this.flashScrollbar("x"),this.flashScrollbar("y")}},{key:"flashScrollbar",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"y";this.resizeScrollbar(t),this.showScrollbar(t)}},{key:"showScrollbar",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"y";this.isVisible[t]&&("x"===t?this.scrollbarX.classList.add("visible"):this.scrollbarY.classList.add("visible"),this.options.autoHide&&("number"==typeof this.flashTimeout&&window.clearTimeout(this.flashTimeout),this.flashTimeout=window.setTimeout(this.hideScrollbar.bind(this),1e3)))}},{key:"hideScrollbar",value:function(){this.scrollbarX.classList.remove("visible"),this.scrollbarY.classList.remove("visible"),"number"==typeof this.flashTimeout&&window.clearTimeout(this.flashTimeout)}},{key:"recalculate",value:function(){this.contentSizeX=this.contentEl[this.scrollSizeAttr.x],this.contentSizeY=this.contentEl[this.scrollSizeAttr.y]-(this.scrollbarWidth||this.offsetSize),this.scrollbarXSize=this.trackX[this.sizeAttr.x],this.scrollbarYSize=this.trackY[this.sizeAttr.y],this.resizeScrollbar("x"),this.resizeScrollbar("y"),this.options.autoHide||(this.showScrollbar("x"),this.showScrollbar("y"))}},{key:"getScrollElement",value:function(){return this.scrollContentEl}},{key:"getContentElement",value:function(){return this.contentEl}},{key:"unMount",value:function(){this.removeListeners(),this.el.SimpleBar=null}},{key:"isChildNode",value:function(t){return null!==t&&(t===this.el||this.isChildNode(t.parentNode))}}],[{key:"initHtmlApi",value:function(){this.initDOMLoadedElements=this.initDOMLoadedElements.bind(this),"undefined"!=typeof MutationObserver&&(this.globalObserver=new MutationObserver(function(e){e.forEach(function(e){(0,c.default)(e.addedNodes).forEach(function(e){1===e.nodeType&&(e.hasAttribute("data-simplebar")?!e.SimpleBar&&new t(e,t.getElOptions(e)):(0,c.default)(e.querySelectorAll("[data-simplebar]")).forEach(function(e){!e.SimpleBar&&new t(e,t.getElOptions(e))}))}),(0,c.default)(e.removedNodes).forEach(function(t){1===t.nodeType&&(t.hasAttribute("data-simplebar")?t.SimpleBar&&t.SimpleBar.unMount():(0,c.default)(t.querySelectorAll("[data-simplebar]")).forEach(function(t){t.SimpleBar&&t.SimpleBar.unMount()}))})})}),this.globalObserver.observe(document,{childList:!0,subtree:!0})),"complete"===document.readyState||"loading"!==document.readyState&&!document.documentElement.doScroll?window.setTimeout(this.initDOMLoadedElements.bind(this)):(document.addEventListener("DOMContentLoaded",this.initDOMLoadedElements),window.addEventListener("load",this.initDOMLoadedElements))}},{key:"getElOptions",value:function(e){var n=(0,o.default)(t.htmlAttributes).reduce(function(n,r){var i=t.htmlAttributes[r];return e.hasAttribute(i)&&(n[r]=JSON.parse(e.getAttribute(i)||!0)),n},{});return n}},{key:"removeObserver",value:function(){this.globalObserver.disconnect()}},{key:"initDOMLoadedElements",value:function(){document.removeEventListener("DOMContentLoaded",this.initDOMLoadedElements),window.removeEventListener("load",this.initDOMLoadedElements),(0,c.default)(document.querySelectorAll("[data-simplebar]")).forEach(function(e){e.SimpleBar||new t(e,t.getElOptions(e))})}},{key:"defaultOptions",get:function(){return{autoHide:!0,classNames:{content:"simplebar-content",scrollContent:"simplebar-scroll-content",scrollbar:"simplebar-scrollbar",track:"simplebar-track"},scrollbarMinSize:25}}},{key:"htmlAttributes",get:function(){return{autoHide:"data-simplebar-autohide",scrollbarMinSize:"data-simplebar-scrollbar-min-size"}}}]),t}();e.default=E,E.initHtmlApi(),t.exports=e.default},function(t,e){var n=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=n)},function(t,e,n){var r=n(25)("wks"),i=n(28),o=n(5).Symbol,s="function"==typeof o,c=t.exports=function(t){return r[t]||(r[t]=s&&o[t]||(s?o:i)("Symbol."+t))};c.store=r},function(t,e,n){t.exports=!n(8)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,e,n){var r=n(5),i=n(1),o=n(20),s=n(10),c="prototype",a=function(t,e,n){var u,l,f,h=t&a.F,d=t&a.G,p=t&a.S,v=t&a.P,b=t&a.B,y=t&a.W,m=d?i:i[e]||(i[e]={}),g=m[c],E=d?r:p?r[e]:(r[e]||{})[c];d&&(n=e);for(u in n)l=!h&&E&&void 0!==E[u],l&&u in m||(f=l?E[u]:n[u],m[u]=d&&"function"!=typeof E[u]?n[u]:b&&l?o(f,r):y&&E[u]==f?function(t){var e=function(e,n,r){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(e);case 2:return new t(e,n)}return new t(e,n,r)}return t.apply(this,arguments)};return e[c]=t[c],e}(f):v&&"function"==typeof f?o(Function.call,f):f,v&&((m.virtual||(m.virtual={}))[u]=f,t&a.R&&g&&!g[u]&&s(g,u,f)))};a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,e){var n=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=n)},function(t,e,n){var r=n(7),i=n(44),o=n(62),s=Object.defineProperty;e.f=n(3)?Object.defineProperty:function(t,e,n){if(r(t),e=o(e,!0),r(n),i)try{return s(t,e,n)}catch(c){}if("get"in n||"set"in n)throw TypeError("Accessors not supported!");return"value"in n&&(t[e]=n.value),t}},function(t,e,n){var r=n(13);t.exports=function(t){if(!r(t))throw TypeError(t+" is not an object!");return t}},function(t,e){t.exports=function(t){try{return!!t()}catch(e){return!0}}},function(t,e){var n={}.hasOwnProperty;t.exports=function(t,e){return n.call(t,e)}},function(t,e,n){var r=n(6),i=n(16);t.exports=n(3)?function(t,e,n){return r.f(t,e,i(1,n))}:function(t,e,n){return t[e]=n,t}},function(t,e,n){var r=n(12);t.exports=function(t){return Object(r(t))}},function(t,e){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,e){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,e){t.exports={}},function(t,e,n){var r=n(56),i=n(22);t.exports=Object.keys||function(t){return r(t,i)}},function(t,e){t.exports=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}}},function(t,e,n){var r=n(25)("keys"),i=n(28);t.exports=function(t){return r[t]||(r[t]=i(t))}},function(t,e){var n=Math.ceil,r=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?r:n)(t)}},function(t,e){var n={}.toString;t.exports=function(t){return n.call(t).slice(8,-1)}},function(t,e,n){var r=n(39);t.exports=function(t,e,n){if(r(t),void 0===e)return t;switch(n){case 1:return function(n){return t.call(e,n)};case 2:return function(n,r){return t.call(e,n,r)};case 3:return function(n,r,i){return t.call(e,n,r,i)}}return function(){return t.apply(e,arguments)}}},function(t,e,n){var r=n(13),i=n(5).document,o=r(i)&&r(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,e){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,e,n){var r=n(19);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==r(t)?t.split(""):Object(t)}},function(t,e,n){var r=n(6).f,i=n(9),o=n(2)("toStringTag");t.exports=function(t,e,n){t&&!i(t=n?t:t.prototype,o)&&r(t,o,{configurable:!0,value:e})}},function(t,e,n){var r=n(5),i="__core-js_shared__",o=r[i]||(r[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,e,n){var r=n(23),i=n(12);t.exports=function(t){return r(i(t))}},function(t,e,n){var r=n(18),i=Math.min;t.exports=function(t){return t>0?i(r(t),9007199254740991):0}},function(t,e){var n=0,r=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++n+r).toString(36))}},function(t,e,n){t.exports={"default":n(35),__esModule:!0}},function(t,e,n){t.exports={"default":n(36),__esModule:!0}},function(t,e,n){t.exports={"default":n(37),__esModule:!0}},function(t,e,n){t.exports={"default":n(38),__esModule:!0}},function(t,e){"use strict";e.__esModule=!0,e.default=function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{"default":t}}e.__esModule=!0;var i=n(31),o=r(i);e.default=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),(0,o.default)(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}()},function(t,e,n){n(68),n(64),t.exports=n(1).Array.from},function(t,e,n){n(65),t.exports=n(1).Object.assign},function(t,e,n){n(66);var r=n(1).Object;t.exports=function(t,e,n){return r.defineProperty(t,e,n)}},function(t,e,n){n(67),t.exports=n(1).Object.keys},function(t,e){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,e,n){var r=n(26),i=n(27),o=n(61);t.exports=function(t){return function(e,n,s){var c,a=r(e),u=i(a.length),l=o(s,u);if(t&&n!=n){for(;u>l;)if(c=a[l++],c!=c)return!0}else for(;u>l;l++)if((t||l in a)&&a[l]===n)return t||l||0;return!t&&-1}}},function(t,e,n){var r=n(19),i=n(2)("toStringTag"),o="Arguments"==r(function(){return arguments}()),s=function(t,e){try{return t[e]}catch(n){}};t.exports=function(t){var e,n,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(n=s(e=Object(t),i))?n:o?r(e):"Object"==(c=r(e))&&"function"==typeof e.callee?"Arguments":c}},function(t,e,n){"use strict";var r=n(6),i=n(16);t.exports=function(t,e,n){e in t?r.f(t,e,i(0,n)):t[e]=n}},function(t,e,n){t.exports=n(5).document&&document.documentElement},function(t,e,n){t.exports=!n(3)&&!n(8)(function(){return 7!=Object.defineProperty(n(21)("div"),"a",{get:function(){return 7}}).a})},function(t,e,n){var r=n(14),i=n(2)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(r.Array===t||o[i]===t)}},function(t,e,n){var r=n(7);t.exports=function(t,e,n,i){try{return i?e(r(n)[0],n[1]):e(n)}catch(o){var s=t.return;throw void 0!==s&&r(s.call(t)),o}}},function(t,e,n){"use strict";var r=n(52),i=n(16),o=n(24),s={};n(10)(s,n(2)("iterator"),function(){return this}),t.exports=function(t,e,n){t.prototype=r(s,{next:i(1,n)}),o(t,e+" Iterator")}},function(t,e,n){"use strict";var r=n(50),i=n(4),o=n(59),s=n(10),c=n(9),a=n(14),u=n(47),l=n(24),f=n(55),h=n(2)("iterator"),d=!([].keys&&"next"in[].keys()),p="@@iterator",v="keys",b="values",y=function(){return this};t.exports=function(t,e,n,m,g,E,_){u(n,e,m);var x,O,w,S=function(t){if(!d&&t in j)return j[t];switch(t){case v:return function(){return new n(this,t)};case b:return function(){return new n(this,t)}}return function(){return new n(this,t)}},k=e+" Iterator",M=g==b,A=!1,j=t.prototype,L=j[h]||j[p]||g&&j[g],C=L||S(g),T=g?M?S("entries"):C:void 0,z="Array"==e?j.entries||L:L;if(z&&(w=f(z.call(new t)),w!==Object.prototype&&(l(w,k,!0),r||c(w,h)||s(w,h,y))),M&&L&&L.name!==b&&(A=!0,C=function(){return L.call(this)}),r&&!_||!d&&!A&&j[h]||s(j,h,C),a[e]=C,a[k]=y,g)if(x={values:M?C:S(b),keys:E?C:S(v),entries:T},_)for(O in x)O in j||o(j,O,x[O]);else i(i.P+i.F*(d||A),e,x);return x}},function(t,e,n){var r=n(2)("iterator"),i=!1;try{var o=[7][r]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(s){}t.exports=function(t,e){if(!e&&!i)return!1;var n=!1;try{var o=[7],s=o[r]();s.next=function(){return{done:n=!0}},o[r]=function(){return s},t(o)}catch(c){}return n}},function(t,e){t.exports=!0},function(t,e,n){"use strict";var r=n(15),i=n(54),o=n(57),s=n(11),c=n(23),a=Object.assign;t.exports=!a||n(8)(function(){var t={},e={},n=Symbol(),r="abcdefghijklmnopqrst";return t[n]=7,r.split("").forEach(function(t){e[t]=t}),7!=a({},t)[n]||Object.keys(a({},e)).join("")!=r})?function(t,e){for(var n=s(t),a=arguments.length,u=1,l=i.f,f=o.f;a>u;)for(var h,d=c(arguments[u++]),p=l?r(d).concat(l(d)):r(d),v=p.length,b=0;v>b;)f.call(d,h=p[b++])&&(n[h]=d[h]);return n}:a},function(t,e,n){var r=n(7),i=n(53),o=n(22),s=n(17)("IE_PROTO"),c=function(){},a="prototype",u=function(){var t,e=n(21)("iframe"),r=o.length,i="<",s=">";for(e.style.display="none",n(43).appendChild(e),e.src="javascript:",t=e.contentWindow.document,t.open(),t.write(i+"script"+s+"document.F=Object"+i+"/script"+s),t.close(),u=t.F;r--;)delete u[a][o[r]];return u()};t.exports=Object.create||function(t,e){var n;return null!==t?(c[a]=r(t),n=new c,c[a]=null,n[s]=t):n=u(),void 0===e?n:i(n,e)}},function(t,e,n){var r=n(6),i=n(7),o=n(15);t.exports=n(3)?Object.defineProperties:function(t,e){i(t);for(var n,s=o(e),c=s.length,a=0;c>a;)r.f(t,n=s[a++],e[n]);return t}},function(t,e){e.f=Object.getOwnPropertySymbols},function(t,e,n){var r=n(9),i=n(11),o=n(17)("IE_PROTO"),s=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),r(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?s:null}},function(t,e,n){var r=n(9),i=n(26),o=n(40)(!1),s=n(17)("IE_PROTO");t.exports=function(t,e){var n,c=i(t),a=0,u=[];for(n in c)n!=s&&r(c,n)&&u.push(n);for(;e.length>a;)r(c,n=e[a++])&&(~o(u,n)||u.push(n));return u}},function(t,e){e.f={}.propertyIsEnumerable},function(t,e,n){var r=n(4),i=n(1),o=n(8);t.exports=function(t,e){var n=(i.Object||{})[t]||Object[t],s={};s[t]=e(n),r(r.S+r.F*o(function(){n(1)}),"Object",s)}},function(t,e,n){t.exports=n(10)},function(t,e,n){var r=n(18),i=n(12);t.exports=function(t){return function(e,n){var o,s,c=String(i(e)),a=r(n),u=c.length;return a<0||a>=u?t?"":void 0:(o=c.charCodeAt(a),o<55296||o>56319||a+1===u||(s=c.charCodeAt(a+1))<56320||s>57343?t?c.charAt(a):o:t?c.slice(a,a+2):(o-55296<<10)+(s-56320)+65536)}}},function(t,e,n){var r=n(18),i=Math.max,o=Math.min;t.exports=function(t,e){return t=r(t),t<0?i(t+e,0):o(t,e)}},function(t,e,n){var r=n(13);t.exports=function(t,e){if(!r(t))return t;var n,i;if(e&&"function"==typeof(n=t.toString)&&!r(i=n.call(t)))return i;if("function"==typeof(n=t.valueOf)&&!r(i=n.call(t)))return i;if(!e&&"function"==typeof(n=t.toString)&&!r(i=n.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,e,n){var r=n(41),i=n(2)("iterator"),o=n(14);t.exports=n(1).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[r(t)]}},function(t,e,n){"use strict";var r=n(20),i=n(4),o=n(11),s=n(46),c=n(45),a=n(27),u=n(42),l=n(63);i(i.S+i.F*!n(49)(function(t){Array.from(t)}),"Array",{from:function(t){var e,n,i,f,h=o(t),d="function"==typeof this?this:Array,p=arguments.length,v=p>1?arguments[1]:void 0,b=void 0!==v,y=0,m=l(h);if(b&&(v=r(v,p>2?arguments[2]:void 0,2)),void 0==m||d==Array&&c(m))for(e=a(h.length),n=new d(e);e>y;y++)u(n,y,b?v(h[y],y):h[y]);else for(f=m.call(h),n=new d;!(i=f.next()).done;y++)u(n,y,b?s(f,v,[i.value,y],!0):i.value);return n.length=y,n}})},function(t,e,n){var r=n(4);r(r.S+r.F,"Object",{assign:n(51)})},function(t,e,n){var r=n(4);r(r.S+r.F*!n(3),"Object",{defineProperty:n(6).f})},function(t,e,n){var r=n(11),i=n(15);n(58)("keys",function(){return function(t){return i(r(t))}})},function(t,e,n){"use strict";var r=n(60)(!0);n(48)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,e=this._t,n=this._i;return n>=e.length?{value:void 0,done:!0}:(t=r(e,n),this._i+=t.length,{value:t,done:!1})})},function(t,e){},function(t,e){(function(e){function n(t,e,n){function i(e){var n=v,r=b;return v=b=void 0,w=e,m=t.apply(r,n)}function o(t){return w=t,g=setTimeout(l,e),S?i(t):m}function a(t){var n=t-O,r=t-w,i=e-n;return k?_(i,y-r):i}function u(t){var n=t-O,r=t-w;return void 0===O||n>=e||n<0||k&&r>=y}function l(){var t=x();return u(t)?f(t):void(g=setTimeout(l,a(t)))}function f(t){return g=void 0,M&&v?i(t):(v=b=void 0,m)}function h(){void 0!==g&&clearTimeout(g),w=0,v=O=b=g=void 0}function d(){return void 0===g?m:f(x())}function p(){var t=x(),n=u(t);if(v=arguments,b=this,O=t,n){if(void 0===g)return o(O);if(k)return g=setTimeout(l,e),i(O)}return void 0===g&&(g=setTimeout(l,e)),m}var v,b,y,m,g,O,w=0,S=!1,k=!1,M=!0;if("function"!=typeof t)throw new TypeError(c);return e=s(e)||0,r(n)&&(S=!!n.leading,k="maxWait"in n,y=k?E(s(n.maxWait)||0,e):y,M="trailing"in n?!!n.trailing:M),p.cancel=h,p.flush=d,p}function r(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function i(t){return!!t&&"object"==typeof t}function o(t){return"symbol"==typeof t||i(t)&&g.call(t)==u}function s(t){if("number"==typeof t)return t;if(o(t))return a;if(r(t)){var e="function"==typeof t.valueOf?t.valueOf():t;t=r(e)?e+"":e}if("string"!=typeof t)return 0===t?t:+t;t=t.replace(l,"");var n=h.test(t);return n||d.test(t)?p(t.slice(2),n?2:8):f.test(t)?a:+t}var c="Expected a function",a=NaN,u="[object Symbol]",l=/^\s+|\s+$/g,f=/^[-+]0x[0-9a-f]+$/i,h=/^0b[01]+$/i,d=/^0o[0-7]+$/i,p=parseInt,v="object"==typeof e&&e&&e.Object===Object&&e,b="object"==typeof self&&self&&self.Object===Object&&self,y=v||b||Function("return this")(),m=Object.prototype,g=m.toString,E=Math.max,_=Math.min,x=function(){return y.Date.now()};t.exports=n}).call(e,function(){return this}())},function(t,e,n){(function(e){!function(e,n){t.exports=n()}(this,function(){"use strict";function t(t){return parseFloat(t)||0}function n(e){var n=Array.prototype.slice.call(arguments,1);return n.reduce(function(n,r){var i=e["border-"+r+"-width"];return n+t(i)},0)}function r(e){for(var n=["top","right","bottom","left"],r={},i=0,o=n;i<o.length;i+=1){var s=o[i],c=e["padding-"+s];r[s]=t(c)}return r}function i(t){var e=t.getBBox();return u(0,0,e.width,e.height)}function o(e){var i=e.clientWidth,o=e.clientHeight;if(!i&&!o)return x;var c=getComputedStyle(e),a=r(c),l=a.left+a.right,f=a.top+a.bottom,h=t(c.width),d=t(c.height);if("border-box"===c.boxSizing&&(Math.round(h+l)!==i&&(h-=n(c,"left","right")+l),Math.round(d+f)!==o&&(d-=n(c,"top","bottom")+f)),!s(e)){var p=Math.round(h+l)-i,v=Math.round(d+f)-o;1!==Math.abs(p)&&(h-=p),1!==Math.abs(v)&&(d-=v)}return u(a.left,a.top,h,d)}function s(t){return t===document.documentElement}function c(t){return h?O(t)?i(t):o(t):x}function a(t){var e=t.x,n=t.y,r=t.width,i=t.height,o="function"==typeof DOMRectReadOnly?DOMRectReadOnly:Object,s=Object.create(o.prototype);return _(s,{x:e,y:n,width:r,height:i,top:n,right:e+r,bottom:i+n,left:e}),s}function u(t,e,n,r){return{x:t,y:e,width:n,height:r}}var l=function(){return"undefined"!=typeof e&&e.Math===Math?e:"undefined"!=typeof self&&self.Math===Math?self:"undefined"!=typeof window&&window.Math===Math?window:Function("return this")()}(),f=function(){function t(t,e){var n=-1;return t.some(function(t,r){return t[0]===e&&(n=r,!0)}),n}return"function"==typeof l.Map?l.Map:function(){function e(){this.__entries__=[]}var n={size:{}};return n.size.get=function(){return this.__entries__.length},e.prototype.get=function(e){var n=t(this.__entries__,e),r=this.__entries__[n];return r&&r[1]},e.prototype.set=function(e,n){var r=t(this.__entries__,e);~r?this.__entries__[r][1]=n:this.__entries__.push([e,n])},e.prototype.delete=function(e){var n=this.__entries__,r=t(n,e);~r&&n.splice(r,1)},e.prototype.has=function(e){return!!~t(this.__entries__,e)},e.prototype.clear=function(){this.__entries__.splice(0)},e.prototype.forEach=function(t,e){var n=this;void 0===e&&(e=null);for(var r=0,i=n.__entries__;r<i.length;r+=1){var o=i[r];t.call(e,o[1],o[0])}},Object.defineProperties(e.prototype,n),e}()}(),h=l.window===l&&"undefined"!=typeof document,d=function(){return"function"==typeof requestAnimationFrame?requestAnimationFrame:function(t){return setTimeout(function(){return t(Date.now())},1e3/60)}}(),p=2,v=function(){var t=Date;return"object"==typeof performance&&"function"==typeof performance.now&&(t=performance),function(){return t.now()}}(),b=function(t,e,n){function r(){s=!1,t(),c&&o()}function i(){n?d(r):r()}function o(){var t=v();if(s){if(t-a<p)return;c=!0}else s=!0,c=!1,setTimeout(i,e);a=t}void 0===n&&(n=!1);var s=!1,c=!1,a=0;return o},y=20,m=80,g="function"==typeof MutationObserver&&"object"==typeof navigator&&!("Netscape"===navigator.appName&&navigator.userAgent.match(/Trident\/.*rv:11/)),E=function(){this.isCycleContinuous_=!g,this.listenersEnabled_=!1,this.mutationsObserver_=null,this.observers_=[],this.refresh=b(this.refresh.bind(this),y,!0),this.continuousUpdateHandler_=b(this.refresh,m)};E.prototype.connect=function(t){this.isConnected(t)||this.observers_.push(t),this.listenersEnabled_||this.addListeners_()},E.prototype.disconnect=function(t){var e=this.observers_,n=e.indexOf(t);~n&&e.splice(n,1),!e.length&&this.listenersEnabled_&&this.removeListeners_()},E.prototype.isConnected=function(t){return!!~this.observers_.indexOf(t)},E.prototype.refresh=function(){var t=this.updateObservers_();t?this.refresh():this.isCycleContinuous_&&this.listenersEnabled_&&this.continuousUpdateHandler_()},E.prototype.updateObservers_=function(){var t=this.observers_.filter(function(t){return t.gatherActive(),t.hasActive()});return t.forEach(function(t){return t.broadcastActive()}),t.length>0},E.prototype.addListeners_=function(){h&&!this.listenersEnabled_&&(window.addEventListener("resize",this.refresh),document.addEventListener("transitionend",this.refresh),g&&(this.mutationsObserver_=new MutationObserver(this.refresh),this.mutationsObserver_.observe(document,{attributes:!0,childList:!0,characterData:!0,subtree:!0})),this.listenersEnabled_=!0,this.isCycleContinuous_&&this.refresh())},E.prototype.removeListeners_=function(){h&&this.listenersEnabled_&&(window.removeEventListener("resize",this.refresh),document.removeEventListener("transitionend",this.refresh),this.mutationsObserver_&&this.mutationsObserver_.disconnect(),this.mutationsObserver_=null,this.listenersEnabled_=!1)};var _=function(t,e){for(var n=0,r=Object.keys(e);n<r.length;n+=1){var i=r[n];Object.defineProperty(t,i,{value:e[i],enumerbale:!1,writable:!1,configurable:!0})}return t},x=u(0,0,0,0),O=function(){return"function"==typeof SVGGraphicsElement?function(t){return t instanceof SVGGraphicsElement}:function(t){return t instanceof SVGElement&&"function"==typeof t.getBBox}}(),w=function(t){this.target=t,this.broadcastWidth=0,this.broadcastHeight=0,this.contentRect_=u(0,0,0,0)};w.prototype.isActive=function(){var t=c(this.target);return this.contentRect_=t,t.width!==this.broadcastWidth||t.height!==this.broadcastHeight},w.prototype.broadcastRect=function(){var t=this.contentRect_;return this.broadcastWidth=t.width,this.broadcastHeight=t.height,t};var S=function(t,e){var n=a(e);_(this,{target:t,contentRect:n})},k=function(t,e,n){if("function"!=typeof t)throw new TypeError("The callback provided as parameter 1 is not a function.");this.activeTargets_=[],this.observationTargets_=new f,this.callback_=t,this.controller_=e,this.callbackCtx_=n};k.prototype.observe=function(t){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("Element"in l&&Element instanceof Object){if(!(t instanceof Element))throw new TypeError('parameter 1 is not of type "Element".');var e=this.observationTargets_;e.has(t)||(e.set(t,new w(t)),this.controller_.isConnected(this)||this.controller_.connect(this),this.controller_.refresh())}},k.prototype.unobserve=function(t){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("Element"in l&&Element instanceof Object){if(!(t instanceof Element))throw new TypeError('parameter 1 is not of type "Element".');var e=this.observationTargets_;e.has(t)&&(e.delete(t),e.size||this.controller_.disconnect(this))}},k.prototype.disconnect=function(){this.clearActive(),this.observationTargets_.clear(),this.controller_.disconnect(this)},k.prototype.gatherActive=function(){this.clearActive();var t=this.activeTargets_;this.observationTargets_.forEach(function(e){e.isActive()&&t.push(e)})},k.prototype.broadcastActive=function(){if(this.hasActive()){var t=this.callbackCtx_,e=this.activeTargets_.map(function(t){return new S(t.target,t.broadcastRect())});this.callback_.call(t,e,t),this.clearActive()}},k.prototype.clearActive=function(){this.activeTargets_.splice(0)},k.prototype.hasActive=function(){return this.activeTargets_.length>0};var M=new E,A="function"==typeof WeakMap?new WeakMap:new f,j=function(t){if(!(this instanceof j))throw new TypeError("Cannot call a class as a function");if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");var e=new k(t,M,this);A.set(this,e)};["observe","unobserve","disconnect"].forEach(function(t){j.prototype[t]=function(){var e;return(e=A.get(this))[t].apply(e,arguments)}});var L=function(){return"function"==typeof l.ResizeObserver?l.ResizeObserver:j}();return L})}).call(e,function(){return this}())},function(t,e,n){var r,i,o;/*! scrollbarWidth.js v0.1.0 | felixexter | MIT | https://github.com/felixexter/scrollbarWidth ../../../_/default.htm
!function(n,s){i=[],r=s,o="function"==typeof r?r.apply(e,i):r,!(void 0!==o&&(t.exports=o))}(this,function(){"use strict";function t(){var t,e=document.body,n=document.createElement("div"),r=n.style;return r.position="absolute",r.top=r.left="-9999px",r.width=r.height="100px",r.overflow="scroll",e.appendChild(n),t=n.offsetWidth-n.clientWidth,e.removeChild(n),t}return t})}])});
!function(e,n){"function"==typeof define&&define.amd?define(["exports"],n):n("undefined"!=typeof exports?exports:e.dragscroll={})}(this,function(e){var n,t,o=window,l=document,c="mousemove",r="mouseup",i="mousedown",m="EventListener",d="add"+m,s="remove"+m,f=[],u=function(e,m){for(e=0;e<f.length;)m=f[e++],m=m.container||m,m[s](i,m.md,0),o[s](r,m.mu,0),o[s](c,m.mm,0);for(f=[].slice.call(l.getElementsByClassName("dragscroll")),e=0;e<f.length;)!function(e,m,s,f,u,a){(a=e.container||e)[d](i,a.md=function(n){e.hasAttribute("nochilddrag")&&l.elementFromPoint(n.pageX,n.pageY)!=a||(f=1,m=n.clientX,s=n.clientY,n.preventDefault())},0),o[d](r,a.mu=function(){f=0},0),o[d](c,a.mm=function(o){f&&((u=e.scroller||e).scrollLeft-=n=-m+(m=o.clientX),u.scrollTop-=t=-s+(s=o.clientY),e==l.body&&((u=l.documentElement).scrollLeft-=n,u.scrollTop-=t))},0)}(f[e++])};"complete"==l.readyState?u():o[d]("load",u,0),e.reset=u});
/*
 * Toastr
 * Copyright 2012-2015
 * Authors: John Papa, Hans Fjällemark, and Tim Ferrell.
 * All Rights Reserved.
 * Use, reproduction, distribution, and modification of this code is subject to the terms and
 * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php
 *
 * ARIA Support: Greta Krafsig
 *
 * Project: https://github.com/CodeSeven/toastr
 ../../../_/default.htm
/* global define ../../../_/default.htm
(function (define) {
    define(['jquery'], function ($) {
        return (function () {
            var $container;
            var listener;
            var toastId = 0;
            var toastType = {
                error: 'error',
                info: 'info',
                success: 'success',
                warning: 'warning'
            };

            var toastr = {
                clear: clear,
                remove: remove,
                error: error,
                getContainer: getContainer,
                info: info,
                options: {},
                subscribe: subscribe,
                success: success,
                version: '2.1.4',
                warning: warning
            };

            var previousToast;

            return toastr;

            ////////////////

            function error(message, title, optionsOverride) {
                return notify({
                    type: toastType.error,
                    iconClass: getOptions().iconClasses.error,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function getContainer(options, create) {
                if (!options) { options = getOptions(); }
                $container = $('#' + options.containerId);
                if ($container.length) {
                    return $container;
                }
                if (create) {
                    $container = createContainer(options);
                }
                return $container;
            }

            function info(message, title, optionsOverride) {
                return notify({
                    type: toastType.info,
                    iconClass: getOptions().iconClasses.info,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function subscribe(callback) {
                listener = callback;
            }

            function success(message, title, optionsOverride) {
                return notify({
                    type: toastType.success,
                    iconClass: getOptions().iconClasses.success,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function warning(message, title, optionsOverride) {
                return notify({
                    type: toastType.warning,
                    iconClass: getOptions().iconClasses.warning,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function clear($toastElement, clearOptions) {
                var options = getOptions();
                if (!$container) { getContainer(options); }
                if (!clearToast($toastElement, options, clearOptions)) {
                    clearContainer(options);
                }
            }

            function remove($toastElement) {
                var options = getOptions();
                if (!$container) { getContainer(options); }
                if ($toastElement && $(':focus', $toastElement).length === 0) {
                    removeToast($toastElement);
                    return;
                }
                if ($container.children().length) {
                    $container.remove();
                }
            }

            // internal functions

            function clearContainer (options) {
                var toastsToClear = $container.children();
                for (var i = toastsToClear.length - 1; i >= 0; i--) {
                    clearToast($(toastsToClear[i]), options);
                }
            }

            function clearToast ($toastElement, options, clearOptions) {
                var force = clearOptions && clearOptions.force ? clearOptions.force : false;
                if ($toastElement && (force || $(':focus', $toastElement).length === 0)) {
                    $toastElement[options.hideMethod]({
                        duration: options.hideDuration,
                        easing: options.hideEasing,
                        complete: function () { removeToast($toastElement); }
                    });
                    return true;
                }
                return false;
            }

            function createContainer(options) {
                $container = $('<div/>')
                    .attr('id', options.containerId)
                    .addClass(options.positionClass);

                $container.appendTo($(options.target));
                return $container;
            }

            function getDefaults() {
                return {
                    tapToDismiss: true,
                    toastClass: 'toast',
                    containerId: 'toast-container',
                    debug: false,

                    showMethod: 'fadeIn', //fadeIn, slideDown, and show are built into jQuery
                    showDuration: 300,
                    showEasing: 'swing', //swing and linear are built into jQuery
                    onShown: undefined,
                    hideMethod: 'fadeOut',
                    hideDuration: 1000,
                    hideEasing: 'swing',
                    onHidden: undefined,
                    closeMethod: false,
                    closeDuration: false,
                    closeEasing: false,
                    closeOnHover: true,

                    extendedTimeOut: 1000,
                    iconClasses: {
                        error: 'toast-error',
                        info: 'toast-info',
                        success: 'toast-success',
                        warning: 'toast-warning'
                    },
                    iconClass: 'toast-info',
                    positionClass: 'toast-top-right',
                    timeOut: 5000, // Set timeOut and extendedTimeOut to 0 to make it sticky
                    titleClass: 'toast-title',
                    messageClass: 'toast-message',
                    escapeHtml: false,
                    target: 'body',
                    closeHtml: '<button type="button">&times;</button>',
                    closeClass: 'toast-close-button',
                    newestOnTop: true,
                    preventDuplicates: false,
                    progressBar: false,
                    progressClass: 'toast-progress',
                    rtl: false
                };
            }

            function publish(args) {
                if (!listener) { return; }
                listener(args);
            }

            function notify(map) {
                var options = getOptions();
                var iconClass = map.iconClass || options.iconClass;

                if (typeof (map.optionsOverride) !== 'undefined') {
                    options = $.extend(options, map.optionsOverride);
                    iconClass = map.optionsOverride.iconClass || iconClass;
                }

                if (shouldExit(options, map)) { return; }

                toastId++;

                $container = getContainer(options, true);

                var intervalId = null;
                var $toastElement = $('<div/>');
                var $titleElement = $('<div/>');
                var $messageElement = $('<div/>');
                var $progressElement = $('<div/>');
                var $closeElement = $(options.closeHtml);
                var progressBar = {
                    intervalId: null,
                    hideEta: null,
                    maxHideTime: null
                };
                var response = {
                    toastId: toastId,
                    state: 'visible',
                    startTime: new Date(),
                    options: options,
                    map: map
                };

                personalizeToast();

                displayToast();

                handleEvents();

                publish(response);

                if (options.debug && console) {
                    console.log(response);
                }

                return $toastElement;

                function escapeHtml(source) {
                    if (source == null) {
                        source = '';
                    }

                    return source
                        .replace(/&/g, '&amp;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                }

                function personalizeToast() {
                    setIcon();
                    setTitle();
                    setMessage();
                    setCloseButton();
                    setProgressBar();
                    setRTL();
                    setSequence();
                    setAria();
                }

                function setAria() {
                    var ariaValue = '';
                    switch (map.iconClass) {
                        case 'toast-success':
                        case 'toast-info':
                            ariaValue =  'polite';
                            break;
                        default:
                            ariaValue = 'assertive';
                    }
                    $toastElement.attr('aria-live', ariaValue);
                }

                function handleEvents() {
                    if (options.closeOnHover) {
                        $toastElement.hover(stickAround, delayedHideToast);
                    }

                    if (!options.onclick && options.tapToDismiss) {
                        $toastElement.click(hideToast);
                    }

                    if (options.closeButton && $closeElement) {
                        $closeElement.click(function (event) {
                            if (event.stopPropagation) {
                                event.stopPropagation();
                            } else if (event.cancelBubble !== undefined && event.cancelBubble !== true) {
                                event.cancelBubble = true;
                            }

                            if (options.onCloseClick) {
                                options.onCloseClick(event);
                            }

                            hideToast(true);
                        });
                    }

                    if (options.onclick) {
                        $toastElement.click(function (event) {
                            options.onclick(event);
                            hideToast();
                        });
                    }
                }

                function displayToast() {
                    $toastElement.hide();

                    $toastElement[options.showMethod](
                        {duration: options.showDuration, easing: options.showEasing, complete: options.onShown}
                    );

                    if (options.timeOut > 0) {
                        intervalId = setTimeout(hideToast, options.timeOut);
                        progressBar.maxHideTime = parseFloat(options.timeOut);
                        progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                        if (options.progressBar) {
                            progressBar.intervalId = setInterval(updateProgress, 10);
                        }
                    }
                }

                function setIcon() {
                    if (map.iconClass) {
                        $toastElement.addClass(options.toastClass).addClass(iconClass);
                    }
                }

                function setSequence() {
                    if (options.newestOnTop) {
                        $container.prepend($toastElement);
                    } else {
                        $container.append($toastElement);
                    }
                }

                function setTitle() {
                    if (map.title) {
                        var suffix = map.title;
                        if (options.escapeHtml) {
                            suffix = escapeHtml(map.title);
                        }
                        $titleElement.append(suffix).addClass(options.titleClass);
                        $toastElement.append($titleElement);
                    }
                }

                function setMessage() {
                    if (map.message) {
                        var suffix = map.message;
                        if (options.escapeHtml) {
                            suffix = escapeHtml(map.message);
                        }
                        $messageElement.append(suffix).addClass(options.messageClass);
                        $toastElement.append($messageElement);
                    }
                }

                function setCloseButton() {
                    if (options.closeButton) {
                        $closeElement.addClass(options.closeClass).attr('role', 'button');
                        $toastElement.prepend($closeElement);
                    }
                }

                function setProgressBar() {
                    if (options.progressBar) {
                        $progressElement.addClass(options.progressClass);
                        $toastElement.prepend($progressElement);
                    }
                }

                function setRTL() {
                    if (options.rtl) {
                        $toastElement.addClass('rtl');
                    }
                }

                function shouldExit(options, map) {
                    if (options.preventDuplicates) {
                        if (map.message === previousToast) {
                            return true;
                        } else {
                            previousToast = map.message;
                        }
                    }
                    return false;
                }

                function hideToast(override) {
                    var method = override && options.closeMethod !== false ? options.closeMethod : options.hideMethod;
                    var duration = override && options.closeDuration !== false ?
                        options.closeDuration : options.hideDuration;
                    var easing = override && options.closeEasing !== false ? options.closeEasing : options.hideEasing;
                    if ($(':focus', $toastElement).length && !override) {
                        return;
                    }
                    clearTimeout(progressBar.intervalId);
                    return $toastElement[method]({
                        duration: duration,
                        easing: easing,
                        complete: function () {
                            removeToast($toastElement);
                            clearTimeout(intervalId);
                            if (options.onHidden && response.state !== 'hidden') {
                                options.onHidden();
                            }
                            response.state = 'hidden';
                            response.endTime = new Date();
                            publish(response);
                        }
                    });
                }

                function delayedHideToast() {
                    if (options.timeOut > 0 || options.extendedTimeOut > 0) {
                        intervalId = setTimeout(hideToast, options.extendedTimeOut);
                        progressBar.maxHideTime = parseFloat(options.extendedTimeOut);
                        progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                    }
                }

                function stickAround() {
                    clearTimeout(intervalId);
                    progressBar.hideEta = 0;
                    $toastElement.stop(true, true)[options.showMethod](
                        {duration: options.showDuration, easing: options.showEasing}
                    );
                }

                function updateProgress() {
                    var percentage = ((progressBar.hideEta - (new Date().getTime())) ../../../default.htm progressBar.maxHideTime) * 100;
                    $progressElement.width(percentage + '%');
                }
            }

            function getOptions() {
                return $.extend({}, getDefaults(), toastr.options);
            }

            function removeToast($toastElement) {
                if (!$container) { $container = getContainer(); }
                if ($toastElement.is(':visible')) {
                    return;
                }
                $toastElement.remove();
                $toastElement = null;
                if ($container.children().length === 0) {
                    $container.remove();
                    previousToast = undefined;
                }
            }

        })();
    });
}(typeof define === 'function' && define.amd ? define : function (deps, factory) {
    if (typeof module !== 'undefined' && module.exports) { //Node
        module.exports = factory(require('jquery'));
    } else {
        window.toastr = factory(window.jQuery);
    }
}));

/**
 * bootbox.js [v4.4.0]
 *
 * http://bootboxjs.com/license.txt
 ../../../_/default.htm

// @see https://github.com/makeusabrew/bootbox/issues/180
// @see https://github.com/makeusabrew/bootbox/issues/186
(function (root, factory) {

  "use strict";
  if (typeof define === "function" && define.amd) {
    // AMD. Register as an anonymous module.
    define(["jquery"], factory);
  } else if (typeof exports === "object") {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory(require("jquery"));
  } else {
    // Browser globals (root is window)
    root.bootbox = factory(root.jQuery);
  }

}(this, function init($, undefined) {

  "use strict";

  // the base DOM structure needed to create a modal
  var templates = {
    dialog:
      "<div class='bootbox modal' tabindex='-1' role='dialog'>" +
        "<div class='modal-dialog'>" +
          "<div class='modal-content'>" +
            "<div class='modal-body'><div class='bootbox-body'></div></div>" +
          "</div>" +
        "</div>" +
      "</div>",
    header:
      "<div class='modal-header'>" +
        "<h4 class='modal-title'></h4>" +
      "</div>",
    footer:
      "<div class='modal-footer'></div>",
    closeButton:
      "<button type='button' class='bootbox-close-button close' data-dismiss='modal' aria-hidden='true'>&times;</button>",
    form:
      "<form class='bootbox-form'></form>",
    inputs: {
      text:
        "<input class='bootbox-input bootbox-input-text form-control' autocomplete=off type=text ../../../default.htm>",
      textarea:
        "<textarea class='bootbox-input bootbox-input-textarea form-control'></textarea>",
      email:
        "<input class='bootbox-input bootbox-input-email form-control' autocomplete='off' type='email' ../../../default.htm>",
      select:
        "<select class='bootbox-input bootbox-input-select form-control'></select>",
      checkbox:
        "<div class='checkbox'><label><input class='bootbox-input bootbox-input-checkbox' type='checkbox' ../../../default.htm></label></div>",
      date:
        "<input class='bootbox-input bootbox-input-date form-control' autocomplete=off type='date' ../../../default.htm>",
      time:
        "<input class='bootbox-input bootbox-input-time form-control' autocomplete=off type='time' ../../../default.htm>",
      number:
        "<input class='bootbox-input bootbox-input-number form-control' autocomplete=off type='number' ../../../default.htm>",
      password:
        "<input class='bootbox-input bootbox-input-password form-control' autocomplete='off' type='password' ../../../default.htm>"
    }
  };

  var defaults = {
    // default language
    locale: "en",
    // show backdrop or not. Default to static so user has to interact with dialog
    backdrop: "static",
    // animate the modal in/out
    animate: true,
    // additional class string applied to the top level dialog
    className: null,
    // whether or not to include a close button
    closeButton: true,
    // show the dialog immediately by default
    show: true,
    // dialog container
    container: "body"
  };

  // our public object; augmented after our private API
  var exports = {};

  /**
   * @private
   ../../../_/default.htm
  function _t(key) {
    var locale = locales[defaults.locale];
    return locale ? locale[key] : locales.en[key];
  }

  function processCallback(e, dialog, callback) {
    e.stopPropagation();
    e.preventDefault();

    // by default we assume a callback will get rid of the dialog,
    // although it is given the opportunity to override this

    // so, if the callback can be invoked and it *explicitly returns false*
    // then we'll set a flag to keep the dialog active...
    var preserveDialog = $.isFunction(callback) && callback.call(dialog, e) === false;

    // ... otherwise we'll bin it
    if (!preserveDialog) {
      dialog.modal("hide");
    }
  }

  function getKeyLength(obj) {
    // @TODO defer to Object.keys(x).length if available?
    var k, t = 0;
    for (k in obj) {
      t ++;
    }
    return t;
  }

  function each(collection, iterator) {
    var index = 0;
    $.each(collection, function(key, value) {
      iterator(key, value, index++);
    });
  }

  function sanitize(options) {
    var buttons;
    var total;

    if (typeof options !== "object") {
      throw new Error("Please supply an object of options");
    }

    if (!options.message) {
      throw new Error("Please specify a message");
    }

    // make sure any supplied options take precedence over defaults
    options = $.extend({}, defaults, options);

    if (!options.buttons) {
      options.buttons = {};
    }

    buttons = options.buttons;

    total = getKeyLength(buttons);

    each(buttons, function(key, button, index) {

      if ($.isFunction(button)) {
        // short form, assume value is our callback. Since button
        // isn't an object it isn't a reference either so re-assign it
        button = buttons[key] = {
          callback: button
        };
      }

      // before any further checks make sure by now button is the correct type
      if ($.type(button) !== "object") {
        throw new Error("button with key " + key + " must be an object");
      }

      if (!button.label) {
        // the lack of an explicit label means we'll assume the key is good enough
        button.label = key;
      }

      if (!button.className) {
        if (total <= 2 && index === total-1) {
          // always add a primary to the main option in a two-button dialog
          button.className = "btn-primary";
        } else {
          button.className = "btn-default";
        }
      }
    });

    return options;
  }

  /**
   * map a flexible set of arguments into a single returned object
   * if args.length is already one just return it, otherwise
   * use the properties argument to map the unnamed args to
   * object properties
   * so in the latter case:
   * mapArguments(["foo", $.noop], ["message", "callback"])
   * -> { message: "foo", callback: $.noop }
   ../../../_/default.htm
  function mapArguments(args, properties) {
    var argn = args.length;
    var options = {};

    if (argn < 1 || argn > 2) {
      throw new Error("Invalid argument length");
    }

    if (argn === 2 || typeof args[0] === "string") {
      options[properties[0]] = args[0];
      options[properties[1]] = args[1];
    } else {
      options = args[0];
    }

    return options;
  }

  /**
   * merge a set of default dialog options with user supplied arguments
   ../../../_/default.htm
  function mergeArguments(defaults, args, properties) {
    return $.extend(
      // deep merge
      true,
      // ensure the target is an empty, unreferenced object
      {},
      // the base options object for this type of dialog (often just buttons)
      defaults,
      // args could be an object or array; if it's an array properties will
      // map it to a proper options object
      mapArguments(
        args,
        properties
      )
    );
  }

  /**
   * this entry-level method makes heavy use of composition to take a simple
   * range of inputs and return valid options suitable for passing to bootbox.dialog
   ../../../_/default.htm
  function mergeDialogOptions(className, labels, properties, args) {
    //  build up a base set of dialog properties
    var baseOptions = {
      className: "bootbox-" + className,
      buttons: createLabels.apply(null, labels)
    };

    // ensure the buttons properties generated, *after* merging
    // with user args are still valid against the supplied labels
    return validateButtons(
      // merge the generated base properties with user supplied arguments
      mergeArguments(
        baseOptions,
        args,
        // if args.length > 1, properties specify how each arg maps to an object key
        properties
      ),
      labels
    );
  }

  /**
   * from a given list of arguments return a suitable object of button labels
   * all this does is normalise the given labels and translate them where possible
   * e.g. "ok", "confirm" -> { ok: "OK, cancel: "Annuleren" }
   ../../../_/default.htm
  function createLabels() {
    var buttons = {};

    for (var i = 0, j = arguments.length; i < j; i++) {
      var argument = arguments[i];
      var key = argument.toLowerCase();
      var value = argument.toUpperCase();

      buttons[key] = {
        label: _t(value)
      };
    }

    return buttons;
  }

  function validateButtons(options, buttons) {
    var allowedButtons = {};
    each(buttons, function(key, value) {
      allowedButtons[value] = true;
    });

    each(options.buttons, function(key) {
      if (allowedButtons[key] === undefined) {
        throw new Error("button key " + key + " is not allowed (options are " + buttons.join("\n") + ")");
      }
    });

    return options;
  }

  exports.alert = function() {
    var options;

    options = mergeDialogOptions("alert", ["ok"], ["message", "callback"], arguments);

    if (options.callback && !$.isFunction(options.callback)) {
      throw new Error("alert requires callback property to be a function when provided");
    }

    /**
     * overrides
     ../../../_/default.htm
    options.buttons.ok.callback = options.onEscape = function() {
      if ($.isFunction(options.callback)) {
        return options.callback.call(this);
      }
      return true;
    };

    return exports.dialog(options);
  };

  exports.confirm = function() {
    var options;

    options = mergeDialogOptions("confirm", ["cancel", "confirm"], ["message", "callback"], arguments);

    /**
     * overrides; undo anything the user tried to set they shouldn't have
     ../../../_/default.htm
    options.buttons.cancel.callback = options.onEscape = function() {
      return options.callback.call(this, false);
    };

    options.buttons.confirm.callback = function() {
      return options.callback.call(this, true);
    };

    // confirm specific validation
    if (!$.isFunction(options.callback)) {
      throw new Error("confirm requires a callback");
    }

    return exports.dialog(options);
  };

  exports.prompt = function() {
    var options;
    var defaults;
    var dialog;
    var form;
    var input;
    var shouldShow;
    var inputOptions;

    // we have to create our form first otherwise
    // its value is undefined when gearing up our options
    // @TODO this could be solved by allowing message to
    // be a function instead...
    form = $(templates.form);

    // prompt defaults are more complex than others in that
    // users can override more defaults
    // @TODO I don't like that prompt has to do a lot of heavy
    // lifting which mergeDialogOptions can *almost* support already
    // just because of 'value' and 'inputType' - can we refactor?
    defaults = {
      className: "bootbox-prompt",
      buttons: createLabels("cancel", "confirm"),
      value: "",
      inputType: "text"
    };

    options = validateButtons(
      mergeArguments(defaults, arguments, ["title", "callback"]),
      ["cancel", "confirm"]
    );

    // capture the user's show value; we always set this to false before
    // spawning the dialog to give us a chance to attach some handlers to
    // it, but we need to make sure we respect a preference not to show it
    shouldShow = (options.show === undefined) ? true : options.show;

    /**
     * overrides; undo anything the user tried to set they shouldn't have
     ../../../_/default.htm
    options.message = form;

    options.buttons.cancel.callback = options.onEscape = function() {
      return options.callback.call(this, null);
    };

    options.buttons.confirm.callback = function() {
      var value;

      switch (options.inputType) {
        case "text":
        case "textarea":
        case "email":
        case "select":
        case "date":
        case "time":
        case "number":
        case "password":
          value = input.val();
          break;

        case "checkbox":
          var checkedItems = input.find("input:checked");

          // we assume that checkboxes are always multiple,
          // hence we default to an empty array
          value = [];

          each(checkedItems, function(_, item) {
            value.push($(item).val());
          });
          break;
      }

      return options.callback.call(this, value);
    };

    options.show = false;

    // prompt specific validation
    if (!options.title) {
      throw new Error("prompt requires a title");
    }

    if (!$.isFunction(options.callback)) {
      throw new Error("prompt requires a callback");
    }

    if (!templates.inputs[options.inputType]) {
      throw new Error("invalid prompt type");
    }

    // create the input based on the supplied type
    input = $(templates.inputs[options.inputType]);

    switch (options.inputType) {
      case "text":
      case "textarea":
      case "email":
      case "date":
      case "time":
      case "number":
      case "password":
        input.val(options.value);
        break;

      case "select":
        var groups = {};
        inputOptions = options.inputOptions || [];

        if (!$.isArray(inputOptions)) {
          throw new Error("Please pass an array of input options");
        }

        if (!inputOptions.length) {
          throw new Error("prompt with select requires options");
        }

        each(inputOptions, function(_, option) {

          // assume the element to attach to is the input...
          var elem = input;

          if (option.value === undefined || option.text === undefined) {
            throw new Error("given options in wrong format");
          }

          // ... but override that element if this option sits in a group

          if (option.group) {
            // initialise group if necessary
            if (!groups[option.group]) {
              groups[option.group] = $("<optgroup/>").attr("label", option.group);
            }

            elem = groups[option.group];
          }

          elem.append("<option value='" + option.value + "'>" + option.text + "</option>");
        });

        each(groups, function(_, group) {
          input.append(group);
        });

        // safe to set a select's value as per a normal input
        input.val(options.value);
        break;

      case "checkbox":
        var values   = $.isArray(options.value) ? options.value : [options.value];
        inputOptions = options.inputOptions || [];

        if (!inputOptions.length) {
          throw new Error("prompt with checkbox requires options");
        }

        if (!inputOptions[0].value || !inputOptions[0].text) {
          throw new Error("given options in wrong format");
        }

        // checkboxes have to nest within a containing element, so
        // they break the rules a bit and we end up re-assigning
        // our 'input' element to this container instead
        input = $("<div/>");

        each(inputOptions, function(_, option) {
          var checkbox = $(templates.inputs[options.inputType]);

          checkbox.find("input").attr("value", option.value);
          checkbox.find("label").append(option.text);

          // we've ensured values is an array so we can always iterate over it
          each(values, function(_, value) {
            if (value === option.value) {
              checkbox.find("input").prop("checked", true);
            }
          });

          input.append(checkbox);
        });
        break;
    }

    // @TODO provide an attributes option instead
    // and simply map that as keys: vals
    if (options.placeholder) {
      input.attr("placeholder", options.placeholder);
    }

    if (options.pattern) {
      input.attr("pattern", options.pattern);
    }

    if (options.maxlength) {
      input.attr("maxlength", options.maxlength);
    }

    // now place it in our form
    form.append(input);

    form.on("submit", function(e) {
      e.preventDefault();
      // Fix for SammyJS (or similar JS routing library) hijacking the form post.
      e.stopPropagation();
      // @TODO can we actually click *the* button object instead?
      // e.g. buttons.confirm.click() or similar
      dialog.find(".btn-primary").click();
    });

    dialog = exports.dialog(options);

    // clear the existing handler focusing the submit button...
    dialog.off("shown.bs.modal");

    // ...and replace it with one focusing our input, if possible
    dialog.on("shown.bs.modal", function() {
      // need the closure here since input isn't
      // an object otherwise
      input.focus();
    });

    if (shouldShow === true) {
      dialog.modal("show");
    }

    return dialog;
  };

  exports.dialog = function(options) {
    options = sanitize(options);

    var dialog = $(templates.dialog);
    var innerDialog = dialog.find(".modal-dialog");
    var body = dialog.find(".modal-body");
    var buttons = options.buttons;
    var buttonStr = "";
    var callbacks = {
      onEscape: options.onEscape
    };

    if ($.fn.modal === undefined) {
      throw new Error(
        "$.fn.modal is not defined; please double check you have included " +
        "the Bootstrap JavaScript library. See http://getbootstrap.com/javascript/ " +
        "for more details."
      );
    }

    each(buttons, function(key, button) {

      // @TODO I don't like this string appending to itself; bit dirty. Needs reworking
      // can we just build up button elements instead? slower but neater. Then button
      // can just become a template too
      buttonStr += "<button data-bb-handler='" + key + "' type='button' class='btn " + button.className + "'>" + button.label + "</button>";
      callbacks[key] = button.callback;
    });

    body.find(".bootbox-body").html(options.message);

    if (options.animate === true) {
      dialog.addClass("fade");
    }

    if (options.className) {
      dialog.addClass(options.className);
    }

    if (options.size === "large") {
      innerDialog.addClass("modal-lg");
    } else if (options.size === "small") {
      innerDialog.addClass("modal-sm");
    }

    if (options.title) {
      body.before(templates.header);
    }

    if (options.closeButton) {
      var closeButton = $(templates.closeButton);

      if (options.title) {
        dialog.find(".modal-header").prepend(closeButton);
      } else {
        closeButton.css("margin-top", "-10px").prependTo(body);
      }
    }

    if (options.title) {
      dialog.find(".modal-title").html(options.title);
    }

    if (buttonStr.length) {
      body.after(templates.footer);
      dialog.find(".modal-footer").html(buttonStr);
    }


    /**
     * Bootstrap event listeners; used handle extra
     * setup & teardown required after the underlying
     * modal has performed certain actions
     ../../../_/default.htm

    dialog.on("hidden.bs.modal", function(e) {
      // ensure we don't accidentally intercept hidden events triggered
      // by children of the current dialog. We shouldn't anymore now BS
      // namespaces its events; but still worth doing
      if (e.target === this) {
        dialog.remove();
      }
    });

    /*
    dialog.on("show.bs.modal", function() {
      // sadly this doesn't work; show is called *just* before
      // the backdrop is added so we'd need a setTimeout hack or
      // otherwise... leaving in as would be nice
      if (options.backdrop) {
        dialog.next(".modal-backdrop").addClass("bootbox-backdrop");
      }
    });
    ../../../_/default.htm

    dialog.on("shown.bs.modal", function() {
      dialog.find(".btn-primary:first").focus();
    });

    /**
     * Bootbox event listeners; experimental and may not last
     * just an attempt to decouple some behaviours from their
     * respective triggers
     ../../../_/default.htm

    if (options.backdrop !== "static") {
      // A boolean true/false according to the Bootstrap docs
      // should show a dialog the user can dismiss by clicking on
      // the background.
      // We always only ever pass static/false to the actual
      // $.modal function because with `true` we can't trap
      // this event (the .modal-backdrop swallows it)
      // However, we still want to sort of respect true
      // and invoke the escape mechanism instead
      dialog.on("click.dismiss.bs.modal", function(e) {
        // @NOTE: the target varies in >= 3.3.x releases since the modal backdrop
        // moved *inside* the outer dialog rather than *alongside* it
        if (dialog.children(".modal-backdrop").length) {
          e.currentTarget = dialog.children(".modal-backdrop").get(0);
        }

        if (e.target !== e.currentTarget) {
          return;
        }

        dialog.trigger("escape.close.bb");
      });
    }

    dialog.on("escape.close.bb", function(e) {
      if (callbacks.onEscape) {
        processCallback(e, dialog, callbacks.onEscape);
      }
    });

    /**
     * Standard jQuery event listeners; used to handle user
     * interaction with our dialog
     ../../../_/default.htm

    dialog.on("click", ".modal-footer button", function(e) {
      var callbackKey = $(this).data("bb-handler");

      processCallback(e, dialog, callbacks[callbackKey]);
    });

    dialog.on("click", ".bootbox-close-button", function(e) {
      // onEscape might be falsy but that's fine; the fact is
      // if the user has managed to click the close button we
      // have to close the dialog, callback or not
      processCallback(e, dialog, callbacks.onEscape);
    });

    dialog.on("keyup", function(e) {
      if (e.which === 27) {
        dialog.trigger("escape.close.bb");
      }
    });

    // the remainder of this method simply deals with adding our
    // dialogent to the DOM, augmenting it with Bootstrap's modal
    // functionality and then giving the resulting object back
    // to our caller

    $(options.container).append(dialog);

    dialog.modal({
      backdrop: options.backdrop ? "static": false,
      keyboard: false,
      show: false
    });

    if (options.show) {
      dialog.modal("show");
    }

    // @TODO should we return the raw element here or should
    // we wrap it in an object on which we can expose some neater
    // methods, e.g. var d = bootbox.alert(); d.hide(); instead
    // of d.modal("hide");

   /*
    function BBDialog(elem) {
      this.elem = elem;
    }

    BBDialog.prototype = {
      hide: function() {
        return this.elem.modal("hide");
      },
      show: function() {
        return this.elem.modal("show");
      }
    };
    ../../../_/default.htm

    return dialog;

  };

  exports.setDefaults = function() {
    var values = {};

    if (arguments.length === 2) {
      // allow passing of single key/value...
      values[arguments[0]] = arguments[1];
    } else {
      // ... and as an object too
      values = arguments[0];
    }

    $.extend(defaults, values);
  };

  exports.hideAll = function() {
    $(".bootbox").modal("hide");

    return exports;
  };


  /**
   * standard locales. Please add more according to ISO 639-1 standard. Multiple language variants are
   * unlikely to be required. If this gets too large it can be split out into separate JS files.
   ../../../_/default.htm
  var locales = {
    bg_BG : {
      OK      : "Ок",
      CANCEL  : "Отказ",
      CONFIRM : "Потвърждавам"
    },
    br : {
      OK      : "OK",
      CANCEL  : "Cancelar",
      CONFIRM : "Sim"
    },
    cs : {
      OK      : "OK",
      CANCEL  : "Zrušit",
      CONFIRM : "Potvrdit"
    },
    da : {
      OK      : "OK",
      CANCEL  : "Annuller",
      CONFIRM : "Accepter"
    },
    de : {
      OK      : "OK",
      CANCEL  : "Abbrechen",
      CONFIRM : "Akzeptieren"
    },
    el : {
      OK      : "Εντάξει",
      CANCEL  : "Ακύρωση",
      CONFIRM : "Επιβεβαίωση"
    },
    en : {
      OK      : "OK",
      CANCEL  : "Cancel",
      CONFIRM : "OK"
    },
    es : {
      OK      : "OK",
      CANCEL  : "Cancelar",
      CONFIRM : "Aceptar"
    },
    et : {
      OK      : "OK",
      CANCEL  : "Katkesta",
      CONFIRM : "OK"
    },
    fa : {
      OK      : "قبول",
      CANCEL  : "لغو",
      CONFIRM : "تایید"
    },
    fi : {
      OK      : "OK",
      CANCEL  : "Peruuta",
      CONFIRM : "OK"
    },
    fr : {
      OK      : "OK",
      CANCEL  : "Annuler",
      CONFIRM : "D'accord"
    },
    he : {
      OK      : "אישור",
      CANCEL  : "ביטול",
      CONFIRM : "אישור"
    },
    hu : {
      OK      : "OK",
      CANCEL  : "Mégsem",
      CONFIRM : "Megerősít"
    },
    hr : {
      OK      : "OK",
      CANCEL  : "Odustani",
      CONFIRM : "Potvrdi"
    },
    id : {
      OK      : "OK",
      CANCEL  : "Batal",
      CONFIRM : "OK"
    },
    it : {
      OK      : "OK",
      CANCEL  : "Annulla",
      CONFIRM : "Conferma"
    },
    ja : {
      OK      : "OK",
      CANCEL  : "キャンセル",
      CONFIRM : "確認"
    },
    lt : {
      OK      : "Gerai",
      CANCEL  : "Atšaukti",
      CONFIRM : "Patvirtinti"
    },
    lv : {
      OK      : "Labi",
      CANCEL  : "Atcelt",
      CONFIRM : "Apstiprināt"
    },
    nl : {
      OK      : "OK",
      CANCEL  : "Annuleren",
      CONFIRM : "Accepteren"
    },
    no : {
      OK      : "OK",
      CANCEL  : "Avbryt",
      CONFIRM : "OK"
    },
    pl : {
      OK      : "OK",
      CANCEL  : "Anuluj",
      CONFIRM : "Potwierdź"
    },
    pt : {
      OK      : "OK",
      CANCEL  : "Cancelar",
      CONFIRM : "Confirmar"
    },
    ru : {
      OK      : "OK",
      CANCEL  : "Отмена",
      CONFIRM : "Применить"
    },
    sq : {
      OK : "OK",
      CANCEL : "Anulo",
      CONFIRM : "Prano"
    },
    sv : {
      OK      : "OK",
      CANCEL  : "Avbryt",
      CONFIRM : "OK"
    },
    th : {
      OK      : "ตกลง",
      CANCEL  : "ยกเลิก",
      CONFIRM : "ยืนยัน"
    },
    tr : {
      OK      : "Tamam",
      CANCEL  : "İptal",
      CONFIRM : "Onayla"
    },
    zh_CN : {
      OK      : "OK",
      CANCEL  : "取消",
      CONFIRM : "确认"
    },
    zh_TW : {
      OK      : "OK",
      CANCEL  : "取消",
      CONFIRM : "確認"
    }
  };

  exports.addLocale = function(name, values) {
    $.each(["OK", "CANCEL", "CONFIRM"], function(_, v) {
      if (!values[v]) {
        throw new Error("Please supply a translation for '" + v + "'");
      }
    });

    locales[name] = {
      OK: values.OK,
      CANCEL: values.CANCEL,
      CONFIRM: values.CONFIRM
    };

    return exports;
  };

  exports.removeLocale = function(name) {
    delete locales[name];

    return exports;
  };

  exports.setLocale = function(name) {
    return exports.setDefaults("locale", name);
  };

  exports.init = function(_$) {
    return init(_$ || $);
  };

  return exports;
}));

/*************************
 * Croppie
 * Copyright 2017
 * Foliotek
 * Version: 2.6.1
 *************************/
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['exports'], factory);
    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
        // CommonJS
        factory(exports);
    } else {
        // Browser globals
        factory((root.commonJsStrict = {}));
    }
}(this, function (exports) {

    /* Polyfills ../../../_/default.htm
    if (typeof Promise !== 'function') {
        /*! promise-polyfill 3.1.0 ../../../_/default.htm
        !function(a){function b(a,b){return function(){a.apply(b,arguments)}}function c(a){if("object"!=typeof this)throw new TypeError("Promises must be constructed via new");if("function"!=typeof a)throw new TypeError("not a function");this._state=null,this._value=null,this._deferreds=[],i(a,b(e,this),b(f,this))}function d(a){var b=this;return null===this._state?void this._deferreds.push(a):void k(function(){var c=b._state?a.onFulfilled:a.onRejected;if(null===c)return void(b._state?a.resolve:a.reject)(b._value);var d;try{d=c(b._value)}catch(e){return void a.reject(e)}a.resolve(d)})}function e(a){try{if(a===this)throw new TypeError("A promise cannot be resolved with itself.");if(a&&("object"==typeof a||"function"==typeof a)){var c=a.then;if("function"==typeof c)return void i(b(c,a),b(e,this),b(f,this))}this._state=!0,this._value=a,g.call(this)}catch(d){f.call(this,d)}}function f(a){this._state=!1,this._value=a,g.call(this)}function g(){for(var a=0,b=this._deferreds.length;b>a;a++)d.call(this,this._deferreds[a]);this._deferreds=null}function h(a,b,c,d){this.onFulfilled="function"==typeof a?a:null,this.onRejected="function"==typeof b?b:null,this.resolve=c,this.reject=d}function i(a,b,c){var d=!1;try{a(function(a){d||(d=!0,b(a))},function(a){d||(d=!0,c(a))})}catch(e){if(d)return;d=!0,c(e)}}var j=setTimeout,k="function"==typeof setImmediate&&setImmediate||function(a){j(a,1)},l=Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)};c.prototype["catch"]=function(a){return this.then(null,a)},c.prototype.then=function(a,b){var e=this;return new c(function(c,f){d.call(e,new h(a,b,c,f))})},c.all=function(){var a=Array.prototype.slice.call(1===arguments.length&&l(arguments[0])?arguments[0]:arguments);return new c(function(b,c){function d(f,g){try{if(g&&("object"==typeof g||"function"==typeof g)){var h=g.then;if("function"==typeof h)return void h.call(g,function(a){d(f,a)},c)}a[f]=g,0===--e&&b(a)}catch(i){c(i)}}if(0===a.length)return b([]);for(var e=a.length,f=0;f<a.length;f++)d(f,a[f])})},c.resolve=function(a){return a&&"object"==typeof a&&a.constructor===c?a:new c(function(b){b(a)})},c.reject=function(a){return new c(function(b,c){c(a)})},c.race=function(a){return new c(function(b,c){for(var d=0,e=a.length;e>d;d++)a[d].then(b,c)})},c._setImmediateFn=function(a){k=a},"undefined"!=typeof module&&module.exports?module.exports=c:a.Promise||(a.Promise=c)}(this);
    }

    if ( typeof window.CustomEvent !== "function" ) {
        (function(){
            function CustomEvent ( event, params ) {
                params = params || { bubbles: false, cancelable: false, detail: undefined };
                var evt = document.createEvent( 'CustomEvent' );
                evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );
                return evt;
            }
            CustomEvent.prototype = window.Event.prototype;
            window.CustomEvent = CustomEvent;
        }());
    }

    if (!HTMLCanvasElement.prototype.toBlob) {
        Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
            value: function (callback, type, quality) {
                var binStr = atob( this.toDataURL(type, quality).split(',')[1] ),
                len = binStr.length,
                arr = new Uint8Array(len);

                for (var i=0; i<len; i++ ) {
                    arr[i] = binStr.charCodeAt(i);
                }

                callback( new Blob( [arr], {type: type || 'image/png'} ) );
            }
        });
    }
    /* End Polyfills ../../../_/default.htm

    var cssPrefixes = ['Webkit', 'Moz', 'ms'],
        emptyStyles = document.createElement('div').style,
        EXIF_NORM = [1,8,3,6],
        EXIF_FLIP = [2,7,4,5],
        CSS_TRANS_ORG,
        CSS_TRANSFORM,
        CSS_USERSELECT;

    function vendorPrefix(prop) {
        if (prop in emptyStyles) {
            return prop;
        }

        var capProp = prop[0].toUpperCase() + prop.slice(1),
            i = cssPrefixes.length;

        while (i--) {
            prop = cssPrefixes[i] + capProp;
            if (prop in emptyStyles) {
                return prop;
            }
        }
    }

    CSS_TRANSFORM = vendorPrefix('transform');
    CSS_TRANS_ORG = vendorPrefix('transformOrigin');
    CSS_USERSELECT = vendorPrefix('userSelect');

    function getExifOffset(ornt, rotate) {
        var arr = EXIF_NORM.indexOf(ornt) > -1 ? EXIF_NORM : EXIF_FLIP,
            index = arr.indexOf(ornt),
            offset = (rotate ../../../default.htm 90) % arr.length;// 180 = 2%4 = 2 shift exif by 2 indexes

        return arr[(arr.length + index + (offset % arr.length)) % arr.length];
    }

    // Credits to : Andrew Dupont - http://andrewdupont.net/2009/08/28/deep-extending-objects-in-javascript/
    function deepExtend(destination, source) {
        destination = destination || {};
        for (var property in source) {
            if (source[property] && source[property].constructor && source[property].constructor === Object) {
                destination[property] = destination[property] || {};
                deepExtend(destination[property], source[property]);
            } else {
                destination[property] = source[property];
            }
        }
        return destination;
    }

    function clone(object) {
        return deepExtend({}, object);
    }

    function debounce(func, wait, immediate) {
        var timeout;
        return function () {
            var context = this, args = arguments;
            var later = function () {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func.apply(context, args);
        };
    }

    function dispatchChange(element) {
        if ("createEvent" in document) {
            var evt = document.createEvent("HTMLEvents");
            evt.initEvent("change", false, true);
            element.dispatchEvent(evt);
        }
        else {
            element.fireEvent("onchange");
        }
    }

    //http://jsperf.com/vanilla-css
    function css(el, styles, val) {
        if (typeof (styles) === 'string') {
            var tmp = styles;
            styles = {};
            styles[tmp] = val;
        }

        for (var prop in styles) {
            el.style[prop] = styles[prop];
        }
    }

    function addClass(el, c) {
        if (el.classList) {
            el.classList.add(c);
        }
        else {
            el.className += ' ' + c;
        }
    }

    function removeClass(el, c) {
        if (el.classList) {
            el.classList.remove(c);
        }
        else {
            el.className = el.className.replace(c, '');
        }
    }

    function setAttributes(el, attrs) {
        for (var key in attrs) {
            el.setAttribute(key, attrs[key]);
        }
    }

    function num(v) {
        return parseInt(v, 10);
    }

    /* Utilities ../../../_/default.htm
    function loadImage(src, doExif) {
        var img = new Image();
        img.style.opacity = 0;
        return new Promise(function (resolve) {
            function _resolve() {
                img.style.opacity = 1;
                setTimeout(function () {
                    resolve(img);
                }, 1);
            }

            img.removeAttribute('crossOrigin');
            if (src.match(/^https?:\/\/|^\/\//)) {
                img.setAttribute('crossOrigin', 'anonymous');
            }

            img.onload = function () {
                if (doExif) {
                    EXIF.getData(img, function () {
                        _resolve();
                    });
                }
                else {
                    _resolve();
                }
            };
            img.src = src;
        });
    }

    function naturalImageDimensions(img, ornt) {
        var w = img.naturalWidth;
        var h = img.naturalHeight;
        var orient = ornt || getExifOrientation(img);
        if (orient && orient >= 5) {
            var x= w;
            w = h;
            h = x;
        }
        return { width: w, height: h };
    }

    /* CSS Transform Prototype ../../../_/default.htm
    var TRANSLATE_OPTS = {
        'translate3d': {
            suffix: ', 0px'
        },
        'translate': {
            suffix: ''
        }
    };
    var Transform = function (x, y, scale) {
        this.x = parseFloat(x);
        this.y = parseFloat(y);
        this.scale = parseFloat(scale);
    };

    Transform.parse = function (v) {
        if (v.style) {
            return Transform.parse(v.style[CSS_TRANSFORM]);
        }
        else if (v.indexOf('matrix') > -1 || v.indexOf('none') > -1) {
            return Transform.fromMatrix(v);
        }
        else {
            return Transform.fromString(v);
        }
    };

    Transform.fromMatrix = function (v) {
        var vals = v.substring(7).split(',');
        if (!vals.length || v === 'none') {
            vals = [1, 0, 0, 1, 0, 0];
        }

        return new Transform(num(vals[4]), num(vals[5]), parseFloat(vals[0]));
    };

    Transform.fromString = function (v) {
        var values = v.split(') '),
            translate = values[0].substring(Croppie.globals.translate.length + 1).split(','),
            scale = values.length > 1 ? values[1].substring(6) : 1,
            x = translate.length > 1 ? translate[0] : 0,
            y = translate.length > 1 ? translate[1] : 0;

        return new Transform(x, y, scale);
    };

    Transform.prototype.toString = function () {
        var suffix = TRANSLATE_OPTS[Croppie.globals.translate].suffix || '';
        return Croppie.globals.translate + '(' + this.x + 'px, ' + this.y + 'px' + suffix + ') scale(' + this.scale + ')';
    };

    var TransformOrigin = function (el) {
        if (!el || !el.style[CSS_TRANS_ORG]) {
            this.x = 0;
            this.y = 0;
            return;
        }
        var css = el.style[CSS_TRANS_ORG].split(' ');
        this.x = parseFloat(css[0]);
        this.y = parseFloat(css[1]);
    };

    TransformOrigin.prototype.toString = function () {
        return this.x + 'px ' + this.y + 'px';
    };

    function getExifOrientation (img) {
        return img.exifdata ? img.exifdata.Orientation : 1;
    }

    function drawCanvas(canvas, img, orientation) {
        var width = img.width,
            height = img.height,
            ctx = canvas.getContext('2d');

        canvas.width = img.width;
        canvas.height = img.height;

        ctx.save();
        switch (orientation) {
          case 2:
             ctx.translate(width, 0);
             ctx.scale(-1, 1);
             break;

          case 3:
              ctx.translate(width, height);
              ctx.rotate(180*Math.PI/180);
              break;

          case 4:
              ctx.translate(0, height);
              ctx.scale(1, -1);
              break;

          case 5:
              canvas.width = height;
              canvas.height = width;
              ctx.rotate(90*Math.PI/180);
              ctx.scale(1, -1);
              break;

          case 6:
              canvas.width = height;
              canvas.height = width;
              ctx.rotate(90*Math.PI/180);
              ctx.translate(0, -height);
              break;

          case 7:
              canvas.width = height;
              canvas.height = width;
              ctx.rotate(-90*Math.PI/180);
              ctx.translate(-width, height);
              ctx.scale(1, -1);
              break;

          case 8:
              canvas.width = height;
              canvas.height = width;
              ctx.translate(0, width);
              ctx.rotate(-90*Math.PI/180);
              break;
        }
        ctx.drawImage(img, 0,0, width, height);
        ctx.restore();
    }

    /* Private Methods ../../../_/default.htm
    function _create() {
        var self = this,
            contClass = 'croppie-container',
            customViewportClass = self.options.viewport.type ? 'cr-vp-' + self.options.viewport.type : null,
            boundary, img, viewport, overlay, bw, bh;

        self.options.useCanvas = self.options.enableOrientation || _hasExif.call(self);
        // Properties on class
        self.data = {};
        self.elements = {};

        boundary = self.elements.boundary = document.createElement('div');
        viewport = self.elements.viewport = document.createElement('div');
        img = self.elements.img = document.createElement('img');
        overlay = self.elements.overlay = document.createElement('div');

        if (self.options.useCanvas) {
            self.elements.canvas = document.createElement('canvas');
            self.elements.preview = self.elements.canvas;
        }
        else {
            self.elements.preview = self.elements.img;
        }

        addClass(boundary, 'cr-boundary');
        boundary.setAttribute('aria-dropeffect', 'none');
        bw = self.options.boundary.width;
        bh = self.options.boundary.height;
        css(boundary, {
            width: (bw + (isNaN(bw) ? '' : 'px')),
            height: (bh + (isNaN(bh) ? '' : 'px'))
        });

        addClass(viewport, 'cr-viewport');
        if (customViewportClass) {
            addClass(viewport, customViewportClass);
        }
        css(viewport, {
            width: self.options.viewport.width + 'px',
            height: self.options.viewport.height + 'px'
        });
        viewport.setAttribute('tabindex', 0);

        addClass(self.elements.preview, 'cr-image');
        setAttributes(self.elements.preview, { 'alt': 'preview', 'aria-grabbed': 'false' });
        addClass(overlay, 'cr-overlay');

        self.element.appendChild(boundary);
        boundary.appendChild(self.elements.preview);
        boundary.appendChild(viewport);
        boundary.appendChild(overlay);

        addClass(self.element, contClass);
        if (self.options.customClass) {
            addClass(self.element, self.options.customClass);
        }

        _initDraggable.call(this);

        if (self.options.enableZoom) {
            _initializeZoom.call(self);
        }

        // if (self.options.enableOrientation) {
        //     _initRotationControls.call(self);
        // }

        if (self.options.enableResize) {
            _initializeResize.call(self);
        }
    }

    // function _initRotationControls () {
    //     var self = this,
    //         wrap, btnLeft, btnRight, iLeft, iRight;

    //     wrap = document.createElement('div');
    //     self.elements.orientationBtnLeft = btnLeft = document.createElement('button');
    //     self.elements.orientationBtnRight = btnRight = document.createElement('button');

    //     wrap.appendChild(btnLeft);
    //     wrap.appendChild(btnRight);

    //     iLeft = document.createElement('i');
    //     iRight = document.createElement('i');
    //     btnLeft.appendChild(iLeft);
    //     btnRight.appendChild(iRight);

    //     addClass(wrap, 'cr-rotate-controls');
    //     addClass(btnLeft, 'cr-rotate-l');
    //     addClass(btnRight, 'cr-rotate-r');

    //     self.elements.boundary.appendChild(wrap);

    //     btnLeft.addEventListener('click', function () {
    //         self.rotate(-90);
    //     });
    //     btnRight.addEventListener('click', function () {
    //         self.rotate(90);
    //     });
    // }

    function _hasExif() {
        return this.options.enableExif && window.EXIF;
    }

    function _initializeResize () {
        var self = this;
        var wrap = document.createElement('div');
        var isDragging = false;
        var direction;
        var originalX;
        var originalY;
        var minSize = 50;
        var maxWidth;
        var maxHeight;
        var vr;
        var hr;

        addClass(wrap, 'cr-resizer');
        css(wrap, {
            width: this.options.viewport.width + 'px',
            height: this.options.viewport.height + 'px'
        });

        if (this.options.resizeControls.height) {
            vr = document.createElement('div');
            addClass(vr, 'cr-resizer-vertical');
            wrap.appendChild(vr);
        }

        if (this.options.resizeControls.width) {
            hr = document.createElement('div');
            addClass(hr, 'cr-resizer-horisontal');
            wrap.appendChild(hr);
        }

        function mouseDown(ev) {
            if (ev.button !== undefined && ev.button !== 0) return;

            ev.preventDefault();
            if (isDragging) {
                return;
            }

            var overlayRect = self.elements.overlay.getBoundingClientRect();

            isDragging = true;
            originalX = ev.pageX;
            originalY = ev.pageY;
            direction = ev.currentTarget.className.indexOf('vertical') !== -1 ? 'v' : 'h';
            maxWidth = overlayRect.width;
            maxHeight = overlayRect.height;

            if (ev.touches) {
                var touches = ev.touches[0];
                originalX = touches.pageX;
                originalY = touches.pageY;
            }

            window.addEventListener('mousemove', mouseMove);
            window.addEventListener('touchmove', mouseMove);
            window.addEventListener('mouseup', mouseUp);
            window.addEventListener('touchend', mouseUp);
            document.body.style[CSS_USERSELECT] = 'none';
        }

        function mouseMove(ev) {
            var pageX = ev.pageX;
            var pageY = ev.pageY;

            ev.preventDefault();

            if (ev.touches) {
                var touches = ev.touches[0];
                pageX = touches.pageX;
                pageY = touches.pageY;
            }

            var deltaX = pageX - originalX;
            var deltaY = pageY - originalY;
            var newHeight = self.options.viewport.height + deltaY;
            var newWidth = self.options.viewport.width + deltaX;

            if (direction === 'v' && newHeight >= minSize && newHeight <= maxHeight) {
                css(wrap, {
                    height: newHeight + 'px'
                });

                self.options.boundary.height += deltaY;
                css(self.elements.boundary, {
                    height: self.options.boundary.height + 'px'
                });

                self.options.viewport.height += deltaY;
                css(self.elements.viewport, {
                    height: self.options.viewport.height + 'px'
                });
            }
            else if (direction === 'h' && newWidth >= minSize && newWidth <= maxWidth) {
                css(wrap, {
                    width: newWidth + 'px'
                });

                self.options.boundary.width += deltaX;
                css(self.elements.boundary, {
                    width: self.options.boundary.width + 'px'
                });

                self.options.viewport.width += deltaX;
                css(self.elements.viewport, {
                    width: self.options.viewport.width + 'px'
                });
            }

            _updateOverlay.call(self);
            _updateZoomLimits.call(self);
            _updateCenterPoint.call(self);
            _triggerUpdate.call(self);
            originalY = pageY;
            originalX = pageX;
        }

        function mouseUp() {
            isDragging = false;
            window.removeEventListener('mousemove', mouseMove);
            window.removeEventListener('touchmove', mouseMove);
            window.removeEventListener('mouseup', mouseUp);
            window.removeEventListener('touchend', mouseUp);
            document.body.style[CSS_USERSELECT] = '';
        }

        if (vr) {
            vr.addEventListener('mousedown', mouseDown);
            vr.addEventListener('touchstart', mouseDown);
        }

        if (hr) {
            hr.addEventListener('mousedown', mouseDown);
            hr.addEventListener('touchstart', mouseDown);
        }

        this.elements.boundary.appendChild(wrap);
    }

    function _setZoomerVal(v) {
        if (this.options.enableZoom) {
            var z = this.elements.zoomer,
                val = fix(v, 4);

            z.value = Math.max(z.min, Math.min(z.max, val));
        }
    }

    function _initializeZoom() {
        var self = this,
            wrap = self.elements.zoomerWrap = document.createElement('div'),
            zoomer = self.elements.zoomer = document.createElement('input');

        addClass(wrap, 'cr-slider-wrap');
        addClass(zoomer, 'cr-slider');
        zoomer.type = 'range';
        zoomer.step = '0.0001';
        zoomer.value = 1;
        zoomer.style.display = self.options.showZoomer ? '' : 'none';
        zoomer.setAttribute('aria-label', 'zoom');

        self.element.appendChild(wrap);
        wrap.appendChild(zoomer);

        self._currentZoom = 1;

        function change() {
            _onZoom.call(self, {
                value: parseFloat(zoomer.value),
                origin: new TransformOrigin(self.elements.preview),
                viewportRect: self.elements.viewport.getBoundingClientRect(),
                transform: Transform.parse(self.elements.preview)
            });
        }

        function scroll(ev) {
            var delta, targetZoom;

            if(self.options.mouseWheelZoom === 'ctrl' && ev.ctrlKey != true){ 
              return 0; 
            } else if (ev.wheelDelta) {
                delta = ev.wheelDelta ../../../default.htm 1200; //wheelDelta min: -120 max: 120 // max x 10 x 2
            } else if (ev.deltaY) {
                delta = ev.deltaY ../../../default.htm 1060; //deltaY min: -53 max: 53 // max x 10 x 2
            } else if (ev.detail) {
                delta = ev.detail ../../../default.htm -60; //delta min: -3 max: 3 // max x 10 x 2
            } else {
                delta = 0;
            }

            targetZoom = self._currentZoom + (delta * self._currentZoom);

            ev.preventDefault();
            _setZoomerVal.call(self, targetZoom);
            change.call(self);
        }

        self.elements.zoomer.addEventListener('input', change);// this is being fired twice on keypress
        self.elements.zoomer.addEventListener('change', change);

        if (self.options.mouseWheelZoom) {
            self.elements.boundary.addEventListener('mousewheel', scroll);
            self.elements.boundary.addEventListener('DOMMouseScroll', scroll);
        }
    }

    function _onZoom(ui) {
        var self = this,
            transform = ui ? ui.transform : Transform.parse(self.elements.preview),
            vpRect = ui ? ui.viewportRect : self.elements.viewport.getBoundingClientRect(),
            origin = ui ? ui.origin : new TransformOrigin(self.elements.preview);

        function applyCss() {
            var transCss = {};
            transCss[CSS_TRANSFORM] = transform.toString();
            transCss[CSS_TRANS_ORG] = origin.toString();
            css(self.elements.preview, transCss);
        }

        self._currentZoom = ui ? ui.value : self._currentZoom;
        transform.scale = self._currentZoom;
        self.elements.zoomer.setAttribute('aria-valuenow', self._currentZoom);
        applyCss();

        if (self.options.enforceBoundary) {
            var boundaries = _getVirtualBoundaries.call(self, vpRect),
                transBoundaries = boundaries.translate,
                oBoundaries = boundaries.origin;

            if (transform.x >= transBoundaries.maxX) {
                origin.x = oBoundaries.minX;
                transform.x = transBoundaries.maxX;
            }

            if (transform.x <= transBoundaries.minX) {
                origin.x = oBoundaries.maxX;
                transform.x = transBoundaries.minX;
            }

            if (transform.y >= transBoundaries.maxY) {
                origin.y = oBoundaries.minY;
                transform.y = transBoundaries.maxY;
            }

            if (transform.y <= transBoundaries.minY) {
                origin.y = oBoundaries.maxY;
                transform.y = transBoundaries.minY;
            }
        }
        applyCss();
        _debouncedOverlay.call(self);
        _triggerUpdate.call(self);
    }

    function _getVirtualBoundaries(viewport) {
        var self = this,
            scale = self._currentZoom,
            vpWidth = viewport.width,
            vpHeight = viewport.height,
            centerFromBoundaryX = self.elements.boundary.clientWidth ../../../default.htm 2,
            centerFromBoundaryY = self.elements.boundary.clientHeight ../../../default.htm 2,
            imgRect = self.elements.preview.getBoundingClientRect(),
            curImgWidth = imgRect.width,
            curImgHeight = imgRect.height,
            halfWidth = vpWidth ../../../default.htm 2,
            halfHeight = vpHeight ../../../default.htm 2;

        var maxX = ((halfWidth ../../../default.htm scale) - centerFromBoundaryX) * -1;
        var minX = maxX - ((curImgWidth * (1 ../../../default.htm scale)) - (vpWidth * (1 ../../../default.htm scale)));

        var maxY = ((halfHeight ../../../default.htm scale) - centerFromBoundaryY) * -1;
        var minY = maxY - ((curImgHeight * (1 ../../../default.htm scale)) - (vpHeight * (1 ../../../default.htm scale)));

        var originMinX = (1 ../../../default.htm scale) * halfWidth;
        var originMaxX = (curImgWidth * (1 ../../../default.htm scale)) - originMinX;

        var originMinY = (1 ../../../default.htm scale) * halfHeight;
        var originMaxY = (curImgHeight * (1 ../../../default.htm scale)) - originMinY;

        return {
            translate: {
                maxX: maxX,
                minX: minX,
                maxY: maxY,
                minY: minY
            },
            origin: {
                maxX: originMaxX,
                minX: originMinX,
                maxY: originMaxY,
                minY: originMinY
            }
        };
    }

    function _updateCenterPoint() {
        var self = this,
            scale = self._currentZoom,
            data = self.elements.preview.getBoundingClientRect(),
            vpData = self.elements.viewport.getBoundingClientRect(),
            transform = Transform.parse(self.elements.preview.style[CSS_TRANSFORM]),
            pc = new TransformOrigin(self.elements.preview),
            top = (vpData.top - data.top) + (vpData.height ../../../default.htm 2),
            left = (vpData.left - data.left) + (vpData.width ../../../default.htm 2),
            center = {},
            adj = {};

        center.y = top ../../../default.htm scale;
        center.x = left ../../../default.htm scale;

        adj.y = (center.y - pc.y) * (1 - scale);
        adj.x = (center.x - pc.x) * (1 - scale);

        transform.x -= adj.x;
        transform.y -= adj.y;

        var newCss = {};
        newCss[CSS_TRANS_ORG] = center.x + 'px ' + center.y + 'px';
        newCss[CSS_TRANSFORM] = transform.toString();
        css(self.elements.preview, newCss);
    }

    function _initDraggable() {
        var self = this,
            isDragging = false,
            originalX,
            originalY,
            originalDistance,
            vpRect,
            transform;

        function assignTransformCoordinates(deltaX, deltaY) {
            var imgRect = self.elements.preview.getBoundingClientRect(),
                top = transform.y + deltaY,
                left = transform.x + deltaX;

            if (self.options.enforceBoundary) {
                if (vpRect.top > imgRect.top + deltaY && vpRect.bottom < imgRect.bottom + deltaY) {
                    transform.y = top;
                }

                if (vpRect.left > imgRect.left + deltaX && vpRect.right < imgRect.right + deltaX) {
                    transform.x = left;
                }
            }
            else {
                transform.y = top;
                transform.x = left;
            }
        }

        function toggleGrabState(isDragging) {
          self.elements.preview.setAttribute('aria-grabbed', isDragging);
          self.elements.boundary.setAttribute('aria-dropeffect', isDragging? 'move': 'none');
        }

        function keyDown(ev) {
            var LEFT_ARROW  = 37,
                UP_ARROW    = 38,
                RIGHT_ARROW = 39,
                DOWN_ARROW  = 40;

            if (ev.shiftKey && (ev.keyCode == UP_ARROW || ev.keyCode == DOWN_ARROW)) {
                var zoom = 0.0;
                if (ev.keyCode == UP_ARROW) {
                    zoom = parseFloat(self.elements.zoomer.value, 10) + parseFloat(self.elements.zoomer.step, 10)
                }
                else {
                    zoom = parseFloat(self.elements.zoomer.value, 10) - parseFloat(self.elements.zoomer.step, 10)
                }
                self.setZoom(zoom);
            }
            else if (self.options.enableKeyMovement && (ev.keyCode >= 37 && ev.keyCode <= 40)) {
                ev.preventDefault();
                var movement = parseKeyDown(ev.keyCode);

                transform = Transform.parse(self.elements.preview);
                document.body.style[CSS_USERSELECT] = 'none';
                vpRect = self.elements.viewport.getBoundingClientRect();
                keyMove(movement);
            };

            function parseKeyDown(key) {
                switch (key) {
                    case LEFT_ARROW:
                        return [1, 0];
                    case UP_ARROW:
                        return [0, 1];
                    case RIGHT_ARROW:
                        return [-1, 0];
                    case DOWN_ARROW:
                        return [0, -1];
                };
            };
        }

        function keyMove(movement) {
            var deltaX = movement[0],
                deltaY = movement[1],
                newCss = {};

            assignTransformCoordinates(deltaX, deltaY);

            newCss[CSS_TRANSFORM] = transform.toString();
            css(self.elements.preview, newCss);
            _updateOverlay.call(self);
            document.body.style[CSS_USERSELECT] = '';
            _updateCenterPoint.call(self);
            _triggerUpdate.call(self);
            originalDistance = 0;
        }

        function mouseDown(ev) {
            if (ev.button !== undefined && ev.button !== 0) return;

            ev.preventDefault();
            if (isDragging) return;
            isDragging = true;
            originalX = ev.pageX;
            originalY = ev.pageY;

            if (ev.touches) {
                var touches = ev.touches[0];
                originalX = touches.pageX;
                originalY = touches.pageY;
            }
            toggleGrabState(isDragging);
            transform = Transform.parse(self.elements.preview);
            window.addEventListener('mousemove', mouseMove);
            window.addEventListener('touchmove', mouseMove);
            window.addEventListener('mouseup', mouseUp);
            window.addEventListener('touchend', mouseUp);
            document.body.style[CSS_USERSELECT] = 'none';
            vpRect = self.elements.viewport.getBoundingClientRect();
        }

        function mouseMove(ev) {
            ev.preventDefault();
            var pageX = ev.pageX,
                pageY = ev.pageY;

            if (ev.touches) {
                var touches = ev.touches[0];
                pageX = touches.pageX;
                pageY = touches.pageY;
            }

            var deltaX = pageX - originalX,
                deltaY = pageY - originalY,
                newCss = {};

            if (ev.type == 'touchmove') {
                if (ev.touches.length > 1) {
                    var touch1 = ev.touches[0];
                    var touch2 = ev.touches[1];
                    var dist = Math.sqrt((touch1.pageX - touch2.pageX) * (touch1.pageX - touch2.pageX) + (touch1.pageY - touch2.pageY) * (touch1.pageY - touch2.pageY));

                    if (!originalDistance) {
                        originalDistance = dist ../../../default.htm self._currentZoom;
                    }

                    var scale = dist ../../../default.htm originalDistance;

                    _setZoomerVal.call(self, scale);
                    dispatchChange(self.elements.zoomer);
                    return;
                }
            }

            assignTransformCoordinates(deltaX, deltaY);

            newCss[CSS_TRANSFORM] = transform.toString();
            css(self.elements.preview, newCss);
            _updateOverlay.call(self);
            originalY = pageY;
            originalX = pageX;
        }

        function mouseUp() {
            isDragging = false;
            toggleGrabState(isDragging);
            window.removeEventListener('mousemove', mouseMove);
            window.removeEventListener('touchmove', mouseMove);
            window.removeEventListener('mouseup', mouseUp);
            window.removeEventListener('touchend', mouseUp);
            document.body.style[CSS_USERSELECT] = '';
            _updateCenterPoint.call(self);
            _triggerUpdate.call(self);
            originalDistance = 0;
        }

        self.elements.overlay.addEventListener('mousedown', mouseDown);
        self.elements.viewport.addEventListener('keydown', keyDown);
        self.elements.overlay.addEventListener('touchstart', mouseDown);
    }

    function _updateOverlay() {
        if (!this.elements) return; // since this is debounced, it can be fired after destroy
        var self = this,
            boundRect = self.elements.boundary.getBoundingClientRect(),
            imgData = self.elements.preview.getBoundingClientRect();

        css(self.elements.overlay, {
            width: imgData.width + 'px',
            height: imgData.height + 'px',
            top: (imgData.top - boundRect.top) + 'px',
            left: (imgData.left - boundRect.left) + 'px'
        });
    }
    var _debouncedOverlay = debounce(_updateOverlay, 500);

    function _triggerUpdate() {
        var self = this,
            data = self.get(),
            ev;

        if (!_isVisible.call(self)) {
            return;
        }

        self.options.update.call(self, data);
        if (self.$ && typeof Prototype == 'undefined') {
            self.$(self.element).trigger('update.croppie', data);
        }
        else {
            var ev;
            if (window.CustomEvent) {
                ev = new CustomEvent('update', { detail: data });
            } else {
                ev = document.createEvent('CustomEvent');
                ev.initCustomEvent('update', true, true, data);
            }

            self.element.dispatchEvent(ev);
        }
    }

    function _isVisible() {
        return this.elements.preview.offsetHeight > 0 && this.elements.preview.offsetWidth > 0;
    }

    function _updatePropertiesFromImage() {
        var self = this,
            initialZoom = 1,
            cssReset = {},
            img = self.elements.preview,
            imgData = null,
            transformReset = new Transform(0, 0, initialZoom),
            originReset = new TransformOrigin(),
            isVisible = _isVisible.call(self);

        if (!isVisible || self.data.bound) {// if the croppie isn't visible or it doesn't need binding
            return;
        }

        self.data.bound = true;
        cssReset[CSS_TRANSFORM] = transformReset.toString();
        cssReset[CSS_TRANS_ORG] = originReset.toString();
        cssReset['opacity'] = 1;
        css(img, cssReset);

        imgData = self.elements.preview.getBoundingClientRect();

        self._originalImageWidth = imgData.width;
        self._originalImageHeight = imgData.height;
        self.data.orientation = getExifOrientation(self.elements.img);

        if (self.options.enableZoom) {
            _updateZoomLimits.call(self, true);
        }
        else {
            self._currentZoom = initialZoom;
        }

        transformReset.scale = self._currentZoom;
        cssReset[CSS_TRANSFORM] = transformReset.toString();
        css(img, cssReset);

        if (self.data.points.length) {
            _bindPoints.call(self, self.data.points);
        }
        else {
            _centerImage.call(self);
        }

        _updateCenterPoint.call(self);
        _updateOverlay.call(self);
    }

    function _updateZoomLimits (initial) {
        var self = this,
            minZoom = 0,
            maxZoom = self.options.maxZoom || 1.5,
            initialZoom,
            defaultInitialZoom,
            zoomer = self.elements.zoomer,
            scale = parseFloat(zoomer.value),
            boundaryData = self.elements.boundary.getBoundingClientRect(),
            imgData = naturalImageDimensions(self.elements.img, self.data.orientation),
            vpData = self.elements.viewport.getBoundingClientRect(),
            minW,
            minH;
        if (self.options.enforceBoundary) {
            minW = vpData.width ../../../default.htm imgData.width;
            minH = vpData.height ../../../default.htm imgData.height;
            minZoom = Math.max(minW, minH);
        }

        if (minZoom >= maxZoom) {
            maxZoom = minZoom + 1;
        }

        zoomer.min = fix(minZoom, 4);
        zoomer.max = fix(maxZoom, 4);
        
        if (!initial && (scale < zoomer.min || scale > zoomer.max)) {
            _setZoomerVal.call(self, scale < zoomer.min ? zoomer.min : zoomer.max);
        }
        else if (initial) {
            defaultInitialZoom = Math.max((boundaryData.width ../../../default.htm imgData.width), (boundaryData.height ../../../default.htm imgData.height));
            initialZoom = self.data.boundZoom !== null ? self.data.boundZoom : defaultInitialZoom;
            _setZoomerVal.call(self, initialZoom);
        }

        dispatchChange(zoomer);
    }

    function _bindPoints(points) {
        if (points.length != 4) {
            throw "Croppie - Invalid number of points supplied: " + points;
        }
        var self = this,
            pointsWidth = points[2] - points[0],
            // pointsHeight = points[3] - points[1],
            vpData = self.elements.viewport.getBoundingClientRect(),
            boundRect = self.elements.boundary.getBoundingClientRect(),
            vpOffset = {
                left: vpData.left - boundRect.left,
                top: vpData.top - boundRect.top
            },
            scale = vpData.width ../../../default.htm pointsWidth,
            originTop = points[1],
            originLeft = points[0],
            transformTop = (-1 * points[1]) + vpOffset.top,
            transformLeft = (-1 * points[0]) + vpOffset.left,
            newCss = {};

        newCss[CSS_TRANS_ORG] = originLeft + 'px ' + originTop + 'px';
        newCss[CSS_TRANSFORM] = new Transform(transformLeft, transformTop, scale).toString();
        css(self.elements.preview, newCss);

        _setZoomerVal.call(self, scale);
        self._currentZoom = scale;
    }

    function _centerImage() {
        var self = this,
            imgDim = self.elements.preview.getBoundingClientRect(),
            vpDim = self.elements.viewport.getBoundingClientRect(),
            boundDim = self.elements.boundary.getBoundingClientRect(),
            vpLeft = vpDim.left - boundDim.left,
            vpTop = vpDim.top - boundDim.top,
            w = vpLeft - ((imgDim.width - vpDim.width) ../../../default.htm 2),
            h = vpTop - ((imgDim.height - vpDim.height) ../../../default.htm 2),
            transform = new Transform(w, h, self._currentZoom);

        css(self.elements.preview, CSS_TRANSFORM, transform.toString());
    }

    function _transferImageToCanvas(customOrientation) {
        var self = this,
            canvas = self.elements.canvas,
            img = self.elements.img,
            ctx = canvas.getContext('2d'),
            exif = _hasExif.call(self),
            customOrientation = self.options.enableOrientation && customOrientation;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.width = img.width;
        canvas.height = img.height;

        if (exif && !customOrientation) {
            var orientation = getExifOrientation(img);
            drawCanvas(canvas, img, num(orientation || 0, 10));
        }
        else if (customOrientation) {
            drawCanvas(canvas, img, customOrientation);
        }
    }

    function _getCanvas(data) {
        var self = this,
            points = data.points,
            left = num(points[0]),
            top = num(points[1]),
            right = num(points[2]),
            bottom = num(points[3]),
            width = right-left,
            height = bottom-top,
            circle = data.circle,
            canvas = document.createElement('canvas'),
            ctx = canvas.getContext('2d'),
            startX = 0,
            startY = 0,
            canvasWidth = data.outputWidth || width,
            canvasHeight = data.outputHeight || height,
            customDimensions = (data.outputWidth && data.outputHeight),
            outputWidthRatio = 1;
            outputHeightRatio = 1;

        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        if (data.backgroundColor) {
            ctx.fillStyle = data.backgroundColor;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        }

        width=Math.min(width, self._originalImageWidth);
        height=Math.min(height, self._originalImageHeight)
    
        // console.table({ left, right, top, bottom, canvasWidth, canvasHeight });
        ctx.drawImage(this.elements.preview, left, top, width, height, startX, startY, canvasWidth, canvasHeight);
        if (circle) {
            ctx.fillStyle = '#fff';
            ctx.globalCompositeOperation = 'destination-in';
            ctx.beginPath();
            ctx.arc(canvas.width ../../../default.htm 2, canvas.height ../../../default.htm 2, canvas.width ../../../default.htm 2, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fill();
        }
        return canvas;
    }

    function _getHtmlResult(data) {
        var points = data.points,
            div = document.createElement('div'),
            img = document.createElement('img'),
            width = points[2] - points[0],
            height = points[3] - points[1];

        addClass(div, 'croppie-result');
        div.appendChild(img);
        css(img, {
            left: (-1 * points[0]) + 'px',
            top: (-1 * points[1]) + 'px'
        });
        img.src = data.url;
        css(div, {
            width: width + 'px',
            height: height + 'px'
        });

        return div;
    }

    function _getBase64Result(data) {
        return _getCanvas.call(this, data).toDataURL(data.format, data.quality);
    }

    function _getBlobResult(data) {
        var self = this;
        return new Promise(function (resolve, reject) {
            _getCanvas.call(self, data).toBlob(function (blob) {
                resolve(blob);
            }, data.format, data.quality);
        });
    }

    function _replaceImage(img) {
        if (this.elements.img.parentNode) {
            Array.prototype.forEach.call(this.elements.img.classList, function(c) { img.classList.add(c); });
            this.elements.img.parentNode.replaceChild(img, this.elements.img);
            this.elements.preview = img; // if the img is attached to the DOM, they're not using the canvas
        }
        this.elements.img = img;
    }

    function _bind(options, cb) {
        var self = this,
            url,
            points = [],
            zoom = null,
            hasExif = _hasExif.call(self);

        if (typeof (options) === 'string') {
            url = options;
            options = {};
        }
        else if (Array.isArray(options)) {
            points = options.slice();
        }
        else if (typeof (options) == 'undefined' && self.data.url) { //refreshing
            _updatePropertiesFromImage.call(self);
            _triggerUpdate.call(self);
            return null;
        }
        else {
            url = options.url;
            points = options.points || [];
            zoom = typeof(options.zoom) === 'undefined' ? null : options.zoom;
        }

        self.data.bound = false;
        self.data.url = url || self.data.url;
        self.data.boundZoom = zoom;

        return loadImage(url, hasExif).then(function (img) {
            _replaceImage.call(self, img);
            if (!points.length) {
                var natDim = naturalImageDimensions(img);
                var rect = self.elements.viewport.getBoundingClientRect();
                var aspectRatio = rect.width ../../../default.htm rect.height;
                var imgAspectRatio = natDim.width ../../../default.htm natDim.height;
                var width, height;

                if (imgAspectRatio > aspectRatio) {
                    height = natDim.height;
                    width = height * aspectRatio;
                }
                else {
                    width = natDim.width;
                    height = natDim.height ../../../default.htm aspectRatio;
                }

                var x0 = (natDim.width - width) ../../../default.htm 2;
                var y0 = (natDim.height - height) ../../../default.htm 2;
                var x1 = x0 + width;
                var y1 = y0 + height;
                self.data.points = [x0, y0, x1, y1];
            }
            else if (self.options.relative) {
                points = [
                    points[0] * img.naturalWidth ../../../default.htm 100,
                    points[1] * img.naturalHeight ../../../default.htm 100,
                    points[2] * img.naturalWidth ../../../default.htm 100,
                    points[3] * img.naturalHeight ../../../default.htm 100
                ];
            }

            self.data.points = points.map(function (p) {
                return parseFloat(p);
            });
            if (self.options.useCanvas) {
                _transferImageToCanvas.call(self, options.orientation || 1);
            }
            _updatePropertiesFromImage.call(self);
            _triggerUpdate.call(self);
            cb && cb();
        }).catch(function (err) {
            console.error("Croppie:" + err);
        });
    }

    function fix(v, decimalPoints) {
        return parseFloat(v).toFixed(decimalPoints || 0);
    }

    function _get() {
        var self = this,
            imgData = self.elements.preview.getBoundingClientRect(),
            vpData = self.elements.viewport.getBoundingClientRect(),
            x1 = vpData.left - imgData.left,
            y1 = vpData.top - imgData.top,
            widthDiff = (vpData.width - self.elements.viewport.offsetWidth) ../../../default.htm 2, //border
            heightDiff = (vpData.height - self.elements.viewport.offsetHeight) ../../../default.htm 2,
            x2 = x1 + self.elements.viewport.offsetWidth + widthDiff,
            y2 = y1 + self.elements.viewport.offsetHeight + heightDiff,
            scale = self._currentZoom;

        if (scale === Infinity || isNaN(scale)) {
            scale = 1;
        }

        var max = self.options.enforceBoundary ? 0 : Number.NEGATIVE_INFINITY;
        x1 = Math.max(max, x1 ../../../default.htm scale);
        y1 = Math.max(max, y1 ../../../default.htm scale);
        x2 = Math.max(max, x2 ../../../default.htm scale);
        y2 = Math.max(max, y2 ../../../default.htm scale);

        return {
            points: [fix(x1), fix(y1), fix(x2), fix(y2)],
            zoom: scale,
            orientation: self.data.orientation
        };
    }

    var RESULT_DEFAULTS = {
            type: 'canvas',
            format: 'png',
            quality: 1
        },
        RESULT_FORMATS = ['jpeg', 'webp', 'png'];

    function _result(options) {
        var self = this,
            data = _get.call(self),
            opts = deepExtend(clone(RESULT_DEFAULTS), clone(options)),
            resultType = (typeof (options) === 'string' ? options : (opts.type || 'base64')),
            size = opts.size || 'viewport',
            format = opts.format,
            quality = opts.quality,
            backgroundColor = opts.backgroundColor,
            circle = typeof opts.circle === 'boolean' ? opts.circle : (self.options.viewport.type === 'circle'),
            vpRect = self.elements.viewport.getBoundingClientRect(),
            ratio = vpRect.width ../../../default.htm vpRect.height,
            prom;

        if (size === 'viewport') {
            data.outputWidth = vpRect.width;
            data.outputHeight = vpRect.height;
        } else if (typeof size === 'object') {
            if (size.width && size.height) {
                data.outputWidth = size.width;
                data.outputHeight = size.height;
            } else if (size.width) {
                data.outputWidth = size.width;
                data.outputHeight = size.width ../../../default.htm ratio;
            } else if (size.height) {
                data.outputWidth = size.height * ratio;
                data.outputHeight = size.height;
            }
        }

        if (RESULT_FORMATS.indexOf(format) > -1) {
            data.format = '../../../image/default.htm' + format;
            data.quality = quality;
        }

        data.circle = circle;
        data.url = self.data.url;
        data.backgroundColor = backgroundColor;

        prom = new Promise(function (resolve, reject) {
            switch(resultType.toLowerCase())
            {
                case 'rawcanvas':
                    resolve(_getCanvas.call(self, data));
                    break;
                case 'canvas':
                case 'base64':
                    resolve(_getBase64Result.call(self, data));
                    break;
                case 'blob':
                    _getBlobResult.call(self, data).then(resolve);
                    break;
                default:
                    resolve(_getHtmlResult.call(self, data));
                    break;
            }
        });
        return prom;
    }

    function _refresh() {
        _updatePropertiesFromImage.call(this);
    }

    function _rotate(deg) {
        if (!this.options.useCanvas || !this.options.enableOrientation) {
            throw 'Croppie: Cannot rotate without enableOrientation && EXIF.js included';
        }

        var self = this,
            canvas = self.elements.canvas,
            ornt;

        self.data.orientation = getExifOffset(self.data.orientation, deg);
        drawCanvas(canvas, self.elements.img, self.data.orientation);
        _updateZoomLimits.call(self);
        _onZoom.call(self);
        copy = null;
    }

    function _destroy() {
        var self = this;
        self.element.removeChild(self.elements.boundary);
        removeClass(self.element, 'croppie-container');
        if (self.options.enableZoom) {
            self.element.removeChild(self.elements.zoomerWrap);
        }
        delete self.elements;
    }

    if (window.jQuery) {
        var $ = window.jQuery;
        $.fn.croppie = function (opts) {
            var ot = typeof opts;

            if (ot === 'string') {
                var args = Array.prototype.slice.call(arguments, 1);
                var singleInst = $(this).data('croppie');

                if (opts === 'get') {
                    return singleInst.get();
                }
                else if (opts === 'result') {
                    return singleInst.result.apply(singleInst, args);
                }
                else if (opts === 'bind') {
                    return singleInst.bind.apply(singleInst, args);
                }

                return this.each(function () {
                    var i = $(this).data('croppie');
                    if (!i) return;

                    var method = i[opts];
                    if ($.isFunction(method)) {
                        method.apply(i, args);
                        if (opts === 'destroy') {
                            $(this).removeData('croppie');
                        }
                    }
                    else {
                        throw 'Croppie ' + opts + ' method not found';
                    }
                });
            }
            else {
                return this.each(function () {
                    var i = new Croppie(this, opts);
                    i.$ = $;
                    $(this).data('croppie', i);
                });
            }
        };
    }

    function Croppie(element, opts) {
        if (element.className.indexOf('croppie-container') > -1) {
            throw new Error("Croppie: Can't initialize croppie more than once");
        }
        this.element = element;
        this.options = deepExtend(clone(Croppie.defaults), opts);

        if (this.element.tagName.toLowerCase() === 'img') {
            var origImage = this.element;
            addClass(origImage, 'cr-original-image');
            setAttributes(origImage, {'aria-hidden' : 'true', 'alt' : '' });
            var replacementDiv = document.createElement('div');
            this.element.parentNode.appendChild(replacementDiv);
            replacementDiv.appendChild(origImage);
            this.element = replacementDiv;
            this.options.url = this.options.url || origImage.src;
        }

        _create.call(this);
        if (this.options.url) {
            var bindOpts = {
                url: this.options.url,
                points: this.options.points
            };
            delete this.options['url'];
            delete this.options['points'];
            _bind.call(this, bindOpts);
        }
    }

    Croppie.defaults = {
        viewport: {
            width: 100,
            height: 100,
            type: 'square'
        },
        boundary: { },
        orientationControls: {
            enabled: true,
            leftClass: '',
            rightClass: ''
        },
        resizeControls: {
            width: true,
            height: true
        },
        customClass: '',
        showZoomer: true,
        enableZoom: true,
        enableResize: false,
        mouseWheelZoom: true,
        enableExif: false,
        enforceBoundary: true,
        enableOrientation: false,
        enableKeyMovement: true,
        update: function () { }
    };

    Croppie.globals = {
        translate: 'translate3d'
    };

    deepExtend(Croppie.prototype, {
        bind: function (options, cb) {
            return _bind.call(this, options, cb);
        },
        get: function () {
            var data = _get.call(this);
            var points = data.points;
            if (this.options.relative) {
                points[0] /= this.elements.img.naturalWidth ../../../default.htm 100;
                points[1] /= this.elements.img.naturalHeight ../../../default.htm 100;
                points[2] /= this.elements.img.naturalWidth ../../../default.htm 100;
                points[3] /= this.elements.img.naturalHeight ../../../default.htm 100;
            }
            return data;
        },
        result: function (type) {
            return _result.call(this, type);
        },
        refresh: function () {
            return _refresh.call(this);
        },
        setZoom: function (v) {
            _setZoomerVal.call(this, v);
            dispatchChange(this.elements.zoomer);
        },
        rotate: function (deg) {
            _rotate.call(this, deg);
        },
        destroy: function () {
            return _destroy.call(this);
        }
    });

    exports.Croppie = window.Croppie = Croppie;
}));

/*! FileAPI 2.1.1 - BSD | git://github.com/mailru/FileAPI.git
 * FileAPI — a set of  javascript tools for working with files. Multiupload, drag'n'drop and chunked file upload. Images: crop, resize and auto orientation by EXIF.
 ../../../_/default.htm

/*
 * JavaScript Canvas to Blob 2.0.5
 * https://github.com/blueimp/JavaScript-Canvas-to-Blob
 *
 * Copyright 2012, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 *
 * Based on stackoverflow user Stoive's code snippet:
 * http://stackoverflow.com/q/4998908
 ../../../_/default.htm

/*jslint nomen: true, regexp: true ../../../_/default.htm
/*global window, atob, Blob, ArrayBuffer, Uint8Array ../../../_/default.htm

(function (window) {
    'use strict';
    var CanvasPrototype = window.HTMLCanvasElement &&
            window.HTMLCanvasElement.prototype,
        hasBlobConstructor = window.Blob && (function () {
            try {
                return Boolean(new Blob());
            } catch (e) {
                return false;
            }
        }()),
        hasArrayBufferViewSupport = hasBlobConstructor && window.Uint8Array &&
            (function () {
                try {
                    return new Blob([new Uint8Array(100)]).size === 100;
                } catch (e) {
                    return false;
                }
            }()),
        BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder ||
            window.MozBlobBuilder || window.MSBlobBuilder,
        dataURLtoBlob = (hasBlobConstructor || BlobBuilder) && window.atob &&
            window.ArrayBuffer && window.Uint8Array && function (dataURI) {
                var byteString,
                    arrayBuffer,
                    intArray,
                    i,
                    mimeString,
                    bb;
                if (dataURI.split(',')[0].indexOf('base64') >= 0) {
                    // Convert base64 to raw binary data held in a string:
                    byteString = atob(dataURI.split(',')[1]);
                } else {
                    // Convert base64/URLEncoded data component to raw binary data:
                    byteString = decodeURIComponent(dataURI.split(',')[1]);
                }
                // Write the bytes of the string to an ArrayBuffer:
                arrayBuffer = new ArrayBuffer(byteString.length);
                intArray = new Uint8Array(arrayBuffer);
                for (i = 0; i < byteString.length; i += 1) {
                    intArray[i] = byteString.charCodeAt(i);
                }
                // Separate out the mime component:
                mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
                // Write the ArrayBuffer (or ArrayBufferView) to a blob:
                if (hasBlobConstructor) {
                    return new Blob(
                        [hasArrayBufferViewSupport ? intArray : arrayBuffer],
                        {type: mimeString}
                    );
                }
                bb = new BlobBuilder();
                bb.append(arrayBuffer);
                return bb.getBlob(mimeString);
            };
    if (window.HTMLCanvasElement && !CanvasPrototype.toBlob) {
        if (CanvasPrototype.mozGetAsFile) {
            CanvasPrototype.toBlob = function (callback, type, quality) {
                if (quality && CanvasPrototype.toDataURL && dataURLtoBlob) {
                    callback(dataURLtoBlob(this.toDataURL(type, quality)));
                } else {
                    callback(this.mozGetAsFile('blob', type));
                }
            };
        } else if (CanvasPrototype.toDataURL && dataURLtoBlob) {
            CanvasPrototype.toBlob = function (callback, type, quality) {
                callback(dataURLtoBlob(this.toDataURL(type, quality)));
            };
        }
    }
    window.dataURLtoBlob = dataURLtoBlob;
})(window);

/*jslint evil: true ../../../_/default.htm
/*global window, URL, webkitURL, ActiveXObject ../../../_/default.htm

(function (window, undef){
	'use strict';

	var
		gid = 1,
		noop = function (){},

		document = window.document,
		doctype = document.doctype || {},
		userAgent = window.navigator.userAgent,
		safari = /safari\//i.test(userAgent) && !/chrome\//i.test(userAgent),
		iemobile = /iemobile\//i.test(userAgent),
		insecureChrome = !safari && /chrome\//i.test(userAgent) && window.location.protocol === 'http:',

		// https://github.com/blueimp/JavaScript-Load-Image/blob/master/load-image.js#L48
		apiURL = (window.createObjectURL && window) || (window.URL && URL.revokeObjectURL && URL) || (window.webkitURL && webkitURL),

		Blob = window.Blob,
		File = window.File,
		FileReader = window.FileReader,
		FormData = window.FormData,


		XMLHttpRequest = window.XMLHttpRequest,
		jQuery = window.jQuery,

		html5 =    !!(File && (FileReader && (window.Uint8Array || FormData || XMLHttpRequest.prototype.sendAsBinary)))
				&& !(safari && /windows/i.test(userAgent) && !iemobile), // BugFix: https://github.com/mailru/FileAPI/issues/25

		cors = html5 && ('withCredentials' in (new XMLHttpRequest)),

		chunked = html5 && !!Blob && !!(Blob.prototype.webkitSlice || Blob.prototype.mozSlice || Blob.prototype.slice),

		normalize = ('' + ''.normalize).indexOf('[native code]') > 0,

		// https://github.com/blueimp/JavaScript-Canvas-to-Blob
		dataURLtoBlob = window.dataURLtoBlob,


		_rimg = /img/i,
		_rcanvas = /canvas/i,
		_rimgcanvas = /img|canvas/i,
		_rinput = /input/i,
		_rdata = /^data:[^,]+,/,

		_toString = {}.toString,
		_supportConsoleLog,
		_supportConsoleLogApply,


		Math = window.Math,

		_SIZE_CONST = function (pow){
			pow = new window.Number(Math.pow(1024, pow));
			pow.from = function (sz){ return Math.round(sz * this); };
			return	pow;
		},

		_elEvents = {}, // element event listeners
		_infoReader = [], // list of file info processors

		_readerEvents = 'abort progress error load loadend',
		_xhrPropsExport = 'status statusText readyState response responseXML responseText responseBody'.split(' '),

		currentTarget = 'currentTarget', // for minimize
		preventDefault = 'preventDefault', // and this too

		_isArray = function (ar) {
			return	ar && ('length' in ar);
		},

		/**
		 * Iterate over a object or array
		 ../../../_/default.htm
		_each = function (obj, fn, ctx){
			if( obj ){
				if( _isArray(obj) ){
					for( var i = 0, n = obj.length; i < n; i++ ){
						if( i in obj ){
							fn.call(ctx, obj[i], i, obj);
						}
					}
				}
				else {
					for( var key in obj ){
						if( obj.hasOwnProperty(key) ){
							fn.call(ctx, obj[key], key, obj);
						}
					}
				}
			}
		},

		/**
		 * Merge the contents of two or more objects together into the first object
		 ../../../_/default.htm
		_extend = function (dst){
			var args = arguments, i = 1, _ext = function (val, key){ dst[key] = val; };
			for( ; i < args.length; i++ ){
				_each(args[i], _ext);
			}
			return  dst;
		},

		/**
		 * Add event listener
		 ../../../_/default.htm
		_on = function (el, type, fn){
			if( el ){
				var uid = api.uid(el);

				if( !_elEvents[uid] ){
					_elEvents[uid] = {};
				}

				var isFileReader = (FileReader && el) && (el instanceof FileReader);
				_each(type.split(/\s+/), function (type){
					if( jQuery && !isFileReader){
						jQuery.event.add(el, type, fn);
					} else {
						if( !_elEvents[uid][type] ){
							_elEvents[uid][type] = [];
						}

						_elEvents[uid][type].push(fn);

						if( el.addEventListener ){ el.addEventListener(type, fn, false); }
						else if( el.attachEvent ){ el.attachEvent('on'+type, fn); }
						else { el['on'+type] = fn; }
					}
				});
			}
		},


		/**
		 * Remove event listener
		 ../../../_/default.htm
		_off = function (el, type, fn){
			if( el ){
				var uid = api.uid(el), events = _elEvents[uid] || {};

				var isFileReader = (FileReader && el) && (el instanceof FileReader);
				_each(type.split(/\s+/), function (type){
					if( jQuery && !isFileReader){
						jQuery.event.remove(el, type, fn);
					}
					else {
						var fns = events[type] || [], i = fns.length;

						while( i-- ){
							if( fns[i] === fn ){
								fns.splice(i, 1);
								break;
							}
						}

						if( el.addEventListener ){ el.removeEventListener(type, fn, false); }
						else if( el.detachEvent ){ el.detachEvent('on'+type, fn); }
						else { el['on'+type] = null; }
					}
				});
			}
		},


		_one = function(el, type, fn){
			_on(el, type, function _(evt){
				_off(el, type, _);
				fn(evt);
			});
		},


		_fixEvent = function (evt){
			if( !evt.target ){ evt.target = window.event && window.event.srcElement || document; }
			if( evt.target.nodeType === 3 ){ evt.target = evt.target.parentNode; }
			return  evt;
		},


		_supportInputAttr = function (attr){
			var input = document.createElement('input');
			input.setAttribute('type', "file");
			return attr in input;
		},


		/**
		 * FileAPI (core object)
		 ../../../_/default.htm
		api = {
			version: '2.1.1',

			cors: false,
			html5: true,
			media: false,
			formData: true,
			multiPassResize: true,
			insecureChrome: insecureChrome,

			debug: false,
			pingUrl: false,
			multiFlash: false,
			flashAbortTimeout: 0,
			withCredentials: true,

			staticPath: '../../../dist/default.htm',

			flashUrl: 0, // @default: '../../../FileAPI.flash.swf'
			flashImageUrl: 0, // @default: '../../../FileAPI.flash.image.swf'

			postNameConcat: function (name, idx){
				return	name + (idx != null ? '['+ idx +']' : '');
			},

			ext2mime: {
				  jpg:	'image/jpeg'
				, tif:	'image/tiff'
				, txt:	'text/plain'
			},

			// Fallback for flash
			accept: {
				  'image/*': 'art bm bmp dwg dxf cbr cbz fif fpx gif ico iefs jfif jpe jpeg jpg jps jut mcf nap nif pbm pcx pgm pict pm png pnm qif qtif ras rast rf rp svf tga tif tiff xbm xbm xpm xwd'
				, 'audio/*': 'm4a flac aac rm mpa wav wma ogg mp3 mp2 m3u mod amf dmf dsm far gdm imf it m15 med okt s3m stm sfx ult uni xm sid ac3 dts cue aif aiff wpl ape mac mpc mpp shn wv nsf spc gym adplug adx dsp adp ymf ast afc hps xs'
				, 'video/*': 'm4v 3gp nsv ts ty strm rm rmvb m3u ifo mov qt divx xvid bivx vob nrg img iso pva wmv asf asx ogm m2v avi bin dat dvr-ms mpg mpeg mp4 mkv avc vp3 svq3 nuv viv dv fli flv wpl'
			},

			uploadRetry : 0,
			networkDownRetryTimeout : 5000, // milliseconds, don't flood when network is down

			chunkSize : 0,
			chunkUploadRetry : 0,
			chunkNetworkDownRetryTimeout : 2000, // milliseconds, don't flood when network is down

			KB: _SIZE_CONST(1),
			MB: _SIZE_CONST(2),
			GB: _SIZE_CONST(3),
			TB: _SIZE_CONST(4),

			EMPTY_PNG: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQIW2NkAAIAAAoAAggA9GkAAAAASUVORK5CYII=',

			expando: 'fileapi' + (new Date).getTime(),

			uid: function (obj){
				return	obj
					? (obj[api.expando] = obj[api.expando] || api.uid())
					: (++gid, api.expando + gid)
				;
			},

			log: function (){
				if( api.debug && _supportConsoleLog ){
					if( _supportConsoleLogApply ){
						console.log.apply(console, arguments);
					}
					else {
						console.log([].join.call(arguments, ' '));
					}
				}
			},

			/**
			 * Create new image
			 *
			 * @param {String} [src]
			 * @param {Function} [fn]   1. error -- boolean, 2. img -- Image element
			 * @returns {HTMLElement}
			 ../../../_/default.htm
			newImage: function (src, fn){
				var img = document.createElement('img');
				if( fn ){
					api.event.one(img, 'error load', function (evt){
						fn(evt.type == 'error', img);
						img = null;
					});
				}
				img.src = src;
				return	img;
			},

			/**
			 * Get XHR
			 * @returns {XMLHttpRequest}
			 ../../../_/default.htm
			getXHR: function (){
				var xhr;

				if( XMLHttpRequest ){
					xhr = new XMLHttpRequest;
				}
				else if( window.ActiveXObject ){
					try {
						xhr = new ActiveXObject('MSXML2.XMLHttp.3.0');
					} catch (e) {
						xhr = new ActiveXObject('Microsoft.XMLHTTP');
					}
				}

				return  xhr;
			},

			isArray: _isArray,

			support: {
				dnd:     cors && ('ondrop' in document.createElement('div')),
				cors:    cors,
				html5:   html5,
				chunked: chunked,
				dataURI: true,
				accept:   _supportInputAttr('accept'),
				multiple: _supportInputAttr('multiple')
			},

			event: {
				  on: _on
				, off: _off
				, one: _one
				, fix: _fixEvent
			},


			throttle: function(fn, delay) {
				var id, args;

				return function _throttle(){
					args = arguments;

					if( !id ){
						fn.apply(window, args);
						id = setTimeout(function (){
							id = 0;
							fn.apply(window, args);
						}, delay);
					}
				};
			},


			F: function (){},


			parseJSON: function (str){
				var json;
				if( window.JSON && JSON.parse ){
					json = JSON.parse(str);
				}
				else {
					json = (new Function('return ('+str.replace(/([\r\n])/g, '\\$1')+');'))();
				}
				return json;
			},


			trim: function (str){
				str = String(str);
				return	str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
			},

			/**
			 * Simple Defer
			 * @return	{Object}
			 ../../../_/default.htm
			defer: function (){
				var
					  list = []
					, result
					, error
					, defer = {
						resolve: function (err, res){
							defer.resolve = noop;
							error	= err || false;
							result	= res;

							while( res = list.shift() ){
								res(error, result);
							}
						},

						then: function (fn){
							if( error !== undef ){
								fn(error, result);
							} else {
								list.push(fn);
							}
						}
				};

				return	defer;
			},

			queue: function (fn){
				var
					  _idx = 0
					, _length = 0
					, _fail = false
					, _end = false
					, queue = {
						inc: function (){
							_length++;
						},

						next: function (){
							_idx++;
							setTimeout(queue.check, 0);
						},

						check: function (){
							(_idx >= _length) && !_fail && queue.end();
						},

						isFail: function (){
							return _fail;
						},

						fail: function (){
							!_fail && fn(_fail = true);
						},

						end: function (){
							if( !_end ){
								_end = true;
								fn();
							}
						}
					}
				;
				return queue;
			},


			/**
			 * For each object
			 *
			 * @param	{Object|Array}	obj
			 * @param	{Function}		fn
			 * @param	{*}				[ctx]
			 ../../../_/default.htm
			each: _each,


			/**
			 * Async for
			 * @param {Array} array
			 * @param {Function} callback
			 ../../../_/default.htm
			afor: function (array, callback){
				var i = 0, n = array.length;

				if( _isArray(array) && n-- ){
					(function _next(){
						callback(n != i && _next, array[i], i++);
					})();
				}
				else {
					callback(false);
				}
			},


			/**
			 * Merge the contents of two or more objects together into the first object
			 *
			 * @param	{Object}	dst
			 * @return	{Object}
			 ../../../_/default.htm
			extend: _extend,


			/**
			 * Is file?
			 * @param  {File}  file
			 * @return {Boolean}
			 ../../../_/default.htm
			isFile: function (file){
				return _toString.call(file) === '[object File]';
			},


			/**
			 * Is blob?
			 * @param   {Blob}  blob
			 * @returns {Boolean}
			 ../../../_/default.htm
			isBlob: function (blob) {
				return this.isFile(blob) || (_toString.call(blob) === '[object Blob]');
			},


			/**
			 * Is canvas element
			 *
			 * @param	{HTMLElement}	el
			 * @return	{Boolean}
			 ../../../_/default.htm
			isCanvas: function (el){
				return	el && _rcanvas.test(el.nodeName);
			},


			getFilesFilter: function (filter){
				filter = typeof filter == 'string' ? filter : (filter.getAttribute && filter.getAttribute('accept') || '');
				return	filter ? new RegExp('('+ filter.replace(/\./g, '\\.').replace(/,/g, '|') +')$', 'i') : /./;
			},



			/**
			 * Read as DataURL
			 *
			 * @param {File|Element} file
			 * @param {Function} fn
			 ../../../_/default.htm
			readAsDataURL: function (file, fn){
				if( api.isCanvas(file) ){
					_emit(file, fn, 'load', api.toDataURL(file));
				}
				else {
					_readAs(file, fn, 'DataURL');
				}
			},


			/**
			 * Read as Binary string
			 *
			 * @param {File} file
			 * @param {Function} fn
			 ../../../_/default.htm
			readAsBinaryString: function (file, fn){
				if( _hasSupportReadAs('BinaryString') ){
					_readAs(file, fn, 'BinaryString');
				} else {
					// Hello IE10!
					_readAs(file, function (evt){
						if( evt.type == 'load' ){
							try {
								// dataURL -> binaryString
								evt.result = api.toBinaryString(evt.result);
							} catch (e){
								evt.type = 'error';
								evt.message = e.toString();
							}
						}
						fn(evt);
					}, 'DataURL');
				}
			},


			/**
			 * Read as ArrayBuffer
			 *
			 * @param {File} file
			 * @param {Function} fn
			 ../../../_/default.htm
			readAsArrayBuffer: function(file, fn){
				_readAs(file, fn, 'ArrayBuffer');
			},


			/**
			 * Read as text
			 *
			 * @param {File} file
			 * @param {String} encoding
			 * @param {Function} [fn]
			 ../../../_/default.htm
			readAsText: function(file, encoding, fn){
				if( !fn ){
					fn	= encoding;
					encoding = 'utf-8';
				}

				_readAs(file, fn, 'Text', encoding);
			},


			/**
			 * Convert image or canvas to DataURL
			 *
			 * @param   {Element}  el      Image or Canvas element
			 * @param   {String}   [type]  mime-type
			 * @return  {String}
			 ../../../_/default.htm
			toDataURL: function (el, type){
				if( typeof el == 'string' ){
					return  el;
				}
				else if( el.toDataURL ){
					return  el.toDataURL(type || 'image/png');
				}
			},


			/**
			 * Canvert string, image or canvas to binary string
			 *
			 * @param   {String|Element} val
			 * @return  {String}
			 ../../../_/default.htm
			toBinaryString: function (val){
				return  window.atob(api.toDataURL(val).replace(_rdata, ''));
			},


			/**
			 * Read file or DataURL as ImageElement
			 *
			 * @param	{File|String}	file
			 * @param	{Function}		fn
			 * @param	{Boolean}		[progress]
			 ../../../_/default.htm
			readAsImage: function (file, fn, progress){
				if( api.isBlob(file) ){
					if( apiURL ){
						/** @namespace apiURL.createObjectURL ../../../_/default.htm
						var data = apiURL.createObjectURL(file);
						if( data === undef ){
							_emit(file, fn, 'error');
						}
						else {
							api.readAsImage(data, fn, progress);
						}
					}
					else {
						api.readAsDataURL(file, function (evt){
							if( evt.type == 'load' ){
								api.readAsImage(evt.result, fn, progress);
							}
							else if( progress || evt.type == 'error' ){
								_emit(file, fn, evt, null, { loaded: evt.loaded, total: evt.total });
							}
						});
					}
				}
				else if( api.isCanvas(file) ){
					_emit(file, fn, 'load', file);
				}
				else if( _rimg.test(file.nodeName) ){
					if( file.complete ){
						_emit(file, fn, 'load', file);
					}
					else {
						var events = 'error abort load';
						_one(file, events, function _fn(evt){
							if( evt.type == 'load' && apiURL ){
								/** @namespace apiURL.revokeObjectURL ../../../_/default.htm
								apiURL.revokeObjectURL(file.src);
							}

							_off(file, events, _fn);
							_emit(file, fn, evt, file);
						});
					}
				}
				else if( file.iframe ){
					_emit(file, fn, { type: 'error' });
				}
				else {
					// Created image
					var img = api.newImage(file.dataURL || file);
					api.readAsImage(img, fn, progress);
				}
			},


			/**
			 * Make file by name
			 *
			 * @param	{String}	name
			 * @return	{Array}
			 ../../../_/default.htm
			checkFileObj: function (name){
				var file = {}, accept = api.accept;

				if( typeof name == 'object' ){
					file = name;
				}
				else {
					file.name = (name + '').split(/\\|\//g).pop();
				}

				if( file.type == null ){
					file.type = file.name.split('.').pop();
				}

				_each(accept, function (ext, type){
					ext = new RegExp(ext.replace(/\s/g, '|'), 'i');
					if( ext.test(file.type) || api.ext2mime[file.type] ){
						file.type = api.ext2mime[file.type] || (type.split('../../../default.htm')[0] +'../../../default.htm'+ file.type);
					}
				});

				return	file;
			},


			/**
			 * Get drop files
			 *
			 * @param	{Event}	evt
			 * @param	{Function} callback
			 ../../../_/default.htm
			getDropFiles: function (evt, callback){
				var
					  files = []
					, all = []
					, items
					, dataTransfer = _getDataTransfer(evt)
					, transFiles = dataTransfer.files
					, transItems = dataTransfer.items
					, entrySupport = _isArray(transItems) && transItems[0] && _getAsEntry(transItems[0])
					, queue = api.queue(function (){ callback(files, all); })
				;

				if( entrySupport ){
					if( normalize && transFiles ){
						var
							i = transFiles.length
							, file
							, entry
						;

						items = new Array(i);
						while( i-- ){
							file = transFiles[i];

							try {
								entry = _getAsEntry(transItems[i]);
							}
							catch( err ){
								api.log('[err] getDropFiles: ', err);
								entry = null;
							}

							if( _isEntry(entry) ){
								// OSX filesystems use Unicode Normalization Form D (NFD),
								// and entry.file(…) can't read the files with the same names
								if( entry.isDirectory || (entry.isFile && file.name == file.name.normalize('NFC')) ){
									items[i] = entry;
								}
								else {
									items[i] = file;
								}
							}
							else {
								items[i] = file;
							}
						}
					}
					else {
						items = transItems;
					}
				}
				else {
					items = transFiles;
				}

				_each(items || [], function (item){
					queue.inc();

					try {
						if( entrySupport && _isEntry(item) ){
							_readEntryAsFiles(item, function (err, entryFiles, allEntries){
								if( err ){
									api.log('[err] getDropFiles:', err);
								} else {
									files.push.apply(files, entryFiles);
								}
								all.push.apply(all, allEntries);

								queue.next();
							});
						}
						else {
							_isRegularFile(item, function (yes, err){
								if( yes ){
									files.push(item);
								}
								else {
									item.error = err;
								}
								all.push(item);

								queue.next();
							});
						}
					}
					catch( err ){
						queue.next();
						api.log('[err] getDropFiles: ', err);
					}
				});

				queue.check();
			},


			/**
			 * Get file list
			 *
			 * @param	{HTMLInputElement|Event}	input
			 * @param	{String|Function}	[filter]
			 * @param	{Function}			[callback]
			 * @return	{Array|Null}
			 ../../../_/default.htm
			getFiles: function (input, filter, callback){
				var files = [];

				if( callback ){
					api.filterFiles(api.getFiles(input), filter, callback);
					return null;
				}

				if( input.jquery ){
					// jQuery object
					input.each(function (){
						files = files.concat(api.getFiles(this));
					});
					input	= files;
					files	= [];
				}

				if( typeof filter == 'string' ){
					filter	= api.getFilesFilter(filter);
				}

				if( input.originalEvent ){
					// jQuery event
					input = _fixEvent(input.originalEvent);
				}
				else if( input.srcElement ){
					// IE Event
					input = _fixEvent(input);
				}


				if( input.dataTransfer ){
					// Drag'n'Drop
					input = input.dataTransfer;
				}
				else if( input.target ){
					// Event
					input = input.target;
				}

				if( input.files ){
					// Input[type="file"]
					files = input.files;

					if( !html5 ){
						// Partial support for file api
						files[0].blob	= input;
						files[0].iframe	= true;
					}
				}
				else if( !html5 && isInputFile(input) ){
					if( api.trim(input.value) ){
						files = [api.checkFileObj(input.value)];
						files[0].blob   = input;
						files[0].iframe = true;
					}
				}
				else if( _isArray(input) ){
					files	= input;
				}

				return	api.filter(files, function (file){ return !filter || filter.test(file.name); });
			},


			/**
			 * Get total file size
			 * @param	{Array}	files
			 * @return	{Number}
			 ../../../_/default.htm
			getTotalSize: function (files){
				var size = 0, i = files && files.length;
				while( i-- ){
					size += files[i].size;
				}
				return	size;
			},


			/**
			 * Get image information
			 *
			 * @param	{File}		file
			 * @param	{Function}	fn
			 ../../../_/default.htm
			getInfo: function (file, fn){
				var info = {}, readers = _infoReader.concat();

				if( api.isBlob(file) ){
					(function _next(){
						var reader = readers.shift();
						if( reader ){
							if( reader.test(file.type) ){
								reader(file, function (err, res){
									if( err ){
										fn(err);
									}
									else {
										_extend(info, res);
										_next();
									}
								});
							}
							else {
								_next();
							}
						}
						else {
							fn(false, info);
						}
					})();
				}
				else {
					fn('not_support_info', info);
				}
			},


			/**
			 * Add information reader
			 *
			 * @param {RegExp} mime
			 * @param {Function} fn
			 ../../../_/default.htm
			addInfoReader: function (mime, fn){
				fn.test = function (type){ return mime.test(type); };
				_infoReader.push(fn);
			},


			/**
			 * Filter of array
			 *
			 * @param	{Array}		input
			 * @param	{Function}	fn
			 * @return	{Array}
			 ../../../_/default.htm
			filter: function (input, fn){
				var result = [], i = 0, n = input.length, val;

				for( ; i < n; i++ ){
					if( i in input ){
						val = input[i];
						if( fn.call(val, val, i, input) ){
							result.push(val);
						}
					}
				}

				return	result;
			},


			/**
			 * Filter files
			 *
			 * @param	{Array}		files
			 * @param	{Function}	eachFn
			 * @param	{Function}	resultFn
			 ../../../_/default.htm
			filterFiles: function (files, eachFn, resultFn){
				if( files.length ){
					// HTML5 or Flash
					var queue = files.concat(), file, result = [], deleted = [];

					(function _next(){
						if( queue.length ){
							file = queue.shift();
							api.getInfo(file, function (err, info){
								(eachFn(file, err ? false : info) ? result : deleted).push(file);
								_next();
							});
						}
						else {
							resultFn(result, deleted);
						}
					})();
				}
				else {
					resultFn([], files);
				}
			},


			upload: function (options){
				options = _extend({
					  jsonp: 'callback'
					, prepare: api.F
					, beforeupload: api.F
					, upload: api.F
					, fileupload: api.F
					, fileprogress: api.F
					, filecomplete: api.F
					, progress: api.F
					, complete: api.F
					, pause: api.F
					, imageOriginal: true
					, chunkSize: api.chunkSize
					, chunkUploadRetry: api.chunkUploadRetry
					, uploadRetry: api.uploadRetry
				}, options);


				if( options.imageAutoOrientation && !options.imageTransform ){
					options.imageTransform = { rotate: 'auto' };
				}


				var
					  proxyXHR = new api.XHR(options)
					, dataArray = this._getFilesDataArray(options.files)
					, _this = this
					, _total = 0
					, _loaded = 0
					, _nextFile
					, _complete = false
				;


				// calc total size
				_each(dataArray, function (data){
					_total += data.size;
				});

				// Array of files
				proxyXHR.files = [];
				_each(dataArray, function (data){
					proxyXHR.files.push(data.file);
				});

				// Set upload status props
				proxyXHR.total	= _total;
				proxyXHR.loaded	= 0;
				proxyXHR.filesLeft = dataArray.length;

				// emit "beforeupload"  event
				options.beforeupload(proxyXHR, options);

				// Upload by file
				_nextFile = function (){
					var
						  data = dataArray.shift()
						, _file = data && data.file
						, _fileLoaded = false
						, _fileOptions = _simpleClone(options)
					;

					proxyXHR.filesLeft = dataArray.length;

					if( _file && _file.name === api.expando ){
						_file = null;
						api.log('[warn] FileAPI.upload() — called without files');
					}

					if( ( proxyXHR.statusText != 'abort' || proxyXHR.current ) && data ){
						// Mark active job
						_complete = false;

						// Set current upload file
						proxyXHR.currentFile = _file;

						// Prepare file options
						if (_file && options.prepare(_file, _fileOptions) === false) {
							_nextFile.call(_this);
							return;
						}
						_fileOptions.file = _file;

						_this._getFormData(_fileOptions, data, function (form){
							if( !_loaded ){
								// emit "upload" event
								options.upload(proxyXHR, options);
							}

							var xhr = new api.XHR(_extend({}, _fileOptions, {

								upload: _file ? function (){
									// emit "fileupload" event
									options.fileupload(_file, xhr, _fileOptions);
								} : noop,

								progress: _file ? function (evt){
									if( !_fileLoaded ){
										// For ignore the double calls.
										_fileLoaded = (evt.loaded === evt.total);

										// emit "fileprogress" event
										options.fileprogress({
											  type:   'progress'
											, total:  data.total = evt.total
											, loaded: data.loaded = evt.loaded
										}, _file, xhr, _fileOptions);

										// emit "progress" event
										options.progress({
											  type:   'progress'
											, total:  _total
											, loaded: proxyXHR.loaded = (_loaded + data.size * (evt.loaded/evt.total)) || 0
										}, _file, xhr, _fileOptions);
									}
								} : noop,

								complete: function (err){
									_each(_xhrPropsExport, function (name){
										proxyXHR[name] = xhr[name];
									});

									if( _file ){
										data.total = (data.total || data.size);
										data.loaded	= data.total;

										if( !err ) {
											// emulate 100% "progress"
											this.progress(data);

											// fixed throttle event
											_fileLoaded = true;

											// bytes loaded
											_loaded += data.size; // data.size != data.total, it's desirable fix this
											proxyXHR.loaded = _loaded;
										}

										// emit "filecomplete" event
										options.filecomplete(err, xhr, _file, _fileOptions);
									}

									// upload next file
									setTimeout(function () {_nextFile.call(_this);}, 0);
								}
							})); // xhr


							// ...
							proxyXHR.abort = function (current){
								if (!current) { dataArray.length = 0; }
								this.current = current;
								xhr.abort();
							};

							// Start upload
							xhr.send(form);
						});
					}
					else {
						var successful = proxyXHR.status == 200 || proxyXHR.status == 201 || proxyXHR.status == 204;
						options.complete(successful ? false : (proxyXHR.statusText || 'error'), proxyXHR, options);
						// Mark done state
						_complete = true;
					}
				};


				// Next tick
				setTimeout(_nextFile, 0);


				// Append more files to the existing request
				// first - add them to the queue head/tail
				proxyXHR.append = function (files, first) {
					files = api._getFilesDataArray([].concat(files));

					_each(files, function (data) {
						_total += data.size;
						proxyXHR.files.push(data.file);
						if (first) {
							dataArray.unshift(data);
						} else {
							dataArray.push(data);
						}
					});

					proxyXHR.statusText = "";

					if( _complete ){
						_nextFile.call(_this);
					}
				};


				// Removes file from queue by file reference and returns it
				proxyXHR.remove = function (file) {
				    var i = dataArray.length, _file;
				    while( i-- ){
						if( dataArray[i].file == file ){
							_file = dataArray.splice(i, 1);
							_total -= _file.size;
						}
					}
					return	_file;
				};

				return proxyXHR;
			},


			_getFilesDataArray: function (data){
				var files = [], oFiles = {};

				if( isInputFile(data) ){
					var tmp = api.getFiles(data);
					oFiles[data.name || 'file'] = data.getAttribute('multiple') !== null ? tmp : tmp[0];
				}
				else if( _isArray(data) && isInputFile(data[0]) ){
					_each(data, function (input){
						oFiles[input.name || 'file'] = api.getFiles(input);
					});
				}
				else {
					oFiles = data;
				}

				_each(oFiles, function add(file, name){
					if( _isArray(file) ){
						_each(file, function (file){
							add(file, name);
						});
					}
					else if( file && (file.name || file.image) ){
						files.push({
							  name: name
							, file: file
							, size: file.size
							, total: file.size
							, loaded: 0
						});
					}
				});

				if( !files.length ){
					// Create fake `file` object
					files.push({ file: { name: api.expando } });
				}

				return	files;
			},


			_getFormData: function (options, data, fn){
				var
					  file = data.file
					, name = data.name
					, filename = file.name
					, filetype = file.type
					, trans = api.support.transform && options.imageTransform
					, Form = new api.Form
					, queue = api.queue(function (){ fn(Form); })
					, isOrignTrans = trans && _isOriginTransform(trans)
					, postNameConcat = api.postNameConcat
				;

				// Append data
				_each(options.data, function add(val, name){
					if( typeof val == 'object' ){
						_each(val, function (v, i){
							add(v, postNameConcat(name, i));
						});
					}
					else {
						Form.append(name, val);
					}
				});

				(function _addFile(file/**Object*/){
					if( file.image ){ // This is a FileAPI.Image
						queue.inc();

						file.toData(function (err, image){
							// @todo: требует рефакторинга и обработки ошибки
							if (file.file) {
								image.type = file.file.type;
								image.quality = file.matrix.quality;
								filename = file.file && file.file.name;
							}

							filename = filename || (new Date).getTime()+'.png';

							_addFile(image);
							queue.next();
						});
					}
					else if( api.Image && trans && (/^image/.test(file.type) || _rimgcanvas.test(file.nodeName)) ){
						queue.inc();

						if( isOrignTrans ){
							// Convert to array for transform function
							trans = [trans];
						}

						api.Image.transform(file, trans, options.imageAutoOrientation, function (err, images){
							if( isOrignTrans && !err ){
								if( !dataURLtoBlob && !api.flashEngine ){
									// Canvas.toBlob or Flash not supported, use multipart
									Form.multipart = true;
								}

								Form.append(name, images[0], filename,  trans[0].type || filetype);
							}
							else {
								var addOrigin = 0;

								if( !err ){
									_each(images, function (image, idx){
										if( !dataURLtoBlob && !api.flashEngine ){
											Form.multipart = true;
										}

										if( !trans[idx].postName ){
											addOrigin = 1;
										}

										Form.append(trans[idx].postName || postNameConcat(name, idx), image, filename, trans[idx].type || filetype);
									});
								}

								if( err || options.imageOriginal ){
									Form.append(postNameConcat(name, (addOrigin ? 'original' : null)), file, filename, filetype);
								}
							}

							queue.next();
						});
					}
					else if( filename !== api.expando ){
						Form.append(name, file, filename);
					}
				})(file);

				queue.check();
			},


			reset: function (inp, notRemove){
				var parent, clone;

				if( jQuery ){
					clone = jQuery(inp).clone(true).insertBefore(inp).val('')[0];
					if( !notRemove ){
						jQuery(inp).remove();
					}
				} else {
					parent  = inp.parentNode;
					clone   = parent.insertBefore(inp.cloneNode(true), inp);
					clone.value = '';

					if( !notRemove ){
						parent.removeChild(inp);
					}

					_each(_elEvents[api.uid(inp)], function (fns, type){
						_each(fns, function (fn){
							_off(inp, type, fn);
							_on(clone, type, fn);
						});
					});
				}

				return  clone;
			},


			/**
			 * Load remote file
			 *
			 * @param   {String}    url
			 * @param   {Function}  fn
			 * @return  {XMLHttpRequest}
			 ../../../_/default.htm
			load: function (url, fn){
				var xhr = api.getXHR();
				if( xhr ){
					xhr.open('GET', url, true);

					if( xhr.overrideMimeType ){
				        xhr.overrideMimeType('text/plain; charset=x-user-defined');
					}

					_on(xhr, 'progress', function (/**Event*/evt){
						/** @namespace evt.lengthComputable ../../../_/default.htm
						if( evt.lengthComputable ){
							fn({ type: evt.type, loaded: evt.loaded, total: evt.total }, xhr);
						}
					});

					xhr.onreadystatechange = function(){
						if( xhr.readyState == 4 ){
							xhr.onreadystatechange = null;
							if( xhr.status == 200 ){
								url = url.split('../../../default.htm');
								/** @namespace xhr.responseBody ../../../_/default.htm
								var file = {
								      name: url[url.length-1]
									, size: xhr.getResponseHeader('Content-Length')
									, type: xhr.getResponseHeader('Content-Type')
								};
								file.dataURL = 'data:'+file.type+';base64,' + api.encode64(xhr.responseBody || xhr.responseText);
								fn({ type: 'load', result: file }, xhr);
							}
							else {
								fn({ type: 'error' }, xhr);
							}
					    }
					};
				    xhr.send(null);
				} else {
					fn({ type: 'error' });
				}

				return  xhr;
			},

			encode64: function (str){
				var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=', outStr = '', i = 0;

				if( typeof str !== 'string' ){
					str	= String(str);
				}

				while( i < str.length ){
					//all three "& 0xff" added below are there to fix a known bug
					//with bytes returned by xhr.responseText
					var
						  byte1 = str.charCodeAt(i++) & 0xff
						, byte2 = str.charCodeAt(i++) & 0xff
						, byte3 = str.charCodeAt(i++) & 0xff
						, enc1 = byte1 >> 2
						, enc2 = ((byte1 & 3) << 4) | (byte2 >> 4)
						, enc3, enc4
					;

					if( isNaN(byte2) ){
						enc3 = enc4 = 64;
					} else {
						enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
						enc4 = isNaN(byte3) ? 64 : byte3 & 63;
					}

					outStr += b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4);
				}

				return  outStr;
			}

		} // api
	;


	function _emit(target, fn, name, res, ext){
		var evt = {
			  type:		name.type || name
			, target:	target
			, result:	res
		};
		_extend(evt, ext);
		fn(evt);
	}


	function _hasSupportReadAs(method){
		return	FileReader && !!FileReader.prototype['readAs' + method];
	}


	function _readAs(file, fn, method, encoding){
		if( api.isBlob(file) && _hasSupportReadAs(method) ){
			var Reader = new FileReader;

			// Add event listener
			_on(Reader, _readerEvents, function _fn(evt){
				var type = evt.type;
				if( type == 'progress' ){
					_emit(file, fn, evt, evt.target.result, { loaded: evt.loaded, total: evt.total });
				}
				else if( type == 'loadend' ){
					_off(Reader, _readerEvents, _fn);
					Reader = null;
				}
				else {
					_emit(file, fn, evt, evt.target.result);
				}
			});


			try {
				// ReadAs ...
				if( encoding ){
					Reader['readAs' + method](file, encoding);
				}
				else {
					Reader['readAs' + method](file);
				}
			}
			catch (err){
				_emit(file, fn, 'error', undef, { error: err.toString() });
			}
		}
		else {
			_emit(file, fn, 'error', undef, { error: 'filreader_not_support_' + method });
		}
	}


	function _isRegularFile(file, callback){
		// http://stackoverflow.com/questions/8856628/detecting-folders-directories-in-javascript-filelist-objects
		if( !file.type && (safari || ((file.size % 4096) === 0 && (file.size <= 102400))) ){
			if( FileReader ){
				try {
					var reader = new FileReader();

					_one(reader, _readerEvents, function (evt){
						var isFile = evt.type != 'error';
						if( isFile ){
							if ( reader.readyState == null || reader.readyState === reader.LOADING ) {
								reader.abort();
							}
							callback(isFile);
						}
						else {
							callback(false, reader.error);
						}
					});

					reader.readAsDataURL(file);
				} catch( err ){
					callback(false, err);
				}
			}
			else {
				callback(null, new Error('FileReader is not supported'));
			}
		}
		else {
			callback(true);
		}
	}


	function _isEntry(item){
		return item && (item.isFile || item.isDirectory);
	}


	function _getAsEntry(item){
		var entry;
		if( item.getAsEntry ){ entry = item.getAsEntry(); }
		else if( item.webkitGetAsEntry ){ entry = item.webkitGetAsEntry(); }
		return	entry;
	}


	function _readEntryAsFiles(entry, callback){
		if( !entry ){
			// error
			var err = new Error('invalid entry');
			entry = new Object(entry);
			entry.error = err;
			callback(err.message, [], [entry]);
		}
		else if( entry.isFile ){
			// Read as file
			entry.file(function (file){
				// success
				file.fullPath = entry.fullPath;
				callback(false, [file], [file]);
			}, function (err){
				// error
				entry.error = err;
				callback('FileError.code: ' + err.code, [], [entry]);
			});
		}
		else if( entry.isDirectory ){
			var
				reader = entry.createReader()
				, firstAttempt = true
				, files = []
				, all = [entry]
			;

			var onerror = function (err){
				// error
				entry.error = err;
				callback('DirectoryError.code: ' + err.code, files, all);
			};
			var ondone = function ondone(entries){
				if( firstAttempt ){
					firstAttempt = false;
					if( !entries.length ){
						entry.error = new Error('directory is empty');
					}
				}

				// success
				if( entries.length ){
					api.afor(entries, function (next, entry){
						_readEntryAsFiles(entry, function (err, entryFiles, allEntries){
							if( !err ){
								files = files.concat(entryFiles);
							}
							all = all.concat(allEntries);

							if( next ){
								next();
							}
							else {
								reader.readEntries(ondone, onerror);
							}
						});
					});
				}
				else {
					callback(false, files, all);
				}
			};

			reader.readEntries(ondone, onerror);
		}
		else {
			_readEntryAsFiles(_getAsEntry(entry), callback);
		}
	}


	function _simpleClone(obj){
		var copy = {};
		_each(obj, function (val, key){
			if( val && (typeof val === 'object') && (val.nodeType === void 0) ){
				val = _extend({}, val);
			}
			copy[key] = val;
		});
		return	copy;
	}


	function isInputFile(el){
		return	_rinput.test(el && el.tagName);
	}


	function _getDataTransfer(evt){
		return	(evt.originalEvent || evt || '').dataTransfer || {};
	}


	function _isOriginTransform(trans){
		var key;
		for( key in trans ){
			if( trans.hasOwnProperty(key) ){
				if( !(trans[key] instanceof Object || key === 'overlay' || key === 'filter') ){
					return	true;
				}
			}
		}
		return	false;
	}


	// Add default image info reader
	api.addInfoReader(/^image/, function (file/**File*/, callback/**Function*/){
		if( !file.__dimensions ){
			var defer = file.__dimensions = api.defer();

			api.readAsImage(file, function (evt){
				var img = evt.target;
				defer.resolve(evt.type == 'load' ? false : 'error', {
					  width:  img.width
					, height: img.height
				});
                img.src = api.EMPTY_PNG;
				img = null;
			});
		}

		file.__dimensions.then(callback);
	});


	/**
	 * Drag'n'Drop special event
	 *
	 * @param	{HTMLElement}	el
	 * @param	{Function}		onHover
	 * @param	{Function}		onDrop
	 ../../../_/default.htm
	api.event.dnd = function (el, onHover, onDrop){
		var _id, _type;

		if( !onDrop ){
			onDrop = onHover;
			onHover = api.F;
		}

		if( FileReader ){
			// Hover
			_on(el, 'dragenter dragleave dragover', onHover.ff = onHover.ff || function (evt){
				var
					  types = _getDataTransfer(evt).types
					, i = types && types.length
					, debounceTrigger = false
				;

				while( i-- ){
					if( ~types[i].indexOf('File') ){
						evt[preventDefault]();

						if( _type !== evt.type ){
							_type = evt.type; // Store current type of event

							if( _type != 'dragleave' ){
								onHover.call(evt[currentTarget], true, evt);
							}

							debounceTrigger = true;
						}

						break; // exit from "while"
					}
				}

				if( debounceTrigger ){
					clearTimeout(_id);
					_id = setTimeout(function (){
						onHover.call(evt[currentTarget], _type != 'dragleave', evt);
					}, 50);
				}
			});


			// Drop
			_on(el, 'drop', onDrop.ff = onDrop.ff || function (evt){
				evt[preventDefault]();

				_type = 0;

				api.getDropFiles(evt, function (files, all){
					onDrop.call(evt[currentTarget], files, all, evt);
				});
				
				onHover.call(evt[currentTarget], false, evt);
			});
		}
		else {
			api.log("Drag'n'Drop -- not supported");
		}
	};


	/**
	 * Remove drag'n'drop
	 * @param	{HTMLElement}	el
	 * @param	{Function}		onHover
	 * @param	{Function}		onDrop
	 ../../../_/default.htm
	api.event.dnd.off = function (el, onHover, onDrop){
		_off(el, 'dragenter dragleave dragover', onHover.ff);
		_off(el, 'drop', onDrop.ff);
	};


	// Support jQuery
	if( jQuery && !jQuery.fn.dnd ){
		jQuery.fn.dnd = function (onHover, onDrop){
			return this.each(function (){
				api.event.dnd(this, onHover, onDrop);
			});
		};

		jQuery.fn.offdnd = function (onHover, onDrop){
			return this.each(function (){
				api.event.dnd.off(this, onHover, onDrop);
			});
		};
	}

	// @export
	window.FileAPI  = _extend(api, window.FileAPI);


	// Debug info
	api.log('FileAPI: ' + api.version);
	api.log('protocol: ' + window.location.protocol);
	api.log('doctype: [' + doctype.name + '] ' + doctype.publicId + ' ' + doctype.systemId);


	// @detect 'x-ua-compatible'
	_each(document.getElementsByTagName('meta'), function (meta){
		if( /x-ua-compatible/i.test(meta.getAttribute('http-equiv')) ){
			api.log('meta.http-equiv: ' + meta.getAttribute('content'));
		}
	});


	// Configuration
	try {
		_supportConsoleLog = !!console.log;
		_supportConsoleLogApply = !!console.log.apply;
	}
	catch (err) {}

	if( !api.flashUrl ){ api.flashUrl = api.staticPath + '../../../FileAPI.flash.swf'; }
	if( !api.flashImageUrl ){ api.flashImageUrl = api.staticPath + '../../../FileAPI.flash.image.swf'; }
	if( !api.flashWebcamUrl ){ api.flashWebcamUrl = api.staticPath + '../../../FileAPI.flash.camera.swf'; }
})(window, void 0);

/*global window, FileAPI, document ../../../_/default.htm

(function (api, document, undef) {
	'use strict';

	var
		min = Math.min,
		round = Math.round,
		getCanvas = function () { return document.createElement('canvas'); },
		support = false,
		exifOrientation = {
			  8:	270
			, 3:	180
			, 6:	90
			, 7:	270
			, 4:	180
			, 5:	90
		}
	;

	try {
		support = getCanvas().toDataURL('image/png').indexOf('data:image/png') > -1;
	}
	catch (e){}


	function Image(file){
		if( file instanceof Image ){
			var img = new Image(file.file);
			api.extend(img.matrix, file.matrix);
			return	img;
		}
		else if( !(this instanceof Image) ){
			return	new Image(file);
		}

		this.file   = file;
		this.size   = file.size || 100;

		this.matrix	= {
			sx: 0,
			sy: 0,
			sw: 0,
			sh: 0,
			dx: 0,
			dy: 0,
			dw: 0,
			dh: 0,
			resize: 0, // min, max OR preview
			deg: 0,
			quality: 1, // jpeg quality
			filter: 0
		};
	}


	Image.prototype = {
		image: true,
		constructor: Image,

		set: function (attrs){
			api.extend(this.matrix, attrs);
			return	this;
		},

		crop: function (x, y, w, h){
			if( w === undef ){
				w	= x;
				h	= y;
				x = y = 0;
			}
			return	this.set({ sx: x, sy: y, sw: w, sh: h || w });
		},

		resize: function (w, h, strategy){
			if( /min|max|height|width/.test(h) ){
				strategy = h;
				h = w;
			}

			return	this.set({ dw: w, dh: h || w, resize: strategy });
		},

		preview: function (w, h){
			return	this.resize(w, h || w, 'preview');
		},

		rotate: function (deg){
			return	this.set({ deg: deg });
		},

		filter: function (filter){
			return	this.set({ filter: filter });
		},

		overlay: function (images){
			return	this.set({ overlay: images });
		},

		clone: function (){
			return	new Image(this);
		},

		_load: function (image, fn){
			var self = this;

			if( /img|video/i.test(image.nodeName) ){
				fn.call(self, null, image);
			}
			else {
				api.readAsImage(image, function (evt){
					fn.call(self, evt.type != 'load', evt.result);
				});
			}
		},

		_apply: function (image, fn){
			var
				  canvas = getCanvas()
				, m = this.getMatrix(image)
				, ctx = canvas.getContext('2d')
				, width = image.videoWidth || image.width
				, height = image.videoHeight || image.height
				, deg = m.deg
				, dw = m.dw
				, dh = m.dh
				, w = width
				, h = height
				, filter = m.filter
				, copy // canvas copy
				, buffer = image
				, overlay = m.overlay
				, queue = api.queue(function (){ image.src = api.EMPTY_PNG; fn(false, canvas); })
				, renderImageToCanvas = api.renderImageToCanvas
			;

			// Normalize angle
			deg = deg - Math.floor(deg/360)*360;

			// For `renderImageToCanvas`
			image._type = this.file.type;

			while(m.multipass && min(w/dw, h/dh) > 2 ){
				w = (w/2 + 0.5)|0;
				h = (h/2 + 0.5)|0;

				copy = getCanvas();
				copy.width  = w;
				copy.height = h;

				if( buffer !== image ){
					renderImageToCanvas(copy, buffer, 0, 0, buffer.width, buffer.height, 0, 0, w, h);
					buffer = copy;
				}
				else {
					buffer = copy;
					renderImageToCanvas(buffer, image, m.sx, m.sy, m.sw, m.sh, 0, 0, w, h);
					m.sx = m.sy = m.sw = m.sh = 0;
				}
			}


			canvas.width  = (deg % 180) ? dh : dw;
			canvas.height = (deg % 180) ? dw : dh;

			canvas.type = m.type;
			canvas.quality = m.quality;

			ctx.rotate(deg * Math.PI ../../../default.htm 180);
			renderImageToCanvas(ctx.canvas, buffer
				, m.sx, m.sy
				, m.sw || buffer.width
				, m.sh || buffer.height
				, (deg == 180 || deg == 270 ? -dw : 0)
				, (deg == 90 || deg == 180 ? -dh : 0)
				, dw, dh
			);
			dw = canvas.width;
			dh = canvas.height;

			// Apply overlay
			overlay && api.each([].concat(overlay), function (over){
				queue.inc();
				// preload
				var img = new window.Image, fn = function (){
					var
						  x = over.x|0
						, y = over.y|0
						, w = over.w || img.width
						, h = over.h || img.height
						, rel = over.rel
					;

					// center  |  right  |  left
					x = (rel == 1 || rel == 4 || rel == 7) ? (dw - w + x)/2 : (rel == 2 || rel == 5 || rel == 8 ? dw - (w + x) : x);

					// center  |  bottom  |  top
					y = (rel == 3 || rel == 4 || rel == 5) ? (dh - h + y)/2 : (rel >= 6 ? dh - (h + y) : y);

					api.event.off(img, 'error load abort', fn);

					try {
						ctx.globalAlpha = over.opacity || 1;
						ctx.drawImage(img, x, y, w, h);
					}
					catch (er){}

					queue.next();
				};

				api.event.on(img, 'error load abort', fn);
				img.src = over.src;

				if( img.complete ){
					fn();
				}
			});

			if( filter ){
				queue.inc();
				Image.applyFilter(canvas, filter, queue.next);
			}

			queue.check();
		},

		getMatrix: function (image){
			var
				  m  = api.extend({}, this.matrix)
				, sw = m.sw = m.sw || image.videoWidth || image.naturalWidth ||  image.width
				, sh = m.sh = m.sh || image.videoHeight || image.naturalHeight || image.height
				, dw = m.dw = m.dw || sw
				, dh = m.dh = m.dh || sh
				, sf = sw/sh, df = dw/dh
				, strategy = m.resize
			;

			if( strategy == 'preview' ){
				if( dw != sw || dh != sh ){
					// Make preview
					var w, h;

					if( df >= sf ){
						w	= sw;
						h	= w ../../../default.htm df;
					} else {
						h	= sh;
						w	= h * df;
					}

					if( w != sw || h != sh ){
						m.sx	= ~~((sw - w)/2);
						m.sy	= ~~((sh - h)/2);
						sw		= w;
						sh		= h;
					}
				}
			}
			else if( strategy == 'height' ){
				dw = dh * sf;
			}
			else if( strategy == 'width' ){
				dh = dw ../../../default.htm sf;
			}
			else if( strategy ){
				if( !(sw > dw || sh > dh) ){
					dw = sw;
					dh = sh;
				}
				else if( strategy == 'min' ){
					dw = round(sf < df ? min(sw, dw) : dh*sf);
					dh = round(sf < df ? dw/sf : min(sh, dh));
				}
				else {
					dw = round(sf >= df ? min(sw, dw) : dh*sf);
					dh = round(sf >= df ? dw/sf : min(sh, dh));
				}
			}

			m.sw = sw;
			m.sh = sh;
			m.dw = dw;
			m.dh = dh;
			m.multipass = api.multiPassResize;
			return	m;
		},

		_trans: function (fn){
			this._load(this.file, function (err, image){
				if( err ){
					fn(err);
				}
				else {
					try {
						this._apply(image, fn);
					} catch (err){
						api.log('[err] FileAPI.Image.fn._apply:', err);
						fn(err);
					}
				}
			});
		},


		get: function (fn){
			if( api.support.transform ){
				var _this = this, matrix = _this.matrix;

				if( matrix.deg == 'auto' ){
					api.getInfo(_this.file, function (err, info){
						// rotate by exif orientation
						matrix.deg = exifOrientation[info && info.exif && info.exif.Orientation] || 0;
						_this._trans(fn);
					});
				}
				else {
					_this._trans(fn);
				}
			}
			else {
				fn('not_support_transform');
			}

			return this;
		},


		toData: function (fn){
			return this.get(fn);
		}

	};


	Image.exifOrientation = exifOrientation;


	Image.transform = function (file, transform, autoOrientation, fn){
		function _transform(err, img){
			// img -- info object
			var
				  images = {}
				, queue = api.queue(function (err){
					fn(err, images);
				})
			;

			if( !err ){
				api.each(transform, function (params, name){
					if( !queue.isFail() ){
						var ImgTrans = new Image(img.nodeType ? img : file), isFn = typeof params == 'function';

						if( isFn ){
							params(img, ImgTrans);
						}
						else if( params.width ){
							ImgTrans[params.preview ? 'preview' : 'resize'](params.width, params.height, params.strategy);
						}
						else {
							if( params.maxWidth && (img.width > params.maxWidth || img.height > params.maxHeight) ){
								ImgTrans.resize(params.maxWidth, params.maxHeight, 'max');
							}
						}

						if( params.crop ){
							var crop = params.crop;
							ImgTrans.crop(crop.x|0, crop.y|0, crop.w || crop.width, crop.h || crop.height);
						}

						if( params.rotate === undef && autoOrientation ){
							params.rotate = 'auto';
						}

						ImgTrans.set({ type: ImgTrans.matrix.type || params.type || file.type || 'image/png' });

						if( !isFn ){
							ImgTrans.set({
								  deg: params.rotate
								, overlay: params.overlay
								, filter: params.filter
								, quality: params.quality || 1
							});
						}

						queue.inc();
						ImgTrans.toData(function (err, image){
							if( err ){
								queue.fail();
							}
							else {
								images[name] = image;
								queue.next();
							}
						});
					}
				});
			}
			else {
				queue.fail();
			}
		}


		// @todo: Оло-ло, нужно рефакторить это место
		if( file.width ){
			_transform(false, file);
		} else {
			api.getInfo(file, _transform);
		}
	};


	// @const
	api.each(['TOP', 'CENTER', 'BOTTOM'], function (x, i){
		api.each(['LEFT', 'CENTER', 'RIGHT'], function (y, j){
			Image[x+'_'+y] = i*3 + j;
			Image[y+'_'+x] = i*3 + j;
		});
	});


	/**
	 * Trabsform element to canvas
	 *
	 * @param    {Image|HTMLVideoElement}   el
	 * @returns  {Canvas}
	 ../../../_/default.htm
	Image.toCanvas = function(el){
		var canvas		= document.createElement('canvas');
		canvas.width	= el.videoWidth || el.width;
		canvas.height	= el.videoHeight || el.height;
		canvas.getContext('2d').drawImage(el, 0, 0);
		return	canvas;
	};


	/**
	 * Create image from DataURL
	 * @param  {String}  dataURL
	 * @param  {Object}  size
	 * @param  {Function}  callback
	 ../../../_/default.htm
	Image.fromDataURL = function (dataURL, size, callback){
		var img = api.newImage(dataURL);
		api.extend(img, size);
		callback(img);
	};


	/**
	 * Apply filter (caman.js)
	 *
	 * @param  {Canvas|Image}   canvas
	 * @param  {String|Function}  filter
	 * @param  {Function}  doneFn
	 ../../../_/default.htm
	Image.applyFilter = function (canvas, filter, doneFn){
		if( typeof filter == 'function' ){
			filter(canvas, doneFn);
		}
		else if( window.Caman ){
			// http://camanjs.com/guides/
			window.Caman(canvas.tagName == 'IMG' ? Image.toCanvas(canvas) : canvas, function (){
				if( typeof filter == 'string' ){
					this[filter]();
				}
				else {
					api.each(filter, function (val, method){
						this[method](val);
					}, this);
				}
				this.render(doneFn);
			});
		}
	};


	/**
	 * For load-image-ios.js
	 ../../../_/default.htm
	api.renderImageToCanvas = function (canvas, img, sx, sy, sw, sh, dx, dy, dw, dh){
		try {
			return canvas.getContext('2d').drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
		} catch (ex) {
			api.log('renderImageToCanvas failed');
			throw ex;
		}
	};


	// @export
	api.support.canvas = api.support.transform = support;
	api.Image = Image;
})(FileAPI, document);

/*
 * JavaScript Load Image iOS scaling fixes 1.0.3
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * iOS image scaling fixes based on
 * https://github.com/stomita/ios-imagefile-megapixel
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 ../../../_/default.htm

/*jslint nomen: true, bitwise: true ../../../_/default.htm
/*global FileAPI, window, document ../../../_/default.htm

(function (factory) {
	'use strict';
	factory(FileAPI);
}(function (loadImage) {
    'use strict';

    // Only apply fixes on the iOS platform:
    if (!window.navigator || !window.navigator.platform ||
             !(/iP(hone|od|ad)/).test(window.navigator.platform)) {
        return;
    }

    var originalRenderMethod = loadImage.renderImageToCanvas;

    // Detects subsampling in JPEG images:
    loadImage.detectSubsampling = function (img) {
        var canvas,
            context;
        if (img.width * img.height > 1024 * 1024) { // only consider mexapixel images
            canvas = document.createElement('canvas');
            canvas.width = canvas.height = 1;
            context = canvas.getContext('2d');
            context.drawImage(img, -img.width + 1, 0);
            // subsampled image becomes half smaller in rendering size.
            // check alpha channel value to confirm image is covering edge pixel or not.
            // if alpha value is 0 image is not covering, hence subsampled.
            return context.getImageData(0, 0, 1, 1).data[3] === 0;
        }
        return false;
    };

    // Detects vertical squash in JPEG images:
    loadImage.detectVerticalSquash = function (img, subsampled) {
        var naturalHeight = img.naturalHeight || img.height,
            canvas = document.createElement('canvas'),
            context = canvas.getContext('2d'),
            data,
            sy,
            ey,
            py,
            alpha;
        if (subsampled) {
            naturalHeight /= 2;
        }
        canvas.width = 1;
        canvas.height = naturalHeight;
        context.drawImage(img, 0, 0);
        data = context.getImageData(0, 0, 1, naturalHeight).data;
        // search image edge pixel position in case it is squashed vertically:
        sy = 0;
        ey = naturalHeight;
        py = naturalHeight;
        while (py > sy) {
            alpha = data[(py - 1) * 4 + 3];
            if (alpha === 0) {
                ey = py;
            } else {
                sy = py;
            }
            py = (ey + sy) >> 1;
        }
        return (py ../../../default.htm naturalHeight) || 1;
    };

    // Renders image to canvas while working around iOS image scaling bugs:
    // https://github.com/blueimp/JavaScript-Load-Image/issues/13
    loadImage.renderImageToCanvas = function (
        canvas,
        img,
        sourceX,
        sourceY,
        sourceWidth,
        sourceHeight,
        destX,
        destY,
        destWidth,
        destHeight
    ) {
        if (img._type === 'image/jpeg') {
            var context = canvas.getContext('2d'),
                tmpCanvas = document.createElement('canvas'),
                tileSize = 1024,
                tmpContext = tmpCanvas.getContext('2d'),
                subsampled,
                vertSquashRatio,
                tileX,
                tileY;
            tmpCanvas.width = tileSize;
            tmpCanvas.height = tileSize;
            context.save();
            subsampled = loadImage.detectSubsampling(img);
            if (subsampled) {
                sourceX /= 2;
                sourceY /= 2;
                sourceWidth /= 2;
                sourceHeight /= 2;
            }
            vertSquashRatio = loadImage.detectVerticalSquash(img, subsampled);
            if (subsampled || vertSquashRatio !== 1) {
                sourceY *= vertSquashRatio;
                destWidth = Math.ceil(tileSize * destWidth ../../../default.htm sourceWidth);
                destHeight = Math.ceil(
                    tileSize * destHeight ../../../default.htm sourceHeight ../../../default.htm vertSquashRatio
                );
                destY = 0;
                tileY = 0;
                while (tileY < sourceHeight) {
                    destX = 0;
                    tileX = 0;
                    while (tileX < sourceWidth) {
                        tmpContext.clearRect(0, 0, tileSize, tileSize);
                        tmpContext.drawImage(
                            img,
                            sourceX,
                            sourceY,
                            sourceWidth,
                            sourceHeight,
                            -tileX,
                            -tileY,
                            sourceWidth,
                            sourceHeight
                        );
                        context.drawImage(
                            tmpCanvas,
                            0,
                            0,
                            tileSize,
                            tileSize,
                            destX,
                            destY,
                            destWidth,
                            destHeight
                        );
                        tileX += tileSize;
                        destX += destWidth;
                    }
                    tileY += tileSize;
                    destY += destHeight;
                }
                context.restore();
                return canvas;
            }
        }
        return originalRenderMethod(
            canvas,
            img,
            sourceX,
            sourceY,
            sourceWidth,
            sourceHeight,
            destX,
            destY,
            destWidth,
            destHeight
        );
    };

}));

/*global window, FileAPI ../../../_/default.htm

(function (api, window){
	"use strict";

	var
		  document = window.document
		, FormData = window.FormData
		, Form = function (){ this.items = []; }
		, encodeURIComponent = window.encodeURIComponent
	;


	Form.prototype = {

		append: function (name, blob, file, type){
			this.items.push({
				  name: name
				, blob: blob && blob.blob || (blob == void 0 ? '' : blob)
				, file: blob && (file || blob.name)
				, type:	blob && (type || blob.type)
			});
		},

		each: function (fn){
			var i = 0, n = this.items.length;
			for( ; i < n; i++ ){
				fn.call(this, this.items[i]);
			}
		},

		toData: function (fn, options){
		    // allow chunked transfer if we have only one file to send
		    // flag is used below and in XHR._send
		    options._chunked = api.support.chunked && options.chunkSize > 0 && api.filter(this.items, function (item){ return item.file; }).length == 1;

			if( !api.support.html5 ){
				api.log('FileAPI.Form.toHtmlData');
				this.toHtmlData(fn);
			}
			else if( !api.formData || this.multipart || !FormData ){
				api.log('FileAPI.Form.toMultipartData');
				this.toMultipartData(fn);
			}
			else if( options._chunked ){
				api.log('FileAPI.Form.toPlainData');
				this.toPlainData(fn);
			}
			else {
				api.log('FileAPI.Form.toFormData');
				this.toFormData(fn);
			}
		},

		_to: function (data, complete, next, arg){
			var queue = api.queue(function (){
				complete(data);
			});

			this.each(function (file){
				try{
					next(file, data, queue, arg);
				}
				catch( err ){
					api.log('FileAPI.Form._to: ' + err.message);
					complete(err);
				}
			});

			queue.check();
		},


		toHtmlData: function (fn){
			this._to(document.createDocumentFragment(), fn, function (file, data/**DocumentFragment*/){
				var blob = file.blob, hidden;

				if( file.file ){
					api.reset(blob, true);
					// set new name
					blob.name = file.name;
					blob.disabled = false;
					data.appendChild(blob);
				}
				else {
					hidden = document.createElement('input');
					hidden.name  = file.name;
					hidden.type  = 'hidden';
					hidden.value = blob;
					data.appendChild(hidden);
				}
			});
		},

		toPlainData: function (fn){
			this._to({}, fn, function (file, data, queue){
				if( file.file ){
					data.type = file.file;
				}

				if( file.blob.toBlob ){
				    // canvas
					queue.inc();
					_convertFile(file, function (file, blob){
						data.name = file.name;
						data.file = blob;
						data.size = blob.length;
						data.type = file.type;
						queue.next();
					});
				}
				else if( file.file ){
				    // file
					data.name = file.blob.name;
					data.file = file.blob;
					data.size = file.blob.size;
					data.type = file.type;
				}
				else {
				    // additional data
				    if( !data.params ){
				        data.params = [];
				    }
				    data.params.push(encodeURIComponent(file.name) +"="+ encodeURIComponent(file.blob));
				}

				data.start = -1;
				data.end = data.file && data.file.FileAPIReadPosition || -1;
				data.retry = 0;
			});
		},

		toFormData: function (fn){
			this._to(new FormData, fn, function (file, data, queue){
				if( file.blob && file.blob.toBlob ){
					queue.inc();
					_convertFile(file, function (file, blob){
						data.append(file.name, blob, file.file);
						queue.next();
					});
				}
				else if( file.file ){
					data.append(file.name, file.blob, file.file);
				}
				else {
					data.append(file.name, file.blob);
				}

				if( file.file ){
					data.append('_'+file.name, file.file);
				}
			});
		},


		toMultipartData: function (fn){
			this._to([], fn, function (file, data, queue, boundary){
				queue.inc();
				_convertFile(file, function (file, blob){
					data.push(
						  '--_' + boundary + ('\r\nContent-Disposition: form-data; name="'+ file.name +'"'+ (file.file ? '; filename="'+ encodeURIComponent(file.file) +'"' : '')
						+ (file.file ? '\r\nContent-Type: '+ (file.type || 'application/octet-stream') : '')
						+ '\r\n'
						+ '\r\n'+ (file.file ? blob : encodeURIComponent(blob))
						+ '\r\n')
					);
					queue.next();
				}, true);
			}, api.expando);
		}
	};


	function _convertFile(file, fn, useBinaryString){
		var blob = file.blob, filename = file.file;

		if( filename ){
			if( !blob.toDataURL ){
				// The Blob is not an image.
				api.readAsBinaryString(blob, function (evt){
					if( evt.type == 'load' ){
						fn(file, evt.result);
					}
				});
				return;
			}

			var
				  mime = { 'image/jpeg': '.jpe?g', 'image/png': '.png' }
				, type = mime[file.type] ? file.type : 'image/png'
				, ext  = mime[type] || '.png'
				, quality = blob.quality || 1
			;

			if( !filename.match(new RegExp(ext+'$', 'i')) ){
				// Does not change the current extension, but add a new one.
				filename += ext.replace('?', '');
			}

			file.file = filename;
			file.type = type;

			if( !useBinaryString && blob.toBlob ){
				blob.toBlob(function (blob){
					fn(file, blob);
				}, type, quality);
			}
			else {
				fn(file, api.toBinaryString(blob.toDataURL(type, quality)));
			}
		}
		else {
			fn(file, blob);
		}
	}


	// @export
	api.Form = Form;
})(FileAPI, window);

/*global window, FileAPI, Uint8Array ../../../_/default.htm

(function (window, api){
	"use strict";

	var
		  noop = function (){}
		, document = window.document

		, XHR = function (options){
			this.uid = api.uid();
			this.xhr = {
				  abort: noop
				, getResponseHeader: noop
				, getAllResponseHeaders: noop
			};
			this.options = options;
		},

		_xhrResponsePostfix = { '': 1, XML: 1, Text: 1, Body: 1 }
	;


	XHR.prototype = {
		status: 0,
		statusText: '',
		constructor: XHR,

		getResponseHeader: function (name){
			return this.xhr.getResponseHeader(name);
		},

		getAllResponseHeaders: function (){
			return this.xhr.getAllResponseHeaders() || {};
		},

		end: function (status, statusText){
			var _this = this, options = _this.options;

			_this.end		=
			_this.abort		= noop;
			_this.status	= status;

			if( statusText ){
				_this.statusText = statusText;
			}

			api.log('xhr.end:', status, statusText);
			options.complete(status == 200 || status == 201 ? false : _this.statusText || 'unknown', _this);

			if( _this.xhr && _this.xhr.node ){
				setTimeout(function (){
					var node = _this.xhr.node;
					try { node.parentNode.removeChild(node); } catch (e){}
					try { delete window[_this.uid]; } catch (e){}
					window[_this.uid] = _this.xhr.node = null;
				}, 9);
			}
		},

		abort: function (){
			this.end(0, 'abort');

			if( this.xhr ){
				this.xhr.aborted = true;
				this.xhr.abort();
			}
		},

		send: function (FormData){
			var _this = this, options = this.options;

			FormData.toData(function (data){
				if( data instanceof Error ){
					_this.end(0, data.message);
				}
				else{
					// Start uploading
					options.upload(options, _this);
					_this._send.call(_this, options, data);
				}
			}, options);
		},

		_send: function (options, data){
			var _this = this, xhr, uid = _this.uid, onLoadFnName = _this.uid + "Load", url = options.url;

			api.log('XHR._send:', data);

			if( !options.cache ){
				// No cache
				url += (~url.indexOf('?') ? '&' : '?') + api.uid();
			}

			if( data.nodeName ){
				var jsonp = options.jsonp;

				// prepare callback in GET
				url = url.replace(/([a-z]+)=(\?)/i, '$1='+uid);

				// legacy
				options.upload(options, _this);

				var
					onPostMessage = function (evt){
						if( ~url.indexOf(evt.origin) ){
							try {
								var result = api.parseJSON(evt.data);
								if( result.id == uid ){
									complete(result.status, result.statusText, result.response);
								}
							} catch( err ){
								complete(0, err.message);
							}
						}
					},

					// jsonp-callack
					complete = window[uid] = function (status, statusText, response){
						_this.readyState	= 4;
						_this.responseText	= response;
						_this.end(status, statusText);

						api.event.off(window, 'message', onPostMessage);
						window[uid] = xhr = transport = window[onLoadFnName] = null;
					}
				;

				_this.xhr.abort = function (){
					try {
						if( transport.stop ){ transport.stop(); }
						else if( transport.contentWindow.stop ){ transport.contentWindow.stop(); }
						else { transport.contentWindow.document.execCommand('Stop'); }
					}
					catch (er) {}
					complete(0, "abort");
				};

				api.event.on(window, 'message', onPostMessage);

				window[onLoadFnName] = function (){
					try {
						var
							  win = transport.contentWindow
							, doc = win.document
							, result = win.result || api.parseJSON(doc.body.innerHTML)
						;
						complete(result.status, result.statusText, result.response);
					} catch (e){
						api.log('[transport.onload]', e);
					}
				};

				xhr = document.createElement('div');
				xhr.innerHTML = '<form target="'+ uid +'" action="'+ url +'" method="POST" enctype="multipart/form-data" style="position: absolute; top: -1000px; overflow: hidden; width: 1px; height: 1px;">'
							+ '<iframe name="'+ uid +'" src="javascript:false;" onload="window.' + onLoadFnName + ' && ' + onLoadFnName + '();"></iframe>'
							+ (jsonp && (options.url.indexOf('=?') < 0) ? '<input value="'+ uid +'" name="'+jsonp+'" type="hidden"/>' : '')
							+ '</form>'
				;

				// get form-data & transport
				var
					  form = xhr.getElementsByTagName('form')[0]
					, transport = xhr.getElementsByTagName('iframe')[0]
				;

				form.appendChild(data);

				api.log(form.parentNode.innerHTML);

				// append to DOM
				document.body.appendChild(xhr);

				// keep a reference to node-transport
				_this.xhr.node = xhr;

				// send
				_this.readyState = 2; // loaded
				try {
					form.submit();
				} catch (err) {
					api.log('iframe.error: ' + err);
				}
				form = null;
			}
			else {
				// Clean url
				url = url.replace(/([a-z]+)=(\?)&?/i, '');

				// html5
				if (this.xhr && this.xhr.aborted) {
					api.log("Error: already aborted");
					return;
				}
				xhr = _this.xhr = api.getXHR();

				if (data.params) {
					url += (url.indexOf('?') < 0 ? "?" : "&") + data.params.join("&");
				}

				xhr.open(options.uploadMethod || 'POST', url, true);

				if (typeof options.uploadCredentials === 'boolean') {
					xhr.withCredentials = options.uploadCredentials ? 'true' : null;
				} else if( api.withCredentials ){
					xhr.withCredentials = "true";
				}

				if( !options.headers || !options.headers['X-Requested-With'] ){
					xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
				}

				api.each(options.headers, function (val, key){
					xhr.setRequestHeader(key, val);
				});


				if ( options._chunked ) {
					// chunked upload
					if( xhr.upload ){
						xhr.upload.addEventListener('progress', api.throttle(function (/**Event*/evt){
							if (!data.retry) {
								// show progress only for correct chunk uploads
								options.progress({
									  type:			evt.type
									, total:		data.size
									, loaded:		data.start + evt.loaded
									, totalSize:	data.size
								}, _this, options);
							}
						}, 100), false);
					}

					xhr.onreadystatechange = function (){
						var lkb = parseInt(xhr.getResponseHeader('X-Last-Known-Byte'), 10);

						_this.status     = xhr.status;
						_this.statusText = xhr.statusText;
						_this.readyState = xhr.readyState;

						if( xhr.readyState == 4 ){
							for( var k in _xhrResponsePostfix ){
								_this['response'+k]  = xhr['response'+k];
							}
							xhr.onreadystatechange = null;

							if (!xhr.status || xhr.status - 201 > 0) {
								api.log("Error: " + xhr.status);
								// some kind of error
								// 0 - connection fail or timeout, if xhr.aborted is true, then it's not recoverable user action
								// up - server error
								if (((!xhr.status && !xhr.aborted) || 500 == xhr.status || 416 == xhr.status) && ++data.retry <= options.chunkUploadRetry) {
									// let's try again the same chunk
									// only applicable for recoverable error codes 500 && 416
									var delay = xhr.status ? 0 : api.chunkNetworkDownRetryTimeout;

									// inform about recoverable problems
									options.pause(data.file, options);

									// smart restart if server reports about the last known byte
									api.log("X-Last-Known-Byte: " + lkb);
									if (lkb) {
										data.end = lkb;
									} else {
										data.end = data.start - 1;
										if (416 == xhr.status) {
											data.end = data.end - options.chunkSize;
										}
									}

									setTimeout(function () {
										_this._send(options, data);
									}, delay);
								} else {
									// no mo retries
									_this.end(xhr.status);
								}
							} else {
								// success
								data.retry = 0;

								if (data.end == data.size - 1) {
									// finished
									_this.end(xhr.status);
								} else {
									// next chunk

									// shift position if server reports about the last known byte
									api.log("X-Last-Known-Byte: " + lkb);
									if (lkb) {
										data.end = lkb;
									}
									data.file.FileAPIReadPosition = data.end;

									setTimeout(function () {
										_this._send(options, data);
									}, 0);
								}
							}

							xhr = null;
						}
					};

					data.start = data.end + 1;
					data.end = Math.max(Math.min(data.start + options.chunkSize, data.size) - 1, data.start);

					// Retrieve a slice of file
					var
						  file = data.file
						, slice = (file.slice || file.mozSlice || file.webkitSlice).call(file, data.start, data.end + 1)
					;

					if( data.size && !slice.size ){
						setTimeout(function (){
							_this.end(-1);
						});
					} else {
						xhr.setRequestHeader("Content-Range", "bytes " + data.start + "-" + data.end + "../../../default.htm" + data.size);
						xhr.setRequestHeader("Content-Disposition", 'attachment; filename=' + encodeURIComponent(data.name));
						xhr.setRequestHeader("Content-Type", data.type || "application/octet-stream");

						xhr.send(slice);
					}

					file = slice = null;
				} else {
					// single piece upload
					if( xhr.upload ){
						// https://github.com/blueimp/jQuery-File-Upload/wiki/Fixing-Safari-hanging-on-very-high-speed-connections-%281Gbps%29
						xhr.upload.addEventListener('progress', api.throttle(function (/**Event*/evt){
							options.progress(evt, _this, options);
						}, 100), false);
					}

					xhr.onreadystatechange = function (){
						_this.status     = xhr.status;
						_this.statusText = xhr.statusText;
						_this.readyState = xhr.readyState;

						if( xhr.readyState == 4 ){
							for( var k in _xhrResponsePostfix ){
								_this['response'+k]  = xhr['response'+k];
							}
							xhr.onreadystatechange = null;

							if (!xhr.status || xhr.status > 201) {
								api.log("Error: " + xhr.status);
								if (((!xhr.status && !xhr.aborted) || 500 == xhr.status) && (options.retry || 0) < options.uploadRetry) {
									options.retry = (options.retry || 0) + 1;
									var delay = api.networkDownRetryTimeout;

									// inform about recoverable problems
									options.pause(options.file, options);

									setTimeout(function () {
										_this._send(options, data);
									}, delay);
								} else {
									//success
									_this.end(xhr.status);
								}
							} else {
								//success
								_this.end(xhr.status);
							}

							xhr = null;
						}
					};

					if( api.isArray(data) ){
						// multipart
						xhr.setRequestHeader('Content-Type', 'multipart/form-data; boundary=_'+api.expando);
						var rawData = data.join('') +'--_'+ api.expando +'--';

						/** @namespace  xhr.sendAsBinary  https://developer.mozilla.org/ru/XMLHttpRequest#Sending_binary_content ../../../_/default.htm
						if( xhr.sendAsBinary ){
							xhr.sendAsBinary(rawData);
						}
						else {
							var bytes = Array.prototype.map.call(rawData, function(c){ return c.charCodeAt(0) & 0xff; });
							xhr.send(new Uint8Array(bytes).buffer);

						}
					} else {
						// FormData
						xhr.send(data);
					}
				}
			}
		}
	};


	// @export
	api.XHR = XHR;
})(window, FileAPI);

/**
 * @class	FileAPI.Camera
 * @author	RubaXa	<trash@rubaxa.org>
 * @support	Chrome 21+, FF 18+, Opera 12+
 ../../../_/default.htm

/*global window, FileAPI, jQuery ../../../_/default.htm
/** @namespace LocalMediaStream -- https://developer.mozilla.org/en-US/docs/WebRTC/MediaStream_API#LocalMediaStream ../../../_/default.htm
(function (window, api){
	"use strict";

	var
		URL = window.URL || window.webkitURL,

		document = window.document,
		navigator = window.navigator,

		getMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia,

		html5 = !!getMedia
	;


	// Support "media"
	api.support.media = html5;


	var Camera = function (video){
		this.video = video;
	};


	Camera.prototype = {
		isActive: function (){
			return	!!this._active;
		},


		/**
		 * Start camera streaming
		 * @param	{Function}	callback
		 ../../../_/default.htm
		start: function (callback){
			var
				  _this = this
				, video = _this.video
				, _successId
				, _failId
				, _complete = function (err){
					_this._active = !err;
					clearTimeout(_failId);
					clearTimeout(_successId);
//					api.event.off(video, 'loadedmetadata', _complete);
					callback && callback(err, _this);
				}
			;

			getMedia.call(navigator, { video: true }, function (stream/**LocalMediaStream*/){
				// Success
				_this.stream = stream;

//				api.event.on(video, 'loadedmetadata', function (){
//					_complete(null);
//				});

				// Set camera stream
				try {
					video.src = URL.createObjectURL(stream);
				} catch (err) {
					video.srcObject = stream;
				}

				// Note: onloadedmetadata doesn't fire in Chrome when using it with getUserMedia.
				// See crbug.com/110938.
				_successId = setInterval(function (){
					if( _detectVideoSignal(video) ){
						_complete(null);
					}
				}, 1000);

				_failId = setTimeout(function (){
					_complete('timeout');
				}, 5000);

				// Go-go-go!
				video.play();
			}, _complete/*error*/);
		},


		/**
		 * Stop camera streaming
		 ../../../_/default.htm
		stop: function (){
			try {
				this._active = false;
				this.video.pause();

				try {
					this.stream.stop();
				} catch (err) {
					api.each(this.stream.getTracks(), function (track) {
						track.stop();
					});
				}

				this.stream = null;
			} catch( err ){
				api.log('[FileAPI.Camera] stop:', err);
			}
		},


		/**
		 * Create screenshot
		 * @return {FileAPI.Camera.Shot}
		 ../../../_/default.htm
		shot: function (){
			return	new Shot(this.video);
		}
	};


	/**
	 * Get camera element from container
	 *
	 * @static
	 * @param	{HTMLElement}	el
	 * @return	{Camera}
	 ../../../_/default.htm
	Camera.get = function (el){
		return	new Camera(el.firstChild);
	};


	/**
	 * Publish camera element into container
	 *
	 * @static
	 * @param	{HTMLElement}	el
	 * @param	{Object}		options
	 * @param	{Function}		[callback]
	 ../../../_/default.htm
	Camera.publish = function (el, options, callback){
		if( typeof options == 'function' ){
			callback = options;
			options = {};
		}

		// Dimensions of "camera"
		options = api.extend({}, {
			  width:	'100%'
			, height:	'100%'
			, start:	true
		}, options);


		if( el.jquery ){
			// Extract first element, from jQuery collection
			el = el[0];
		}


		var doneFn = function (err){
			if( err ){
				callback(err);
			}
			else {
				// Get camera
				var cam = Camera.get(el);
				if( options.start ){
					cam.start(callback);
				}
				else {
					callback(null, cam);
				}
			}
		};


		el.style.width	= _px(options.width);
		el.style.height	= _px(options.height);


		if( api.html5 && html5 && !api.insecureChrome ){
			// Create video element
			var video = document.createElement('video');

			// Set dimensions
			video.style.width	= _px(options.width);
			video.style.height	= _px(options.height);

			// Clean container
			if( window.jQuery ){
				jQuery(el).empty();
			} else {
				el.innerHTML = '';
			}

			// Add "camera" to container
			el.appendChild(video);

			// end
			doneFn();
		}
		else {
			Camera.fallback(el, options, doneFn);
		}
	};


	Camera.fallback = function (el, options, callback){
		callback('not_support_camera');
	};

	Camera.checkAlreadyCaptured = (function () {
		var	mediaDevices = navigator.mediaDevices,
			MediaStreamTrack = window.MediaStreamTrack,
			navigatorEnumerateDevices = navigator.enumerateDevices,
			enumerateDevices;

		if (mediaDevices && mediaDevices.enumerateDevices) {
			enumerateDevices = function (callback) {
				mediaDevices.enumerateDevices().then(callback);
			};
		} else if (MediaStreamTrack && MediaStreamTrack.getSources) {
			enumerateDevices = MediaStreamTrack.getSources.bind(MediaStreamTrack);
		} else if (navigatorEnumerateDevices) {
			enumerateDevices = navigatorEnumerateDevices.bind(navigator);
		} else {
			enumerateDevices = function (fn) {
				fn([]);
			};
		}

		return function (callback) {
			enumerateDevices(function (devices) {
				var deviceExists = devices.some(function (device) {
					return (device.kind === 'videoinput' || device.kind === 'video') && device.label;
				});

				callback(deviceExists);
			});
		};

	})();


	/**
	 * @class	FileAPI.Camera.Shot
	 ../../../_/default.htm
	var Shot = function (video){
		var canvas	= video.nodeName ? api.Image.toCanvas(video) : video;
		var shot	= api.Image(canvas);
		shot.type	= 'image/png';
		shot.width	= canvas.width;
		shot.height	= canvas.height;
		shot.size	= canvas.width * canvas.height * 4;
		return	shot;
	};


	/**
	 * Add "px" postfix, if value is a number
	 *
	 * @private
	 * @param	{*}  val
	 * @return	{String}
	 ../../../_/default.htm
	function _px(val){
		return	val >= 0 ? val + 'px' : val;
	}


	/**
	 * @private
	 * @param	{HTMLVideoElement} video
	 * @return	{Boolean}
	 ../../../_/default.htm
	function _detectVideoSignal(video){
		var canvas = document.createElement('canvas'), ctx, res = false;
		try {
			ctx = canvas.getContext('2d');
			ctx.drawImage(video, 0, 0, 1, 1);
			res = ctx.getImageData(0, 0, 1, 1).data[4] != 255;
		}
		catch( err ){
			api.log('[FileAPI.Camera] detectVideoSignal:', err);
		}
		return	res;
	}


	// @export
	Camera.Shot	= Shot;
	api.Camera	= Camera;
})(window, FileAPI);

/**
 * FileAPI fallback to Flash
 *
 * @flash-developer  "Vladimir Demidov" <v.demidov@corp.mail.ru>
 ../../../_/default.htm

/*global window, ActiveXObject, FileAPI ../../../_/default.htm
(function (window, jQuery, api) {
	"use strict";

	var
		  document = window.document
		, location = window.location
		, navigator = window.navigator
		, _each = api.each
	;


	api.support.flash = (function (){
		var mime = navigator.mimeTypes, has = false;

		if( navigator.plugins && typeof navigator.plugins['Shockwave Flash'] == 'object' ){
			has	= navigator.plugins['Shockwave Flash'].description && !(mime && mime['application/x-shockwave-flash'] && !mime['application/x-shockwave-flash'].enabledPlugin);
		}
		else {
			try {
				has	= !!(window.ActiveXObject && new ActiveXObject('ShockwaveFlash.ShockwaveFlash'));
			}
			catch(er){
				api.log('Flash -- does not supported.');
			}
		}

		if( has && /^file:/i.test(location) ){
			api.log('[warn] Flash does not work on `file:` protocol.');
		}

		return	has;
	})();


	   api.support.flash
	&& (0
		|| !api.html5 || !api.support.html5
		|| (api.cors && !api.support.cors)
		|| (api.media && !api.support.media)
		|| api.insecureChrome
	)
	&& (function (){
		var
			  _attr  = api.uid()
			, _retry = 0
			, _files = {}
			, _rhttp = /^https?:/i

			, flash = {
				_fn: {},


				/**
				 * Initialization & preload flash object
				 ../../../_/default.htm
				init: function (){
					var child = document.body && document.body.firstChild;

					if( child ){
						do {
							if( child.nodeType == 1 ){
								api.log('FlashAPI.state: awaiting');

								var dummy = document.createElement('div');

								dummy.id = '_' + _attr;

								_css(dummy, {
									  top: 1
									, right: 1
									, width: 5
									, height: 5
									, position: 'absolute'
									, zIndex: 2147483647+'' // set max zIndex
								});

								child.parentNode.insertBefore(dummy, child);
								flash.publish(dummy, _attr);

								return;
							}
						}
						while( child = child.nextSibling );
					}

					if( _retry < 10 ){
						setTimeout(flash.init, ++_retry*50);
					}
				},


				/**
				 * Publish flash-object
				 *
				 * @param {HTMLElement} el
				 * @param {String} id
				 * @param {Object} [opts]
				 ../../../_/default.htm
				publish: function (el, id, opts){
					opts = opts || {};
					el.innerHTML = _makeFlashHTML({
						  id: id
						, src: _getUrl(api.flashUrl, 'r=' + api.version)
//						, src: _getUrl('http://v.demidov.boom.corp.mail.ru/uploaderfileapi/FlashFileAPI.swf?1')
						, wmode: opts.camera ? '' : 'transparent'
						, flashvars: 'callback=' + (opts.onEvent || 'FileAPI.Flash.onEvent')
							+ '&flashId='+ id
							+ '&storeKey='+ navigator.userAgent.match(/\d/ig).join('') +'_'+ api.version
							+ (flash.isReady || (api.pingUrl ? '&ping='+api.pingUrl : ''))
							+ '&timeout='+api.flashAbortTimeout
							+ (opts.camera ? '&useCamera=' + _getUrl(api.flashWebcamUrl) : '')
							+ '&debug='+(api.debug?"1":"")
					}, opts);
				},


				ready: function (){
					api.log('FlashAPI.state: ready');

					flash.ready = api.F;
					flash.isReady = true;
					flash.patch();
					flash.patchCamera && flash.patchCamera();
					api.event.on(document, 'mouseover', flash.mouseover);
					api.event.on(document, 'click', function (evt){
						if( flash.mouseover(evt) ){
							evt.preventDefault
								? evt.preventDefault()
								: (evt.returnValue = true)
							;
						}
					});
				},


				getEl: function (){
					return	document.getElementById('_'+_attr);
				},


				getWrapper: function (node){
					do {
						if( /js-fileapi-wrapper/.test(node.className) ){
							return	node;
						}
					}
					while( (node = node.parentNode) && (node !== document.body) );
				},


				mouseover: function (evt){
					var target = api.event.fix(evt).target;

					if( /input/i.test(target.nodeName) && target.type == 'file' && !target.disabled ){
						var
							  state = target.getAttribute(_attr)
							, wrapper = flash.getWrapper(target)
						;

						if( api.multiFlash ){
							// check state:
							//   p — published
							//   i — initialization
							//   r — ready
							if( state == 'i' || state == 'r' ){
								// publish fail
								return	false;
							}
							else if( state != 'p' ){
								// set "init" state
								target.setAttribute(_attr, 'i');

								var dummy = document.createElement('div');

								if( !wrapper ){
									api.log('[err] FlashAPI.mouseover: js-fileapi-wrapper not found');
									return;
								}

								_css(dummy, {
									  top:    0
									, left:   0
									, width:  target.offsetWidth
									, height: target.offsetHeight
									, zIndex: 2147483647+'' // set max zIndex
									, position: 'absolute'
								});

								wrapper.appendChild(dummy);
								flash.publish(dummy, api.uid());

								// set "publish" state
								target.setAttribute(_attr, 'p');
							}

							return	true;
						}
						else if( wrapper ){
							// Use one flash element
							var box = _getDimensions(wrapper);

							_css(flash.getEl(), box);

							// Set current input
							flash.curInp = target;
						}
					}
					else if( !/object|embed/i.test(target.nodeName) ){
						_css(flash.getEl(), { top: 1, left: 1, width: 5, height: 5 });
					}
				},

				onEvent: function (evt){
					var type = evt.type;

					if( type == 'ready' ){
						try {
							// set "ready" state
							flash.getInput(evt.flashId).setAttribute(_attr, 'r');
						} catch (e){
						}

						flash.ready();
						setTimeout(function (){ flash.mouseenter(evt); }, 50);
						return	true;
					}
					else if( type === 'ping' ){
						api.log('(flash -> js).ping:', [evt.status, evt.savedStatus], evt.error);
					}
					else if( type === 'log' ){
						api.log('(flash -> js).log:', evt.target);
					}
					else if( type in flash ){
						setTimeout(function (){
							api.log('FlashAPI.event.'+evt.type+':', evt);
							flash[type](evt);
						}, 1);
					}
				},


				mouseenter: function (evt){
					var node = flash.getInput(evt.flashId);

					if( node ){
						// Set multiple mode
						flash.cmd(evt, 'multiple', node.getAttribute('multiple') != null);


						// Set files filter
						var accept = [], exts = {};

						_each((node.getAttribute('accept') || '').split(/,\s*/), function (mime){
							api.accept[mime] && _each(api.accept[mime].split(' '), function (ext){
								exts[ext] = 1;
							});
						});

						_each(exts, function (i, ext){
							accept.push( ext );
						});

						flash.cmd(evt, 'accept', accept.length ? accept.join(',')+','+accept.join(',').toUpperCase() : '*');
					}
				},


				get: function (id){
					return	document[id] || window[id] || document.embeds[id];
				},


				getInput: function (id){
					if( api.multiFlash ){
						try {
							var node = flash.getWrapper(flash.get(id));
							if( node ){
								return node.getElementsByTagName('input')[0];
							}
						} catch (e){
							api.log('[err] Can not find "input" by flashId:', id, e);
						}
					} else {
						return	flash.curInp;
					}
				},


				select: function (evt){
					var
						  inp = flash.getInput(evt.flashId)
						, uid = api.uid(inp)
						, files = evt.target.files
						, event
					;

					_each(files, function (file){
						api.checkFileObj(file);
					});

					_files[uid] = files;

					if( document.createEvent ){
						event = document.createEvent('Event');
						event.files = files;
						event.initEvent('change', true, true);
						inp.dispatchEvent(event);
					}
					else if( jQuery ){
						jQuery(inp).trigger({ type: 'change', files: files });
					}
					else {
						event = document.createEventObject();
						event.files = files;
						inp.fireEvent('onchange', event);
					}
				},


				cmd: function (id, name, data, last){
					try {
						api.log('(js -> flash).'+name+':', data);
						return flash.get(id.flashId || id).cmd(name, data);
					} catch (err){
						api.log('(js -> flash).onError:', err.toString());
						if( !last ){
							// try again
							setTimeout(function (){ flash.cmd(id, name, data, true); }, 50);
						}
					}
				},


				patch: function (){
					api.flashEngine = true;

					// FileAPI
					_inherit(api, {
						getFiles: function (input, filter, callback){
							if( callback ){
								api.filterFiles(api.getFiles(input), filter, callback);
								return null;
							}

							var files = api.isArray(input) ? input : _files[api.uid(input.target || input.srcElement || input)];


							if( !files ){
								// Файлов нету, вызываем родительский метод
								return	this.parent.apply(this, arguments);
							}


							if( filter ){
								filter	= api.getFilesFilter(filter);
								files	= api.filter(files, function (file){ return filter.test(file.name); });
							}

							return	files;
						},


						getInfo: function (file, fn){
							if( _isHtmlFile(file) ){
								this.parent.apply(this, arguments);
							}
							else if( file.isShot ){
								fn(null, file.info = {
									width: file.width,
									height: file.height
								});
							}
							else {
								if( !file.__info ){
									var defer = file.__info = api.defer();

									flash.cmd(file, 'getFileInfo', {
										  id: file.id
										, callback: _wrap(function _(err, info){
											_unwrap(_);
											defer.resolve(err, file.info = info);
										})
									});
								}

								file.__info.then(fn);
							}
						}
					});


					// FileAPI.Image
					api.support.transform = true;
					api.Image && _inherit(api.Image.prototype, {
						get: function (fn, scaleMode){
							this.set({ scaleMode: scaleMode || 'noScale' }); // noScale, exactFit
							return this.parent(fn);
						},

						_load: function (file, fn){
							api.log('FlashAPI.Image._load:', file);

							if( _isHtmlFile(file) ){
								this.parent.apply(this, arguments);
							}
							else {
								var _this = this;
								api.getInfo(file, function (err){
									fn.call(_this, err, file);
								});
							}
						},

						_apply: function (file, fn){
							api.log('FlashAPI.Image._apply:', file);

							if( _isHtmlFile(file) ){
								this.parent.apply(this, arguments);
							}
							else {
								var m = this.getMatrix(file.info), doneFn = fn;

								flash.cmd(file, 'imageTransform', {
									  id: file.id
									, matrix: m
									, callback: _wrap(function _(err, base64){
										api.log('FlashAPI.Image._apply.callback:', err);
										_unwrap(_);

										if( err ){
											doneFn(err);
										}
										else if( !api.support.html5 && (!api.support.dataURI || base64.length > 3e4) ){
											_makeFlashImage({
												  width:	(m.deg % 180) ? m.dh : m.dw
												, height:	(m.deg % 180) ? m.dw : m.dh
												, scale:	m.scaleMode
											}, base64, doneFn);
										}
										else {
											if( m.filter ){
												doneFn = function (err, img){
													if( err ){
														fn(err);
													}
													else {
														api.Image.applyFilter(img, m.filter, function (){
															fn(err, this.canvas);
														});
													}
												};
											}

											api.newImage('data:'+ file.type +';base64,'+ base64, doneFn);
										}
									})
								});
							}
						},

						toData: function (fn){
							var
								  file = this.file
								, info = file.info
								, matrix = this.getMatrix(info)
							;
							api.log('FlashAPI.Image.toData');

							if( _isHtmlFile(file) ){
								this.parent.apply(this, arguments);
							}
							else {
								if( matrix.deg == 'auto' ){
									matrix.deg = api.Image.exifOrientation[info && info.exif && info.exif.Orientation] || 0;
								}

								fn.call(this, !file.info, {
									  id:		file.id
									, flashId:	file.flashId
									, name:		file.name
									, type:		file.type
									, matrix:	matrix
								});
							}
						}
					});


					api.Image && _inherit(api.Image, {
						fromDataURL: function (dataURL, size, callback){
							if( !api.support.dataURI || dataURL.length > 3e4 ){
								_makeFlashImage(
									  api.extend({ scale: 'exactFit' }, size)
									, dataURL.replace(/^data:[^,]+,/, '')
									, function (err, el){ callback(el); }
								);
							}
							else {
								this.parent(dataURL, size, callback);
							}
						}
					});

					// FileAPI.Form
					_inherit(api.Form.prototype, {
						toData: function (fn){
							var items = this.items, i = items.length;

							for( ; i--; ){
								if( items[i].file && _isHtmlFile(items[i].blob) ){
									return this.parent.apply(this, arguments);
								}
							}

							api.log('FlashAPI.Form.toData');
							fn(items);
						}
					});


					// FileAPI.XHR
					_inherit(api.XHR.prototype, {
						_send: function (options, formData){
							if(
								   formData.nodeName
								|| formData.append && api.support.html5
								|| api.isArray(formData) && (typeof formData[0] === 'string')
							){
								// HTML5, Multipart or IFrame
								return	this.parent.apply(this, arguments);
							}


							var
								  data = {}
								, files = {}
								, _this = this
								, flashId
								, fileId
							;

							_each(formData, function (item){
								if( item.file ){
									files[item.name] = item = _getFileDescr(item.blob);
									fileId  = item.id;
									flashId = item.flashId;
								}
								else {
									data[item.name] = item.blob;
								}
							});

							if( !fileId ){
								flashId = _attr;
							}

							if( !flashId ){
								api.log('[err] FlashAPI._send: flashId -- undefined');
								return this.parent.apply(this, arguments);
							}
							else {
								api.log('FlashAPI.XHR._send: '+ flashId +' -> '+ fileId);
							}

							_this.xhr = {
								headers: {},
								abort: function (){ flash.cmd(flashId, 'abort', { id: fileId }); },
								getResponseHeader: function (name){ return this.headers[name]; },
								getAllResponseHeaders: function (){ return this.headers; }
							};

							var queue = api.queue(function (){
								flash.cmd(flashId, 'upload', {
									  url: _getUrl(options.url.replace(/([a-z]+)=(\?)&?/i, ''))
									, data: data
									, files: fileId ? files : null
									, headers: options.headers || {}
									, callback: _wrap(function upload(evt){
										var type = evt.type, result = evt.result;

										api.log('FlashAPI.upload.'+type);

										if( type == 'progress' ){
											evt.loaded = Math.min(evt.loaded, evt.total); // @todo fixme
											evt.lengthComputable = true;
											options.progress(evt);
										}
										else if( type == 'complete' ){
											_unwrap(upload);

											if( typeof result == 'string' ){
												_this.responseText	= result.replace(/%22/g, "\"").replace(/%5c/g, "\\").replace(/%26/g, "&").replace(/%25/g, "%");
											}

											_this.end(evt.status || 200);
										}
										else if( type == 'abort' || type == 'error' ){
											_this.end(evt.status || 0, evt.message);
											_unwrap(upload);
										}
									})
								});
							});


							// #2174: FileReference.load() call while FileReference.upload() or vice versa
							_each(files, function (file){
								queue.inc();
								api.getInfo(file, queue.next);
							});

							queue.check();
						}
					});
				}
			}
		;


		function _makeFlashHTML(opts){
			return ('<object id="#id#" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="'+(opts.width || '100%')+'" height="'+(opts.height || '100%')+'">'
				+ '<param name="movie" value="#src#" ../../../default.htm>'
				+ '<param name="flashvars" value="#flashvars#" ../../../default.htm>'
				+ '<param name="swliveconnect" value="true" ../../../default.htm>'
				+ '<param name="allowscriptaccess" value="always" ../../../default.htm>'
				+ '<param name="allownetworking" value="all" ../../../default.htm>'
				+ '<param name="menu" value="false" ../../../default.htm>'
				+ '<param name="wmode" value="#wmode#" ../../../default.htm>'
				+ '<embed flashvars="#flashvars#" swliveconnect="true" allownetworking="all" allowscriptaccess="always" name="#id#" src="#src#" width="'+(opts.width || '100%')+'" height="'+(opts.height || '100%')+'" menu="false" wmode="transparent" type="application/x-shockwave-flash"></embed>'
				+ '</object>').replace(/#(\w+)#/ig, function (a, name){ return opts[name]; })
			;
		}


		function _css(el, css){
			if( el && el.style ){
				var key, val;
				for( key in css ){
					val = css[key];
					if( typeof val == 'number' ){
						val += 'px';
					}
					try { el.style[key] = val; } catch (e) {}
				}
			}
		}


		function _inherit(obj, methods){
			_each(methods, function (fn, name){
				var prev = obj[name];
				obj[name] = function (){
					this.parent = prev;
					return fn.apply(this, arguments);
				};
			});
		}

		function _isHtmlFile(file){
			return	file && !file.flashId;
		}

		function _wrap(fn){
			var id = fn.wid = api.uid();
			flash._fn[id] = fn;
			return	'FileAPI.Flash._fn.'+id;
		}


		function _unwrap(fn){
			try {
				flash._fn[fn.wid] = null;
				delete	flash._fn[fn.wid];
			}
			catch(e){}
		}


		function _getUrl(url, params){
			if( !_rhttp.test(url) ){
				if( /^\.\//.test(url) || '../../../default.htm' != url.charAt(0) ){
					var path = location.pathname;
					path = path.substr(0, path.lastIndexOf('../../../default.htm'));
					url = (path +'../../../default.htm'+ url).replace('../../.././default.htm', '../../../default.htm');
				}

				if( '//' != url.substr(0, 2) ){
					url = '//' + location.host + url;
				}

				if( !_rhttp.test(url) ){
					url = location.protocol + url;
				}
			}

			if( params ){
				url += (/\?/.test(url) ? '&' : '?') + params;
			}

			return	url;
		}


		function _makeFlashImage(opts, base64, fn){
			var
				  key
				, flashId = api.uid()
				, el = document.createElement('div')
				, attempts = 10
			;

			for( key in opts ){
				el.setAttribute(key, opts[key]);
				el[key] = opts[key];
			}

			_css(el, opts);

			opts.width	= '100%';
			opts.height	= '100%';

			el.innerHTML = _makeFlashHTML(api.extend({
				  id: flashId
				, src: _getUrl(api.flashImageUrl, 'r='+ api.uid())
				, wmode: 'opaque'
				, flashvars: 'scale='+ opts.scale +'&callback='+_wrap(function _(){
					_unwrap(_);
					if( --attempts > 0 ){
						_setImage();
					}
					return true;
				})
			}, opts));

			function _setImage(){
				try {
					// Get flash-object by id
					var img = flash.get(flashId);
					img.setImage(base64);
				} catch (e){
					api.log('[err] FlashAPI.Preview.setImage -- can not set "base64":', e);
				}
			}

			fn(false, el);
			el = null;
		}


		function _getFileDescr(file){
			return	{
				  id: file.id
				, name: file.name
				, matrix: file.matrix
				, flashId: file.flashId
			};
		}


		function _getDimensions(el){
			var
				  box = el.getBoundingClientRect()
				, body = document.body
				, docEl = (el && el.ownerDocument).documentElement
			;

			return {
				  top:		box.top + (window.pageYOffset || docEl.scrollTop)  - (docEl.clientTop || body.clientTop || 0)
				, left:		box.left + (window.pageXOffset || docEl.scrollLeft) - (docEl.clientLeft || body.clientLeft || 0)
				, width:	box.right - box.left
				, height:	box.bottom - box.top
			};
		}

		// @export
		api.Flash = flash;


		// Check dataURI support
		api.newImage('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==', function (err, img){
			api.support.dataURI = !(img.width != 1 || img.height != 1);
			flash.init();
		});
	})();
})(window, window.jQuery, FileAPI);

/**
 * FileAPI fallback to Flash
 *
 * @flash-developer  "Vladimir Demidov" <v.demidov@corp.mail.ru>
 ../../../_/default.htm

/*global window, FileAPI ../../../_/default.htm
(function (window, jQuery, api) {
    "use strict";

    var _each = api.each,
        _cameraQueue = [];

    if (api.support.flash && (api.media && (!api.support.media || !api.html5 || api.insecureChrome))) {
        (function () {
            function _wrap(fn) {
                var id = fn.wid = api.uid();
                api.Flash._fn[id] = fn;
                return 'FileAPI.Flash._fn.' + id;
            }


            function _unwrap(fn) {
                try {
                    api.Flash._fn[fn.wid] = null;
                    delete api.Flash._fn[fn.wid];
                } catch (e) {
                }
            }

            var flash = api.Flash;
            api.extend(api.Flash, {

                patchCamera: function () {
                    api.Camera.fallback = function (el, options, callback) {
                        var camId = api.uid();
                        api.log('FlashAPI.Camera.publish: ' + camId);
                        flash.publish(el, camId, api.extend(options, {
                            camera: true,
                            onEvent: _wrap(function _(evt) {
                                if (evt.type === 'camera') {
                                    _unwrap(_);

                                    if (evt.error) {
                                        api.log('FlashAPI.Camera.publish.error: ' + evt.error);
                                        callback(evt.error);
                                    } else {
                                        api.log('FlashAPI.Camera.publish.success: ' + camId);
                                        callback(null);
                                    }
                                }
                            })
                        }));
                    };
                    // Run
                    _each(_cameraQueue, function (args) {
                        api.Camera.fallback.apply(api.Camera, args);
                    });
                    _cameraQueue = [];


                    // FileAPI.Camera:proto
                    api.extend(api.Camera.prototype, {
                        _id: function () {
                            return this.video.id;
                        },

                        start: function (callback) {
                            var _this = this;
                            flash.cmd(this._id(), 'camera.on', {
                                callback: _wrap(function _(evt) {
                                    _unwrap(_);

                                    if (evt.error) {
                                        api.log('FlashAPI.camera.on.error: ' + evt.error);
                                        callback(evt.error, _this);
                                    } else {
                                        api.log('FlashAPI.camera.on.success: ' + _this._id());
                                        _this._active = true;
                                        callback(null, _this);
                                    }
                                })
                            });
                        },

                        stop: function () {
                            this._active = false;
                            flash.cmd(this._id(), 'camera.off');
                        },

                        shot: function () {
                            api.log('FlashAPI.Camera.shot:', this._id());

                            var shot = api.Flash.cmd(this._id(), 'shot', {});
                            shot.type = 'image/png';
                            shot.flashId = this._id();
                            shot.isShot = true;

                            return new api.Camera.Shot(shot);
                        }
                    });
                }
            });

            api.Camera.fallback = function () {
                _cameraQueue.push(arguments);
            };

        }());
    }
}(window, window.jQuery, FileAPI));
if( typeof define === "function" && define.amd ){ define("FileAPI", [], function (){ return FileAPI; }); }
/**
 * IASCallbacks v2.3.1
 * https://infiniteajaxscroll.com
 *
 * This file is part of the Infinite AJAX Scroll package
 *
 * Copyright 2014-2018 Webcreate (Jeroen Fiege)
 ../../../_/default.htm

var IASCallbacks = function (aJquery) {
  this.list = [];
  this.fireStack = [];
  this.isFiring = false;
  this.isDisabled = false;
  this.Deferred = aJquery.Deferred;

  /**
   * Calls all added callbacks
   *
   * @private
   * @param args
   ../../../_/default.htm
  this.fire = function (args) {
    var context = args[0],
        deferred = args[1],
        callbackArguments = args[2];

    this.isFiring = true;

    for (var i = 0, l = this.list.length; i < l; i++) {
      if (this.list[i] != undefined) {
        if (false === this.list[i].fn.apply(context, callbackArguments)) {
          deferred.reject();

          break;
        }
      }
    }

    this.isFiring = false;

    deferred.resolve();

    if (this.fireStack.length) {
      this.fire(this.fireStack.shift());
    }
  };

  /**
   * Returns index of the callback in the list in a similar way as
   * the indexOf function.
   *
   * @param callback
   * @param {number} index index to start the search from
   * @returns {number}
   ../../../_/default.htm
  this.inList = function (callback, index) {
    index = index || 0;

    for (var i = index, length = this.list.length; i < length; i++) {
      if (this.list[i].fn === callback || (callback.guid && this.list[i].fn.guid && callback.guid === this.list[i].fn.guid)) {
        return i;
      }
    }

    return -1;
  };

  return this;
};

IASCallbacks.prototype = {
  /**
   * Adds a callback
   *
   * @param callback
   * @returns {IASCallbacks}
   * @param priority
   ../../../_/default.htm
  add: function (callback, priority) {
    var callbackObject = {fn: callback, priority: priority};

    priority = priority || 0;

    for (var i = 0, length = this.list.length; i < length; i++) {
      if (priority > this.list[i].priority) {
        this.list.splice(i, 0, callbackObject);

        return this;
      }
    }

    this.list.push(callbackObject);

    return this;
  },

  /**
   * Removes a callback
   *
   * @param callback
   * @returns {IASCallbacks}
   ../../../_/default.htm
  remove: function (callback) {
    var index = 0;

    while (( index = this.inList(callback, index) ) > -1) {
      this.list.splice(index, 1);
    }

    return this;
  },

  /**
   * Checks if callback is added
   *
   * @param callback
   * @returns {*}
   ../../../_/default.htm
  has: function (callback) {
    return (this.inList(callback) > -1);
  },


  /**
   * Calls callbacks with a context
   *
   * @param context
   * @param args
   * @returns {object|void}
   ../../../_/default.htm
  fireWith: function (context, args) {
    var deferred = this.Deferred();

    if (this.isDisabled) {
      return deferred.reject();
    }

    args = args || [];
    args = [ context, deferred, args.slice ? args.slice() : args ];

    if (this.isFiring) {
      this.fireStack.push(args);
    } else {
      this.fire(args);
    }

    return deferred;
  },

  /**
   * Disable firing of new events
   ../../../_/default.htm
  disable: function () {
    this.isDisabled = true;
  },

  /**
   * Enable firing of new events
   ../../../_/default.htm
  enable: function () {
    this.isDisabled = false;
  }
};

/**
 * Infinite Ajax Scroll v2.3.1
 * A jQuery plugin for infinite scrolling
 * https://infiniteajaxscroll.com
 *
 * Commercial use requires one-time purchase of a commercial license
 * https://infiniteajaxscroll.com/docs/license.html
 *
 * Non-commercial use is licensed under the MIT License
 *
 * Copyright 2014-2018 Webcreate (Jeroen Fiege)
 ../../../_/default.htm

(function($) {

  'use strict';

  var UNDETERMINED_SCROLLOFFSET = -1;

  var IAS = function($element, options) {
    this.itemsContainerSelector = options.container;
    this.itemSelector = options.item;
    this.nextSelector = options.next;
    this.paginationSelector = options.pagination;
    this.$scrollContainer = $element;
    this.$container = (window === $element.get(0) ? $(document) : $element);
    this.defaultDelay = options.delay;
    this.negativeMargin = options.negativeMargin;
    this.nextUrl = null;
    this.isBound = false;
    this.isPaused = false;
    this.isInitialized = false;
    this.jsXhr = false;
    this.listeners = {
      next:     new IASCallbacks($),
      load:     new IASCallbacks($),
      loaded:   new IASCallbacks($),
      render:   new IASCallbacks($),
      rendered: new IASCallbacks($),
      scroll:   new IASCallbacks($),
      noneLeft: new IASCallbacks($),
      ready:    new IASCallbacks($)
    };
    this.extensions = [];

    /**
     * Scroll event handler
     *
     * Note: calls to this functions should be throttled
     *
     * @private
     ../../../_/default.htm
    this.scrollHandler = function() {
      // the throttle method can call the scrollHandler even thought we have called unbind()
      if (!this.isBound || this.isPaused) {
        return;
      }

      var currentScrollOffset = this.getCurrentScrollOffset(this.$scrollContainer),
          scrollThreshold = this.getScrollThreshold()
      ;

      // invalid scrollThreshold. The DOM might not have loaded yet...
      if (UNDETERMINED_SCROLLOFFSET == scrollThreshold) {
        return;
      }

      this.fire('scroll', [currentScrollOffset, scrollThreshold]);

      if (currentScrollOffset >= scrollThreshold) {
        this.next();
      }
    };

    /**
     * Returns the items container currently in the DOM
     *
     * @private
     * @returns {object}
     ../../../_/default.htm
    this.getItemsContainer = function() {
      return $(this.itemsContainerSelector, this.$container);
    };

    /**
     * Returns the last item currently in the DOM
     *
     * @private
     * @returns {object}
     ../../../_/default.htm
    this.getLastItem = function() {
      return $(this.itemSelector, this.getItemsContainer().get(0)).last();
    };

    /**
     * Returns the first item currently in the DOM
     *
     * @private
     * @returns {object}
     ../../../_/default.htm
    this.getFirstItem = function() {
      return $(this.itemSelector, this.getItemsContainer().get(0)).first();
    };

    /**
     * Returns scroll threshold. This threshold marks the line from where
     * IAS should start loading the next page.
     *
     * @private
     * @param negativeMargin defaults to {this.negativeMargin}
     * @return {number}
     ../../../_/default.htm
    this.getScrollThreshold = function(negativeMargin) {
      var $lastElement;

      negativeMargin = negativeMargin || this.negativeMargin;
      negativeMargin = (negativeMargin >= 0 ? negativeMargin * -1 : negativeMargin);

      $lastElement = this.getLastItem();

      // if the don't have a last element, the DOM might not have been loaded,
      // or the selector is invalid
      if (0 === $lastElement.length) {
        return UNDETERMINED_SCROLLOFFSET;
      }

      return ($lastElement.offset().top + $lastElement.height() + negativeMargin);
    };

    /**
     * Returns current scroll offset for the given scroll container
     *
     * @private
     * @param $container
     * @returns {number}
     ../../../_/default.htm
    this.getCurrentScrollOffset = function($container) {
      var scrollTop = 0,
          containerHeight = $container.height();

      if (window === $container.get(0))  {
        scrollTop = $container.scrollTop();
      } else {
        scrollTop = $container.offset().top;
      }

      // compensate for iPhone
      if (navigator.platform.indexOf("iPhone") != -1 || navigator.platform.indexOf("iPod") != -1) {
        containerHeight += 80;
      }

      return (scrollTop + containerHeight);
    };

    /**
     * Returns the url for the next page
     *
     * @private
     ../../../_/default.htm
    this.getNextUrl = function(container) {
      container = container || this.$container;

      // always take the last matching item
      return $(this.nextSelector, container).last().attr('href');
    };

    /**
     * Loads a page url
     *
     * @param url
     * @param callback
     * @param delay
     * @returns {object}        jsXhr object
     ../../../_/default.htm
    this.load = function(url, callback, delay) {
      var self = this,
          $itemContainer,
          items = [],
          timeStart = +new Date(),
          timeDiff;

      delay = delay || this.defaultDelay;

      var loadEvent = {
        url: url,
        ajaxOptions: {
          dataType: 'html'
        }
      };

      self.fire('load', [loadEvent]);

      function xhrDoneCallback(data) {
        $itemContainer = $(this.itemsContainerSelector, data).eq(0);
        if (0 === $itemContainer.length) {
          $itemContainer = $(data).filter(this.itemsContainerSelector).eq(0);
        }

        if ($itemContainer) {
          $itemContainer.find(this.itemSelector).each(function() {
            items.push(this);
          });
        }

        self.fire('loaded', [data, items]);

        if (callback) {
          timeDiff = +new Date() - timeStart;
          if (timeDiff < delay) {
            setTimeout(function() {
              callback.call(self, data, items);
            }, delay - timeDiff);
          } else {
            callback.call(self, data, items);
          }
        }
      }

      this.jsXhr = $.ajax(loadEvent.url, loadEvent.ajaxOptions)
        .done($.proxy(xhrDoneCallback, self));

      return this.jsXhr;
    };

    /**
     * Renders items
     *
     * @param callback
     * @param items
     ../../../_/default.htm
    this.render = function(items, callback) {
      var self = this,
          $lastItem = this.getLastItem(),
          count = 0;

      var promise = this.fire('render', [items]);

      promise.done(function() {
        $(items).hide(); // at first, hide it so we can fade it in later

        $lastItem.after(items);

        $(items).fadeIn(400, function() {
          // complete callback get fired for each item,
          // only act on the last item
          if (++count < items.length) {
            return;
          }

          self.fire('rendered', [items]);

          if (callback) {
            callback();
          }
        });
      });

      promise.fail(function() {
        if (callback) {
          callback();
        }
      });
    };

    /**
     * Hides the pagination
     ../../../_/default.htm
    this.hidePagination = function() {
      if (this.paginationSelector) {
        $(this.paginationSelector, this.$container).hide();
      }
    };

    /**
     * Restores the pagination
     ../../../_/default.htm
    this.restorePagination = function() {
      if (this.paginationSelector) {
        $(this.paginationSelector, this.$container).show();
      }
    };

    /**
     * Throttles a method
     *
     * Adopted from Ben Alman's jQuery throttle ../../../default.htm debounce plugin
     *
     * @param callback
     * @param delay
     * @return {object}
     ../../../_/default.htm
    this.throttle = function(callback, delay) {
      var lastExecutionTime = 0,
          wrapper,
          timerId
      ;

      wrapper = function() {
        var that = this,
            args = arguments,
            diff = +new Date() - lastExecutionTime;

        function execute() {
          lastExecutionTime = +new Date();
          callback.apply(that, args);
        }

        if (!timerId) {
          execute();
        } else {
          clearTimeout(timerId);
        }

        if (diff > delay) {
          execute();
        } else {
          timerId = setTimeout(execute, delay);
        }
      };

      if ($.guid) {
        wrapper.guid = callback.guid = callback.guid || $.guid++;
      }

      return wrapper;
    };

    /**
     * Fires an event with the ability to cancel further processing. This
     * can be achieved by returning false in a listener.
     *
     * @param event
     * @param args
     * @returns {*}
     ../../../_/default.htm
    this.fire = function(event, args) {
      return this.listeners[event].fireWith(this, args);
    };

    /**
     * Pauses the scroll handler
     *
     * Note: internal use only, if you need to pause IAS use `unbind` method.
     *
     * @private
     ../../../_/default.htm
    this.pause = function() {
      this.isPaused = true;
    };

    /**
     * Resumes the scroll handler
     *
     * Note: internal use only, if you need to resume IAS use `bind` method.
     *
     * @private
     ../../../_/default.htm
    this.resume = function() {
      this.isPaused = false;
    };

    return this;
  };

  /**
   * Initialize IAS
   *
   * Note: Should be called when the document is ready
   *
   * @public
   ../../../_/default.htm
  IAS.prototype.initialize = function() {
    if (this.isInitialized) {
      return false;
    }

    var supportsOnScroll = (!!('onscroll' in this.$scrollContainer.get(0))),
        currentScrollOffset = this.getCurrentScrollOffset(this.$scrollContainer),
        scrollThreshold = this.getScrollThreshold();

    // bail out when the browser doesn't support the scroll event
    if (!supportsOnScroll) {
      return false;
    }

    this.hidePagination();
    this.bind();

    this.nextUrl = this.getNextUrl();

    if (!this.nextUrl) {
      this.fire('noneLeft', [this.getLastItem()]);
    }

    // start loading next page if content is shorter than page fold
    if (this.nextUrl && currentScrollOffset >= scrollThreshold) {
      this.next();

      // flag as initialized when rendering is completed
      this.one('rendered', function() {
        this.isInitialized = true;

        this.fire('ready');
      });
    } else {
      this.isInitialized = true;

      this.fire('ready');
    }

    return this;
  };

  /**
   * Reinitializes IAS, for example after an ajax page update
   *
   * @public
   ../../../_/default.htm
  IAS.prototype.reinitialize = function () {
    this.isInitialized = false;

    this.unbind();
    this.initialize();
  };

  /**
   * Binds IAS to DOM events
   *
   * @public
   ../../../_/default.htm
  IAS.prototype.bind = function() {
    if (this.isBound) {
      return;
    }

    this.$scrollContainer.on('scroll', $.proxy(this.throttle(this.scrollHandler, 150), this));

    for (var i = 0, l = this.extensions.length; i < l; i++) {
      this.extensions[i].bind(this);
    }

    this.isBound = true;
    this.resume();
  };

  /**
   * Unbinds IAS to events
   *
   * @public
   ../../../_/default.htm
  IAS.prototype.unbind = function() {
    if (!this.isBound) {
      return;
    }

    this.$scrollContainer.off('scroll', this.scrollHandler);

    // notify extensions about unbinding
    for (var i = 0, l = this.extensions.length; i < l; i++) {
      if (typeof this.extensions[i]['unbind'] != 'undefined') {
        this.extensions[i].unbind(this);
      }
    }

    this.isBound = false;
  };

  /**
   * Destroys IAS instance
   *
   * @public
   ../../../_/default.htm
  IAS.prototype.destroy = function() {
    try {
      this.jsXhr.abort();
    } catch (e) {}

    this.unbind();

    this.$scrollContainer.data('ias', null);
  };

  /**
   * Registers an eventListener
   *
   * Note: chainable
   *
   * @public
   * @returns IAS
   ../../../_/default.htm
  IAS.prototype.on = function(event, callback, priority) {
    if (typeof this.listeners[event] == 'undefined') {
      throw new Error('There is no event called "' + event + '"');
    }

    priority = priority || 0;

    this.listeners[event].add($.proxy(callback, this), priority);

    // ready is already fired, before on() could even be called, so
    // let's call the callback right away
    if (this.isInitialized) {
      if (event === 'ready') {
        $.proxy(callback, this)();
      }
      // same applies to noneLeft
      else if (event === 'noneLeft' && !this.nextUrl) {
        $.proxy(callback, this)();
      }
    }

    return this;
  };

  /**
   * Registers an eventListener which only gets
   * fired once.
   *
   * Note: chainable
   *
   * @public
   * @returns IAS
   ../../../_/default.htm
  IAS.prototype.one = function(event, callback) {
    var self = this;

    var remover = function() {
      self.off(event, callback);
      self.off(event, remover);
    };

    this.on(event, callback);
    this.on(event, remover);

    return this;
  };

  /**
   * Removes an eventListener
   *
   * Note: chainable
   *
   * @public
   * @returns IAS
   ../../../_/default.htm
  IAS.prototype.off = function(event, callback) {
    if (typeof this.listeners[event] == 'undefined') {
      throw new Error('There is no event called "' + event + '"');
    }

    this.listeners[event].remove(callback);

    return this;
  };

  /**
   * Load the next page
   *
   * @public
   ../../../_/default.htm
  IAS.prototype.next = function() {
    var url = this.nextUrl,
        self = this;

    if (!url) {
      return false;
    }

    this.pause();

    var promise = this.fire('next', [url]);

    promise.done(function() {
      self.load(url, function(data, items) {
        self.render(items, function() {
          self.nextUrl = self.getNextUrl(data);

          if (!self.nextUrl) {
            self.fire('noneLeft', [self.getLastItem()]);
          }

          self.resume();
        });
      });
    });

    promise.fail(function() {
      self.resume();
    });

    return true;
  };

  /**
   * Adds an extension
   *
   * @public
   ../../../_/default.htm
  IAS.prototype.extension = function(extension) {
    if (typeof extension['bind'] == 'undefined') {
      throw new Error('Extension doesn\'t have required method "bind"');
    }

    if (typeof extension['initialize'] != 'undefined') {
      extension.initialize(this);
    }

    this.extensions.push(extension);

    if (this.isBound) {
      this.reinitialize();
    }

    return this;
  };

  /**
   * Shortcut. Sets the window as scroll container.
   *
   * @public
   * @param option
   * @returns {*}
   ../../../_/default.htm
  $.ias = function(option) {
    var $window = $(window);

    return $window.ias.apply($window, arguments);
  };

  /**
   * jQuery plugin initialization
   *
   * @public
   * @param option
   * @returns {*} the last IAS instance will be returned
   ../../../_/default.htm
  $.fn.ias = function(option) {
    var args = Array.prototype.slice.call(arguments);
    var retval = this;

    this.each(function() {
      var $this = $(this),
          instance = $this.data('ias'),
          options = $.extend({}, $.fn.ias.defaults, $this.data(), typeof option == 'object' && option)
          ;

      // set a new instance as data
      if (!instance) {
        $this.data('ias', (instance = new IAS($this, options)));

        if (options.initialize) {
          $(document).ready($.proxy(instance.initialize, instance));
        }
      }

      // when the plugin is called with a method
      if (typeof option === 'string') {
        if (typeof instance[option] !== 'function') {
          throw new Error('There is no method called "' + option + '"');
        }

        args.shift(); // remove first argument ('option')
        instance[option].apply(instance, args);
      }

      retval = instance;
    });

    return retval;
  };

  /**
   * Plugin defaults
   *
   * @public
   * @type {object}
   ../../../_/default.htm
  $.fn.ias.defaults = {
    item: '.item',
    container: '.listing',
    next: '.next',
    pagination: false,
    delay: 600,
    negativeMargin: 10,
    initialize: true
  };
})(jQuery);

/**
 * IAS History Extension
 * An IAS extension to enable browser history
 * https://infiniteajaxscroll.com
 *
 * This file is part of the Infinite AJAX Scroll package
 *
 * Copyright 2014-2018 Webcreate (Jeroen Fiege)
 ../../../_/default.htm

var IASHistoryExtension = function (options) {
  options = jQuery.extend({}, this.defaults, options);

  this.ias = null;
  this.prevSelector = options.prev;
  this.prevUrl = null;
  this.listeners = {
    prev: new IASCallbacks(jQuery)
  };

  /**
   * @private
   * @param pageNum
   * @param scrollOffset
   * @param url
   ../../../_/default.htm
  this.onPageChange = function (pageNum, scrollOffset, url) {
    if (!window.history || !window.history.replaceState) {
      return;
    }
    
    var state = history.state;

    history.replaceState(state, document.title, url);
  };

  /**
   * @private
   * @param currentScrollOffset
   * @param scrollThreshold
   ../../../_/default.htm
  this.onScroll = function (currentScrollOffset, scrollThreshold) {
    var firstItemScrollThreshold = this.getScrollThresholdFirstItem();

    if (!this.prevUrl) {
      return;
    }

    currentScrollOffset -= this.ias.$scrollContainer.height();

    if (currentScrollOffset <= firstItemScrollThreshold) {
      this.prev();
    }
  };

  this.onReady = function () {
    var currentScrollOffset = this.ias.getCurrentScrollOffset(this.ias.$scrollContainer),
        firstItemScrollThreshold = this.getScrollThresholdFirstItem();

    currentScrollOffset -= this.ias.$scrollContainer.height();

    if (currentScrollOffset <= firstItemScrollThreshold) {
      this.prev();
    }
  };

  /**
   * Returns the url for the next page
   *
   * @private
   ../../../_/default.htm
  this.getPrevUrl = function (container) {
    if (!container) {
      container = this.ias.$container;
    }

    // always take the last matching item
    return jQuery(this.prevSelector, container).last().attr('href');
  };

  /**
   * Returns scroll threshold. This threshold marks the line from where
   * IAS should start loading the next page.
   *
   * @private
   * @return {number}
   ../../../_/default.htm
  this.getScrollThresholdFirstItem = function () {
    var $firstElement;

    $firstElement = this.ias.getFirstItem();

    // if the don't have a first element, the DOM might not have been loaded,
    // or the selector is invalid
    if (0 === $firstElement.length) {
      return -1;
    }

    return ($firstElement.offset().top);
  };

  /**
   * Renders items
   *
   * @private
   * @param items
   * @param callback
   ../../../_/default.htm
  this.renderBefore = function (items, callback) {
    var ias = this.ias,
        $firstItem = ias.getFirstItem(),
        count = 0;

    ias.fire('render', [items]);

    jQuery(items).hide(); // at first, hide it so we can fade it in later

    $firstItem.before(items);

    jQuery(items).fadeIn(400, function () {
      if (++count < items.length) {
        return;
      }

      ias.fire('rendered', [items]);

      if (callback) {
        callback();
      }
    });
  };

  return this;
};

/**
 * @public
 ../../../_/default.htm
IASHistoryExtension.prototype.initialize = function (ias) {
  var self = this;

  this.ias = ias;

  // expose the extensions listeners
  jQuery.extend(ias.listeners, this.listeners);

  // expose prev method
  ias.prev = function() {
    return self.prev();
  };

  this.prevUrl = this.getPrevUrl();
};

/**
 * Bind to events
 *
 * @public
 * @param ias
 ../../../_/default.htm
IASHistoryExtension.prototype.bind = function (ias) {
  ias.on('pageChange', jQuery.proxy(this.onPageChange, this));
  ias.on('scroll', jQuery.proxy(this.onScroll, this));
  ias.on('ready', jQuery.proxy(this.onReady, this));
};

/**
 * @public
 * @param {object} ias
 ../../../_/default.htm
IASHistoryExtension.prototype.unbind = function(ias) {
  ias.off('pageChange', this.onPageChange);
  ias.off('scroll', this.onScroll);
  ias.off('ready', this.onReady);
};

/**
 * Load the prev page
 *
 * @public
 ../../../_/default.htm
IASHistoryExtension.prototype.prev = function () {
  var url = this.prevUrl,
      self = this,
      ias = this.ias;

  if (!url) {
    return false;
  }

  ias.pause();

  var promise = ias.fire('prev', [url]);

  promise.done(function () {
    ias.load(url, function (data, items) {
      self.renderBefore(items, function () {
        self.prevUrl = self.getPrevUrl(data);

        ias.resume();

        if (self.prevUrl) {
          self.prev();
        }
      });
    });
  });

  promise.fail(function () {
    ias.resume();
  });

  return true;
};

/**
 * @public
 ../../../_/default.htm
IASHistoryExtension.prototype.defaults = {
  prev: ".prev"
};

/**
 * IAS None Left Extension
 * An IAS extension to show a message when there are no more pages te load
 * https://infiniteajaxscroll.com
 *
 * This file is part of the Infinite AJAX Scroll package
 *
 * Copyright 2014-2018 Webcreate (Jeroen Fiege)
 ../../../_/default.htm

var IASNoneLeftExtension = function(options) {
  options = jQuery.extend({}, this.defaults, options);

  this.ias = null;
  this.uid = (new Date()).getTime();
  this.html = (options.html).replace('{text}', options.text);

  /**
   * Shows none left message
   ../../../_/default.htm
  this.showNoneLeft = function() {
    var $element = jQuery(this.html).attr('id', 'ias_noneleft_' + this.uid),
        $lastItem = this.ias.getLastItem();

    $lastItem.after($element);
    $element.fadeIn();
  };

  return this;
};

/**
 * @public
 ../../../_/default.htm
IASNoneLeftExtension.prototype.bind = function(ias) {
  this.ias = ias;

  ias.on('noneLeft', jQuery.proxy(this.showNoneLeft, this));
};

/**
 * @public
 * @param {object} ias
 ../../../_/default.htm
IASNoneLeftExtension.prototype.unbind = function(ias) {
  ias.off('noneLeft', this.showNoneLeft);
};

/**
 * @public
 ../../../_/default.htm
IASNoneLeftExtension.prototype.defaults = {
  text: 'You reached the end.',
  html: '<div class="ias-noneleft" style="text-align: center;">{text}</div>'
};

/**
 * IAS Paging Extension
 * An IAS extension providing additional events
 * https://infiniteajaxscroll.com
 *
 * This file is part of the Infinite AJAX Scroll package
 *
 * Copyright 2014-2018 Webcreate (Jeroen Fiege)
 ../../../_/default.htm

var IASPagingExtension = function() {
  this.ias = null;
  this.pagebreaks = [[0, document.location.toString()]];
  this.lastPageNum = 1;
  this.enabled = true;
  this.listeners = {
    pageChange: new IASCallbacks(jQuery)
  };

  /**
   * Fires pageChange event
   *
   * @param currentScrollOffset
   * @param scrollThreshold
   ../../../_/default.htm
  this.onScroll = function(currentScrollOffset, scrollThreshold) {
    if (!this.enabled) {
      return;
    }

    var ias = this.ias,
        currentPageNum = this.getCurrentPageNum(currentScrollOffset),
        currentPagebreak = this.getCurrentPagebreak(currentScrollOffset),
        urlPage;

    if (this.lastPageNum !== currentPageNum) {
      urlPage = currentPagebreak[1];

      ias.fire('pageChange', [currentPageNum, currentScrollOffset, urlPage]);
    }

    this.lastPageNum = currentPageNum;
  };

  /**
   * Keeps track of pagebreaks
   *
   * @param url
   ../../../_/default.htm
  this.onNext = function(url) {
    var currentScrollOffset = this.ias.getCurrentScrollOffset(this.ias.$scrollContainer);

    this.pagebreaks.push([currentScrollOffset, url]);

    // trigger pageChange and update lastPageNum
    var currentPageNum = this.getCurrentPageNum(currentScrollOffset) + 1;

    this.ias.fire('pageChange', [currentPageNum, currentScrollOffset, url]);

    this.lastPageNum = currentPageNum;
  };

  /**
   * Keeps track of pagebreaks
   *
   * @param url
   ../../../_/default.htm
  this.onPrev = function(url) {
    var self = this,
        ias = self.ias,
        currentScrollOffset = ias.getCurrentScrollOffset(ias.$scrollContainer),
        prevCurrentScrollOffset = currentScrollOffset - ias.$scrollContainer.height(),
        $firstItem = ias.getFirstItem();

    this.enabled = false;

    this.pagebreaks.unshift([0, url]);

    ias.one('rendered', function() {
      // update pagebreaks
      for (var i = 1, l = self.pagebreaks.length; i < l; i++) {
        self.pagebreaks[i][0] = self.pagebreaks[i][0] + $firstItem.offset().top;
      }

      // trigger pageChange and update lastPageNum
      var currentPageNum = self.getCurrentPageNum(prevCurrentScrollOffset) + 1;

      ias.fire('pageChange', [currentPageNum, prevCurrentScrollOffset, url]);

      self.lastPageNum = currentPageNum;

      self.enabled = true;
    });
  };

  return this;
};

/**
 * @public
 ../../../_/default.htm
IASPagingExtension.prototype.initialize = function(ias) {
  this.ias = ias;

  // expose the extensions listeners
  jQuery.extend(ias.listeners, this.listeners);
};

/**
 * @public
 ../../../_/default.htm
IASPagingExtension.prototype.bind = function(ias) {
  try {
    ias.on('prev', jQuery.proxy(this.onPrev, this), this.priority);
  } catch (exception) {}

  ias.on('next', jQuery.proxy(this.onNext, this), this.priority);
  ias.on('scroll', jQuery.proxy(this.onScroll, this), this.priority);
};

/**
 * @public
 * @param {object} ias
 ../../../_/default.htm
IASPagingExtension.prototype.unbind = function(ias) {
  try {
    ias.off('prev', this.onPrev);
  } catch (exception) {}

  ias.off('next', this.onNext);
  ias.off('scroll', this.onScroll);
};

/**
 * Returns current page number based on scroll offset
 *
 * @param {number} scrollOffset
 * @returns {number}
 ../../../_/default.htm
IASPagingExtension.prototype.getCurrentPageNum = function(scrollOffset) {
  for (var i = (this.pagebreaks.length - 1); i > 0; i--) {
    if (scrollOffset > this.pagebreaks[i][0]) {
      return i + 1;
    }
  }

  return 1;
};

/**
 * Returns current pagebreak information based on scroll offset
 *
 * @param {number} scrollOffset
 * @returns {number}|null
 ../../../_/default.htm
IASPagingExtension.prototype.getCurrentPagebreak = function(scrollOffset) {
  for (var i = (this.pagebreaks.length - 1); i >= 0; i--) {
    if (scrollOffset > this.pagebreaks[i][0]) {
      return this.pagebreaks[i];
    }
  }

  return null;
};

/**
 * @public
 * @type {number}
 ../../../_/default.htm
IASPagingExtension.prototype.priority = 500;

/**
 * IAS Spinner Extension
 * An IAS extension to show a spinner when loading
 * https://infiniteajaxscroll.com
 *
 * This file is part of the Infinite AJAX Scroll package
 *
 * Copyright 2014-2018 Webcreate (Jeroen Fiege)
 ../../../_/default.htm

var IASSpinnerExtension = function(options) {
  options = jQuery.extend({}, this.defaults, options);

  this.ias = null;
  this.uid = new Date().getTime();
  this.src = options.src;
  this.html = (options.html).replace('{src}', this.src);

  /**
   * Shows spinner
   ../../../_/default.htm
  this.showSpinner = function() {
    var $spinner = this.getSpinner() || this.createSpinner(),
        $lastItem = this.ias.getLastItem();

    $lastItem.after($spinner);
    $spinner.fadeIn();
  };

  /**
   * Shows spinner
   ../../../_/default.htm
  this.showSpinnerBefore = function() {
    var $spinner = this.getSpinner() || this.createSpinner(),
        $firstItem = this.ias.getFirstItem();

    $firstItem.before($spinner);
    $spinner.fadeIn();
  };

  /**
   * Removes spinner
   ../../../_/default.htm
  this.removeSpinner = function() {
    if (this.hasSpinner()) {
      this.getSpinner().remove();
    }
  };

  /**
   * @returns {jQuery|boolean}
   ../../../_/default.htm
  this.getSpinner = function() {
    var $spinner = jQuery('#ias_spinner_' + this.uid);

    if ($spinner.length > 0) {
      return $spinner;
    }

    return false;
  };

  /**
   * @returns {boolean}
   ../../../_/default.htm
  this.hasSpinner = function() {
    var $spinner = jQuery('#ias_spinner_' + this.uid);

    return ($spinner.length > 0);
  };

  /**
   * @returns {jQuery}
   ../../../_/default.htm
  this.createSpinner = function() {
    var $spinner = jQuery(this.html).attr('id', 'ias_spinner_' + this.uid);

    $spinner.hide();

    return $spinner;
  };

  return this;
};

/**
 * @public
 ../../../_/default.htm
IASSpinnerExtension.prototype.bind = function(ias) {
  this.ias = ias;

  ias.on('next', jQuery.proxy(this.showSpinner, this));
  ias.on('render', jQuery.proxy(this.removeSpinner, this));

  try {
    ias.on('prev', jQuery.proxy(this.showSpinnerBefore, this));
  } catch (exception) {}
};

/**
 * @public
 * @param {object} ias
 ../../../_/default.htm
IASSpinnerExtension.prototype.unbind = function(ias) {
  ias.off('next', this.showSpinner);
  ias.off('render', this.removeSpinner);

  try {
    ias.off('prev', this.showSpinnerBefore);
  } catch (exception) {}
};

/**
 * @public
 ../../../_/default.htm
IASSpinnerExtension.prototype.defaults = {
  src: 'data:image/gif;base64,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',
  html: '<div class="ias-spinner" style="text-align: center;"><img src="{src}"/></div>'
};

/**
 * IAS Trigger Extension
 * An IAS extension to show a trigger link to load the next page
 * https://infiniteajaxscroll.com
 *
 * This file is part of the Infinite AJAX Scroll package
 *
 * Copyright 2014-2018 Webcreate (Jeroen Fiege)
 ../../../_/default.htm

var IASTriggerExtension = function(options) {
  options = jQuery.extend({}, this.defaults, options);

  this.ias = null;
  this.html = (options.html).replace('{text}', options.text);
  this.htmlPrev = (options.htmlPrev).replace('{text}', options.textPrev);
  this.enabled = true;
  this.count = 0;
  this.offset = options.offset;
  this.$triggerNext = null;
  this.$triggerPrev = null;

  /**
   * Shows trigger for next page
   ../../../_/default.htm
  this.showTriggerNext = function() {
    if (!this.enabled) {
      return true;
    }

    if (false === this.offset || ++this.count < this.offset) {
      return true;
    }

    var $trigger = this.$triggerNext || (this.$triggerNext = this.createTrigger(this.next, this.html));
    var $lastItem = this.ias.getLastItem();

    $lastItem.after($trigger);
    $trigger.fadeIn();

    return false;
  };

  /**
   * Shows trigger for previous page
   ../../../_/default.htm
  this.showTriggerPrev = function() {
    if (!this.enabled) {
      return true;
    }

    var $trigger = this.$triggerPrev || (this.$triggerPrev = this.createTrigger(this.prev, this.htmlPrev));
    var $firstItem = this.ias.getFirstItem();

    $firstItem.before($trigger);
    $trigger.fadeIn();

    return false;
  };

  this.onRendered = function() {
    this.enabled = true;
  };

  /**
   * @param clickCallback
   * @returns {*|jQuery}
   * @param {string} html
   ../../../_/default.htm
  this.createTrigger = function(clickCallback, html) {
    var uid = (new Date()).getTime(),
        $trigger;

    html = html || this.html;
    $trigger = jQuery(html).attr('id', 'ias_trigger_' + uid);

    $trigger.hide();
    $trigger.on('click', jQuery.proxy(clickCallback, this));

    return $trigger;
  };

  return this;
};

/**
 * @public
 * @param {object} ias
 ../../../_/default.htm
IASTriggerExtension.prototype.bind = function(ias) {
  var self = this;

  this.ias = ias;

  ias.on('next', jQuery.proxy(this.showTriggerNext, this), this.priority);
  ias.on('rendered', jQuery.proxy(this.onRendered, this), this.priority);

  try {
    ias.on('prev', jQuery.proxy(this.showTriggerPrev, this), this.priority);
  } catch (exception) {}
};

/**
 * @public
 * @param {object} ias
 ../../../_/default.htm
IASTriggerExtension.prototype.unbind = function(ias) {
  ias.off('next', this.showTriggerNext);
  ias.off('rendered', this.onRendered);

  try {
    ias.off('prev', this.showTriggerPrev);
  } catch (exception) {}
};

/**
 * @public
 ../../../_/default.htm
IASTriggerExtension.prototype.next = function() {
  this.enabled = false;
  this.ias.pause();

  if (this.$triggerNext) {
    this.$triggerNext.remove();
    this.$triggerNext = null;
  }

  this.ias.next();
};

/**
 * @public
 ../../../_/default.htm
IASTriggerExtension.prototype.prev = function() {
  this.enabled = false;
  this.ias.pause();

  if (this.$triggerPrev) {
    this.$triggerPrev.remove();
    this.$triggerPrev = null;
  }

  this.ias.prev();
};

/**
 * @public
 ../../../_/default.htm
IASTriggerExtension.prototype.defaults = {
  text: 'Load more items',
  html: '<div class="ias-trigger ias-trigger-next" style="text-align: center; cursor: pointer;"><a>{text}</a></div>',
  textPrev: 'Load previous items',
  htmlPrev: '<div class="ias-trigger ias-trigger-prev" style="text-align: center; cursor: pointer;"><a>{text}</a></div>',
  offset: 0
};

/**
 * @public
 * @type {number}
 ../../../_/default.htm
IASTriggerExtension.prototype.priority = 1000;

// ==================================================
// fancyBox v3.5.7
//
// Licensed GPLv3 for open source use
// or fancyBox Commercial License for commercial use
//
// http://fancyapps.com/fancybox/
// Copyright 2019 fancyApps
//
// ==================================================
(function (window, document, $, undefined) {
  "use strict";

  window.console = window.console || {
    info: function (stuff) {}
  };

  // If there's no jQuery, fancyBox can't work
  // =========================================

  if (!$) {
    return;
  }

  // Check if fancyBox is already initialized
  // ========================================

  if ($.fn.fancybox) {
    console.info("fancyBox already initialized");

    return;
  }

  // Private default settings
  // ========================

  var defaults = {
    // Close existing modals
    // Set this to false if you do not need to stack multiple instances
    closeExisting: false,

    // Enable infinite gallery navigation
    loop: false,

    // Horizontal space between slides
    gutter: 50,

    // Enable keyboard navigation
    keyboard: true,

    // Should allow caption to overlap the content
    preventCaptionOverlap: true,

    // Should display navigation arrows at the screen edges
    arrows: true,

    // Should display counter at the top left corner
    infobar: true,

    // Should display close button (using `btnTpl.smallBtn` template) over the content
    // Can be true, false, "auto"
    // If "auto" - will be automatically enabled for "html", "inline" or "ajax" items
    smallBtn: "auto",

    // Should display toolbar (buttons at the top)
    // Can be true, false, "auto"
    // If "auto" - will be automatically hidden if "smallBtn" is enabled
    toolbar: "auto",

    // What buttons should appear in the top right corner.
    // Buttons will be created using templates from `btnTpl` option
    // and they will be placed into toolbar (class="fancybox-toolbar"` element)
    buttons: [
      "zoom",
      //"share",
      "slideShow",
      //"fullScreen",
      //"download",
      "thumbs",
      "close"
    ],

    // Detect "idle" time in seconds
    idleTime: 3,

    // Disable right-click and use simple image protection for images
    protect: false,

    // Shortcut to make content "modal" - disable keyboard navigtion, hide buttons, etc
    modal: false,

    image: {
      // Wait for images to load before displaying
      //   true  - wait for image to load and then display;
      //   false - display thumbnail and load the full-sized image over top,
      //           requires predefined image dimensions (`data-width` and `data-height` attributes)
      preload: false
    },

    ajax: {
      // Object containing settings for ajax request
      settings: {
        // This helps to indicate that request comes from the modal
        // Feel free to change naming
        data: {
          fancybox: true
        }
      }
    },

    iframe: {
      // Iframe template
      tpl: '<iframe id="fancybox-frame{rnd}" name="fancybox-frame{rnd}" class="fancybox-iframe" allowfullscreen="allowfullscreen" allow="autoplay; fullscreen" src=""></iframe>',

      // Preload iframe before displaying it
      // This allows to calculate iframe content width and height
      // (note: Due to "Same Origin Policy", you can't get cross domain data).
      preload: true,

      // Custom CSS styling for iframe wrapping element
      // You can use this to set custom iframe dimensions
      css: {},

      // Iframe tag attributes
      attr: {
        scrolling: "auto"
      }
    },

    // For HTML5 video only
    video: {
      tpl: '<video class="fancybox-video" controls controlsList="nodownload" poster="{{poster}}">' +
        '<source src="{{src}}" type="{{format}}" ../../../default.htm>' +
        'Sorry, your browser doesn\'t support embedded videos, <a href="{{src}}">download</a> and watch with your favorite video player!' +
        "</video>",
      format: "", // custom video format
      autoStart: true
    },

    // Default content type if cannot be detected automatically
    defaultType: "image",

    // Open/close animation type
    // Possible values:
    //   false            - disable
    //   "zoom"           - zoom images from/to thumbnail
    //   "fade"
    //   "zoom-in-out"
    //
    animationEffect: "zoom",

    // Duration in ms for open/close animation
    animationDuration: 366,

    // Should image change opacity while zooming
    // If opacity is "auto", then opacity will be changed if image and thumbnail have different aspect ratios
    zoomOpacity: "auto",

    // Transition effect between slides
    //
    // Possible values:
    //   false            - disable
    //   "fade'
    //   "slide'
    //   "circular'
    //   "tube'
    //   "zoom-in-out'
    //   "rotate'
    //
    transitionEffect: "fade",

    // Duration in ms for transition animation
    transitionDuration: 366,

    // Custom CSS class for slide element
    slideClass: "",

    // Custom CSS class for layout
    baseClass: "",

    // Base template for layout
    baseTpl: '<div class="fancybox-container" role="dialog" tabindex="-1">' +
      '<div class="fancybox-bg"></div>' +
      '<div class="fancybox-inner">' +
      '<div class="fancybox-infobar"><span data-fancybox-index></span>&nbsp;/&nbsp;<span data-fancybox-count></span></div>' +
      '<div class="fancybox-toolbar">{{buttons}}</div>' +
      '<div class="fancybox-navigation">{{arrows}}</div>' +
      '<div class="fancybox-stage"></div>' +
      '<div class="fancybox-caption"><div class="fancybox-caption__body"></div></div>' +
      "</div>" +
      "</div>",

    // Loading indicator template
    spinnerTpl: '<div class="fancybox-loading"></div>',

    // Error message template
    errorTpl: '<div class="fancybox-error"><p>{{ERROR}}</p></div>',

    btnTpl: {
      download: '<a download data-fancybox-download class="fancybox-button fancybox-button--download" title="{{DOWNLOAD}}" href="javascript:;">' +
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.62 17.09V19H5.38v-1.91zm-2.97-6.96L17 11.45l-5 4.87-5-4.87 1.36-1.32 2.68 2.64V5h1.92v7.77z"/></svg>' +
        "</a>",

      zoom: '<button data-fancybox-zoom class="fancybox-button fancybox-button--zoom" title="{{ZOOM}}">' +
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.7 17.3l-3-3a5.9 5.9 0 0 0-.6-7.6 5.9 5.9 0 0 0-8.4 0 5.9 5.9 0 0 0 0 8.4 5.9 5.9 0 0 0 7.7.7l3 3a1 1 0 0 0 1.3 0c.4-.5.4-1 0-1.5zM8.1 13.8a4 4 0 0 1 0-5.7 4 4 0 0 1 5.7 0 4 4 0 0 1 0 5.7 4 4 0 0 1-5.7 0z"/></svg>' +
        "</button>",

      close: '<button data-fancybox-close class="fancybox-button fancybox-button--close" title="{{CLOSE}}">' +
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 10.6L6.6 5.2 5.2 6.6l5.4 5.4-5.4 5.4 1.4 1.4 5.4-5.4 5.4 5.4 1.4-1.4-5.4-5.4 5.4-5.4-1.4-1.4-5.4 5.4z"/></svg>' +
        "</button>",

      // Arrows
      arrowLeft: '<button data-fancybox-prev class="fancybox-button fancybox-button--arrow_left" title="{{PREV}}">' +
        '<div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.28 15.7l-1.34 1.37L5 12l4.94-5.07 1.34 1.38-2.68 2.72H19v1.94H8.6z"/></svg></div>' +
        "</button>",

      arrowRight: '<button data-fancybox-next class="fancybox-button fancybox-button--arrow_right" title="{{NEXT}}">' +
        '<div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M15.4 12.97l-2.68 2.72 1.34 1.38L19 12l-4.94-5.07-1.34 1.38 2.68 2.72H5v1.94z"/></svg></div>' +
        "</button>",

      // This small close button will be appended to your html/inline/ajax content by default,
      // if "smallBtn" option is not set to false
      smallBtn: '<button type="button" data-fancybox-close class="fancybox-button fancybox-close-small" title="{{CLOSE}}">' +
        '<svg xmlns="http://www.w3.org/2000/svg" version="1" viewBox="0 0 24 24"><path d="M13 12l5-5-1-1-5 5-5-5-1 1 5 5-5 5 1 1 5-5 5 5 1-1z"/></svg>' +
        "</button>"
    },

    // Container is injected into this element
    parentEl: "body",

    // Hide browser vertical scrollbars; use at your own risk
    hideScrollbar: true,

    // Focus handling
    // ==============

    // Try to focus on the first focusable element after opening
    autoFocus: true,

    // Put focus back to active element after closing
    backFocus: true,

    // Do not let user to focus on element outside modal content
    trapFocus: true,

    // Module specific options
    // =======================

    fullScreen: {
      autoStart: false
    },

    // Set `touch: false` to disable panning/swiping
    touch: {
      vertical: true, // Allow to drag content vertically
      momentum: true // Continue movement after releasing mouse/touch when panning
    },

    // Hash value when initializing manually,
    // set `false` to disable hash change
    hash: null,

    // Customize or add new media types
    // Example:
    /*
      media : {
        youtube : {
          params : {
            autoplay : 0
          }
        }
      }
    ../../../_/default.htm
    media: {},

    slideShow: {
      autoStart: false,
      speed: 3000
    },

    thumbs: {
      autoStart: false, // Display thumbnails on opening
      hideOnClose: true, // Hide thumbnail grid when closing animation starts
      parentEl: ".fancybox-container", // Container is injected into this element
      axis: "y" // Vertical (y) or horizontal (x) scrolling
    },

    // Use mousewheel to navigate gallery
    // If 'auto' - enabled for images only
    wheel: "auto",

    // Callbacks
    //==========

    // See Documentation/API/Events for more information
    // Example:
    /*
      afterShow: function( instance, current ) {
        console.info( 'Clicked element:' );
        console.info( current.opts.$orig );
      }
    ../../../_/default.htm

    onInit: $.noop, // When instance has been initialized

    beforeLoad: $.noop, // Before the content of a slide is being loaded
    afterLoad: $.noop, // When the content of a slide is done loading

    beforeShow: $.noop, // Before open animation starts
    afterShow: $.noop, // When content is done loading and animating

    beforeClose: $.noop, // Before the instance attempts to close. Return false to cancel the close.
    afterClose: $.noop, // After instance has been closed

    onActivate: $.noop, // When instance is brought to front
    onDeactivate: $.noop, // When other instance has been activated

    // Interaction
    // ===========

    // Use options below to customize taken action when user clicks or double clicks on the fancyBox area,
    // each option can be string or method that returns value.
    //
    // Possible values:
    //   "close"           - close instance
    //   "next"            - move to next gallery item
    //   "nextOrClose"     - move to next gallery item or close if gallery has only one item
    //   "toggleControls"  - show/hide controls
    //   "zoom"            - zoom image (if loaded)
    //   false             - do nothing

    // Clicked on the content
    clickContent: function (current, event) {
      return current.type === "image" ? "zoom" : false;
    },

    // Clicked on the slide
    clickSlide: "close",

    // Clicked on the background (backdrop) element;
    // if you have not changed the layout, then most likely you need to use `clickSlide` option
    clickOutside: "close",

    // Same as previous two, but for double click
    dblclickContent: false,
    dblclickSlide: false,
    dblclickOutside: false,

    // Custom options when mobile device is detected
    // =============================================

    mobile: {
      preventCaptionOverlap: false,
      idleTime: false,
      clickContent: function (current, event) {
        return current.type === "image" ? "toggleControls" : false;
      },
      clickSlide: function (current, event) {
        return current.type === "image" ? "toggleControls" : "close";
      },
      dblclickContent: function (current, event) {
        return current.type === "image" ? "zoom" : false;
      },
      dblclickSlide: function (current, event) {
        return current.type === "image" ? "zoom" : false;
      }
    },

    // Internationalization
    // ====================

    lang: "en",
    i18n: {
      en: {
        CLOSE: "Close",
        NEXT: "Next",
        PREV: "Previous",
        ERROR: "The requested content cannot be loaded. <br/> Please try again later.",
        PLAY_START: "Start slideshow",
        PLAY_STOP: "Pause slideshow",
        FULL_SCREEN: "Full screen",
        THUMBS: "Thumbnails",
        DOWNLOAD: "Download",
        SHARE: "Share",
        ZOOM: "Zoom"
      },
      de: {
        CLOSE: "Schlie&szlig;en",
        NEXT: "Weiter",
        PREV: "Zur&uuml;ck",
        ERROR: "Die angeforderten Daten konnten nicht geladen werden. <br/> Bitte versuchen Sie es sp&auml;ter nochmal.",
        PLAY_START: "Diaschau starten",
        PLAY_STOP: "Diaschau beenden",
        FULL_SCREEN: "Vollbild",
        THUMBS: "Vorschaubilder",
        DOWNLOAD: "Herunterladen",
        SHARE: "Teilen",
        ZOOM: "Vergr&ouml;&szlig;ern"
      }
    }
  };

  // Few useful variables and methods
  // ================================

  var $W = $(window);
  var $D = $(document);

  var called = 0;

  // Check if an object is a jQuery object and not a native JavaScript object
  // ========================================================================
  var isQuery = function (obj) {
    return obj && obj.hasOwnProperty && obj instanceof $;
  };

  // Handle multiple browsers for "requestAnimationFrame" and "cancelAnimationFrame"
  // ===============================================================================
  var requestAFrame = (function () {
    return (
      window.requestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      // if all else fails, use setTimeout
      function (callback) {
        return window.setTimeout(callback, 1000 ../../../default.htm 60);
      }
    );
  })();

  var cancelAFrame = (function () {
    return (
      window.cancelAnimationFrame ||
      window.webkitCancelAnimationFrame ||
      window.mozCancelAnimationFrame ||
      window.oCancelAnimationFrame ||
      function (id) {
        window.clearTimeout(id);
      }
    );
  })();

  // Detect the supported transition-end event property name
  // =======================================================
  var transitionEnd = (function () {
    var el = document.createElement("fakeelement"),
      t;

    var transitions = {
      transition: "transitionend",
      OTransition: "oTransitionEnd",
      MozTransition: "transitionend",
      WebkitTransition: "webkitTransitionEnd"
    };

    for (t in transitions) {
      if (el.style[t] !== undefined) {
        return transitions[t];
      }
    }

    return "transitionend";
  })();

  // Force redraw on an element.
  // This helps in cases where the browser doesn't redraw an updated element properly
  // ================================================================================
  var forceRedraw = function ($el) {
    return $el && $el.length && $el[0].offsetHeight;
  };

  // Exclude array (`buttons`) options from deep merging
  // ===================================================
  var mergeOpts = function (opts1, opts2) {
    var rez = $.extend(true, {}, opts1, opts2);

    $.each(opts2, function (key, value) {
      if ($.isArray(value)) {
        rez[key] = value;
      }
    });

    return rez;
  };

  // How much of an element is visible in viewport
  // =============================================

  var inViewport = function (elem) {
    var elemCenter, rez;

    if (!elem || elem.ownerDocument !== document) {
      return false;
    }

    $(".fancybox-container").css("pointer-events", "none");

    elemCenter = {
      x: elem.getBoundingClientRect().left + elem.offsetWidth ../../../default.htm 2,
      y: elem.getBoundingClientRect().top + elem.offsetHeight ../../../default.htm 2
    };

    rez = document.elementFromPoint(elemCenter.x, elemCenter.y) === elem;

    $(".fancybox-container").css("pointer-events", "");

    return rez;
  };

  // Class definition
  // ================

  var FancyBox = function (content, opts, index) {
    var self = this;

    self.opts = mergeOpts({
      index: index
    }, $.fancybox.defaults);

    if ($.isPlainObject(opts)) {
      self.opts = mergeOpts(self.opts, opts);
    }

    if ($.fancybox.isMobile) {
      self.opts = mergeOpts(self.opts, self.opts.mobile);
    }

    self.id = self.opts.id || ++called;

    self.currIndex = parseInt(self.opts.index, 10) || 0;
    self.prevIndex = null;

    self.prevPos = null;
    self.currPos = 0;

    self.firstRun = true;

    // All group items
    self.group = [];

    // Existing slides (for current, next and previous gallery items)
    self.slides = {};

    // Create group elements
    self.addContent(content);

    if (!self.group.length) {
      return;
    }

    self.init();
  };

  $.extend(FancyBox.prototype, {
    // Create DOM structure
    // ====================

    init: function () {
      var self = this,
        firstItem = self.group[self.currIndex],
        firstItemOpts = firstItem.opts,
        $container,
        buttonStr;

      if (firstItemOpts.closeExisting) {
        $.fancybox.close(true);
      }

      // Hide scrollbars
      // ===============

      $("body").addClass("fancybox-active");

      if (
        !$.fancybox.getInstance() &&
        firstItemOpts.hideScrollbar !== false &&
        !$.fancybox.isMobile &&
        document.body.scrollHeight > window.innerHeight
      ) {
        $("head").append(
          '<style id="fancybox-style-noscroll" type="text/css">.compensate-for-scrollbar{margin-right:' +
          (window.innerWidth - document.documentElement.clientWidth) +
          "px;}</style>"
        );

        $("body").addClass("compensate-for-scrollbar");
      }

      // Build html markup and set references
      // ====================================

      // Build html code for buttons and insert into main template
      buttonStr = "";

      $.each(firstItemOpts.buttons, function (index, value) {
        buttonStr += firstItemOpts.btnTpl[value] || "";
      });

      // Create markup from base template, it will be initially hidden to
      // avoid unnecessary work like painting while initializing is not complete
      $container = $(
          self.translate(
            self,
            firstItemOpts.baseTpl
            .replace("{{buttons}}", buttonStr)
            .replace("{{arrows}}", firstItemOpts.btnTpl.arrowLeft + firstItemOpts.btnTpl.arrowRight)
          )
        )
        .attr("id", "fancybox-container-" + self.id)
        .addClass(firstItemOpts.baseClass)
        .data("FancyBox", self)
        .appendTo(firstItemOpts.parentEl);

      // Create object holding references to jQuery wrapped nodes
      self.$refs = {
        container: $container
      };

      ["bg", "inner", "infobar", "toolbar", "stage", "caption", "navigation"].forEach(function (item) {
        self.$refs[item] = $container.find(".fancybox-" + item);
      });

      self.trigger("onInit");

      // Enable events, deactive previous instances
      self.activate();

      // Build slides, load and reveal content
      self.jumpTo(self.currIndex);
    },

    // Simple i18n support - replaces object keys found in template
    // with corresponding values
    // ============================================================

    translate: function (obj, str) {
      var arr = obj.opts.i18n[obj.opts.lang] || obj.opts.i18n.en;

      return str.replace(/\{\{(\w+)\}\}/g, function (match, n) {
        return arr[n] === undefined ? match : arr[n];
      });
    },

    // Populate current group with fresh content
    // Check if each object has valid type and content
    // ===============================================

    addContent: function (content) {
      var self = this,
        items = $.makeArray(content),
        thumbs;

      $.each(items, function (i, item) {
        var obj = {},
          opts = {},
          $item,
          type,
          found,
          src,
          srcParts;

        // Step 1 - Make sure we have an object
        // ====================================

        if ($.isPlainObject(item)) {
          // We probably have manual usage here, something like
          // $.fancybox.open( [ { src : "../../../image.jpg", type : "image" } ] )

          obj = item;
          opts = item.opts || item;
        } else if ($.type(item) === "object" && $(item).length) {
          // Here we probably have jQuery collection returned by some selector
          $item = $(item);

          // Support attributes like `data-options='{"touch" : false}'` and `data-touch='false'`
          opts = $item.data() || {};
          opts = $.extend(true, {}, opts, opts.options);

          // Here we store clicked element
          opts.$orig = $item;

          obj.src = self.opts.src || opts.src || $item.attr("href");

          // Assume that simple syntax is used, for example:
          //   `$.fancybox.open( $("#test"), {} );`
          if (!obj.type && !obj.src) {
            obj.type = "inline";
            obj.src = item;
          }
        } else {
          // Assume we have a simple html code, for example:
          //   $.fancybox.open( '<div><h1>Hi!</h1></div>' );
          obj = {
            type: "html",
            src: item + ""
          };
        }

        // Each gallery object has full collection of options
        obj.opts = $.extend(true, {}, self.opts, opts);

        // Do not merge buttons array
        if ($.isArray(opts.buttons)) {
          obj.opts.buttons = opts.buttons;
        }

        if ($.fancybox.isMobile && obj.opts.mobile) {
          obj.opts = mergeOpts(obj.opts, obj.opts.mobile);
        }

        // Step 2 - Make sure we have content type, if not - try to guess
        // ==============================================================

        type = obj.type || obj.opts.type;
        src = obj.src || "";

        if (!type && src) {
          if ((found = src.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i))) {
            type = "video";

            if (!obj.opts.video.format) {
              obj.opts.video.format = "../../../video/default.htm" + (found[1] === "ogv" ? "ogg" : found[1]);
            }
          } else if (src.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i)) {
            type = "image";
          } else if (src.match(/\.(pdf)((\?|#).*)?$/i)) {
            type = "iframe";
            obj = $.extend(true, obj, {
              contentType: "pdf",
              opts: {
                iframe: {
                  preload: false
                }
              }
            });
          } else if (src.charAt(0) === "#") {
            type = "inline";
          }
        }

        if (type) {
          obj.type = type;
        } else {
          self.trigger("objectNeedsType", obj);
        }

        if (!obj.contentType) {
          obj.contentType = $.inArray(obj.type, ["html", "inline", "ajax"]) > -1 ? "html" : obj.type;
        }

        // Step 3 - Some adjustments
        // =========================

        obj.index = self.group.length;

        if (obj.opts.smallBtn == "auto") {
          obj.opts.smallBtn = $.inArray(obj.type, ["html", "inline", "ajax"]) > -1;
        }

        if (obj.opts.toolbar === "auto") {
          obj.opts.toolbar = !obj.opts.smallBtn;
        }

        // Find thumbnail image, check if exists and if is in the viewport
        obj.$thumb = obj.opts.$thumb || null;

        if (obj.opts.$trigger && obj.index === self.opts.index) {
          obj.$thumb = obj.opts.$trigger.find("img:first");

          if (obj.$thumb.length) {
            obj.opts.$orig = obj.opts.$trigger;
          }
        }

        if (!(obj.$thumb && obj.$thumb.length) && obj.opts.$orig) {
          obj.$thumb = obj.opts.$orig.find("img:first");
        }

        if (obj.$thumb && !obj.$thumb.length) {
          obj.$thumb = null;
        }

        obj.thumb = obj.opts.thumb || (obj.$thumb ? obj.$thumb[0].src : null);

        // "caption" is a "special" option, it can be used to customize caption per gallery item
        if ($.type(obj.opts.caption) === "function") {
          obj.opts.caption = obj.opts.caption.apply(item, [self, obj]);
        }

        if ($.type(self.opts.caption) === "function") {
          obj.opts.caption = self.opts.caption.apply(item, [self, obj]);
        }

        // Make sure we have caption as a string or jQuery object
        if (!(obj.opts.caption instanceof $)) {
          obj.opts.caption = obj.opts.caption === undefined ? "" : obj.opts.caption + "";
        }

        // Check if url contains "filter" used to filter the content
        // Example: "ajax.html #something"
        if (obj.type === "ajax") {
          srcParts = src.split(/\s+/, 2);

          if (srcParts.length > 1) {
            obj.src = srcParts.shift();

            obj.opts.filter = srcParts.shift();
          }
        }

        // Hide all buttons and disable interactivity for modal items
        if (obj.opts.modal) {
          obj.opts = $.extend(true, obj.opts, {
            trapFocus: true,
            // Remove buttons
            infobar: 0,
            toolbar: 0,

            smallBtn: 0,

            // Disable keyboard navigation
            keyboard: 0,

            // Disable some modules
            slideShow: 0,
            fullScreen: 0,
            thumbs: 0,
            touch: 0,

            // Disable click event handlers
            clickContent: false,
            clickSlide: false,
            clickOutside: false,
            dblclickContent: false,
            dblclickSlide: false,
            dblclickOutside: false
          });
        }

        // Step 4 - Add processed object to group
        // ======================================

        self.group.push(obj);
      });

      // Update controls if gallery is already opened
      if (Object.keys(self.slides).length) {
        self.updateControls();

        // Update thumbnails, if needed
        thumbs = self.Thumbs;

        if (thumbs && thumbs.isActive) {
          thumbs.create();

          thumbs.focus();
        }
      }
    },

    // Attach an event handler functions for:
    //   - navigation buttons
    //   - browser scrolling, resizing;
    //   - focusing
    //   - keyboard
    //   - detecting inactivity
    // ======================================

    addEvents: function () {
      var self = this;

      self.removeEvents();

      // Make navigation elements clickable
      // ==================================

      self.$refs.container
        .on("click.fb-close", "[data-fancybox-close]", function (e) {
          e.stopPropagation();
          e.preventDefault();

          self.close(e);
        })
        .on("touchstart.fb-prev click.fb-prev", "[data-fancybox-prev]", function (e) {
          e.stopPropagation();
          e.preventDefault();

          self.previous();
        })
        .on("touchstart.fb-next click.fb-next", "[data-fancybox-next]", function (e) {
          e.stopPropagation();
          e.preventDefault();

          self.next();
        })
        .on("click.fb", "[data-fancybox-zoom]", function (e) {
          // Click handler for zoom button
          self[self.isScaledDown() ? "scaleToActual" : "scaleToFit"]();
        });

      // Handle page scrolling and browser resizing
      // ==========================================

      $W.on("orientationchange.fb resize.fb", function (e) {
        if (e && e.originalEvent && e.originalEvent.type === "resize") {
          if (self.requestId) {
            cancelAFrame(self.requestId);
          }

          self.requestId = requestAFrame(function () {
            self.update(e);
          });
        } else {
          if (self.current && self.current.type === "iframe") {
            self.$refs.stage.hide();
          }

          setTimeout(
            function () {
              self.$refs.stage.show();

              self.update(e);
            },
            $.fancybox.isMobile ? 600 : 250
          );
        }
      });

      $D.on("keydown.fb", function (e) {
        var instance = $.fancybox ? $.fancybox.getInstance() : null,
          current = instance.current,
          keycode = e.keyCode || e.which;

        // Trap keyboard focus inside of the modal
        // =======================================

        if (keycode == 9) {
          if (current.opts.trapFocus) {
            self.focus(e);
          }

          return;
        }

        // Enable keyboard navigation
        // ==========================

        if (!current.opts.keyboard || e.ctrlKey || e.altKey || e.shiftKey || $(e.target).is("input,textarea,video,audio,select")) {
          return;
        }

        // Backspace and Esc keys
        if (keycode === 8 || keycode === 27) {
          e.preventDefault();

          self.close(e);

          return;
        }

        // Left arrow and Up arrow
        if (keycode === 37 || keycode === 38) {
          e.preventDefault();

          self.previous();

          return;
        }

        // Righ arrow and Down arrow
        if (keycode === 39 || keycode === 40) {
          e.preventDefault();

          self.next();

          return;
        }

        self.trigger("afterKeydown", e, keycode);
      });

      // Hide controls after some inactivity period
      if (self.group[self.currIndex].opts.idleTime) {
        self.idleSecondsCounter = 0;

        $D.on(
          "mousemove.fb-idle mouseleave.fb-idle mousedown.fb-idle touchstart.fb-idle touchmove.fb-idle scroll.fb-idle keydown.fb-idle",
          function (e) {
            self.idleSecondsCounter = 0;

            if (self.isIdle) {
              self.showControls();
            }

            self.isIdle = false;
          }
        );

        self.idleInterval = window.setInterval(function () {
          self.idleSecondsCounter++;

          if (self.idleSecondsCounter >= self.group[self.currIndex].opts.idleTime && !self.isDragging) {
            self.isIdle = true;
            self.idleSecondsCounter = 0;

            self.hideControls();
          }
        }, 1000);
      }
    },

    // Remove events added by the core
    // ===============================

    removeEvents: function () {
      var self = this;

      $W.off("orientationchange.fb resize.fb");
      $D.off("keydown.fb .fb-idle");

      this.$refs.container.off(".fb-close .fb-prev .fb-next");

      if (self.idleInterval) {
        window.clearInterval(self.idleInterval);

        self.idleInterval = null;
      }
    },

    // Change to previous gallery item
    // ===============================

    previous: function (duration) {
      return this.jumpTo(this.currPos - 1, duration);
    },

    // Change to next gallery item
    // ===========================

    next: function (duration) {
      return this.jumpTo(this.currPos + 1, duration);
    },

    // Switch to selected gallery item
    // ===============================

    jumpTo: function (pos, duration) {
      var self = this,
        groupLen = self.group.length,
        firstRun,
        isMoved,
        loop,
        current,
        previous,
        slidePos,
        stagePos,
        prop,
        diff;

      if (self.isDragging || self.isClosing || (self.isAnimating && self.firstRun)) {
        return;
      }

      // Should loop?
      pos = parseInt(pos, 10);
      loop = self.current ? self.current.opts.loop : self.opts.loop;

      if (!loop && (pos < 0 || pos >= groupLen)) {
        return false;
      }

      // Check if opening for the first time; this helps to speed things up
      firstRun = self.firstRun = !Object.keys(self.slides).length;

      // Create slides
      previous = self.current;

      self.prevIndex = self.currIndex;
      self.prevPos = self.currPos;

      current = self.createSlide(pos);

      if (groupLen > 1) {
        if (loop || current.index < groupLen - 1) {
          self.createSlide(pos + 1);
        }

        if (loop || current.index > 0) {
          self.createSlide(pos - 1);
        }
      }

      self.current = current;
      self.currIndex = current.index;
      self.currPos = current.pos;

      self.trigger("beforeShow", firstRun);

      self.updateControls();

      // Validate duration length
      current.forcedDuration = undefined;

      if ($.isNumeric(duration)) {
        current.forcedDuration = duration;
      } else {
        duration = current.opts[firstRun ? "animationDuration" : "transitionDuration"];
      }

      duration = parseInt(duration, 10);

      // Check if user has swiped the slides or if still animating
      isMoved = self.isMoved(current);

      // Make sure current slide is visible
      current.$slide.addClass("fancybox-slide--current");

      // Fresh start - reveal container, current slide and start loading content
      if (firstRun) {
        if (current.opts.animationEffect && duration) {
          self.$refs.container.css("transition-duration", duration + "ms");
        }

        self.$refs.container.addClass("fancybox-is-open").trigger("focus");

        // Attempt to load content into slide
        // This will later call `afterLoad` -> `revealContent`
        self.loadSlide(current);

        self.preload("image");

        return;
      }

      // Get actual slide/stage positions (before cleaning up)
      slidePos = $.fancybox.getTranslate(previous.$slide);
      stagePos = $.fancybox.getTranslate(self.$refs.stage);

      // Clean up all slides
      $.each(self.slides, function (index, slide) {
        $.fancybox.stop(slide.$slide, true);
      });

      if (previous.pos !== current.pos) {
        previous.isComplete = false;
      }

      previous.$slide.removeClass("fancybox-slide--complete fancybox-slide--current");

      // If slides are out of place, then animate them to correct position
      if (isMoved) {
        // Calculate horizontal swipe distance
        diff = slidePos.left - (previous.pos * slidePos.width + previous.pos * previous.opts.gutter);

        $.each(self.slides, function (index, slide) {
          slide.$slide.removeClass("fancybox-animated").removeClass(function (index, className) {
            return (className.match(/(^|\s)fancybox-fx-\S+/g) || []).join(" ");
          });

          // Make sure that each slide is in equal distance
          // This is mostly needed for freshly added slides, because they are not yet positioned
          var leftPos = slide.pos * slidePos.width + slide.pos * slide.opts.gutter;

          $.fancybox.setTranslate(slide.$slide, {
            top: 0,
            left: leftPos - stagePos.left + diff
          });

          if (slide.pos !== current.pos) {
            slide.$slide.addClass("fancybox-slide--" + (slide.pos > current.pos ? "next" : "previous"));
          }

          // Redraw to make sure that transition will start
          forceRedraw(slide.$slide);

          // Animate the slide
          $.fancybox.animate(
            slide.$slide, {
              top: 0,
              left: (slide.pos - current.pos) * slidePos.width + (slide.pos - current.pos) * slide.opts.gutter
            },
            duration,
            function () {
              slide.$slide
                .css({
                  transform: "",
                  opacity: ""
                })
                .removeClass("fancybox-slide--next fancybox-slide--previous");

              if (slide.pos === self.currPos) {
                self.complete();
              }
            }
          );
        });
      } else if (duration && current.opts.transitionEffect) {
        // Set transition effect for previously active slide
        prop = "fancybox-animated fancybox-fx-" + current.opts.transitionEffect;

        previous.$slide.addClass("fancybox-slide--" + (previous.pos > current.pos ? "next" : "previous"));

        $.fancybox.animate(
          previous.$slide,
          prop,
          duration,
          function () {
            previous.$slide.removeClass(prop).removeClass("fancybox-slide--next fancybox-slide--previous");
          },
          false
        );
      }

      if (current.isLoaded) {
        self.revealContent(current);
      } else {
        self.loadSlide(current);
      }

      self.preload("image");
    },

    // Create new "slide" element
    // These are gallery items  that are actually added to DOM
    // =======================================================

    createSlide: function (pos) {
      var self = this,
        $slide,
        index;

      index = pos % self.group.length;
      index = index < 0 ? self.group.length + index : index;

      if (!self.slides[pos] && self.group[index]) {
        $slide = $('<div class="fancybox-slide"></div>').appendTo(self.$refs.stage);

        self.slides[pos] = $.extend(true, {}, self.group[index], {
          pos: pos,
          $slide: $slide,
          isLoaded: false
        });

        self.updateSlide(self.slides[pos]);
      }

      return self.slides[pos];
    },

    // Scale image to the actual size of the image;
    // x and y values should be relative to the slide
    // ==============================================

    scaleToActual: function (x, y, duration) {
      var self = this,
        current = self.current,
        $content = current.$content,
        canvasWidth = $.fancybox.getTranslate(current.$slide).width,
        canvasHeight = $.fancybox.getTranslate(current.$slide).height,
        newImgWidth = current.width,
        newImgHeight = current.height,
        imgPos,
        posX,
        posY,
        scaleX,
        scaleY;

      if (self.isAnimating || self.isMoved() || !$content || !(current.type == "image" && current.isLoaded && !current.hasError)) {
        return;
      }

      self.isAnimating = true;

      $.fancybox.stop($content);

      x = x === undefined ? canvasWidth * 0.5 : x;
      y = y === undefined ? canvasHeight * 0.5 : y;

      imgPos = $.fancybox.getTranslate($content);

      imgPos.top -= $.fancybox.getTranslate(current.$slide).top;
      imgPos.left -= $.fancybox.getTranslate(current.$slide).left;

      scaleX = newImgWidth ../../../default.htm imgPos.width;
      scaleY = newImgHeight ../../../default.htm imgPos.height;

      // Get center position for original image
      posX = canvasWidth * 0.5 - newImgWidth * 0.5;
      posY = canvasHeight * 0.5 - newImgHeight * 0.5;

      // Make sure image does not move away from edges
      if (newImgWidth > canvasWidth) {
        posX = imgPos.left * scaleX - (x * scaleX - x);

        if (posX > 0) {
          posX = 0;
        }

        if (posX < canvasWidth - newImgWidth) {
          posX = canvasWidth - newImgWidth;
        }
      }

      if (newImgHeight > canvasHeight) {
        posY = imgPos.top * scaleY - (y * scaleY - y);

        if (posY > 0) {
          posY = 0;
        }

        if (posY < canvasHeight - newImgHeight) {
          posY = canvasHeight - newImgHeight;
        }
      }

      self.updateCursor(newImgWidth, newImgHeight);

      $.fancybox.animate(
        $content, {
          top: posY,
          left: posX,
          scaleX: scaleX,
          scaleY: scaleY
        },
        duration || 366,
        function () {
          self.isAnimating = false;
        }
      );

      // Stop slideshow
      if (self.SlideShow && self.SlideShow.isActive) {
        self.SlideShow.stop();
      }
    },

    // Scale image to fit inside parent element
    // ========================================

    scaleToFit: function (duration) {
      var self = this,
        current = self.current,
        $content = current.$content,
        end;

      if (self.isAnimating || self.isMoved() || !$content || !(current.type == "image" && current.isLoaded && !current.hasError)) {
        return;
      }

      self.isAnimating = true;

      $.fancybox.stop($content);

      end = self.getFitPos(current);

      self.updateCursor(end.width, end.height);

      $.fancybox.animate(
        $content, {
          top: end.top,
          left: end.left,
          scaleX: end.width ../../../default.htm $content.width(),
          scaleY: end.height ../../../default.htm $content.height()
        },
        duration || 366,
        function () {
          self.isAnimating = false;
        }
      );
    },

    // Calculate image size to fit inside viewport
    // ===========================================

    getFitPos: function (slide) {
      var self = this,
        $content = slide.$content,
        $slide = slide.$slide,
        width = slide.width || slide.opts.width,
        height = slide.height || slide.opts.height,
        maxWidth,
        maxHeight,
        minRatio,
        aspectRatio,
        rez = {};

      if (!slide.isLoaded || !$content || !$content.length) {
        return false;
      }

      maxWidth = $.fancybox.getTranslate(self.$refs.stage).width;
      maxHeight = $.fancybox.getTranslate(self.$refs.stage).height;

      maxWidth -=
        parseFloat($slide.css("paddingLeft")) +
        parseFloat($slide.css("paddingRight")) +
        parseFloat($content.css("marginLeft")) +
        parseFloat($content.css("marginRight"));

      maxHeight -=
        parseFloat($slide.css("paddingTop")) +
        parseFloat($slide.css("paddingBottom")) +
        parseFloat($content.css("marginTop")) +
        parseFloat($content.css("marginBottom"));

      if (!width || !height) {
        width = maxWidth;
        height = maxHeight;
      }

      minRatio = Math.min(1, maxWidth ../../../default.htm width, maxHeight ../../../default.htm height);

      width = minRatio * width;
      height = minRatio * height;

      // Adjust width/height to precisely fit into container
      if (width > maxWidth - 0.5) {
        width = maxWidth;
      }

      if (height > maxHeight - 0.5) {
        height = maxHeight;
      }

      if (slide.type === "image") {
        rez.top = Math.floor((maxHeight - height) * 0.5) + parseFloat($slide.css("paddingTop"));
        rez.left = Math.floor((maxWidth - width) * 0.5) + parseFloat($slide.css("paddingLeft"));
      } else if (slide.contentType === "video") {
        // Force aspect ratio for the video
        // "I say the whole world must learn of our peaceful ways… by force!"
        aspectRatio = slide.opts.width && slide.opts.height ? width ../../../default.htm height : slide.opts.ratio || 16 ../../../default.htm 9;

        if (height > width ../../../default.htm aspectRatio) {
          height = width ../../../default.htm aspectRatio;
        } else if (width > height * aspectRatio) {
          width = height * aspectRatio;
        }
      }

      rez.width = width;
      rez.height = height;

      return rez;
    },

    // Update content size and position for all slides
    // ==============================================

    update: function (e) {
      var self = this;

      $.each(self.slides, function (key, slide) {
        self.updateSlide(slide, e);
      });
    },

    // Update slide content position and size
    // ======================================

    updateSlide: function (slide, e) {
      var self = this,
        $content = slide && slide.$content,
        width = slide.width || slide.opts.width,
        height = slide.height || slide.opts.height,
        $slide = slide.$slide;

      // First, prevent caption overlap, if needed
      self.adjustCaption(slide);

      // Then resize content to fit inside the slide
      if ($content && (width || height || slide.contentType === "video") && !slide.hasError) {
        $.fancybox.stop($content);

        $.fancybox.setTranslate($content, self.getFitPos(slide));

        if (slide.pos === self.currPos) {
          self.isAnimating = false;

          self.updateCursor();
        }
      }

      // Then some adjustments
      self.adjustLayout(slide);

      if ($slide.length) {
        $slide.trigger("refresh");

        if (slide.pos === self.currPos) {
          self.$refs.toolbar
            .add(self.$refs.navigation.find(".fancybox-button--arrow_right"))
            .toggleClass("compensate-for-scrollbar", $slide.get(0).scrollHeight > $slide.get(0).clientHeight);
        }
      }

      self.trigger("onUpdate", slide, e);
    },

    // Horizontally center slide
    // =========================

    centerSlide: function (duration) {
      var self = this,
        current = self.current,
        $slide = current.$slide;

      if (self.isClosing || !current) {
        return;
      }

      $slide.siblings().css({
        transform: "",
        opacity: ""
      });

      $slide
        .parent()
        .children()
        .removeClass("fancybox-slide--previous fancybox-slide--next");

      $.fancybox.animate(
        $slide, {
          top: 0,
          left: 0,
          opacity: 1
        },
        duration === undefined ? 0 : duration,
        function () {
          // Clean up
          $slide.css({
            transform: "",
            opacity: ""
          });

          if (!current.isComplete) {
            self.complete();
          }
        },
        false
      );
    },

    // Check if current slide is moved (swiped)
    // ========================================

    isMoved: function (slide) {
      var current = slide || this.current,
        slidePos,
        stagePos;

      if (!current) {
        return false;
      }

      stagePos = $.fancybox.getTranslate(this.$refs.stage);
      slidePos = $.fancybox.getTranslate(current.$slide);

      return (
        !current.$slide.hasClass("fancybox-animated") &&
        (Math.abs(slidePos.top - stagePos.top) > 0.5 || Math.abs(slidePos.left - stagePos.left) > 0.5)
      );
    },

    // Update cursor style depending if content can be zoomed
    // ======================================================

    updateCursor: function (nextWidth, nextHeight) {
      var self = this,
        current = self.current,
        $container = self.$refs.container,
        canPan,
        isZoomable;

      if (!current || self.isClosing || !self.Guestures) {
        return;
      }

      $container.removeClass("fancybox-is-zoomable fancybox-can-zoomIn fancybox-can-zoomOut fancybox-can-swipe fancybox-can-pan");

      canPan = self.canPan(nextWidth, nextHeight);

      isZoomable = canPan ? true : self.isZoomable();

      $container.toggleClass("fancybox-is-zoomable", isZoomable);

      $("[data-fancybox-zoom]").prop("disabled", !isZoomable);

      if (canPan) {
        $container.addClass("fancybox-can-pan");
      } else if (
        isZoomable &&
        (current.opts.clickContent === "zoom" || ($.isFunction(current.opts.clickContent) && current.opts.clickContent(current) == "zoom"))
      ) {
        $container.addClass("fancybox-can-zoomIn");
      } else if (current.opts.touch && (current.opts.touch.vertical || self.group.length > 1) && current.contentType !== "video") {
        $container.addClass("fancybox-can-swipe");
      }
    },

    // Check if current slide is zoomable
    // ==================================

    isZoomable: function () {
      var self = this,
        current = self.current,
        fitPos;

      // Assume that slide is zoomable if:
      //   - image is still loading
      //   - actual size of the image is smaller than available area
      if (current && !self.isClosing && current.type === "image" && !current.hasError) {
        if (!current.isLoaded) {
          return true;
        }

        fitPos = self.getFitPos(current);

        if (fitPos && (current.width > fitPos.width || current.height > fitPos.height)) {
          return true;
        }
      }

      return false;
    },

    // Check if current image dimensions are smaller than actual
    // =========================================================

    isScaledDown: function (nextWidth, nextHeight) {
      var self = this,
        rez = false,
        current = self.current,
        $content = current.$content;

      if (nextWidth !== undefined && nextHeight !== undefined) {
        rez = nextWidth < current.width && nextHeight < current.height;
      } else if ($content) {
        rez = $.fancybox.getTranslate($content);
        rez = rez.width < current.width && rez.height < current.height;
      }

      return rez;
    },

    // Check if image dimensions exceed parent element
    // ===============================================

    canPan: function (nextWidth, nextHeight) {
      var self = this,
        current = self.current,
        pos = null,
        rez = false;

      if (current.type === "image" && (current.isComplete || (nextWidth && nextHeight)) && !current.hasError) {
        rez = self.getFitPos(current);

        if (nextWidth !== undefined && nextHeight !== undefined) {
          pos = {
            width: nextWidth,
            height: nextHeight
          };
        } else if (current.isComplete) {
          pos = $.fancybox.getTranslate(current.$content);
        }

        if (pos && rez) {
          rez = Math.abs(pos.width - rez.width) > 1.5 || Math.abs(pos.height - rez.height) > 1.5;
        }
      }

      return rez;
    },

    // Load content into the slide
    // ===========================

    loadSlide: function (slide) {
      var self = this,
        type,
        $slide,
        ajaxLoad;

      if (slide.isLoading || slide.isLoaded) {
        return;
      }

      slide.isLoading = true;

      if (self.trigger("beforeLoad", slide) === false) {
        slide.isLoading = false;

        return false;
      }

      type = slide.type;
      $slide = slide.$slide;

      $slide
        .off("refresh")
        .trigger("onReset")
        .addClass(slide.opts.slideClass);

      // Create content depending on the type
      switch (type) {
        case "image":
          self.setImage(slide);

          break;

        case "iframe":
          self.setIframe(slide);

          break;

        case "html":
          self.setContent(slide, slide.src || slide.content);

          break;

        case "video":
          self.setContent(
            slide,
            slide.opts.video.tpl
            .replace(/\{\{src\}\}/gi, slide.src)
            .replace("{{format}}", slide.opts.videoFormat || slide.opts.video.format || "")
            .replace("{{poster}}", slide.thumb || "")
          );

          break;

        case "inline":
          if ($(slide.src).length) {
            self.setContent(slide, $(slide.src));
          } else {
            self.setError(slide);
          }

          break;

        case "ajax":
          self.showLoading(slide);

          ajaxLoad = $.ajax(
            $.extend({}, slide.opts.ajax.settings, {
              url: slide.src,
              success: function (data, textStatus) {
                if (textStatus === "success") {
                  self.setContent(slide, data);
                }
              },
              error: function (jqXHR, textStatus) {
                if (jqXHR && textStatus !== "abort") {
                  self.setError(slide);
                }
              }
            })
          );

          $slide.one("onReset", function () {
            ajaxLoad.abort();
          });

          break;

        default:
          self.setError(slide);

          break;
      }

      return true;
    },

    // Use thumbnail image, if possible
    // ================================

    setImage: function (slide) {
      var self = this,
        ghost;

      // Check if need to show loading icon
      setTimeout(function () {
        var $img = slide.$image;

        if (!self.isClosing && slide.isLoading && (!$img || !$img.length || !$img[0].complete) && !slide.hasError) {
          self.showLoading(slide);
        }
      }, 50);

      //Check if image has srcset
      self.checkSrcset(slide);

      // This will be wrapper containing both ghost and actual image
      slide.$content = $('<div class="fancybox-content"></div>')
        .addClass("fancybox-is-hidden")
        .appendTo(slide.$slide.addClass("fancybox-slide--image"));

      // If we have a thumbnail, we can display it while actual image is loading
      // Users will not stare at black screen and actual image will appear gradually
      if (slide.opts.preload !== false && slide.opts.width && slide.opts.height && slide.thumb) {
        slide.width = slide.opts.width;
        slide.height = slide.opts.height;

        ghost = document.createElement("img");

        ghost.onerror = function () {
          $(this).remove();

          slide.$ghost = null;
        };

        ghost.onload = function () {
          self.afterLoad(slide);
        };

        slide.$ghost = $(ghost)
          .addClass("fancybox-image")
          .appendTo(slide.$content)
          .attr("src", slide.thumb);
      }

      // Start loading actual image
      self.setBigImage(slide);
    },

    // Check if image has srcset and get the source
    // ============================================
    checkSrcset: function (slide) {
      var srcset = slide.opts.srcset || slide.opts.image.srcset,
        found,
        temp,
        pxRatio,
        windowWidth;

      // If we have "srcset", then we need to find first matching "src" value.
      // This is necessary, because when you set an src attribute, the browser will preload the image
      // before any javascript or even CSS is applied.
      if (srcset) {
        pxRatio = window.devicePixelRatio || 1;
        windowWidth = window.innerWidth * pxRatio;

        temp = srcset.split(",").map(function (el) {
          var ret = {};

          el.trim()
            .split(/\s+/)
            .forEach(function (el, i) {
              var value = parseInt(el.substring(0, el.length - 1), 10);

              if (i === 0) {
                return (ret.url = el);
              }

              if (value) {
                ret.value = value;
                ret.postfix = el[el.length - 1];
              }
            });

          return ret;
        });

        // Sort by value
        temp.sort(function (a, b) {
          return a.value - b.value;
        });

        // Ok, now we have an array of all srcset values
        for (var j = 0; j < temp.length; j++) {
          var el = temp[j];

          if ((el.postfix === "w" && el.value >= windowWidth) || (el.postfix === "x" && el.value >= pxRatio)) {
            found = el;
            break;
          }
        }

        // If not found, take the last one
        if (!found && temp.length) {
          found = temp[temp.length - 1];
        }

        if (found) {
          slide.src = found.url;

          // If we have default width/height values, we can calculate height for matching source
          if (slide.width && slide.height && found.postfix == "w") {
            slide.height = (slide.width ../../../default.htm slide.height) * found.value;
            slide.width = found.value;
          }

          slide.opts.srcset = srcset;
        }
      }
    },

    // Create full-size image
    // ======================

    setBigImage: function (slide) {
      var self = this,
        img = document.createElement("img"),
        $img = $(img);

      slide.$image = $img
        .one("error", function () {
          self.setError(slide);
        })
        .one("load", function () {
          var sizes;

          if (!slide.$ghost) {
            self.resolveImageSlideSize(slide, this.naturalWidth, this.naturalHeight);

            self.afterLoad(slide);
          }

          if (self.isClosing) {
            return;
          }

          if (slide.opts.srcset) {
            sizes = slide.opts.sizes;

            if (!sizes || sizes === "auto") {
              sizes =
                (slide.width ../../../default.htm slide.height > 1 && $W.width() ../../../default.htm $W.height() > 1 ? "100" : Math.round((slide.width ../../../default.htm slide.height) * 100)) +
                "vw";
            }

            $img.attr("sizes", sizes).attr("srcset", slide.opts.srcset);
          }

          // Hide temporary image after some delay
          if (slide.$ghost) {
            setTimeout(function () {
              if (slide.$ghost && !self.isClosing) {
                slide.$ghost.hide();
              }
            }, Math.min(300, Math.max(1000, slide.height ../../../default.htm 1600)));
          }

          self.hideLoading(slide);
        })
        .addClass("fancybox-image")
        .attr("src", slide.src)
        .appendTo(slide.$content);

      if ((img.complete || img.readyState == "complete") && $img.naturalWidth && $img.naturalHeight) {
        $img.trigger("load");
      } else if (img.error) {
        $img.trigger("error");
      }
    },

    // Computes the slide size from image size and maxWidth/maxHeight
    // ==============================================================

    resolveImageSlideSize: function (slide, imgWidth, imgHeight) {
      var maxWidth = parseInt(slide.opts.width, 10),
        maxHeight = parseInt(slide.opts.height, 10);

      // Sets the default values from the image
      slide.width = imgWidth;
      slide.height = imgHeight;

      if (maxWidth > 0) {
        slide.width = maxWidth;
        slide.height = Math.floor((maxWidth * imgHeight) ../../../default.htm imgWidth);
      }

      if (maxHeight > 0) {
        slide.width = Math.floor((maxHeight * imgWidth) ../../../default.htm imgHeight);
        slide.height = maxHeight;
      }
    },

    // Create iframe wrapper, iframe and bindings
    // ==========================================

    setIframe: function (slide) {
      var self = this,
        opts = slide.opts.iframe,
        $slide = slide.$slide,
        $iframe;

      slide.$content = $('<div class="fancybox-content' + (opts.preload ? " fancybox-is-hidden" : "") + '"></div>')
        .css(opts.css)
        .appendTo($slide);

      $slide.addClass("fancybox-slide--" + slide.contentType);

      slide.$iframe = $iframe = $(opts.tpl.replace(/\{rnd\}/g, new Date().getTime()))
        .attr(opts.attr)
        .appendTo(slide.$content);

      if (opts.preload) {
        self.showLoading(slide);

        // Unfortunately, it is not always possible to determine if iframe is successfully loaded
        // (due to browser security policy)

        $iframe.on("load.fb error.fb", function (e) {
          this.isReady = 1;

          slide.$slide.trigger("refresh");

          self.afterLoad(slide);
        });

        // Recalculate iframe content size
        // ===============================

        $slide.on("refresh.fb", function () {
          var $content = slide.$content,
            frameWidth = opts.css.width,
            frameHeight = opts.css.height,
            $contents,
            $body;

          if ($iframe[0].isReady !== 1) {
            return;
          }

          try {
            $contents = $iframe.contents();
            $body = $contents.find("body");
          } catch (ignore) {}

          // Calculate content dimensions, if it is accessible
          if ($body && $body.length && $body.children().length) {
            // Avoid scrolling to top (if multiple instances)
            $slide.css("overflow", "visible");

            $content.css({
              width: "100%",
              "max-width": "100%",
              height: "9999px"
            });

            if (frameWidth === undefined) {
              frameWidth = Math.ceil(Math.max($body[0].clientWidth, $body.outerWidth(true)));
            }

            $content.css("width", frameWidth ? frameWidth : "").css("max-width", "");

            if (frameHeight === undefined) {
              frameHeight = Math.ceil(Math.max($body[0].clientHeight, $body.outerHeight(true)));
            }

            $content.css("height", frameHeight ? frameHeight : "");

            $slide.css("overflow", "auto");
          }

          $content.removeClass("fancybox-is-hidden");
        });
      } else {
        self.afterLoad(slide);
      }

      $iframe.attr("src", slide.src);

      // Remove iframe if closing or changing gallery item
      $slide.one("onReset", function () {
        // This helps IE not to throw errors when closing
        try {
          $(this)
            .find("iframe")
            .hide()
            .unbind()
            .attr("src", "//about:blank");
        } catch (ignore) {}

        $(this)
          .off("refresh.fb")
          .empty();

        slide.isLoaded = false;
        slide.isRevealed = false;
      });
    },

    // Wrap and append content to the slide
    // ======================================

    setContent: function (slide, content) {
      var self = this;

      if (self.isClosing) {
        return;
      }

      self.hideLoading(slide);

      if (slide.$content) {
        $.fancybox.stop(slide.$content);
      }

      slide.$slide.empty();

      // If content is a jQuery object, then it will be moved to the slide.
      // The placeholder is created so we will know where to put it back.
      if (isQuery(content) && content.parent().length) {
        // Make sure content is not already moved to fancyBox
        if (content.hasClass("fancybox-content") || content.parent().hasClass("fancybox-content")) {
          content.parents(".fancybox-slide").trigger("onReset");
        }

        // Create temporary element marking original place of the content
        slide.$placeholder = $("<div>")
          .hide()
          .insertAfter(content);

        // Make sure content is visible
        content.css("display", "inline-block");
      } else if (!slide.hasError) {
        // If content is just a plain text, try to convert it to html
        if ($.type(content) === "string") {
          content = $("<div>")
            .append($.trim(content))
            .contents();
        }

        // If "filter" option is provided, then filter content
        if (slide.opts.filter) {
          content = $("<div>")
            .html(content)
            .find(slide.opts.filter);
        }
      }

      slide.$slide.one("onReset", function () {
        // Pause all html5 video/audio
        $(this)
          .find("video,audio")
          .trigger("pause");

        // Put content back
        if (slide.$placeholder) {
          slide.$placeholder.after(content.removeClass("fancybox-content").hide()).remove();

          slide.$placeholder = null;
        }

        // Remove custom close button
        if (slide.$smallBtn) {
          slide.$smallBtn.remove();

          slide.$smallBtn = null;
        }

        // Remove content and mark slide as not loaded
        if (!slide.hasError) {
          $(this).empty();

          slide.isLoaded = false;
          slide.isRevealed = false;
        }
      });

      $(content).appendTo(slide.$slide);

      if ($(content).is("video,audio")) {
        $(content).addClass("fancybox-video");

        $(content).wrap("<div></div>");

        slide.contentType = "video";

        slide.opts.width = slide.opts.width || $(content).attr("width");
        slide.opts.height = slide.opts.height || $(content).attr("height");
      }

      slide.$content = slide.$slide
        .children()
        .filter("div,form,main,video,audio,article,.fancybox-content")
        .first();

      slide.$content.siblings().hide();

      // Re-check if there is a valid content
      // (in some cases, ajax response can contain various elements or plain text)
      if (!slide.$content.length) {
        slide.$content = slide.$slide
          .wrapInner("<div></div>")
          .children()
          .first();
      }

      slide.$content.addClass("fancybox-content");

      slide.$slide.addClass("fancybox-slide--" + slide.contentType);

      self.afterLoad(slide);
    },

    // Display error message
    // =====================

    setError: function (slide) {
      slide.hasError = true;

      slide.$slide
        .trigger("onReset")
        .removeClass("fancybox-slide--" + slide.contentType)
        .addClass("fancybox-slide--error");

      slide.contentType = "html";

      this.setContent(slide, this.translate(slide, slide.opts.errorTpl));

      if (slide.pos === this.currPos) {
        this.isAnimating = false;
      }
    },

    // Show loading icon inside the slide
    // ==================================

    showLoading: function (slide) {
      var self = this;

      slide = slide || self.current;

      if (slide && !slide.$spinner) {
        slide.$spinner = $(self.translate(self, self.opts.spinnerTpl))
          .appendTo(slide.$slide)
          .hide()
          .fadeIn("fast");
      }
    },

    // Remove loading icon from the slide
    // ==================================

    hideLoading: function (slide) {
      var self = this;

      slide = slide || self.current;

      if (slide && slide.$spinner) {
        slide.$spinner.stop().remove();

        delete slide.$spinner;
      }
    },

    // Adjustments after slide content has been loaded
    // ===============================================

    afterLoad: function (slide) {
      var self = this;

      if (self.isClosing) {
        return;
      }

      slide.isLoading = false;
      slide.isLoaded = true;

      self.trigger("afterLoad", slide);

      self.hideLoading(slide);

      // Add small close button
      if (slide.opts.smallBtn && (!slide.$smallBtn || !slide.$smallBtn.length)) {
        slide.$smallBtn = $(self.translate(slide, slide.opts.btnTpl.smallBtn)).appendTo(slide.$content);
      }

      // Disable right click
      if (slide.opts.protect && slide.$content && !slide.hasError) {
        slide.$content.on("contextmenu.fb", function (e) {
          if (e.button == 2) {
            e.preventDefault();
          }

          return true;
        });

        // Add fake element on top of the image
        // This makes a bit harder for user to select image
        if (slide.type === "image") {
          $('<div class="fancybox-spaceball"></div>').appendTo(slide.$content);
        }
      }

      self.adjustCaption(slide);

      self.adjustLayout(slide);

      if (slide.pos === self.currPos) {
        self.updateCursor();
      }

      self.revealContent(slide);
    },

    // Prevent caption overlap,
    // fix css inconsistency across browsers
    // =====================================

    adjustCaption: function (slide) {
      var self = this,
        current = slide || self.current,
        caption = current.opts.caption,
        preventOverlap = current.opts.preventCaptionOverlap,
        $caption = self.$refs.caption,
        $clone,
        captionH = false;

      $caption.toggleClass("fancybox-caption--separate", preventOverlap);

      if (preventOverlap && caption && caption.length) {
        if (current.pos !== self.currPos) {
          $clone = $caption.clone().appendTo($caption.parent());

          $clone
            .children()
            .eq(0)
            .empty()
            .html(caption);

          captionH = $clone.outerHeight(true);

          $clone.empty().remove();
        } else if (self.$caption) {
          captionH = self.$caption.outerHeight(true);
        }

        current.$slide.css("padding-bottom", captionH || "");
      }
    },

    // Simple hack to fix inconsistency across browsers, described here (affects Edge, too):
    // https://bugzilla.mozilla.org/show_bug.cgi?id=748518
    // ====================================================================================

    adjustLayout: function (slide) {
      var self = this,
        current = slide || self.current,
        scrollHeight,
        marginBottom,
        inlinePadding,
        actualPadding;

      if (current.isLoaded && current.opts.disableLayoutFix !== true) {
        current.$content.css("margin-bottom", "");

        // If we would always set margin-bottom for the content,
        // then it would potentially break vertical align
        if (current.$content.outerHeight() > current.$slide.height() + 0.5) {
          inlinePadding = current.$slide[0].style["padding-bottom"];
          actualPadding = current.$slide.css("padding-bottom");

          if (parseFloat(actualPadding) > 0) {
            scrollHeight = current.$slide[0].scrollHeight;

            current.$slide.css("padding-bottom", 0);

            if (Math.abs(scrollHeight - current.$slide[0].scrollHeight) < 1) {
              marginBottom = actualPadding;
            }

            current.$slide.css("padding-bottom", inlinePadding);
          }
        }

        current.$content.css("margin-bottom", marginBottom);
      }
    },

    // Make content visible
    // This method is called right after content has been loaded or
    // user navigates gallery and transition should start
    // ============================================================

    revealContent: function (slide) {
      var self = this,
        $slide = slide.$slide,
        end = false,
        start = false,
        isMoved = self.isMoved(slide),
        isRevealed = slide.isRevealed,
        effect,
        effectClassName,
        duration,
        opacity;

      slide.isRevealed = true;

      effect = slide.opts[self.firstRun ? "animationEffect" : "transitionEffect"];
      duration = slide.opts[self.firstRun ? "animationDuration" : "transitionDuration"];

      duration = parseInt(slide.forcedDuration === undefined ? duration : slide.forcedDuration, 10);

      if (isMoved || slide.pos !== self.currPos || !duration) {
        effect = false;
      }

      // Check if can zoom
      if (effect === "zoom") {
        if (slide.pos === self.currPos && duration && slide.type === "image" && !slide.hasError && (start = self.getThumbPos(slide))) {
          end = self.getFitPos(slide);
        } else {
          effect = "fade";
        }
      }

      // Zoom animation
      // ==============
      if (effect === "zoom") {
        self.isAnimating = true;

        end.scaleX = end.width ../../../default.htm start.width;
        end.scaleY = end.height ../../../default.htm start.height;

        // Check if we need to animate opacity
        opacity = slide.opts.zoomOpacity;

        if (opacity == "auto") {
          opacity = Math.abs(slide.width ../../../default.htm slide.height - start.width ../../../default.htm start.height) > 0.1;
        }

        if (opacity) {
          start.opacity = 0.1;
          end.opacity = 1;
        }

        // Draw image at start position
        $.fancybox.setTranslate(slide.$content.removeClass("fancybox-is-hidden"), start);

        forceRedraw(slide.$content);

        // Start animation
        $.fancybox.animate(slide.$content, end, duration, function () {
          self.isAnimating = false;

          self.complete();
        });

        return;
      }

      self.updateSlide(slide);

      // Simply show content if no effect
      // ================================
      if (!effect) {
        slide.$content.removeClass("fancybox-is-hidden");

        if (!isRevealed && isMoved && slide.type === "image" && !slide.hasError) {
          slide.$content.hide().fadeIn("fast");
        }

        if (slide.pos === self.currPos) {
          self.complete();
        }

        return;
      }

      // Prepare for CSS transiton
      // =========================
      $.fancybox.stop($slide);

      //effectClassName = "fancybox-animated fancybox-slide--" + (slide.pos >= self.prevPos ? "next" : "previous") + " fancybox-fx-" + effect;
      effectClassName = "fancybox-slide--" + (slide.pos >= self.prevPos ? "next" : "previous") + " fancybox-animated fancybox-fx-" + effect;

      $slide.addClass(effectClassName).removeClass("fancybox-slide--current"); //.addClass(effectClassName);

      slide.$content.removeClass("fancybox-is-hidden");

      // Force reflow
      forceRedraw($slide);

      if (slide.type !== "image") {
        slide.$content.hide().show(0);
      }

      $.fancybox.animate(
        $slide,
        "fancybox-slide--current",
        duration,
        function () {
          $slide.removeClass(effectClassName).css({
            transform: "",
            opacity: ""
          });

          if (slide.pos === self.currPos) {
            self.complete();
          }
        },
        true
      );
    },

    // Check if we can and have to zoom from thumbnail
    //================================================

    getThumbPos: function (slide) {
      var rez = false,
        $thumb = slide.$thumb,
        thumbPos,
        btw,
        brw,
        bbw,
        blw;

      if (!$thumb || !inViewport($thumb[0])) {
        return false;
      }

      thumbPos = $.fancybox.getTranslate($thumb);

      btw = parseFloat($thumb.css("border-top-width") || 0);
      brw = parseFloat($thumb.css("border-right-width") || 0);
      bbw = parseFloat($thumb.css("border-bottom-width") || 0);
      blw = parseFloat($thumb.css("border-left-width") || 0);

      rez = {
        top: thumbPos.top + btw,
        left: thumbPos.left + blw,
        width: thumbPos.width - brw - blw,
        height: thumbPos.height - btw - bbw,
        scaleX: 1,
        scaleY: 1
      };

      return thumbPos.width > 0 && thumbPos.height > 0 ? rez : false;
    },

    // Final adjustments after current gallery item is moved to position
    // and it`s content is loaded
    // ==================================================================

    complete: function () {
      var self = this,
        current = self.current,
        slides = {},
        $el;

      if (self.isMoved() || !current.isLoaded) {
        return;
      }

      if (!current.isComplete) {
        current.isComplete = true;

        current.$slide.siblings().trigger("onReset");

        self.preload("inline");

        // Trigger any CSS transiton inside the slide
        forceRedraw(current.$slide);

        current.$slide.addClass("fancybox-slide--complete");

        // Remove unnecessary slides
        $.each(self.slides, function (key, slide) {
          if (slide.pos >= self.currPos - 1 && slide.pos <= self.currPos + 1) {
            slides[slide.pos] = slide;
          } else if (slide) {
            $.fancybox.stop(slide.$slide);

            slide.$slide.off().remove();
          }
        });

        self.slides = slides;
      }

      self.isAnimating = false;

      self.updateCursor();

      self.trigger("afterShow");

      // Autoplay first html5 video/audio
      if (!!current.opts.video.autoStart) {
        current.$slide
          .find("video,audio")
          .filter(":visible:first")
          .trigger("play")
          .one("ended", function () {
            if (Document.exitFullscreen) {
              Document.exitFullscreen();
            } else if (this.webkitExitFullscreen) {
              this.webkitExitFullscreen();
            }

            self.next();
          });
      }

      // Try to focus on the first focusable element
      if (current.opts.autoFocus && current.contentType === "html") {
        // Look for the first input with autofocus attribute
        $el = current.$content.find("input[autofocus]:enabled:visible:first");

        if ($el.length) {
          $el.trigger("focus");
        } else {
          self.focus(null, true);
        }
      }

      // Avoid jumping
      current.$slide.scrollTop(0).scrollLeft(0);
    },

    // Preload next and previous slides
    // ================================

    preload: function (type) {
      var self = this,
        prev,
        next;

      if (self.group.length < 2) {
        return;
      }

      next = self.slides[self.currPos + 1];
      prev = self.slides[self.currPos - 1];

      if (prev && prev.type === type) {
        self.loadSlide(prev);
      }

      if (next && next.type === type) {
        self.loadSlide(next);
      }
    },

    // Try to find and focus on the first focusable element
    // ====================================================

    focus: function (e, firstRun) {
      var self = this,
        focusableStr = [
          "a[href]",
          "area[href]",
          'input:not([disabled]):not([type="hidden"]):not([aria-hidden])',
          "select:not([disabled]):not([aria-hidden])",
          "textarea:not([disabled]):not([aria-hidden])",
          "button:not([disabled]):not([aria-hidden])",
          "iframe",
          "object",
          "embed",
          "video",
          "audio",
          "[contenteditable]",
          '[tabindex]:not([tabindex^="-"])'
        ].join(","),
        focusableItems,
        focusedItemIndex;

      if (self.isClosing) {
        return;
      }

      if (e || !self.current || !self.current.isComplete) {
        // Focus on any element inside fancybox
        focusableItems = self.$refs.container.find("*:visible");
      } else {
        // Focus inside current slide
        focusableItems = self.current.$slide.find("*:visible" + (firstRun ? ":not(.fancybox-close-small)" : ""));
      }

      focusableItems = focusableItems.filter(focusableStr).filter(function () {
        return $(this).css("visibility") !== "hidden" && !$(this).hasClass("disabled");
      });

      if (focusableItems.length) {
        focusedItemIndex = focusableItems.index(document.activeElement);

        if (e && e.shiftKey) {
          // Back tab
          if (focusedItemIndex < 0 || focusedItemIndex == 0) {
            e.preventDefault();

            focusableItems.eq(focusableItems.length - 1).trigger("focus");
          }
        } else {
          // Outside or Forward tab
          if (focusedItemIndex < 0 || focusedItemIndex == focusableItems.length - 1) {
            if (e) {
              e.preventDefault();
            }

            focusableItems.eq(0).trigger("focus");
          }
        }
      } else {
        self.$refs.container.trigger("focus");
      }
    },

    // Activates current instance - brings container to the front and enables keyboard,
    // notifies other instances about deactivating
    // =================================================================================

    activate: function () {
      var self = this;

      // Deactivate all instances
      $(".fancybox-container").each(function () {
        var instance = $(this).data("FancyBox");

        // Skip self and closing instances
        if (instance && instance.id !== self.id && !instance.isClosing) {
          instance.trigger("onDeactivate");

          instance.removeEvents();

          instance.isVisible = false;
        }
      });

      self.isVisible = true;

      if (self.current || self.isIdle) {
        self.update();

        self.updateControls();
      }

      self.trigger("onActivate");

      self.addEvents();
    },

    // Start closing procedure
    // This will start "zoom-out" animation if needed and clean everything up afterwards
    // =================================================================================

    close: function (e, d) {
      var self = this,
        current = self.current,
        effect,
        duration,
        $content,
        domRect,
        opacity,
        start,
        end;

      var done = function () {
        self.cleanUp(e);
      };

      if (self.isClosing) {
        return false;
      }

      self.isClosing = true;

      // If beforeClose callback prevents closing, make sure content is centered
      if (self.trigger("beforeClose", e) === false) {
        self.isClosing = false;

        requestAFrame(function () {
          self.update();
        });

        return false;
      }

      // Remove all events
      // If there are multiple instances, they will be set again by "activate" method
      self.removeEvents();

      $content = current.$content;
      effect = current.opts.animationEffect;
      duration = $.isNumeric(d) ? d : effect ? current.opts.animationDuration : 0;

      current.$slide.removeClass("fancybox-slide--complete fancybox-slide--next fancybox-slide--previous fancybox-animated");

      if (e !== true) {
        $.fancybox.stop(current.$slide);
      } else {
        effect = false;
      }

      // Remove other slides
      current.$slide
        .siblings()
        .trigger("onReset")
        .remove();

      // Trigger animations
      if (duration) {
        self.$refs.container
          .removeClass("fancybox-is-open")
          .addClass("fancybox-is-closing")
          .css("transition-duration", duration + "ms");
      }

      // Clean up
      self.hideLoading(current);

      self.hideControls(true);

      self.updateCursor();

      // Check if possible to zoom-out
      if (
        effect === "zoom" &&
        !($content && duration && current.type === "image" && !self.isMoved() && !current.hasError && (end = self.getThumbPos(current)))
      ) {
        effect = "fade";
      }

      if (effect === "zoom") {
        $.fancybox.stop($content);

        domRect = $.fancybox.getTranslate($content);

        start = {
          top: domRect.top,
          left: domRect.left,
          scaleX: domRect.width ../../../default.htm end.width,
          scaleY: domRect.height ../../../default.htm end.height,
          width: end.width,
          height: end.height
        };

        // Check if we need to animate opacity
        opacity = current.opts.zoomOpacity;

        if (opacity == "auto") {
          opacity = Math.abs(current.width ../../../default.htm current.height - end.width ../../../default.htm end.height) > 0.1;
        }

        if (opacity) {
          end.opacity = 0;
        }

        $.fancybox.setTranslate($content, start);

        forceRedraw($content);

        $.fancybox.animate($content, end, duration, done);

        return true;
      }

      if (effect && duration) {
        $.fancybox.animate(
          current.$slide.addClass("fancybox-slide--previous").removeClass("fancybox-slide--current"),
          "fancybox-animated fancybox-fx-" + effect,
          duration,
          done
        );
      } else {
        // If skip animation
        if (e === true) {
          setTimeout(done, duration);
        } else {
          done();
        }
      }

      return true;
    },

    // Final adjustments after removing the instance
    // =============================================

    cleanUp: function (e) {
      var self = this,
        instance,
        $focus = self.current.opts.$orig,
        x,
        y;

      self.current.$slide.trigger("onReset");

      self.$refs.container.empty().remove();

      self.trigger("afterClose", e);

      // Place back focus
      if (!!self.current.opts.backFocus) {
        if (!$focus || !$focus.length || !$focus.is(":visible")) {
          $focus = self.$trigger;
        }

        if ($focus && $focus.length) {
          x = window.scrollX;
          y = window.scrollY;

          $focus.trigger("focus");

          $("html, body")
            .scrollTop(y)
            .scrollLeft(x);
        }
      }

      self.current = null;

      // Check if there are other instances
      instance = $.fancybox.getInstance();

      if (instance) {
        instance.activate();
      } else {
        $("body").removeClass("fancybox-active compensate-for-scrollbar");

        $("#fancybox-style-noscroll").remove();
      }
    },

    // Call callback and trigger an event
    // ==================================

    trigger: function (name, slide) {
      var args = Array.prototype.slice.call(arguments, 1),
        self = this,
        obj = slide && slide.opts ? slide : self.current,
        rez;

      if (obj) {
        args.unshift(obj);
      } else {
        obj = self;
      }

      args.unshift(self);

      if ($.isFunction(obj.opts[name])) {
        rez = obj.opts[name].apply(obj, args);
      }

      if (rez === false) {
        return rez;
      }

      if (name === "afterClose" || !self.$refs) {
        $D.trigger(name + ".fb", args);
      } else {
        self.$refs.container.trigger(name + ".fb", args);
      }
    },

    // Update infobar values, navigation button states and reveal caption
    // ==================================================================

    updateControls: function () {
      var self = this,
        current = self.current,
        index = current.index,
        $container = self.$refs.container,
        $caption = self.$refs.caption,
        caption = current.opts.caption;

      // Recalculate content dimensions
      current.$slide.trigger("refresh");

      // Set caption
      if (caption && caption.length) {
        self.$caption = $caption;

        $caption
          .children()
          .eq(0)
          .html(caption);
      } else {
        self.$caption = null;
      }

      if (!self.hasHiddenControls && !self.isIdle) {
        self.showControls();
      }

      // Update info and navigation elements
      $container.find("[data-fancybox-count]").html(self.group.length);
      $container.find("[data-fancybox-index]").html(index + 1);

      $container.find("[data-fancybox-prev]").prop("disabled", !current.opts.loop && index <= 0);
      $container.find("[data-fancybox-next]").prop("disabled", !current.opts.loop && index >= self.group.length - 1);

      if (current.type === "image") {
        // Re-enable buttons; update download button source
        $container
          .find("[data-fancybox-zoom]")
          .show()
          .end()
          .find("[data-fancybox-download]")
          .attr("href", current.opts.image.src || current.src)
          .show();
      } else if (current.opts.toolbar) {
        $container.find("[data-fancybox-download],[data-fancybox-zoom]").hide();
      }

      // Make sure focus is not on disabled button/element
      if ($(document.activeElement).is(":hidden,[disabled]")) {
        self.$refs.container.trigger("focus");
      }
    },

    // Hide toolbar and caption
    // ========================

    hideControls: function (andCaption) {
      var self = this,
        arr = ["infobar", "toolbar", "nav"];

      if (andCaption || !self.current.opts.preventCaptionOverlap) {
        arr.push("caption");
      }

      this.$refs.container.removeClass(
        arr
        .map(function (i) {
          return "fancybox-show-" + i;
        })
        .join(" ")
      );

      this.hasHiddenControls = true;
    },

    showControls: function () {
      var self = this,
        opts = self.current ? self.current.opts : self.opts,
        $container = self.$refs.container;

      self.hasHiddenControls = false;
      self.idleSecondsCounter = 0;

      $container
        .toggleClass("fancybox-show-toolbar", !!(opts.toolbar && opts.buttons))
        .toggleClass("fancybox-show-infobar", !!(opts.infobar && self.group.length > 1))
        .toggleClass("fancybox-show-caption", !!self.$caption)
        .toggleClass("fancybox-show-nav", !!(opts.arrows && self.group.length > 1))
        .toggleClass("fancybox-is-modal", !!opts.modal);
    },

    // Toggle toolbar and caption
    // ==========================

    toggleControls: function () {
      if (this.hasHiddenControls) {
        this.showControls();
      } else {
        this.hideControls();
      }
    }
  });

  $.fancybox = {
    version: "3.5.7",
    defaults: defaults,

    // Get current instance and execute a command.
    //
    // Examples of usage:
    //
    //   $instance = $.fancybox.getInstance();
    //   $.fancybox.getInstance().jumpTo( 1 );
    //   $.fancybox.getInstance( 'jumpTo', 1 );
    //   $.fancybox.getInstance( function() {
    //       console.info( this.currIndex );
    //   });
    // ======================================================

    getInstance: function (command) {
      var instance = $('.fancybox-container:not(".fancybox-is-closing"):last').data("FancyBox"),
        args = Array.prototype.slice.call(arguments, 1);

      if (instance instanceof FancyBox) {
        if ($.type(command) === "string") {
          instance[command].apply(instance, args);
        } else if ($.type(command) === "function") {
          command.apply(instance, args);
        }

        return instance;
      }

      return false;
    },

    // Create new instance
    // ===================

    open: function (items, opts, index) {
      return new FancyBox(items, opts, index);
    },

    // Close current or all instances
    // ==============================

    close: function (all) {
      var instance = this.getInstance();

      if (instance) {
        instance.close();

        // Try to find and close next instance
        if (all === true) {
          this.close(all);
        }
      }
    },

    // Close all instances and unbind all events
    // =========================================

    destroy: function () {
      this.close(true);

      $D.add("body").off("click.fb-start", "**");
    },

    // Try to detect mobile devices
    // ============================

    isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),

    // Detect if 'translate3d' support is available
    // ============================================

    use3d: (function () {
      var div = document.createElement("div");

      return (
        window.getComputedStyle &&
        window.getComputedStyle(div) &&
        window.getComputedStyle(div).getPropertyValue("transform") &&
        !(document.documentMode && document.documentMode < 11)
      );
    })(),

    // Helper function to get current visual state of an element
    // returns array[ top, left, horizontal-scale, vertical-scale, opacity ]
    // =====================================================================

    getTranslate: function ($el) {
      var domRect;

      if (!$el || !$el.length) {
        return false;
      }

      domRect = $el[0].getBoundingClientRect();

      return {
        top: domRect.top || 0,
        left: domRect.left || 0,
        width: domRect.width,
        height: domRect.height,
        opacity: parseFloat($el.css("opacity"))
      };
    },

    // Shortcut for setting "translate3d" properties for element
    // Can set be used to set opacity, too
    // ========================================================

    setTranslate: function ($el, props) {
      var str = "",
        css = {};

      if (!$el || !props) {
        return;
      }

      if (props.left !== undefined || props.top !== undefined) {
        str =
          (props.left === undefined ? $el.position().left : props.left) +
          "px, " +
          (props.top === undefined ? $el.position().top : props.top) +
          "px";

        if (this.use3d) {
          str = "translate3d(" + str + ", 0px)";
        } else {
          str = "translate(" + str + ")";
        }
      }

      if (props.scaleX !== undefined && props.scaleY !== undefined) {
        str += " scale(" + props.scaleX + ", " + props.scaleY + ")";
      } else if (props.scaleX !== undefined) {
        str += " scaleX(" + props.scaleX + ")";
      }

      if (str.length) {
        css.transform = str;
      }

      if (props.opacity !== undefined) {
        css.opacity = props.opacity;
      }

      if (props.width !== undefined) {
        css.width = props.width;
      }

      if (props.height !== undefined) {
        css.height = props.height;
      }

      return $el.css(css);
    },

    // Simple CSS transition handler
    // =============================

    animate: function ($el, to, duration, callback, leaveAnimationName) {
      var self = this,
        from;

      if ($.isFunction(duration)) {
        callback = duration;
        duration = null;
      }

      self.stop($el);

      from = self.getTranslate($el);

      $el.on(transitionEnd, function (e) {
        // Skip events from child elements and z-index change
        if (e && e.originalEvent && (!$el.is(e.originalEvent.target) || e.originalEvent.propertyName == "z-index")) {
          return;
        }

        self.stop($el);

        if ($.isNumeric(duration)) {
          $el.css("transition-duration", "");
        }

        if ($.isPlainObject(to)) {
          if (to.scaleX !== undefined && to.scaleY !== undefined) {
            self.setTranslate($el, {
              top: to.top,
              left: to.left,
              width: from.width * to.scaleX,
              height: from.height * to.scaleY,
              scaleX: 1,
              scaleY: 1
            });
          }
        } else if (leaveAnimationName !== true) {
          $el.removeClass(to);
        }

        if ($.isFunction(callback)) {
          callback(e);
        }
      });

      if ($.isNumeric(duration)) {
        $el.css("transition-duration", duration + "ms");
      }

      // Start animation by changing CSS properties or class name
      if ($.isPlainObject(to)) {
        if (to.scaleX !== undefined && to.scaleY !== undefined) {
          delete to.width;
          delete to.height;

          if ($el.parent().hasClass("fancybox-slide--image")) {
            $el.parent().addClass("fancybox-is-scaling");
          }
        }

        $.fancybox.setTranslate($el, to);
      } else {
        $el.addClass(to);
      }

      // Make sure that `transitionend` callback gets fired
      $el.data(
        "timer",
        setTimeout(function () {
          $el.trigger(transitionEnd);
        }, duration + 33)
      );
    },

    stop: function ($el, callCallback) {
      if ($el && $el.length) {
        clearTimeout($el.data("timer"));

        if (callCallback) {
          $el.trigger(transitionEnd);
        }

        $el.off(transitionEnd).css("transition-duration", "");

        $el.parent().removeClass("fancybox-is-scaling");
      }
    }
  };

  // Default click handler for "fancyboxed" links
  // ============================================

  function _run(e, opts) {
    var items = [],
      index = 0,
      $target,
      value,
      instance;

    // Avoid opening multiple times
    if (e && e.isDefaultPrevented()) {
      return;
    }

    e.preventDefault();

    opts = opts || {};

    if (e && e.data) {
      opts = mergeOpts(e.data.options, opts);
    }

    $target = opts.$target || $(e.currentTarget).trigger("blur");
    instance = $.fancybox.getInstance();

    if (instance && instance.$trigger && instance.$trigger.is($target)) {
      return;
    }

    if (opts.selector) {
      items = $(opts.selector);
    } else {
      // Get all related items and find index for clicked one
      value = $target.attr("data-fancybox") || "";

      if (value) {
        items = e.data ? e.data.items : [];
        items = items.length ? items.filter('[data-fancybox="' + value + '"]') : $('[data-fancybox="' + value + '"]');
      } else {
        items = [$target];
      }
    }

    index = $(items).index($target);

    // Sometimes current item can not be found
    if (index < 0) {
      index = 0;
    }

    instance = $.fancybox.open(items, opts, index);

    // Save last active element
    instance.$trigger = $target;
  }

  // Create a jQuery plugin
  // ======================

  $.fn.fancybox = function (options) {
    var selector;

    options = options || {};
    selector = options.selector || false;

    if (selector) {
      // Use body element instead of document so it executes first
      $("body")
        .off("click.fb-start", selector)
        .on("click.fb-start", selector, {
          options: options
        }, _run);
    } else {
      this.off("click.fb-start").on(
        "click.fb-start", {
          items: this,
          options: options
        },
        _run
      );
    }

    return this;
  };

  // Self initializing plugin for all elements having `data-fancybox` attribute
  // ==========================================================================

  $D.on("click.fb-start", "[data-fancybox]", _run);

  // Enable "trigger elements"
  // =========================

  $D.on("click.fb-start", "[data-fancybox-trigger]", function (e) {
    $('[data-fancybox="' + $(this).attr("data-fancybox-trigger") + '"]')
      .eq($(this).attr("data-fancybox-index") || 0)
      .trigger("click.fb-start", {
        $trigger: $(this)
      });
  });

  // Track focus event for better accessibility styling
  // ==================================================
  (function () {
    var buttonStr = ".fancybox-button",
      focusStr = "fancybox-focus",
      $pressed = null;

    $D.on("mousedown mouseup focus blur", buttonStr, function (e) {
      switch (e.type) {
        case "mousedown":
          $pressed = $(this);
          break;
        case "mouseup":
          $pressed = null;
          break;
        case "focusin":
          $(buttonStr).removeClass(focusStr);

          if (!$(this).is($pressed) && !$(this).is("[disabled]")) {
            $(this).addClass(focusStr);
          }
          break;
        case "focusout":
          $(buttonStr).removeClass(focusStr);
          break;
      }
    });
  })();
})(window, document, jQuery);
// ==========================================================================
//
// Media
// Adds additional media type support
//
// ==========================================================================
(function ($) {
  "use strict";

  // Object containing properties for each media type
  var defaults = {
    youtube: {
      matcher: /(youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(watch\?(.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(.*)|[\w-]{11}|\?listType=(.*)&list=(.*))(.*)/i,
      params: {
        autoplay: 1,
        autohide: 1,
        fs: 1,
        rel: 0,
        hd: 1,
        wmode: "transparent",
        enablejsapi: 1,
        html5: 1
      },
      paramPlace: 8,
      type: "iframe",
      url: "https://www.youtube-nocookie.com/embed/$4",
      thumb: "../../../img.youtube.com/vi/$4/hqdefault.jpg"
    },

    vimeo: {
      matcher: /^.+vimeo.com\/(.*\/)?([\d]+)(.*)?/,
      params: {
        autoplay: 1,
        hd: 1,
        show_title: 1,
        show_byline: 1,
        show_portrait: 0,
        fullscreen: 1
      },
      paramPlace: 3,
      type: "iframe",
      url: "//player.vimeo.com/video/$2"
    },

    instagram: {
      matcher: /(instagr\.am|instagram\.com)\/p\/([a-zA-Z0-9_\-]+)\/?/i,
      type: "image",
      url: "//$1/p/$2/media/?size=l"
    },

    // Examples:
    // http://maps.google.com/?ll=48.857995,2.294297&spn=0.007666,0.021136&t=m&z=16
    // https://www.google.com/maps/@37.7852006,-122.4146355,14.65z
    // https://www.google.com/maps/@52.2111123,2.9237542,6.61z?hl=en
    // https://www.google.com/maps/place/Googleplex/@37.4220041,-122.0833494,17z/data=!4m5!3m4!1s0x0:0x6c296c66619367e0!8m2!3d37.4219998!4d-122.0840572
    gmap_place: {
      matcher: /(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(((maps\/(place\/(.*)\/)?\@(.*),(\d+.?\d+?)z))|(\?ll=))(.*)?/i,
      type: "iframe",
      url: function (rez) {
        return (
          "//maps.google." +
          rez[2] +
          "/?ll=" +
          (rez[9] ? rez[9] + "&z=" + Math.floor(rez[10]) + (rez[12] ? rez[12].replace(/^\//, "&") : "") : rez[12] + "").replace(/\?/, "&") +
          "&output=" +
          (rez[12] && rez[12].indexOf("layer=c") > 0 ? "svembed" : "embed")
        );
      }
    },

    // Examples:
    // https://www.google.com/maps/search/Empire+State+Building/
    // https://www.google.com/maps/search/?api=1&query=centurylink+field
    // https://www.google.com/maps/search/?api=1&query=47.5951518,-122.3316393
    gmap_search: {
      matcher: /(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(maps\/search\/)(.*)/i,
      type: "iframe",
      url: function (rez) {
        return "//maps.google." + rez[2] + "/maps?q=" + rez[5].replace("query=", "q=").replace("api=1", "") + "&output=embed";
      }
    }
  };

  // Formats matching url to final form
  var format = function (url, rez, params) {
    if (!url) {
      return;
    }

    params = params || "";

    if ($.type(params) === "object") {
      params = $.param(params, true);
    }

    $.each(rez, function (key, value) {
      url = url.replace("$" + key, value || "");
    });

    if (params.length) {
      url += (url.indexOf("?") > 0 ? "&" : "?") + params;
    }

    return url;
  };

  $(document).on("objectNeedsType.fb", function (e, instance, item) {
    var url = item.src || "",
      type = false,
      media,
      thumb,
      rez,
      params,
      urlParams,
      paramObj,
      provider;

    media = $.extend(true, {}, defaults, item.opts.media);

    // Look for any matching media type
    $.each(media, function (providerName, providerOpts) {
      rez = url.match(providerOpts.matcher);

      if (!rez) {
        return;
      }

      type = providerOpts.type;
      provider = providerName;
      paramObj = {};

      if (providerOpts.paramPlace && rez[providerOpts.paramPlace]) {
        urlParams = rez[providerOpts.paramPlace];

        if (urlParams[0] == "?") {
          urlParams = urlParams.substring(1);
        }

        urlParams = urlParams.split("&");

        for (var m = 0; m < urlParams.length; ++m) {
          var p = urlParams[m].split("=", 2);

          if (p.length == 2) {
            paramObj[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
          }
        }
      }

      params = $.extend(true, {}, providerOpts.params, item.opts[providerName], paramObj);

      url =
        $.type(providerOpts.url) === "function" ? providerOpts.url.call(this, rez, params, item) : format(providerOpts.url, rez, params);

      thumb =
        $.type(providerOpts.thumb) === "function" ? providerOpts.thumb.call(this, rez, params, item) : format(providerOpts.thumb, rez);

      if (providerName === "youtube") {
        url = url.replace(/&t=((\d+)m)?(\d+)s/, function (match, p1, m, s) {
          return "&start=" + ((m ? parseInt(m, 10) * 60 : 0) + parseInt(s, 10));
        });
      } else if (providerName === "vimeo") {
        url = url.replace("&%23", "#");
      }

      return false;
    });

    // If it is found, then change content type and update the url

    if (type) {
      if (!item.opts.thumb && !(item.opts.$thumb && item.opts.$thumb.length)) {
        item.opts.thumb = thumb;
      }

      if (type === "iframe") {
        item.opts = $.extend(true, item.opts, {
          iframe: {
            preload: false,
            attr: {
              scrolling: "no"
            }
          }
        });
      }

      $.extend(item, {
        type: type,
        src: url,
        origSrc: item.src,
        contentSource: provider,
        contentType: type === "image" ? "image" : provider == "gmap_place" || provider == "gmap_search" ? "map" : "video"
      });
    } else if (url) {
      item.type = item.opts.defaultType;
    }
  });

  // Load YouTube/Video API on request to detect when video finished playing
  var VideoAPILoader = {
    youtube: {
      src: "https://www.youtube.com/iframe_api",
      class: "YT",
      loading: false,
      loaded: false
    },

    vimeo: {
      src: "https://player.vimeo.com/api/player.js",
      class: "Vimeo",
      loading: false,
      loaded: false
    },

    load: function (vendor) {
      var _this = this,
        script;

      if (this[vendor].loaded) {
        setTimeout(function () {
          _this.done(vendor);
        });
        return;
      }

      if (this[vendor].loading) {
        return;
      }

      this[vendor].loading = true;

      script = document.createElement("script");
      script.type = "text/javascript";
      script.src = this[vendor].src;

      if (vendor === "youtube") {
        window.onYouTubeIframeAPIReady = function () {
          _this[vendor].loaded = true;
          _this.done(vendor);
        };
      } else {
        script.onload = function () {
          _this[vendor].loaded = true;
          _this.done(vendor);
        };
      }

      document.body.appendChild(script);
    },
    done: function (vendor) {
      var instance, $el, player;

      if (vendor === "youtube") {
        delete window.onYouTubeIframeAPIReady;
      }

      instance = $.fancybox.getInstance();

      if (instance) {
        $el = instance.current.$content.find("iframe");

        if (vendor === "youtube" && YT !== undefined && YT) {
          player = new YT.Player($el.attr("id"), {
            events: {
              onStateChange: function (e) {
                if (e.data == 0) {
                  instance.next();
                }
              }
            }
          });
        } else if (vendor === "vimeo" && Vimeo !== undefined && Vimeo) {
          player = new Vimeo.Player($el);

          player.on("ended", function () {
            instance.next();
          });
        }
      }
    }
  };

  $(document).on({
    "afterShow.fb": function (e, instance, current) {
      if (instance.group.length > 1 && (current.contentSource === "youtube" || current.contentSource === "vimeo")) {
        VideoAPILoader.load(current.contentSource);
      }
    }
  });
})(jQuery);
// ==========================================================================
//
// Guestures
// Adds touch guestures, handles click and tap events
//
// ==========================================================================
(function (window, document, $) {
  "use strict";

  var requestAFrame = (function () {
    return (
      window.requestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      // if all else fails, use setTimeout
      function (callback) {
        return window.setTimeout(callback, 1000 ../../../default.htm 60);
      }
    );
  })();

  var cancelAFrame = (function () {
    return (
      window.cancelAnimationFrame ||
      window.webkitCancelAnimationFrame ||
      window.mozCancelAnimationFrame ||
      window.oCancelAnimationFrame ||
      function (id) {
        window.clearTimeout(id);
      }
    );
  })();

  var getPointerXY = function (e) {
    var result = [];

    e = e.originalEvent || e || window.e;
    e = e.touches && e.touches.length ? e.touches : e.changedTouches && e.changedTouches.length ? e.changedTouches : [e];

    for (var key in e) {
      if (e[key].pageX) {
        result.push({
          x: e[key].pageX,
          y: e[key].pageY
        });
      } else if (e[key].clientX) {
        result.push({
          x: e[key].clientX,
          y: e[key].clientY
        });
      }
    }

    return result;
  };

  var distance = function (point2, point1, what) {
    if (!point1 || !point2) {
      return 0;
    }

    if (what === "x") {
      return point2.x - point1.x;
    } else if (what === "y") {
      return point2.y - point1.y;
    }

    return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
  };

  var isClickable = function ($el) {
    if (
      $el.is('a,area,button,[role="button"],input,label,select,summary,textarea,video,audio,iframe') ||
      $.isFunction($el.get(0).onclick) ||
      $el.data("selectable")
    ) {
      return true;
    }

    // Check for attributes like data-fancybox-next or data-fancybox-close
    for (var i = 0, atts = $el[0].attributes, n = atts.length; i < n; i++) {
      if (atts[i].nodeName.substr(0, 14) === "data-fancybox-") {
        return true;
      }
    }

    return false;
  };

  var hasScrollbars = function (el) {
    var overflowY = window.getComputedStyle(el)["overflow-y"],
      overflowX = window.getComputedStyle(el)["overflow-x"],
      vertical = (overflowY === "scroll" || overflowY === "auto") && el.scrollHeight > el.clientHeight,
      horizontal = (overflowX === "scroll" || overflowX === "auto") && el.scrollWidth > el.clientWidth;

    return vertical || horizontal;
  };

  var isScrollable = function ($el) {
    var rez = false;

    while (true) {
      rez = hasScrollbars($el.get(0));

      if (rez) {
        break;
      }

      $el = $el.parent();

      if (!$el.length || $el.hasClass("fancybox-stage") || $el.is("body")) {
        break;
      }
    }

    return rez;
  };

  var Guestures = function (instance) {
    var self = this;

    self.instance = instance;

    self.$bg = instance.$refs.bg;
    self.$stage = instance.$refs.stage;
    self.$container = instance.$refs.container;

    self.destroy();

    self.$container.on("touchstart.fb.touch mousedown.fb.touch", $.proxy(self, "ontouchstart"));
  };

  Guestures.prototype.destroy = function () {
    var self = this;

    self.$container.off(".fb.touch");

    $(document).off(".fb.touch");

    if (self.requestId) {
      cancelAFrame(self.requestId);
      self.requestId = null;
    }

    if (self.tapped) {
      clearTimeout(self.tapped);
      self.tapped = null;
    }
  };

  Guestures.prototype.ontouchstart = function (e) {
    var self = this,
      $target = $(e.target),
      instance = self.instance,
      current = instance.current,
      $slide = current.$slide,
      $content = current.$content,
      isTouchDevice = e.type == "touchstart";

    // Do not respond to both (touch and mouse) events
    if (isTouchDevice) {
      self.$container.off("mousedown.fb.touch");
    }

    // Ignore right click
    if (e.originalEvent && e.originalEvent.button == 2) {
      return;
    }

    // Ignore taping on links, buttons, input elements
    if (!$slide.length || !$target.length || isClickable($target) || isClickable($target.parent())) {
      return;
    }
    // Ignore clicks on the scrollbar
    if (!$target.is("img") && e.originalEvent.clientX > $target[0].clientWidth + $target.offset().left) {
      return;
    }

    // Ignore clicks while zooming or closing
    if (!current || instance.isAnimating || current.$slide.hasClass("fancybox-animated")) {
      e.stopPropagation();
      e.preventDefault();

      return;
    }

    self.realPoints = self.startPoints = getPointerXY(e);

    if (!self.startPoints.length) {
      return;
    }

    // Allow other scripts to catch touch event if "touch" is set to false
    if (current.touch) {
      e.stopPropagation();
    }

    self.startEvent = e;

    self.canTap = true;
    self.$target = $target;
    self.$content = $content;
    self.opts = current.opts.touch;

    self.isPanning = false;
    self.isSwiping = false;
    self.isZooming = false;
    self.isScrolling = false;
    self.canPan = instance.canPan();

    self.startTime = new Date().getTime();
    self.distanceX = self.distanceY = self.distance = 0;

    self.canvasWidth = Math.round($slide[0].clientWidth);
    self.canvasHeight = Math.round($slide[0].clientHeight);

    self.contentLastPos = null;
    self.contentStartPos = $.fancybox.getTranslate(self.$content) || {
      top: 0,
      left: 0
    };
    self.sliderStartPos = $.fancybox.getTranslate($slide);

    // Since position will be absolute, but we need to make it relative to the stage
    self.stagePos = $.fancybox.getTranslate(instance.$refs.stage);

    self.sliderStartPos.top -= self.stagePos.top;
    self.sliderStartPos.left -= self.stagePos.left;

    self.contentStartPos.top -= self.stagePos.top;
    self.contentStartPos.left -= self.stagePos.left;

    $(document)
      .off(".fb.touch")
      .on(isTouchDevice ? "touchend.fb.touch touchcancel.fb.touch" : "mouseup.fb.touch mouseleave.fb.touch", $.proxy(self, "ontouchend"))
      .on(isTouchDevice ? "touchmove.fb.touch" : "mousemove.fb.touch", $.proxy(self, "ontouchmove"));

    if ($.fancybox.isMobile) {
      document.addEventListener("scroll", self.onscroll, true);
    }

    // Skip if clicked outside the sliding area
    if (!(self.opts || self.canPan) || !($target.is(self.$stage) || self.$stage.find($target).length)) {
      if ($target.is(".fancybox-image")) {
        e.preventDefault();
      }

      if (!($.fancybox.isMobile && $target.parents(".fancybox-caption").length)) {
        return;
      }
    }

    self.isScrollable = isScrollable($target) || isScrollable($target.parent());

    // Check if element is scrollable and try to prevent default behavior (scrolling)
    if (!($.fancybox.isMobile && self.isScrollable)) {
      e.preventDefault();
    }

    // One finger or mouse click - swipe or pan an image
    if (self.startPoints.length === 1 || current.hasError) {
      if (self.canPan) {
        $.fancybox.stop(self.$content);

        self.isPanning = true;
      } else {
        self.isSwiping = true;
      }

      self.$container.addClass("fancybox-is-grabbing");
    }

    // Two fingers - zoom image
    if (self.startPoints.length === 2 && current.type === "image" && (current.isLoaded || current.$ghost)) {
      self.canTap = false;
      self.isSwiping = false;
      self.isPanning = false;

      self.isZooming = true;

      $.fancybox.stop(self.$content);

      self.centerPointStartX = (self.startPoints[0].x + self.startPoints[1].x) * 0.5 - $(window).scrollLeft();
      self.centerPointStartY = (self.startPoints[0].y + self.startPoints[1].y) * 0.5 - $(window).scrollTop();

      self.percentageOfImageAtPinchPointX = (self.centerPointStartX - self.contentStartPos.left) ../../../default.htm self.contentStartPos.width;
      self.percentageOfImageAtPinchPointY = (self.centerPointStartY - self.contentStartPos.top) ../../../default.htm self.contentStartPos.height;

      self.startDistanceBetweenFingers = distance(self.startPoints[0], self.startPoints[1]);
    }
  };

  Guestures.prototype.onscroll = function (e) {
    var self = this;

    self.isScrolling = true;

    document.removeEventListener("scroll", self.onscroll, true);
  };

  Guestures.prototype.ontouchmove = function (e) {
    var self = this;

    // Make sure user has not released over iframe or disabled element
    if (e.originalEvent.buttons !== undefined && e.originalEvent.buttons === 0) {
      self.ontouchend(e);
      return;
    }

    if (self.isScrolling) {
      self.canTap = false;
      return;
    }

    self.newPoints = getPointerXY(e);

    if (!(self.opts || self.canPan) || !self.newPoints.length || !self.newPoints.length) {
      return;
    }

    if (!(self.isSwiping && self.isSwiping === true)) {
      e.preventDefault();
    }

    self.distanceX = distance(self.newPoints[0], self.startPoints[0], "x");
    self.distanceY = distance(self.newPoints[0], self.startPoints[0], "y");

    self.distance = distance(self.newPoints[0], self.startPoints[0]);

    // Skip false ontouchmove events (Chrome)
    if (self.distance > 0) {
      if (self.isSwiping) {
        self.onSwipe(e);
      } else if (self.isPanning) {
        self.onPan();
      } else if (self.isZooming) {
        self.onZoom();
      }
    }
  };

  Guestures.prototype.onSwipe = function (e) {
    var self = this,
      instance = self.instance,
      swiping = self.isSwiping,
      left = self.sliderStartPos.left || 0,
      angle;

    // If direction is not yet determined
    if (swiping === true) {
      // We need at least 10px distance to correctly calculate an angle
      if (Math.abs(self.distance) > 10) {
        self.canTap = false;

        if (instance.group.length < 2 && self.opts.vertical) {
          self.isSwiping = "y";
        } else if (instance.isDragging || self.opts.vertical === false || (self.opts.vertical === "auto" && $(window).width() > 800)) {
          self.isSwiping = "x";
        } else {
          angle = Math.abs((Math.atan2(self.distanceY, self.distanceX) * 180) ../../../default.htm Math.PI);

          self.isSwiping = angle > 45 && angle < 135 ? "y" : "x";
        }

        if (self.isSwiping === "y" && $.fancybox.isMobile && self.isScrollable) {
          self.isScrolling = true;

          return;
        }

        instance.isDragging = self.isSwiping;

        // Reset points to avoid jumping, because we dropped first swipes to calculate the angle
        self.startPoints = self.newPoints;

        $.each(instance.slides, function (index, slide) {
          var slidePos, stagePos;

          $.fancybox.stop(slide.$slide);

          slidePos = $.fancybox.getTranslate(slide.$slide);
          stagePos = $.fancybox.getTranslate(instance.$refs.stage);

          slide.$slide
            .css({
              transform: "",
              opacity: "",
              "transition-duration": ""
            })
            .removeClass("fancybox-animated")
            .removeClass(function (index, className) {
              return (className.match(/(^|\s)fancybox-fx-\S+/g) || []).join(" ");
            });

          if (slide.pos === instance.current.pos) {
            self.sliderStartPos.top = slidePos.top - stagePos.top;
            self.sliderStartPos.left = slidePos.left - stagePos.left;
          }

          $.fancybox.setTranslate(slide.$slide, {
            top: slidePos.top - stagePos.top,
            left: slidePos.left - stagePos.left
          });
        });

        // Stop slideshow
        if (instance.SlideShow && instance.SlideShow.isActive) {
          instance.SlideShow.stop();
        }
      }

      return;
    }

    // Sticky edges
    if (swiping == "x") {
      if (
        self.distanceX > 0 &&
        (self.instance.group.length < 2 || (self.instance.current.index === 0 && !self.instance.current.opts.loop))
      ) {
        left = left + Math.pow(self.distanceX, 0.8);
      } else if (
        self.distanceX < 0 &&
        (self.instance.group.length < 2 ||
          (self.instance.current.index === self.instance.group.length - 1 && !self.instance.current.opts.loop))
      ) {
        left = left - Math.pow(-self.distanceX, 0.8);
      } else {
        left = left + self.distanceX;
      }
    }

    self.sliderLastPos = {
      top: swiping == "x" ? 0 : self.sliderStartPos.top + self.distanceY,
      left: left
    };

    if (self.requestId) {
      cancelAFrame(self.requestId);

      self.requestId = null;
    }

    self.requestId = requestAFrame(function () {
      if (self.sliderLastPos) {
        $.each(self.instance.slides, function (index, slide) {
          var pos = slide.pos - self.instance.currPos;

          $.fancybox.setTranslate(slide.$slide, {
            top: self.sliderLastPos.top,
            left: self.sliderLastPos.left + pos * self.canvasWidth + pos * slide.opts.gutter
          });
        });

        self.$container.addClass("fancybox-is-sliding");
      }
    });
  };

  Guestures.prototype.onPan = function () {
    var self = this;

    // Prevent accidental movement (sometimes, when tapping casually, finger can move a bit)
    if (distance(self.newPoints[0], self.realPoints[0]) < ($.fancybox.isMobile ? 10 : 5)) {
      self.startPoints = self.newPoints;
      return;
    }

    self.canTap = false;

    self.contentLastPos = self.limitMovement();

    if (self.requestId) {
      cancelAFrame(self.requestId);
    }

    self.requestId = requestAFrame(function () {
      $.fancybox.setTranslate(self.$content, self.contentLastPos);
    });
  };

  // Make panning sticky to the edges
  Guestures.prototype.limitMovement = function () {
    var self = this;

    var canvasWidth = self.canvasWidth;
    var canvasHeight = self.canvasHeight;

    var distanceX = self.distanceX;
    var distanceY = self.distanceY;

    var contentStartPos = self.contentStartPos;

    var currentOffsetX = contentStartPos.left;
    var currentOffsetY = contentStartPos.top;

    var currentWidth = contentStartPos.width;
    var currentHeight = contentStartPos.height;

    var minTranslateX, minTranslateY, maxTranslateX, maxTranslateY, newOffsetX, newOffsetY;

    if (currentWidth > canvasWidth) {
      newOffsetX = currentOffsetX + distanceX;
    } else {
      newOffsetX = currentOffsetX;
    }

    newOffsetY = currentOffsetY + distanceY;

    // Slow down proportionally to traveled distance
    minTranslateX = Math.max(0, canvasWidth * 0.5 - currentWidth * 0.5);
    minTranslateY = Math.max(0, canvasHeight * 0.5 - currentHeight * 0.5);

    maxTranslateX = Math.min(canvasWidth - currentWidth, canvasWidth * 0.5 - currentWidth * 0.5);
    maxTranslateY = Math.min(canvasHeight - currentHeight, canvasHeight * 0.5 - currentHeight * 0.5);

    //   ->
    if (distanceX > 0 && newOffsetX > minTranslateX) {
      newOffsetX = minTranslateX - 1 + Math.pow(-minTranslateX + currentOffsetX + distanceX, 0.8) || 0;
    }

    //    <-
    if (distanceX < 0 && newOffsetX < maxTranslateX) {
      newOffsetX = maxTranslateX + 1 - Math.pow(maxTranslateX - currentOffsetX - distanceX, 0.8) || 0;
    }

    //   \/
    if (distanceY > 0 && newOffsetY > minTranslateY) {
      newOffsetY = minTranslateY - 1 + Math.pow(-minTranslateY + currentOffsetY + distanceY, 0.8) || 0;
    }

    //   /\
    if (distanceY < 0 && newOffsetY < maxTranslateY) {
      newOffsetY = maxTranslateY + 1 - Math.pow(maxTranslateY - currentOffsetY - distanceY, 0.8) || 0;
    }

    return {
      top: newOffsetY,
      left: newOffsetX
    };
  };

  Guestures.prototype.limitPosition = function (newOffsetX, newOffsetY, newWidth, newHeight) {
    var self = this;

    var canvasWidth = self.canvasWidth;
    var canvasHeight = self.canvasHeight;

    if (newWidth > canvasWidth) {
      newOffsetX = newOffsetX > 0 ? 0 : newOffsetX;
      newOffsetX = newOffsetX < canvasWidth - newWidth ? canvasWidth - newWidth : newOffsetX;
    } else {
      // Center horizontally
      newOffsetX = Math.max(0, canvasWidth ../../../default.htm 2 - newWidth ../../../default.htm 2);
    }

    if (newHeight > canvasHeight) {
      newOffsetY = newOffsetY > 0 ? 0 : newOffsetY;
      newOffsetY = newOffsetY < canvasHeight - newHeight ? canvasHeight - newHeight : newOffsetY;
    } else {
      // Center vertically
      newOffsetY = Math.max(0, canvasHeight ../../../default.htm 2 - newHeight ../../../default.htm 2);
    }

    return {
      top: newOffsetY,
      left: newOffsetX
    };
  };

  Guestures.prototype.onZoom = function () {
    var self = this;

    // Calculate current distance between points to get pinch ratio and new width and height
    var contentStartPos = self.contentStartPos;

    var currentWidth = contentStartPos.width;
    var currentHeight = contentStartPos.height;

    var currentOffsetX = contentStartPos.left;
    var currentOffsetY = contentStartPos.top;

    var endDistanceBetweenFingers = distance(self.newPoints[0], self.newPoints[1]);

    var pinchRatio = endDistanceBetweenFingers ../../../default.htm self.startDistanceBetweenFingers;

    var newWidth = Math.floor(currentWidth * pinchRatio);
    var newHeight = Math.floor(currentHeight * pinchRatio);

    // This is the translation due to pinch-zooming
    var translateFromZoomingX = (currentWidth - newWidth) * self.percentageOfImageAtPinchPointX;
    var translateFromZoomingY = (currentHeight - newHeight) * self.percentageOfImageAtPinchPointY;

    // Point between the two touches
    var centerPointEndX = (self.newPoints[0].x + self.newPoints[1].x) ../../../default.htm 2 - $(window).scrollLeft();
    var centerPointEndY = (self.newPoints[0].y + self.newPoints[1].y) ../../../default.htm 2 - $(window).scrollTop();

    // And this is the translation due to translation of the centerpoint
    // between the two fingers
    var translateFromTranslatingX = centerPointEndX - self.centerPointStartX;
    var translateFromTranslatingY = centerPointEndY - self.centerPointStartY;

    // The new offset is the old/current one plus the total translation
    var newOffsetX = currentOffsetX + (translateFromZoomingX + translateFromTranslatingX);
    var newOffsetY = currentOffsetY + (translateFromZoomingY + translateFromTranslatingY);

    var newPos = {
      top: newOffsetY,
      left: newOffsetX,
      scaleX: pinchRatio,
      scaleY: pinchRatio
    };

    self.canTap = false;

    self.newWidth = newWidth;
    self.newHeight = newHeight;

    self.contentLastPos = newPos;

    if (self.requestId) {
      cancelAFrame(self.requestId);
    }

    self.requestId = requestAFrame(function () {
      $.fancybox.setTranslate(self.$content, self.contentLastPos);
    });
  };

  Guestures.prototype.ontouchend = function (e) {
    var self = this;

    var swiping = self.isSwiping;
    var panning = self.isPanning;
    var zooming = self.isZooming;
    var scrolling = self.isScrolling;

    self.endPoints = getPointerXY(e);
    self.dMs = Math.max(new Date().getTime() - self.startTime, 1);

    self.$container.removeClass("fancybox-is-grabbing");

    $(document).off(".fb.touch");

    document.removeEventListener("scroll", self.onscroll, true);

    if (self.requestId) {
      cancelAFrame(self.requestId);

      self.requestId = null;
    }

    self.isSwiping = false;
    self.isPanning = false;
    self.isZooming = false;
    self.isScrolling = false;

    self.instance.isDragging = false;

    if (self.canTap) {
      return self.onTap(e);
    }

    self.speed = 100;

    // Speed in px/ms
    self.velocityX = (self.distanceX ../../../default.htm self.dMs) * 0.5;
    self.velocityY = (self.distanceY ../../../default.htm self.dMs) * 0.5;

    if (panning) {
      self.endPanning();
    } else if (zooming) {
      self.endZooming();
    } else {
      self.endSwiping(swiping, scrolling);
    }

    return;
  };

  Guestures.prototype.endSwiping = function (swiping, scrolling) {
    var self = this,
      ret = false,
      len = self.instance.group.length,
      distanceX = Math.abs(self.distanceX),
      canAdvance = swiping == "x" && len > 1 && ((self.dMs > 130 && distanceX > 10) || distanceX > 50),
      speedX = 300;

    self.sliderLastPos = null;

    // Close if swiped vertically ../../../default.htm navigate if horizontally
    if (swiping == "y" && !scrolling && Math.abs(self.distanceY) > 50) {
      // Continue vertical movement
      $.fancybox.animate(
        self.instance.current.$slide, {
          top: self.sliderStartPos.top + self.distanceY + self.velocityY * 150,
          opacity: 0
        },
        200
      );
      ret = self.instance.close(true, 250);
    } else if (canAdvance && self.distanceX > 0) {
      ret = self.instance.previous(speedX);
    } else if (canAdvance && self.distanceX < 0) {
      ret = self.instance.next(speedX);
    }

    if (ret === false && (swiping == "x" || swiping == "y")) {
      self.instance.centerSlide(200);
    }

    self.$container.removeClass("fancybox-is-sliding");
  };

  // Limit panning from edges
  // ========================
  Guestures.prototype.endPanning = function () {
    var self = this,
      newOffsetX,
      newOffsetY,
      newPos;

    if (!self.contentLastPos) {
      return;
    }

    if (self.opts.momentum === false || self.dMs > 350) {
      newOffsetX = self.contentLastPos.left;
      newOffsetY = self.contentLastPos.top;
    } else {
      // Continue movement
      newOffsetX = self.contentLastPos.left + self.velocityX * 500;
      newOffsetY = self.contentLastPos.top + self.velocityY * 500;
    }

    newPos = self.limitPosition(newOffsetX, newOffsetY, self.contentStartPos.width, self.contentStartPos.height);

    newPos.width = self.contentStartPos.width;
    newPos.height = self.contentStartPos.height;

    $.fancybox.animate(self.$content, newPos, 366);
  };

  Guestures.prototype.endZooming = function () {
    var self = this;

    var current = self.instance.current;

    var newOffsetX, newOffsetY, newPos, reset;

    var newWidth = self.newWidth;
    var newHeight = self.newHeight;

    if (!self.contentLastPos) {
      return;
    }

    newOffsetX = self.contentLastPos.left;
    newOffsetY = self.contentLastPos.top;

    reset = {
      top: newOffsetY,
      left: newOffsetX,
      width: newWidth,
      height: newHeight,
      scaleX: 1,
      scaleY: 1
    };

    // Reset scalex/scaleY values; this helps for perfomance and does not break animation
    $.fancybox.setTranslate(self.$content, reset);

    if (newWidth < self.canvasWidth && newHeight < self.canvasHeight) {
      self.instance.scaleToFit(150);
    } else if (newWidth > current.width || newHeight > current.height) {
      self.instance.scaleToActual(self.centerPointStartX, self.centerPointStartY, 150);
    } else {
      newPos = self.limitPosition(newOffsetX, newOffsetY, newWidth, newHeight);

      $.fancybox.animate(self.$content, newPos, 150);
    }
  };

  Guestures.prototype.onTap = function (e) {
    var self = this;
    var $target = $(e.target);

    var instance = self.instance;
    var current = instance.current;

    var endPoints = (e && getPointerXY(e)) || self.startPoints;

    var tapX = endPoints[0] ? endPoints[0].x - $(window).scrollLeft() - self.stagePos.left : 0;
    var tapY = endPoints[0] ? endPoints[0].y - $(window).scrollTop() - self.stagePos.top : 0;

    var where;

    var process = function (prefix) {
      var action = current.opts[prefix];

      if ($.isFunction(action)) {
        action = action.apply(instance, [current, e]);
      }

      if (!action) {
        return;
      }

      switch (action) {
        case "close":
          instance.close(self.startEvent);

          break;

        case "toggleControls":
          instance.toggleControls();

          break;

        case "next":
          instance.next();

          break;

        case "nextOrClose":
          if (instance.group.length > 1) {
            instance.next();
          } else {
            instance.close(self.startEvent);
          }

          break;

        case "zoom":
          if (current.type == "image" && (current.isLoaded || current.$ghost)) {
            if (instance.canPan()) {
              instance.scaleToFit();
            } else if (instance.isScaledDown()) {
              instance.scaleToActual(tapX, tapY);
            } else if (instance.group.length < 2) {
              instance.close(self.startEvent);
            }
          }

          break;
      }
    };

    // Ignore right click
    if (e.originalEvent && e.originalEvent.button == 2) {
      return;
    }

    // Skip if clicked on the scrollbar
    if (!$target.is("img") && tapX > $target[0].clientWidth + $target.offset().left) {
      return;
    }

    // Check where is clicked
    if ($target.is(".fancybox-bg,.fancybox-inner,.fancybox-outer,.fancybox-container")) {
      where = "Outside";
    } else if ($target.is(".fancybox-slide")) {
      where = "Slide";
    } else if (
      instance.current.$content &&
      instance.current.$content
      .find($target)
      .addBack()
      .filter($target).length
    ) {
      where = "Content";
    } else {
      return;
    }

    // Check if this is a double tap
    if (self.tapped) {
      // Stop previously created single tap
      clearTimeout(self.tapped);
      self.tapped = null;

      // Skip if distance between taps is too big
      if (Math.abs(tapX - self.tapX) > 50 || Math.abs(tapY - self.tapY) > 50) {
        return this;
      }

      // OK, now we assume that this is a double-tap
      process("dblclick" + where);
    } else {
      // Single tap will be processed if user has not clicked second time within 300ms
      // or there is no need to wait for double-tap
      self.tapX = tapX;
      self.tapY = tapY;

      if (current.opts["dblclick" + where] && current.opts["dblclick" + where] !== current.opts["click" + where]) {
        self.tapped = setTimeout(function () {
          self.tapped = null;

          if (!instance.isAnimating) {
            process("click" + where);
          }
        }, 500);
      } else {
        process("click" + where);
      }
    }

    return this;
  };

  $(document)
    .on("onActivate.fb", function (e, instance) {
      if (instance && !instance.Guestures) {
        instance.Guestures = new Guestures(instance);
      }
    })
    .on("beforeClose.fb", function (e, instance) {
      if (instance && instance.Guestures) {
        instance.Guestures.destroy();
      }
    });
})(window, document, jQuery);
// ==========================================================================
//
// SlideShow
// Enables slideshow functionality
//
// Example of usage:
// $.fancybox.getInstance().SlideShow.start()
//
// ==========================================================================
(function (document, $) {
  "use strict";

  $.extend(true, $.fancybox.defaults, {
    btnTpl: {
      slideShow: '<button data-fancybox-play class="fancybox-button fancybox-button--play" title="{{PLAY_START}}">' +
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6.5 5.4v13.2l11-6.6z"/></svg>' +
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.33 5.75h2.2v12.5h-2.2V5.75zm5.15 0h2.2v12.5h-2.2V5.75z"/></svg>' +
        "</button>"
    },
    slideShow: {
      autoStart: false,
      speed: 3000,
      progress: true
    }
  });

  var SlideShow = function (instance) {
    this.instance = instance;
    this.init();
  };

  $.extend(SlideShow.prototype, {
    timer: null,
    isActive: false,
    $button: null,

    init: function () {
      var self = this,
        instance = self.instance,
        opts = instance.group[instance.currIndex].opts.slideShow;

      self.$button = instance.$refs.toolbar.find("[data-fancybox-play]").on("click", function () {
        self.toggle();
      });

      if (instance.group.length < 2 || !opts) {
        self.$button.hide();
      } else if (opts.progress) {
        self.$progress = $('<div class="fancybox-progress"></div>').appendTo(instance.$refs.inner);
      }
    },

    set: function (force) {
      var self = this,
        instance = self.instance,
        current = instance.current;

      // Check if reached last element
      if (current && (force === true || current.opts.loop || instance.currIndex < instance.group.length - 1)) {
        if (self.isActive && current.contentType !== "video") {
          if (self.$progress) {
            $.fancybox.animate(self.$progress.show(), {
              scaleX: 1
            }, current.opts.slideShow.speed);
          }

          self.timer = setTimeout(function () {
            if (!instance.current.opts.loop && instance.current.index == instance.group.length - 1) {
              instance.jumpTo(0);
            } else {
              instance.next();
            }
          }, current.opts.slideShow.speed);
        }
      } else {
        self.stop();
        instance.idleSecondsCounter = 0;
        instance.showControls();
      }
    },

    clear: function () {
      var self = this;

      clearTimeout(self.timer);

      self.timer = null;

      if (self.$progress) {
        self.$progress.removeAttr("style").hide();
      }
    },

    start: function () {
      var self = this,
        current = self.instance.current;

      if (current) {
        self.$button
          .attr("title", (current.opts.i18n[current.opts.lang] || current.opts.i18n.en).PLAY_STOP)
          .removeClass("fancybox-button--play")
          .addClass("fancybox-button--pause");

        self.isActive = true;

        if (current.isComplete) {
          self.set(true);
        }

        self.instance.trigger("onSlideShowChange", true);
      }
    },

    stop: function () {
      var self = this,
        current = self.instance.current;

      self.clear();

      self.$button
        .attr("title", (current.opts.i18n[current.opts.lang] || current.opts.i18n.en).PLAY_START)
        .removeClass("fancybox-button--pause")
        .addClass("fancybox-button--play");

      self.isActive = false;

      self.instance.trigger("onSlideShowChange", false);

      if (self.$progress) {
        self.$progress.removeAttr("style").hide();
      }
    },

    toggle: function () {
      var self = this;

      if (self.isActive) {
        self.stop();
      } else {
        self.start();
      }
    }
  });

  $(document).on({
    "onInit.fb": function (e, instance) {
      if (instance && !instance.SlideShow) {
        instance.SlideShow = new SlideShow(instance);
      }
    },

    "beforeShow.fb": function (e, instance, current, firstRun) {
      var SlideShow = instance && instance.SlideShow;

      if (firstRun) {
        if (SlideShow && current.opts.slideShow.autoStart) {
          SlideShow.start();
        }
      } else if (SlideShow && SlideShow.isActive) {
        SlideShow.clear();
      }
    },

    "afterShow.fb": function (e, instance, current) {
      var SlideShow = instance && instance.SlideShow;

      if (SlideShow && SlideShow.isActive) {
        SlideShow.set();
      }
    },

    "afterKeydown.fb": function (e, instance, current, keypress, keycode) {
      var SlideShow = instance && instance.SlideShow;

      // "P" or Spacebar
      if (SlideShow && current.opts.slideShow && (keycode === 80 || keycode === 32) && !$(document.activeElement).is("button,a,input")) {
        keypress.preventDefault();

        SlideShow.toggle();
      }
    },

    "beforeClose.fb onDeactivate.fb": function (e, instance) {
      var SlideShow = instance && instance.SlideShow;

      if (SlideShow) {
        SlideShow.stop();
      }
    }
  });

  // Page Visibility API to pause slideshow when window is not active
  $(document).on("visibilitychange", function () {
    var instance = $.fancybox.getInstance(),
      SlideShow = instance && instance.SlideShow;

    if (SlideShow && SlideShow.isActive) {
      if (document.hidden) {
        SlideShow.clear();
      } else {
        SlideShow.set();
      }
    }
  });
})(document, jQuery);
// ==========================================================================
//
// FullScreen
// Adds fullscreen functionality
//
// ==========================================================================
(function (document, $) {
  "use strict";

  // Collection of methods supported by user browser
  var fn = (function () {
    var fnMap = [
      ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"],
      // new WebKit
      [
        "webkitRequestFullscreen",
        "webkitExitFullscreen",
        "webkitFullscreenElement",
        "webkitFullscreenEnabled",
        "webkitfullscreenchange",
        "webkitfullscreenerror"
      ],
      // old WebKit (Safari 5.1)
      [
        "webkitRequestFullScreen",
        "webkitCancelFullScreen",
        "webkitCurrentFullScreenElement",
        "webkitCancelFullScreen",
        "webkitfullscreenchange",
        "webkitfullscreenerror"
      ],
      [
        "mozRequestFullScreen",
        "mozCancelFullScreen",
        "mozFullScreenElement",
        "mozFullScreenEnabled",
        "mozfullscreenchange",
        "mozfullscreenerror"
      ],
      ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]
    ];

    var ret = {};

    for (var i = 0; i < fnMap.length; i++) {
      var val = fnMap[i];

      if (val && val[1] in document) {
        for (var j = 0; j < val.length; j++) {
          ret[fnMap[0][j]] = val[j];
        }

        return ret;
      }
    }

    return false;
  })();

  if (fn) {
    var FullScreen = {
      request: function (elem) {
        elem = elem || document.documentElement;

        elem[fn.requestFullscreen](elem.ALLOW_KEYBOARD_INPUT);
      },
      exit: function () {
        document[fn.exitFullscreen]();
      },
      toggle: function (elem) {
        elem = elem || document.documentElement;

        if (this.isFullscreen()) {
          this.exit();
        } else {
          this.request(elem);
        }
      },
      isFullscreen: function () {
        return Boolean(document[fn.fullscreenElement]);
      },
      enabled: function () {
        return Boolean(document[fn.fullscreenEnabled]);
      }
    };

    $.extend(true, $.fancybox.defaults, {
      btnTpl: {
        fullScreen: '<button data-fancybox-fullscreen class="fancybox-button fancybox-button--fsenter" title="{{FULL_SCREEN}}">' +
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>' +
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 16h3v3h2v-5H5zm3-8H5v2h5V5H8zm6 11h2v-3h3v-2h-5zm2-11V5h-2v5h5V8z"/></svg>' +
          "</button>"
      },
      fullScreen: {
        autoStart: false
      }
    });

    $(document).on(fn.fullscreenchange, function () {
      var isFullscreen = FullScreen.isFullscreen(),
        instance = $.fancybox.getInstance();

      if (instance) {
        // If image is zooming, then force to stop and reposition properly
        if (instance.current && instance.current.type === "image" && instance.isAnimating) {
          instance.isAnimating = false;

          instance.update(true, true, 0);

          if (!instance.isComplete) {
            instance.complete();
          }
        }

        instance.trigger("onFullscreenChange", isFullscreen);

        instance.$refs.container.toggleClass("fancybox-is-fullscreen", isFullscreen);

        instance.$refs.toolbar
          .find("[data-fancybox-fullscreen]")
          .toggleClass("fancybox-button--fsenter", !isFullscreen)
          .toggleClass("fancybox-button--fsexit", isFullscreen);
      }
    });
  }

  $(document).on({
    "onInit.fb": function (e, instance) {
      var $container;

      if (!fn) {
        instance.$refs.toolbar.find("[data-fancybox-fullscreen]").remove();

        return;
      }

      if (instance && instance.group[instance.currIndex].opts.fullScreen) {
        $container = instance.$refs.container;

        $container.on("click.fb-fullscreen", "[data-fancybox-fullscreen]", function (e) {
          e.stopPropagation();
          e.preventDefault();

          FullScreen.toggle();
        });

        if (instance.opts.fullScreen && instance.opts.fullScreen.autoStart === true) {
          FullScreen.request();
        }

        // Expose API
        instance.FullScreen = FullScreen;
      } else if (instance) {
        instance.$refs.toolbar.find("[data-fancybox-fullscreen]").hide();
      }
    },

    "afterKeydown.fb": function (e, instance, current, keypress, keycode) {
      // "F"
      if (instance && instance.FullScreen && keycode === 70) {
        keypress.preventDefault();

        instance.FullScreen.toggle();
      }
    },

    "beforeClose.fb": function (e, instance) {
      if (instance && instance.FullScreen && instance.$refs.container.hasClass("fancybox-is-fullscreen")) {
        FullScreen.exit();
      }
    }
  });
})(document, jQuery);
// ==========================================================================
//
// Thumbs
// Displays thumbnails in a grid
//
// ==========================================================================
(function (document, $) {
  "use strict";

  var CLASS = "fancybox-thumbs",
    CLASS_ACTIVE = CLASS + "-active";

  // Make sure there are default values
  $.fancybox.defaults = $.extend(
    true, {
      btnTpl: {
        thumbs: '<button data-fancybox-thumbs class="fancybox-button fancybox-button--thumbs" title="{{THUMBS}}">' +
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.59 14.59h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76H5.65V5.65z"/></svg>' +
          "</button>"
      },
      thumbs: {
        autoStart: false, // Display thumbnails on opening
        hideOnClose: true, // Hide thumbnail grid when closing animation starts
        parentEl: ".fancybox-container", // Container is injected into this element
        axis: "y" // Vertical (y) or horizontal (x) scrolling
      }
    },
    $.fancybox.defaults
  );

  var FancyThumbs = function (instance) {
    this.init(instance);
  };

  $.extend(FancyThumbs.prototype, {
    $button: null,
    $grid: null,
    $list: null,
    isVisible: false,
    isActive: false,

    init: function (instance) {
      var self = this,
        group = instance.group,
        enabled = 0;

      self.instance = instance;
      self.opts = group[instance.currIndex].opts.thumbs;

      instance.Thumbs = self;

      self.$button = instance.$refs.toolbar.find("[data-fancybox-thumbs]");

      // Enable thumbs if at least two group items have thumbnails
      for (var i = 0, len = group.length; i < len; i++) {
        if (group[i].thumb) {
          enabled++;
        }

        if (enabled > 1) {
          break;
        }
      }

      if (enabled > 1 && !!self.opts) {
        self.$button.removeAttr("style").on("click", function () {
          self.toggle();
        });

        self.isActive = true;
      } else {
        self.$button.hide();
      }
    },

    create: function () {
      var self = this,
        instance = self.instance,
        parentEl = self.opts.parentEl,
        list = [],
        src;

      if (!self.$grid) {
        // Create main element
        self.$grid = $('<div class="' + CLASS + " " + CLASS + "-" + self.opts.axis + '"></div>').appendTo(
          instance.$refs.container
          .find(parentEl)
          .addBack()
          .filter(parentEl)
        );

        // Add "click" event that performs gallery navigation
        self.$grid.on("click", "a", function () {
          instance.jumpTo($(this).attr("data-index"));
        });
      }

      // Build the list
      if (!self.$list) {
        self.$list = $('<div class="' + CLASS + '__list">').appendTo(self.$grid);
      }

      $.each(instance.group, function (i, item) {
        src = item.thumb;

        if (!src && item.type === "image") {
          src = item.src;
        }

        list.push(
          '<a href="javascript:;" tabindex="0" data-index="' +
          i +
          '"' +
          (src && src.length ? ' style="background-image:url(' + src + ')"' : 'class="fancybox-thumbs-missing"') +
          "></a>"
        );
      });

      self.$list[0].innerHTML = list.join("");

      if (self.opts.axis === "x") {
        // Set fixed width for list element to enable horizontal scrolling
        self.$list.width(
          parseInt(self.$grid.css("padding-right"), 10) +
          instance.group.length *
          self.$list
          .children()
          .eq(0)
          .outerWidth(true)
        );
      }
    },

    focus: function (duration) {
      var self = this,
        $list = self.$list,
        $grid = self.$grid,
        thumb,
        thumbPos;

      if (!self.instance.current) {
        return;
      }

      thumb = $list
        .children()
        .removeClass(CLASS_ACTIVE)
        .filter('[data-index="' + self.instance.current.index + '"]')
        .addClass(CLASS_ACTIVE);

      thumbPos = thumb.position();

      // Check if need to scroll to make current thumb visible
      if (self.opts.axis === "y" && (thumbPos.top < 0 || thumbPos.top > $list.height() - thumb.outerHeight())) {
        $list.stop().animate({
            scrollTop: $list.scrollTop() + thumbPos.top
          },
          duration
        );
      } else if (
        self.opts.axis === "x" &&
        (thumbPos.left < $grid.scrollLeft() || thumbPos.left > $grid.scrollLeft() + ($grid.width() - thumb.outerWidth()))
      ) {
        $list
          .parent()
          .stop()
          .animate({
              scrollLeft: thumbPos.left
            },
            duration
          );
      }
    },

    update: function () {
      var that = this;
      that.instance.$refs.container.toggleClass("fancybox-show-thumbs", this.isVisible);

      if (that.isVisible) {
        if (!that.$grid) {
          that.create();
        }

        that.instance.trigger("onThumbsShow");

        that.focus(0);
      } else if (that.$grid) {
        that.instance.trigger("onThumbsHide");
      }

      // Update content position
      that.instance.update();
    },

    hide: function () {
      this.isVisible = false;
      this.update();
    },

    show: function () {
      this.isVisible = true;
      this.update();
    },

    toggle: function () {
      this.isVisible = !this.isVisible;
      this.update();
    }
  });

  $(document).on({
    "onInit.fb": function (e, instance) {
      var Thumbs;

      if (instance && !instance.Thumbs) {
        Thumbs = new FancyThumbs(instance);

        if (Thumbs.isActive && Thumbs.opts.autoStart === true) {
          Thumbs.show();
        }
      }
    },

    "beforeShow.fb": function (e, instance, item, firstRun) {
      var Thumbs = instance && instance.Thumbs;

      if (Thumbs && Thumbs.isVisible) {
        Thumbs.focus(firstRun ? 0 : 250);
      }
    },

    "afterKeydown.fb": function (e, instance, current, keypress, keycode) {
      var Thumbs = instance && instance.Thumbs;

      // "G"
      if (Thumbs && Thumbs.isActive && keycode === 71) {
        keypress.preventDefault();

        Thumbs.toggle();
      }
    },

    "beforeClose.fb": function (e, instance) {
      var Thumbs = instance && instance.Thumbs;

      if (Thumbs && Thumbs.isVisible && Thumbs.opts.hideOnClose !== false) {
        Thumbs.$grid.hide();
      }
    }
  });
})(document, jQuery);
//// ==========================================================================
//
// Share
// Displays simple form for sharing current url
//
// ==========================================================================
(function (document, $) {
  "use strict";

  $.extend(true, $.fancybox.defaults, {
    btnTpl: {
      share: '<button data-fancybox-share class="fancybox-button fancybox-button--share" title="{{SHARE}}">' +
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M2.55 19c1.4-8.4 9.1-9.8 11.9-9.8V5l7 7-7 6.3v-3.5c-2.8 0-10.5 2.1-11.9 4.2z"/></svg>' +
        "</button>"
    },
    share: {
      url: function (instance, item) {
        return (
          (!instance.currentHash && !(item.type === "inline" || item.type === "html") ? item.origSrc || item.src : false) || window.location
        );
      },
      tpl: '<div class="fancybox-share">' +
        "<h1>{{SHARE}}</h1>" +
        "<p>" +
        '<a class="fancybox-share__button fancybox-share__button--fb" href="https://www.facebook.com/sharer/sharer.php?u={{url}}">' +
        '<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m287 456v-299c0-21 6-35 35-35h38v-63c-7-1-29-3-55-3-54 0-91 33-91 94v306m143-254h-205v72h196" ../../../default.htm></svg>' +
        "<span>Facebook</span>" +
        "</a>" +
        '<a class="fancybox-share__button fancybox-share__button--tw" href="https://twitter.com/intent/tweet?url={{url}}&text={{descr}}">' +
        '<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m456 133c-14 7-31 11-47 13 17-10 30-27 37-46-15 10-34 16-52 20-61-62-157-7-141 75-68-3-129-35-169-85-22 37-11 86 26 109-13 0-26-4-37-9 0 39 28 72 65 80-12 3-25 4-37 2 10 33 41 57 77 57-42 30-77 38-122 34 170 111 378-32 359-208 16-11 30-25 41-42z" ../../../default.htm></svg>' +
        "<span>Twitter</span>" +
        "</a>" +
        '<a class="fancybox-share__button fancybox-share__button--pt" href="https://www.pinterest.com/pin/create/button/?url={{url}}&description={{descr}}&media={{media}}">' +
        '<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m265 56c-109 0-164 78-164 144 0 39 15 74 47 87 5 2 10 0 12-5l4-19c2-6 1-8-3-13-9-11-15-25-15-45 0-58 43-110 113-110 62 0 96 38 96 88 0 67-30 122-73 122-24 0-42-19-36-44 6-29 20-60 20-81 0-19-10-35-31-35-25 0-44 26-44 60 0 21 7 36 7 36l-30 125c-8 37-1 83 0 87 0 3 4 4 5 2 2-3 32-39 42-75l16-64c8 16 31 29 56 29 74 0 124-67 124-157 0-69-58-132-146-132z" fill="#fff"/></svg>' +
        "<span>Pinterest</span>" +
        "</a>" +
        "</p>" +
        '<p><input class="fancybox-share__input" type="text" value="{{url_raw}}" onclick="select()" ../../../default.htm></p>' +
        "</div>"
    }
  });

  function escapeHtml(string) {
    var entityMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
      "../../../default.htm": "&#x2F;",
      "`": "&#x60;",
      "=": "&#x3D;"
    };

    return String(string).replace(/[&<>"'`=\/]/g, function (s) {
      return entityMap[s];
    });
  }

  $(document).on("click", "[data-fancybox-share]", function () {
    var instance = $.fancybox.getInstance(),
      current = instance.current || null,
      url,
      tpl;

    if (!current) {
      return;
    }

    if ($.type(current.opts.share.url) === "function") {
      url = current.opts.share.url.apply(current, [instance, current]);
    }

    tpl = current.opts.share.tpl
      .replace(/\{\{media\}\}/g, current.type === "image" ? encodeURIComponent(current.src) : "")
      .replace(/\{\{url\}\}/g, encodeURIComponent(url))
      .replace(/\{\{url_raw\}\}/g, escapeHtml(url))
      .replace(/\{\{descr\}\}/g, instance.$caption ? encodeURIComponent(instance.$caption.text()) : "");

    $.fancybox.open({
      src: instance.translate(instance, tpl),
      type: "html",
      opts: {
        touch: false,
        animationEffect: false,
        afterLoad: function (shareInstance, shareCurrent) {
          // Close self if parent instance is closing
          instance.$refs.container.one("beforeClose.fb", function () {
            shareInstance.close(null, 0);
          });

          // Opening links in a popup window
          shareCurrent.$content.find(".fancybox-share__button").click(function () {
            window.open(this.href, "Share", "width=550, height=450");
            return false;
          });
        },
        mobile: {
          autoFocus: false
        }
      }
    });
  });
})(document, jQuery);
// ==========================================================================
//
// Hash
// Enables linking to each modal
//
// ==========================================================================
(function (window, document, $) {
  "use strict";

  // Simple $.escapeSelector polyfill (for jQuery prior v3)
  if (!$.escapeSelector) {
    $.escapeSelector = function (sel) {
      var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
      var fcssescape = function (ch, asCodePoint) {
        if (asCodePoint) {
          // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
          if (ch === "\0") {
            return "\uFFFD";
          }

          // Control characters and (dependent upon position) numbers get escaped as code points
          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        }

        // Other potentially-special ASCII characters get backslash-escaped
        return "\\" + ch;
      };

      return (sel + "").replace(rcssescape, fcssescape);
    };
  }

  // Get info about gallery name and current index from url
  function parseUrl() {
    var hash = window.location.hash.substr(1),
      rez = hash.split("-"),
      index = rez.length > 1 && /^\+?\d+$/.test(rez[rez.length - 1]) ? parseInt(rez.pop(-1), 10) || 1 : 1,
      gallery = rez.join("-");

    return {
      hash: hash,
      /* Index is starting from 1 ../../../_/default.htm
      index: index < 1 ? 1 : index,
      gallery: gallery
    };
  }

  // Trigger click evnt on links to open new fancyBox instance
  function triggerFromUrl(url) {
    if (url.gallery !== "") {
      // If we can find element matching 'data-fancybox' atribute,
      // then triggering click event should start fancyBox
      $("[data-fancybox='" + $.escapeSelector(url.gallery) + "']")
        .eq(url.index - 1)
        .focus()
        .trigger("click.fb-start");
    }
  }

  // Get gallery name from current instance
  function getGalleryID(instance) {
    var opts, ret;

    if (!instance) {
      return false;
    }

    opts = instance.current ? instance.current.opts : instance.opts;
    ret = opts.hash || (opts.$orig ? opts.$orig.data("fancybox") || opts.$orig.data("fancybox-trigger") : "");

    return ret === "" ? false : ret;
  }

  // Start when DOM becomes ready
  $(function () {
    // Check if user has disabled this module
    if ($.fancybox.defaults.hash === false) {
      return;
    }

    // Update hash when opening/closing fancyBox
    $(document).on({
      "onInit.fb": function (e, instance) {
        var url, gallery;

        if (instance.group[instance.currIndex].opts.hash === false) {
          return;
        }

        url = parseUrl();
        gallery = getGalleryID(instance);

        // Make sure gallery start index matches index from hash
        if (gallery && url.gallery && gallery == url.gallery) {
          instance.currIndex = url.index - 1;
        }
      },

      "beforeShow.fb": function (e, instance, current, firstRun) {
        var gallery;

        if (!current || current.opts.hash === false) {
          return;
        }

        // Check if need to update window hash
        gallery = getGalleryID(instance);

        if (!gallery) {
          return;
        }

        // Variable containing last hash value set by fancyBox
        // It will be used to determine if fancyBox needs to close after hash change is detected
        instance.currentHash = gallery + (instance.group.length > 1 ? "-" + (current.index + 1) : "");

        // If current hash is the same (this instance most likely is opened by hashchange), then do nothing
        if (window.location.hash === "#" + instance.currentHash) {
          return;
        }

        if (firstRun && !instance.origHash) {
          instance.origHash = window.location.hash;
        }

        if (instance.hashTimer) {
          clearTimeout(instance.hashTimer);
        }

        // Update hash
        instance.hashTimer = setTimeout(function () {
          if ("replaceState" in window.history) {
            window.history[firstRun ? "pushState" : "replaceState"]({},
              document.title,
              window.location.pathname + window.location.search + "#" + instance.currentHash
            );

            if (firstRun) {
              instance.hasCreatedHistory = true;
            }
          } else {
            window.location.hash = instance.currentHash;
          }

          instance.hashTimer = null;
        }, 300);
      },

      "beforeClose.fb": function (e, instance, current) {
        if (!current || current.opts.hash === false) {
          return;
        }

        clearTimeout(instance.hashTimer);

        // Goto previous history entry
        if (instance.currentHash && instance.hasCreatedHistory) {
          window.history.back();
        } else if (instance.currentHash) {
          if ("replaceState" in window.history) {
            window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (instance.origHash || ""));
          } else {
            window.location.hash = instance.origHash;
          }
        }

        instance.currentHash = null;
      }
    });

    // Check if need to start/close after url has changed
    $(window).on("hashchange.fb", function () {
      var url = parseUrl(),
        fb = null;

      // Find last fancyBox instance that has "hash"
      $.each(
        $(".fancybox-container")
        .get()
        .reverse(),
        function (index, value) {
          var tmp = $(value).data("FancyBox");

          if (tmp && tmp.currentHash) {
            fb = tmp;
            return false;
          }
        }
      );

      if (fb) {
        // Now, compare hash values
        if (fb.currentHash !== url.gallery + "-" + url.index && !(url.index === 1 && fb.currentHash == url.gallery)) {
          fb.currentHash = null;

          fb.close();
        }
      } else if (url.gallery !== "") {
        triggerFromUrl(url);
      }
    });

    // Check current hash and trigger click event on matching element to start fancyBox, if needed
    setTimeout(function () {
      if (!$.fancybox.getInstance()) {
        triggerFromUrl(parseUrl());
      }
    }, 50);
  });
})(window, document, jQuery);
// ==========================================================================
//
// Wheel
// Basic mouse weheel support for gallery navigation
//
// ==========================================================================
(function (document, $) {
  "use strict";

  var prevTime = new Date().getTime();

  $(document).on({
    "onInit.fb": function (e, instance, current) {
      instance.$refs.stage.on("mousewheel DOMMouseScroll wheel MozMousePixelScroll", function (e) {
        var current = instance.current,
          currTime = new Date().getTime();

        if (instance.group.length < 2 || current.opts.wheel === false || (current.opts.wheel === "auto" && current.type !== "image")) {
          return;
        }

        e.preventDefault();
        e.stopPropagation();

        if (current.$slide.hasClass("fancybox-animated")) {
          return;
        }

        e = e.originalEvent || e;

        if (currTime - prevTime < 250) {
          return;
        }

        prevTime = currTime;

        instance[(-e.deltaY || -e.deltaX || e.wheelDelta || -e.detail) < 0 ? "next" : "previous"]();
      });
    }
  });
})(document, jQuery);
jQuery(function($) {
    "use strict";

    $(function () {
        $('[data-toggle="tooltip"]').tooltip();
    });

    $.scrollTo = function(el, offset, container) {
        var pos = (el && el.length > 0) ? el.offset().top : 0;
        var actuallContainer = !!container ? container : "html, body";
        pos = pos - el.height() - offset;
        $(actuallContainer).animate({
            scrollTop: pos
        }, 'slow');
    };

    $.getCookie = function(name) {
        var matches = document.cookie.match(new RegExp(
            "(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"
        ));

        return matches ? decodeURIComponent(matches[1]) : undefined;
    };

    $.setCookie = function(name, value, options) {
        options = options || {};

        var expires = options.expires;

        if (typeof expires === "number" && expires) {
            var d = new Date();
            d.setTime(d.getTime() + expires * 1000);
            expires = options.expires = d;
        }
        if (expires && expires.toUTCString) {
            options.expires = expires.toUTCString();
        }

        value = encodeURIComponent(value);

        var updatedCookie = name + "=" + value;

        for (var propName in options) {
            updatedCookie += "; " + propName;
            var propValue = options[propName];
            if (propValue !== true) {
                updatedCookie += "=" + propValue;
            }
        }

        document.cookie = updatedCookie;
    };

    $.deleteCookie = function(name) {
        setCookie(name, "", {
            expires: -1
        })
    };

    // todo: remove it
    $('.comment a, .comment .reply-to').click(function(){
        let hash = $(this).attr('href');

        if (hash.length === 1) {
            return;
        }

        let item = $( $(this).parents('.comments') ).find(hash);

        if (item.length) {
            $('html, body').animate({
                scrollTop: item.offset().top - 62
            }, 100);
        }
    });

    $('.create-user-message').on('click', function (e) {
        e.preventDefault();

        let link = $(this).data('href');
        let entry = $('#create-message-modal');

        $.ajax(link, {
            method: 'get',
            beforeSend: function () {
                entry.modal('show');
            },
            success: function (data) {
                entry.find('.modal-content').html(data);

                $.initSelectRecipient();
            }
        });
    });

    $.initSelectRecipient = function (className) {
        $(className ? className : '#select-recipient').selectize({
            valueField: 'id',
            labelField: 'name',
            searchField: 'name',
            create: false,
            preload: true,
            placeholder: 'Выберите или введите ник для поиска...',
            render: {
                option: function(item, escape) {
                    return '<div class="p-2">' +
                        '<span class="title">' +
                        '<span class="avatar mr-2"><img src="' + item.avatar + '" height="34" width="34"></span>' +
                        '<span class="name">' + escape(item.name) + '</span>' +
                        '</span>' +
                        '</div>';
                }
            },
            load: function(query, callback) {
                //if (!query.length) return callback();
                $.ajax({
                    url: '/api/1.0/users/friends?q=' + encodeURIComponent(query),
                    type: 'GET',
                    dataType: 'json',
                    error: function() {
                        callback();
                    },
                    success: function(res) {
                        callback(res);
                        //callback(res.repositories.slice(0, 10));
                    }
                });
            }
        });
    };

    $('select').not('.standalone, #select-country, #select-city, .selectized, .update-role').each(function () {
        $(this).selectize();
    });

    $(':reset').on('click', function () {
        $('select').each(function() {
            if ($(this)[0].selectize) {
                $(this)[0].selectize.clear();

                if ($(this).is('#select-city')) {
                    $(this)[0].selectize.disable();
                }
            }
        });
    });
});

yii.confirm = function (message, ok, cancel) {
    bootbox.confirm({
            title: "Подтвердите действие",
            message: message,
            animate: false,
            buttons: {
                cancel: {
                    label: '<i class="fa fa-times"></i> Отмена'
                },
                confirm: {
                    label: '<i class="fa fa-check"></i> Применить'
                }
            },
            callback: function (result) {
                result ? !ok || ok() : !cancel || cancel();
            }
        }
    );
};



jQuery(function($) {
    "use strict";

    var form = $('#community-advert-form');

    if (form.length === 0) {
        return;
    }
    var updateBtn = form.find('button[name=update]');
    var removeBtn = form.find('button[name=remove]');
    var removeAndUpdateBtn = form.find('button[name=update], button[name=remove]');

    var forRemove = false;
    updateBtn.on('click', function () {
        forRemove = false;
    });
    removeBtn.on('click', function () {
        forRemove = true;
    });

    $(form).on('beforeSubmit', function () {
        var form = $(this);
        var formData = form.serializeArray();
        if (forRemove) {
            formData.push({name: "remove", value: 1});
        }
        $.ajax({
                type: form.attr('method'),
                url: form.attr('action'),
                data: formData,
                beforeSend: function () {
                    removeAndUpdateBtn.prop('disabled', true);
                    //form.find('button[name=update], button[name=remove]').prop('disabled', true);
                }
            }
        )
            .done(function(data) {
                removeAndUpdateBtn.prop('disabled', false);
                //form.find('button[name=update], button[name=remove]').prop('disabled', false);
                if(data.success) {
                    document.location.reload();
                } else if (data.validation) {
                    form.yiiActiveForm('updateMessages', data.validation, true);
                } else {

                }
            })
            .fail(function () {

            });
        return false;
    });
});


jQuery(function($) {
    "use strict";

    var conversationContainer = $('#conversation-container');

    var formElement = '#sendMessageForm';

    let params = new URLSearchParams(document.location.search.substring(1));
    let selectedDialog = params.get("sel");

    $('#message-conversation').on('click', '.media.preview', function () {
        let conversationId = $(this).data('id');
        let messageDetailsContainer = $('#message-details');

        history.pushState(null, document.title, document.location.pathname + '?sel=' + conversationId);

        $.ajax({
            type: 'GET',
            url:  '/mail/show?id=' + conversationId,
            cache: false,

            beforeSend: function () {
                $('.media.preview').removeClass('selected');

                let preview = $("#messagePreview-" + conversationId);
                let cardBody = $('#message-details .card-body');

                preview.addClass('selected');
                preview.find('.badge').hide('slow');

                cardBody.html('<div class="m-auto text-muted">' +
                    '<i class="fa fa-circle-o-notch fa-spin fa-fw"></i>' +
                    '</div>');
            },
            success: function (data) {
                $(messageDetailsContainer).html(data);

                let simplebar = new SimpleBar($("#message-details .card-body")[0]);

                simplebar.getScrollElement().scrollTop = simplebar.getScrollElement().scrollHeight;

                var ias = $(messageDetailsContainer).ias({
                    container:  '#message-details-over',
                    item:       '.media',
                    pagination: '.pagination',
                    //next:       '.next .page-link',
                });

            }
        })
    });

    $(conversationContainer).on('beforeSubmit', formElement, function () {
        $.ajax({
            url: '/mail/create',
            type: 'POST',
            data: $(this).serialize(),
            success: function(res){
                if (res.success) {
                    $("#messagePreview-" + res.sel).trigger("click");
                }
            },
        });

        return false;
    });

    $(conversationContainer).on('click', '#message-conversation .load-more', function(el) {
        let self = $(this);
        let id = self.data('id');
        $.ajax({
            url: '/mail/index',
            data: {start: id},
            dataType: 'html',
            beforeSend: function () {
                self.html('<i class="fa fa-cog fa-spin fa-fw"></i>')
            },
            success: function (data) {
                let messages = $(data);

                if (selectedDialog) {
                    messages.closest('#messagePreview-' + selectedDialog).addClass('selected');
                }

                $('#message-conversation .simplebar-content').append(messages);
                self.remove();
            }
        });

        return false;
    });

    $(conversationContainer).on('click', '#message-details .load-more', function() {
        let self = $(this);
        let offset = self.data('offset');
        let id = self.data('id');
        $.ajax({
            url: '/mail/show',
            data: {id: id, offset: offset},
            dataType: 'html',
            beforeSend: function () {
                self.html('<i class="fa fa-cog fa-spin fa-fw"></i>')
            },
            success: function (data) {
                let media = $(data).find('.media, .load-more');
                $('#message-details-over .simplebar-content').prepend(media);
                self.remove();
            }
        });

        return false;
    });

    $(conversationContainer).on('keypress', '#message-details textarea', function(e) {
        if (e.keyCode === 13) {
            e.preventDefault();

            var area = $(this);
            if (e.ctrlKey) {
                area.val(area.val() + "\n");
                return;
            }

            $('#sendMessageForm').trigger("submit");
        }
    });

    if (selectedDialog) {
        conversationContainer.find("#messagePreview-" + selectedDialog).trigger('click');
    }
});

jQuery(function($) {
    "use strict";

    if (!$.getCookie("filter-games")) {
        $.setCookie('filter-games', [], {
            expires: 86400,
            path: "../../../default.htm"
        })
    }

    var gameIds = [];
    var cookie = $.getCookie("filter-games").split(",");
    var reloadTimer;

    $(".filtering-games .switch input").each(function() {
        var self = $(this);

        var id = self.parent('.switch').data('id');
        var index = cookie.indexOf(String(id));

        if (index === -1) {
            self.attr('checked', 'checked');
        } else {
            gameIds.push(id)
        }
    });

    $('.filtering-games .nav-link').click(function() {
        clearTimeout(reloadTimer);
    });

    $(".filtering-games .dropdown-menu")
        .click(function (e) {
            e.stopPropagation();
        })
        .mouseleave(function() {
            if (cookie.join(',') !== gameIds.join(',')) {
                reloadTimer = setTimeout(function() {
                    window.location.reload();
                }, 1500);
            }
        }
    );

    $(".filtering-games label").change(function() {
        var self = $(this).find('.switch');
        var id = self.data('id');
        var index = gameIds.indexOf(id);

        if (index >= 0) {
            gameIds.splice(index, 1);
        } else {
            gameIds.push(id);
        }

        $.setCookie('filter-games', gameIds, {
            expires: 86400,
            path: "../../../default.htm"
        });
    });
});

jQuery(function($) {
    "use strict";

    var formatTime = function(secs) {
        let time = (secs) ? new Date(secs * 1000) : new Date();
        let pad = '00';
        let hours = '' + time.getHours();
        let mins = '' + time.getMinutes();
        return pad.substring(0, pad.length - hours.length) + hours + ':' + pad.substring(0, pad.length - mins.length) + mins;
    };

    const ACTIONS = {
        JOIN: 'join',
        READY: 'ready',
        PICK: 'pick',
        CHECKIN: 'checkin',
        LOADMORE: 'loadMore',
        MESSAGE: 'message',
        VETO: 'veto',
    };

    let host = location.host.replace('www', 'wss');
    let url = "wss://"  + host + "/lobby";
    let scrollTop = true;

    let socket = new WebSocket(url);

    socket.onopen = (event) => {
        if (typeof(authkey) !== "undefined" && authkey !== null) {
            socket.send(JSON.stringify({type: ACTIONS.JOIN, authkey: authkey, lobby_id: lobby_id}));
        }
    };

    socket.onmessage = (event) => {
        let self = this;
        let data = JSON.parse(event.data);

        switch (data.type) {
            case ACTIONS.VETO:
                console.log('vetoes');
                break;
            case ACTIONS.JOIN:
                socket.send(JSON.stringify({type: ACTIONS.LOADMORE, lobby_id: lobby_id}));
                break;
            case ACTIONS.READY:
                let icon = $('.match-lineup-container li[data-id="' + data.userId + '"]').find('i.fa.fa-ban');
                icon.removeClass('fa-ban').addClass('fa-check text-success');
                break;
            case ACTIONS.PICK:
                break;
            case ACTIONS.CHECKIN:
                break;
            case ACTIONS.MESSAGE:
                renderMessage(data, true);

                if (data.userId === userId || !('Notification' in window)) {
                    return;
                }

                if (data.sound === 1) {
                    if (typeof Audio !== "function" && typeof Audio !== "object") {
                        console.log('HTML5 Audio is not supported in this browser');
                    } else {
                        let audio = new Audio('../../../chat-warning.wav');
                        audio.play();
                        audio.currentTime=0;
                    }
                }

                Notification.requestPermission().then(function(permission) {
                    if (permission !== 'denied') {
                        let msg = data.message;
                        if (msg.length > 40) {
                            msg = msg.substring(0, 40) + '...';
                        }
                        let notification = new Notification('Новое сообщение от ' + data.username, {
                            body: msg,
                            lang: 'ru-RU'
                        });
                        notification.onshow = function () {
                            setTimeout(function () {
                                notification.close();
                            }, 5000);
                        };
                    }
                });

                break;
            case ACTIONS.LOADMORE:
                var history = data.data.history;

                $.each(history, function(idx, message) {
                    renderMessage(message, false, scrollTop);
                });

                if (data.allowMore) {
                    $('.chat-container')
                        .prepend('<div class="px-3"><button class="btn btn-light my-3 bordered-0 btn-block load-more-messages" data-last="' + history[history.length - 1].id + '">Загрузить ещё</button></div>');
                }

                break;
        }
    };
    socket.onclose = (event) => {};
    socket.onerror = (event) => {};

    var input = $('#chat-message');

    var sendMessage = function() {
        let message = input.val().trim();

        input.val('');

        socket.send(JSON.stringify({type: ACTIONS.MESSAGE, message: message}));
    };

    var renderMessage = function(message, append = false, scrollTop = true) {
        let container = $('.chat-container');
        let widget = $('.chat-widget');
        let messages_body = $('.m-messenger__messages-body');

        if (widget.length) {
            let height = widget.height();
            if (height < 400) {
                height += 80;
                widget.height(height);
            }
        }

        if (messages_body.length) {
            let height = messages_body.height();
            if (height < 400) {
                height += 80;
                messages_body.height(height);
            }
        }

        let template = '';
        template =+ (message.userId === userId) ? '<div class="m-messenger__messages-message is-self chat-msg">' : '<div class="m-messenger__messages-message is-interlocutor chat-msg">';
        template += '<div class="m-messenger__messages-wrap">';
        template += '<div class="m-messenger__messages-message-text">';
        template += message.message;
        template += '</div>';
        template += '<span class="m-messenger__messages-date">';
        template += formatTime(message.timestamp) + ', ' + message.teamname + ' @' + message.username;
        template += '</span>';
        template += '</div>';
        template += '</div>';

        if (append) {
            container.append(template);
        } else {
            container.prepend(template);
        }

        if (scrollTop) {
            $('.simplebar-scroll-content').animate({
                scrollTop: container[0].scrollHeight
            }, 3);

            var con = messages_body.find('.simplebar-scroll-content');
            if (con.length) {
                con.animate({
                    scrollTop: con[0].scrollHeight
                }, 0);
            }
        }
    };

    $('#send-msg').on('click', function (e) {
        sendMessage();
    });

    input.on('keypress', function (e) {
        if (e.keyCode === 13 && !e.ctrlKey) {
            sendMessage();
        }
        if (e.keyCode === 13 && e.ctrlKey) {
            $(this.input).val(function(i, val) {
                return val + "%0A"
            });
        }
    });
    $('.chat-container').on('click', '.load-more-messages', function() {
        scrollTop = false;
        socket.send(JSON.stringify({
            type: ACTIONS.LOADMORE,
            last_message: $(this).data('last')
        }));
        $(this).remove();
    });

    $('#btn-ready').on('click', function(e) {
        e.preventDefault();
        let container = $(this).closest('.card');

        socket.send(JSON.stringify({type: ACTIONS.READY}));

        container.remove();
    });
});









jQuery(function($) {
    "use strict";

    var select_country = $('form #select-country');
    var select_city    = $('form #select-city');

    if (!select_country.length || !select_city.length) {
        if (select_country.length) {
            select_country.selectize({
                valueField: 'id',
                labelField: 'name',
                searchField: 'name',
                options: [],
                load: function(query, callback) {
                    if (!query.length) return callback();

                    $.ajax({
                        url: '../../../api/1.0/database/countries/default.htm' + query,
                        type: 'GET',
                        dataType: 'json',
                        error: function() {
                            callback();
                        },
                        success: function(res) {
                            callback(res);
                        }
                    });
                }
            });
        }

        return;
    }

    select_country.selectize({
        // inputClass : 'selectize-input form-control',
        onChange: function(value) {
            if (!value.length) return;

            select_city.disable();
            select_city.clear();
            select_city.clearOptions();

            select_city.load(function(callback) {
                $.ajax({
                    url: '../../../api/1.0/database/countries/default.htm' + value + '/cities',
                    type: 'GET',
                    dataType: 'json',
                    // data: { country: value },
                    success: function (results) {
                        select_city.enable();
                        callback(results);
                    },
                    error: function() {
                        callback();
                    }
                });
            });
        }
    });

    select_country = select_country[0].selectize;

    select_city.selectize({
        valueField: 'value',
        labelField: 'label',
        searchField: ['label', 'region', 'area'],
        dropdownParent: 'body',
        preload: false,
        render: {
            option: function(item, escape) {
                var template = '<div class="option">';

                if (item.area || item.region) {
                    template = '<div class="extended">';
                    template += item.label;
                    template += '<div class="item">';

                    if (item.area != null && item.area != item.region) {
                        template += '<span>' + item.area + ',<br></span>';
                    }
                    template += '<span>' + item.region + '</span>';

                    template += '</div>';
                } else {
                    template += item.label;
                }
                template += '</div>';

                return template
            }
        },

        load: function(query, callback) {
            if (!query.length || !select_country.getValue().length) return;

            $.ajax({
                url: '../../../api/1.0/database/countries/default.htm' + select_country.getValue() + '../../../cities/default.htm' + query,
                type: 'GET',
                dataType: 'json',

                error: function() {
                    callback();
                },
                success: function(res) {
                    select_city.clearOptions();

                    callback(res);
                }
            });
        }

    });

    select_city = select_city[0].selectize;

    if (!select_country.getValue().length) {
        select_city.disable();
    }
});


/*
$(document).ready(function() {

    var socket = io.connect('http://www.vscl.dev:80');

    var nickname = 'd3vnu11';

    socket.emit('join', 'devnu11');


    // Function to add a message to the page
    var newMessage = function(data) {
        var who = $('<div class="who">').text(data.nickname),
            when = $('<div class="when">').text(new Date().toString().substr(0, 24)),
            msg = $('<div class="msg">').text(data.msg),
            header = $('<div class="header clearfix">').append(who).append(when),
            li = $('<li>').append(header).append(msg);

        msgList.prepend(li);
    };


    socket.on('msg', function(data) { newMessage(data); });
});
../../../_/default.htm


/**
 * notifications plugin
 ../../../_/default.htm

var Notifications = (function(opts) {
    if(!opts.id){
        return;
    }

    var elem = $('#' + opts.id);
    if(!elem.length){
        return;
    }

    var options = $.extend({
        pollInterval: 60000,
        xhrTimeout: 2000,
    }, opts);

    /**
     * Renders a notification row
     *
     * @param object The notification instance
     * @returns {jQuery|HTMLElement|*}
     ../../../_/default.htm
    /*
    var renderRow = function (object) {

        // var html = '<div href="#" class="dropdown-item notification-item' + (object.read != '0' ? ' read' : '') + '"' +
        //     ' data-id="' + object.id + '"' +
        //     ' data-class="' + object.class + '"' +
        //     ' data-key="' + object.key + '">' +
        //     //'<span class="icon"></span> '+
        //     '<span class="message">' + object.message + '</span>' +
        //     '<small class="timeago">' + object.timeago + '</small>' +
        //     '<span class="mark-read" data-toggle="tooltip" title="' + (object.read != '0' ? options.readLabel : options.markAsReadLabel) + '"></span>' +
        //     '</div>';

        var html = '<li href="#" class="notification"' +
            ' data-id="' + object.id + '"' +
            ' data-class="' + object.class + '"' +
            ' data-key="' + object.key + '">' +
            // '<div class="media">' +
            // '<img class="mr-2 img-circle" alt="50x50" style="width: 50px; height: 50px;" src="../../../img/placeholder.png">' +
            //
            // '<div class="media-body">' +
            //     '<strong class="notification-title"><a href="#">Dave Lister</a> commented on <a href="#">DWARF-13 - Maintenance</a></strong>' +
            //     '<p class="notification-desc">I totally don\'t wanna do it. Rimmer can do it.</p>' +
            //
            //     '<div class="notification-meta">' +
            //         '<small class="timestamp">' + object.timeago + '</small>' +
            //     '</div>' +
            // '</div>' +
            object.message +

            '</div>' +
            '</li>';

        return $(html);

    };
    ../../../_/default.htm

    var showList = function() {
        var list = elem.find('.dropdown-menu.notifications');

        $.ajax({
            url: options.url,
            type: "GET",
            dataType: "html",
            timeout: opts.xhrTimeout,
            beforeSend: function () {
                list.html('' +
                    '<li class="notification loader">' +
                        '<i class="fa fa-cog fa-spin fa-3x fa-fw"></i>\n' +
                        '<span class="sr-only">Загрузка...</span>' +
                    '</li>');
            },

            success: function(data) {
                // list.empty();
                list.html(data);
                setCount(data.count);
                startPoll(true);
            }
        });
    };

    elem.find('> a[data-toggle="dropdown"]').on('click', function(e){
        if( !$(this).parent().hasClass('show') ) {
            showList();
        }
    });

    elem.find('.read-all').on('click', function(e){
        e.stopPropagation();
        var link = $(this);
        $.ajax({
            url: options.readAllUrl,
            type: "GET",
            dataType: "json",
            timeout: opts.xhrTimeout,
            success: function (data) {
                markRead(elem.find('.dropdown-item:not(.read)').find('.mark-read'));
                link.off('click').on('click', function(){ return false; });
            }
        });
    });

    var markRead = function(mark){
        mark.off('click').on('click', function(){ return false; });
        mark.attr('title', options.readLabel);
        mark.tooltip('dispose').tooltip();
        mark.closest('.dropdown-item').addClass('read');
    };

    var setCount = function(count) {
        var badge = elem.find('.notification-icon');

        elem.find('.notification-link').find('.count').text('(' + count  + ')');

        var link;
        if (elem.is('#notification-messages')) {
            link = $('.navbar #notification-messages-link i').attr('data-count', count);
        }

        if (elem.is('#notification')) {
            link = $('.navbar #notification-link i').attr('data-count', count);
        }

        if(count > 0){
            badge.attr('data-count', count).removeClass('icon-hide');
            link.removeClass('icon-hide');
        } else {
            badge.attr('data-count', count).addClass('icon-hide');
            link.addClass('icon-hide');
        }
    };

    var updateCount = function() {
        $.ajax({
            url: options.countUrl,
            type: "GET",
            dataType: "json",
            timeout: opts.xhrTimeout,
            success: function(data) {
                setCount(data.count);
            },
            complete: function() {
                startPoll();
            }
        });
    };

    var _updateTimeout;
    var startPoll = function(restart) {
        if (restart && _updateTimeout){
            clearTimeout(_updateTimeout);
        }
        _updateTimeout = setTimeout(function() {
            updateCount();
        }, opts.pollInterval);
    };

    // Fire the initial poll
    //startPoll();

    updateCount();
});

jQuery(function($) {
    "use strict";
    let container = $('#server-manage-container');

    var loader = function() {
        return '<div id="loader" class="mx-auto"></div>';
    };

    $.fn.serverManage = function(options) {
        let $self = $(this);

        let initSelectize = function () {
            $self.find('select').selectize();
        };

        let loadPage = function () {
            $.ajax({
                url: $self.data('endpoint'),
                type: 'get',
                dataType: 'html',
                beforeSend: function () {
                    $self.empty();
                    $self.append(loader())
                },
                complete: function () {
                    $self.find('#loader').remove();
                },
                success: function (response) {
                    $self.html(response);
                    initSelectize();
                },
                error: function () {
                    $self.find('#loader').remove();
                    toastr.error('Произошла внутренняя ошибка сервера.');
                }
            });
        };

        loadPage();

        $self.on('change', '#vscl_config', function (e) {
            $.ajax({
                url: $(this).data('endpoint'),
                data: {
                    value: this.checked,
                    orderId: $(this).data('id'),
                },
                method: 'POST',
            });
        });

        $self.on('submit', '#config-form', function (e) {
            e.preventDefault();

            var form = $(this);
            var url = form.attr('action');

            $.ajax({
                type: 'post',
                url: url,
                data: form.serialize(),
                success: function (response) {
                    if (response.success) {
                        toastr.success('Конфигурация успешно обновлена.');
                    } else {
                        toastr.error('Произошла ошибка при сохранении конфигурации.');
                    }
                }
            });
        });

        $self.on('click', '.load-backup', function (e) {
            e.preventDefault();

            var self = $(this);

            $.ajax({
                url: $(this).data('endpoint'),
                method: 'get',
                beforeSend: function () {
                    $('.load-backup').prop('disabled', true);
                },
                complete: function () {
                    $('.load-backup').prop('disabled', false);
                },
            })
        });

        $self.on('click', '.exec-config', function (e) {
            e.preventDefault();

            var self = $(this);

            $.ajax({
                url: $(this).data('endpoint'),
                method: 'get',
                beforeSend: function () {
                    $('.exec-config').prop('disabled', true);
                    if (self.is('#live')) {
                        container.find('#pause-toggle').prop('disabled', false);
                    } else {
                        container.find('#pause-toggle').prop('disabled', true);
                    }
                },
                complete: function () {
                    $('.exec-config').prop('disabled', false);

                    loadPage();
                },
            })
        });

        $self.on('click', '#pause-toggle', function (e) {
            e.preventDefault();

            var self = $(this);
            $.ajax({
                url: $(this).data('endpoint'),
                method: 'get',
                beforeSend: function () {
                    self.prop('disabled', true);
                },
                complete: function () {
                    self.prop('disabled', false);
                },
                success: function (response) {
                    if (!response.success) {
                        return;
                    }
                    if (response.state === 'paused') {
                        self.html('Снять паузу');
                        self.removeClass('btn-info').addClass('btn-light');
                    }
                    if (response.state === 'live') {
                        self.html('Поставить паузу');
                        self.removeClass('btn-light').addClass('btn-info');
                    }
                }
            });
        });

        $self.on('click', '#changemap', function (e) {
            var self = $(this);
            $.ajax({
                url: self.data('endpoint'),
                method: 'get',
                data: {
                    map: $('#select-maps').val(),
                },
                beforeSend: function () {
                    self.prop('disabled', true);
                },
                complete: function () {
                    self.prop('disabled', false);
                },
                success: function (response) {
                    loadPage();
                }
            })
        });
    };
});



jQuery(function($) {
    "use strict";

    const RESERVED = 0, MAIN = 1, MANAGER = 2, CAPTAIN = 3, COACH = 4;

    var previous;

    /**
     * Проверяем наличие лимитированных ролей и меняем прыдыдущие/текущие значения.
     *
     * @param state boolean
     * @param selectize is Selectize input instance
     ../../../_/default.htm
    var checkLimitedRoles = function (selectize, state) {
        var selectizeValue = parseInt(selectize.getValue());

        if (state === false) {
            selectize.setValue(previous.value, true);
            return;
        }

        if (state === true && selectizeValue === MAIN) {
            return;
        }

        selects.each(function () {
            if (selectize != this.selectize) {
                var value = parseInt(this.selectize.getValue());

                if (value === selectizeValue) {
                    this.selectize.setValue(0, true);
                }
            }
        });
    };

    var selects = $('.update-role').selectize({
        onFocus: function() {
            previous = this.options[this.getValue()];
        },
        onChange: function (val) {
            var value = parseInt(val);
            var self  = this;
            var participant  = $(this.$control).closest('.participants-item');
            var endpoint = $(this.$control).parents().find('select.update-role').data('endpoint');

            $.ajax({
                url: endpoint,
                method: 'patch',
                dataType: 'json',
                data: {
                    uid: participant.data('uid'),
                    role: value
                },
                error: function () {
                    toastr.error('Произошла внутренняя ошибка сервера.');

                    checkLimitedRoles(self, false);
                },
                success: function(data) {
                    checkLimitedRoles(self, data.success);

                    if (data.success === true) {
                        toastr.success('Роль успешно изменена.');

                        previous = self.options[value];
                    } else {
                        toastr.warning(data.data.message);
                    }
                }
            });
        }
    });

    $('#join-self').on('click', function(e) {
        e.preventDefault();
        let el = $(this);
        $.ajax({
            url: el.data('endpoint'),
            method: 'POST',
            dataType: 'json',
            data: {
                'code': $('input[name=code]').val(),
            },
            beforeSend: function() {
                el.attr('disable');
            },
            complete: function() {
                el.removeAttr('disable');
            },
            success: function(data) {
                if (data.success) {
                    toastr.success(data.message);

                    setTimeout(function() {
                        window.location.reload();
                    }, 2500);

                } else {
                    toastr.error(data.message);
                }
            },
        });

    });

    $('.squad .update-country').on('change', function (e) {
        e.preventDefault();

        var el = $(this);
        var endpoint = el.data('endpoint');

        $.ajax({
            url: endpoint,
            method: 'patch',
            dataType: 'json',
            data: {
                'country': el.val()
            },
            success: function(data) {
                toastr.success('Страна успешно изменена.')
            },
        });
    });

    $('.squad .update-invite').on('click', function (e) {
        e.preventDefault();

        var el = $(this);
        var container = el.parents('.input-group');
        var endpoint = el.data('endpoint');

        if (el.is('.disabled')) {
            return false;
        }

        $.ajax({
            url: endpoint,
            method: 'patch',
            dataType: 'json',
            beforeSend: function () {
                el.prop('disabled', true);
            },
            complete: function () {
                el.prop('disabled', false);
            },
            success: function(data) {
                container.find('input').val(data.code);
            },
        });

    });




    $('.squad .delete').on('click', function (e) {
        e.preventDefault();

        var endpoint = $(this).data('endpoint');

        bootbox.confirm(
            {
                animate: false,
                title: "Расформировать состав?",
                message: "Вы действительно хотите расформировать состав? Это действие удалит дисциплину в команде.",
                buttons: {
                    cancel: {
                        label: 'Отмена'
                    },
                    confirm: {
                        label: 'Расформировать'
                    }
                },
                callback: function (result) {
                    if (result) {
                        $.ajax({
                            url: endpoint,
                            method: 'delete',
                            dataType: 'json',
                            success: function(data) {
                                toastr.success('Состав успешно расформирован.');

                                setTimeout(function () {
                                    window.location = '/team/my';
                                }, 1800);
                            },
                        });
                    }
                }
            }
        );
    });

    $('.squad .delete-member').on('click', function (e) {
        e.preventDefault();

        var endpoint = $(this).data('endpoint');
        var container = $(this).parents('.participants-item');
        var uid = container.data('uid');

        console.log(uid);
        bootbox.confirm(
            {
                animate: false,
                title: "Удалить участника?",
                message: "Вы действительно хотите удалить участника состава?",
                buttons: {
                    cancel: {
                        label: 'Отмена'
                    },
                    confirm: {
                        label: 'Удалить'
                    }
                },
                callback: function (result) {
                    if (result) {
                        $.ajax({
                            url: endpoint,
                            method: 'delete',
                            dataType: 'json',
                            data: {
                                'uid': uid
                            },
                            success: function(data) {
                                //container.hide();
                                container.remove();
                            },
                        });
                    }
                }
            }
        );
    });
});


jQuery(function($) {
    "use strict";

    var button = $('#join-modal button.btn');

    var input  = $('#join-modal input[name="code"]');

    var modal  = $('#join-modal');

    var btnDisable = function() {
        button
            .attr('disabled', true)
            .addClass('btn-outline-secondary')
            .removeClass('btn-outline-success');
    };

    var btnEnable = function() {
        button
            .removeAttr('disabled')
            .addClass('btn-outline-success')
            .removeClass('btn-outline-secondary');
    };

    $(input).on('input', function() {
        input.val().length <= 7 ? btnDisable() : btnEnable();
    });

    $(modal).on('click', 'button.btn', function(e) {
        e.preventDefault();

        var el = $(this);
        var code = input.val();
        var endpoint = el.data('endpoint');

        $.ajax({
            url: endpoint,
            method: 'POST',
            dataType: 'json',
            data: {
                'code': code
            },
            beforeSend: btnDisable,
            complete: btnEnable,

            success: function(data) {
                if (data.success) {
                    toastr.success(data.message);
                } else {
                    btnDisable();

                    var msg = data.message;

                    if (data.url) {
                        msg += '<hr><a href="' + data.url + '" target="_blank" class="btn btn-sm btn-light text-dark text-uppercase">Активировать</a>';
                    }

                    toastr.error(msg, {timeOut: 10000});
                }
            },
            error: function() {
                toastr.error('Произошла внутренняя ошибка сервера.');
                btnDisable();
            }
        });

    });

    $('.squad .delete-team').on('click', function (e) {
        e.preventDefault();

        var endpoint = $(this).data('endpoint');

        bootbox.confirm(
            {
                animate: false,
                title: "Удалить команду?",
                message: "Вы действительно хотите удалить команду? Действие навсегда удалит команду и не может быть отменено.",
                buttons: {
                    cancel: {
                        label: 'Отмена'
                    },
                    confirm: {
                        label: 'Удалить'
                    }
                },
                callback: function (result) {
                    if (result) {
                        $.ajax({
                            url: endpoint,
                            method: 'delete',
                            dataType: 'json',
                            success: function(data) {
                                toastr.success('Команда успешно удалена');

                                setTimeout(function () {
                                    window.location = '/team/my';
                                }, 1800);
                            },
                        });
                    }
                }
            }
        );
    });


});

/*
 * Toastr
 * Copyright 2012-2015
 * Authors: John Papa, Hans Fjällemark, and Tim Ferrell.
 * All Rights Reserved.
 * Use, reproduction, distribution, and modification of this code is subject to the terms and
 * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php
 *
 * ARIA Support: Greta Krafsig
 *
 * Project: https://github.com/CodeSeven/toastr
 ../../../_/default.htm
/* global define ../../../_/default.htm
(function (define) {
    define(['jquery'], function ($) {
        return (function () {
            var $container;
            var listener;
            var toastId = 0;
            var toastType = {
                error: 'error',
                info: 'info',
                success: 'success',
                warning: 'warning'
            };

            var toastr = {
                clear: clear,
                remove: remove,
                error: error,
                getContainer: getContainer,
                info: info,
                options: {},
                subscribe: subscribe,
                success: success,
                version: '2.1.3',
                warning: warning
            };

            var previousToast;

            return toastr;

            ////////////////

            function error(message, title, optionsOverride) {
                return notify({
                    type: toastType.error,
                    iconClass: getOptions().iconClasses.error,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function getContainer(options, create) {
                if (!options) { options = getOptions(); }
                $container = $('#' + options.containerId);
                if ($container.length) {
                    return $container;
                }
                if (create) {
                    $container = createContainer(options);
                }
                return $container;
            }

            function info(message, title, optionsOverride) {
                return notify({
                    type: toastType.info,
                    iconClass: getOptions().iconClasses.info,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function subscribe(callback) {
                listener = callback;
            }

            function success(message, title, optionsOverride) {
                return notify({
                    type: toastType.success,
                    iconClass: getOptions().iconClasses.success,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function warning(message, title, optionsOverride) {
                return notify({
                    type: toastType.warning,
                    iconClass: getOptions().iconClasses.warning,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function clear($toastElement, clearOptions) {
                var options = getOptions();
                if (!$container) { getContainer(options); }
                if (!clearToast($toastElement, options, clearOptions)) {
                    clearContainer(options);
                }
            }

            function remove($toastElement) {
                var options = getOptions();
                if (!$container) { getContainer(options); }
                if ($toastElement && $(':focus', $toastElement).length === 0) {
                    removeToast($toastElement);
                    return;
                }
                if ($container.children().length) {
                    $container.remove();
                }
            }

            // internal functions

            function clearContainer (options) {
                var toastsToClear = $container.children();
                for (var i = toastsToClear.length - 1; i >= 0; i--) {
                    clearToast($(toastsToClear[i]), options);
                }
            }

            function clearToast ($toastElement, options, clearOptions) {
                var force = clearOptions && clearOptions.force ? clearOptions.force : false;
                if ($toastElement && (force || $(':focus', $toastElement).length === 0)) {
                    $toastElement[options.hideMethod]({
                        duration: options.hideDuration,
                        easing: options.hideEasing,
                        complete: function () { removeToast($toastElement); }
                    });
                    return true;
                }
                return false;
            }

            function createContainer(options) {
                $container = $('<div/>')
                    .attr('id', options.containerId)
                    .addClass(options.positionClass);

                $container.appendTo($(options.target));
                return $container;
            }

            function getDefaults() {
                return {
                    tapToDismiss: true,
                    toastClass: 'toast',
                    containerId: 'toast-container',
                    debug: false,

                    showMethod: 'fadeIn', //fadeIn, slideDown, and show are built into jQuery
                    showDuration: 300,
                    showEasing: 'swing', //swing and linear are built into jQuery
                    onShown: undefined,
                    hideMethod: 'fadeOut',
                    hideDuration: 1000,
                    hideEasing: 'swing',
                    onHidden: undefined,
                    closeMethod: false,
                    closeDuration: false,
                    closeEasing: false,
                    closeOnHover: true,

                    extendedTimeOut: 1000,
                    iconClasses: {
                        error: 'toast-error',
                        info: 'toast-info',
                        success: 'toast-success',
                        warning: 'toast-warning'
                    },
                    iconClass: 'toast-info',
                    positionClass: 'toast-top-right',
                    timeOut: 5000, // Set timeOut and extendedTimeOut to 0 to make it sticky
                    titleClass: 'toast-title',
                    messageClass: 'toast-message',
                    escapeHtml: false,
                    target: 'body',
                    closeHtml: '<button type="button">&times;</button>',
                    closeClass: 'toast-close-button',
                    newestOnTop: true,
                    preventDuplicates: false,
                    progressBar: false,
                    progressClass: 'toast-progress',
                    rtl: false
                };
            }

            function publish(args) {
                if (!listener) { return; }
                listener(args);
            }

            function notify(map) {
                var options = getOptions();
                var iconClass = map.iconClass || options.iconClass;

                if (typeof (map.optionsOverride) !== 'undefined') {
                    options = $.extend(options, map.optionsOverride);
                    iconClass = map.optionsOverride.iconClass || iconClass;
                }

                if (shouldExit(options, map)) { return; }

                toastId++;

                $container = getContainer(options, true);

                var intervalId = null;
                var $toastElement = $('<div/>');
                var $titleElement = $('<div/>');
                var $messageElement = $('<div/>');
                var $progressElement = $('<div/>');
                var $closeElement = $(options.closeHtml);
                var progressBar = {
                    intervalId: null,
                    hideEta: null,
                    maxHideTime: null
                };
                var response = {
                    toastId: toastId,
                    state: 'visible',
                    startTime: new Date(),
                    options: options,
                    map: map
                };

                personalizeToast();

                displayToast();

                handleEvents();

                publish(response);

                if (options.debug && console) {
                    console.log(response);
                }

                return $toastElement;

                function escapeHtml(source) {
                    if (source == null) {
                        source = '';
                    }

                    return source
                        .replace(/&/g, '&amp;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                }

                function personalizeToast() {
                    setIcon();
                    setTitle();
                    setMessage();
                    setCloseButton();
                    setProgressBar();
                    setRTL();
                    setSequence();
                    setAria();
                }

                function setAria() {
                    var ariaValue = '';
                    switch (map.iconClass) {
                        case 'toast-success':
                        case 'toast-info':
                            ariaValue =  'polite';
                            break;
                        default:
                            ariaValue = 'assertive';
                    }
                    $toastElement.attr('aria-live', ariaValue);
                }

                function handleEvents() {
                    if (options.closeOnHover) {
                        $toastElement.hover(stickAround, delayedHideToast);
                    }

                    if (!options.onclick && options.tapToDismiss) {
                        $toastElement.click(hideToast);
                    }

                    if (options.closeButton && $closeElement) {
                        $closeElement.click(function (event) {
                            if (event.stopPropagation) {
                                event.stopPropagation();
                            } else if (event.cancelBubble !== undefined && event.cancelBubble !== true) {
                                event.cancelBubble = true;
                            }

                            if (options.onCloseClick) {
                                options.onCloseClick(event);
                            }

                            hideToast(true);
                        });
                    }

                    if (options.onclick) {
                        $toastElement.click(function (event) {
                            options.onclick(event);
                            hideToast();
                        });
                    }
                }

                function displayToast() {
                    $toastElement.hide();

                    $toastElement[options.showMethod](
                        {duration: options.showDuration, easing: options.showEasing, complete: options.onShown}
                    );

                    if (options.timeOut > 0) {
                        intervalId = setTimeout(hideToast, options.timeOut);
                        progressBar.maxHideTime = parseFloat(options.timeOut);
                        progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                        if (options.progressBar) {
                            progressBar.intervalId = setInterval(updateProgress, 10);
                        }
                    }
                }

                function setIcon() {
                    if (map.iconClass) {
                        $toastElement.addClass(options.toastClass).addClass(iconClass);
                    }
                }

                function setSequence() {
                    if (options.newestOnTop) {
                        $container.prepend($toastElement);
                    } else {
                        $container.append($toastElement);
                    }
                }

                function setTitle() {
                    if (map.title) {
                        var suffix = map.title;
                        if (options.escapeHtml) {
                            suffix = escapeHtml(map.title);
                        }
                        $titleElement.append(suffix).addClass(options.titleClass);
                        $toastElement.append($titleElement);
                    }
                }

                function setMessage() {
                    if (map.message) {
                        var suffix = map.message;
                        if (options.escapeHtml) {
                            suffix = escapeHtml(map.message);
                        }
                        $messageElement.append(suffix).addClass(options.messageClass);
                        $toastElement.append($messageElement);
                    }
                }

                function setCloseButton() {
                    if (options.closeButton) {
                        $closeElement.addClass(options.closeClass).attr('role', 'button');
                        $toastElement.prepend($closeElement);
                    }
                }

                function setProgressBar() {
                    if (options.progressBar) {
                        $progressElement.addClass(options.progressClass);
                        $toastElement.prepend($progressElement);
                    }
                }

                function setRTL() {
                    if (options.rtl) {
                        $toastElement.addClass('rtl');
                    }
                }

                function shouldExit(options, map) {
                    if (options.preventDuplicates) {
                        if (map.message === previousToast) {
                            return true;
                        } else {
                            previousToast = map.message;
                        }
                    }
                    return false;
                }

                function hideToast(override) {
                    var method = override && options.closeMethod !== false ? options.closeMethod : options.hideMethod;
                    var duration = override && options.closeDuration !== false ?
                        options.closeDuration : options.hideDuration;
                    var easing = override && options.closeEasing !== false ? options.closeEasing : options.hideEasing;
                    if ($(':focus', $toastElement).length && !override) {
                        return;
                    }
                    clearTimeout(progressBar.intervalId);
                    return $toastElement[method]({
                        duration: duration,
                        easing: easing,
                        complete: function () {
                            removeToast($toastElement);
                            clearTimeout(intervalId);
                            if (options.onHidden && response.state !== 'hidden') {
                                options.onHidden();
                            }
                            response.state = 'hidden';
                            response.endTime = new Date();
                            publish(response);
                        }
                    });
                }

                function delayedHideToast() {
                    if (options.timeOut > 0 || options.extendedTimeOut > 0) {
                        intervalId = setTimeout(hideToast, options.extendedTimeOut);
                        progressBar.maxHideTime = parseFloat(options.extendedTimeOut);
                        progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                    }
                }

                function stickAround() {
                    clearTimeout(intervalId);
                    progressBar.hideEta = 0;
                    $toastElement.stop(true, true)[options.showMethod](
                        {duration: options.showDuration, easing: options.showEasing}
                    );
                }

                function updateProgress() {
                    var percentage = ((progressBar.hideEta - (new Date().getTime())) ../../../default.htm progressBar.maxHideTime) * 100;
                    $progressElement.width(percentage + '%');
                }
            }

            function getOptions() {
                return $.extend({}, getDefaults(), toastr.options);
            }

            function removeToast($toastElement) {
                if (!$container) { $container = getContainer(); }
                if ($toastElement.is(':visible')) {
                    return;
                }
                $toastElement.remove();
                $toastElement = null;
                if ($container.children().length === 0) {
                    $container.remove();
                    previousToast = undefined;
                }
            }

        })();
    });
}(typeof define === 'function' && define.amd ? define : function (deps, factory) {
    if (typeof module !== 'undefined' && module.exports) { //Node
        module.exports = factory(require('jquery'));
    } else {
        window.toastr = factory(window.jQuery);
    }
}));

jQuery(function($) {
    "use strict";

    let globalModal = $('#globalModal');
    let modalBody   = $('#globalModal .modal-body');
    let modalHeader = $('#globalModal .modal-header');
    let modalTitle  = $('#globalModal-title');

    var loader = function() {
        return '<div id="loader" class="mx-auto"></div>';
    };

    $.fn.tournamentWidget = function(options) {
        let $self = $(this);

        let initSelectize = function () {
            $self.find('select').selectize();
        };

        let updateState = function (team) {
            return $.ajax({
                url: '/tournaments/widget-state',
                method: 'get',
                data: {id: options.tournament, team: (team) ? team :  options.team},
                dataType: 'html',
                beforeSend: function() {
                    $self.html(loader());
                },
                success: function(response) {
                    $self.html(response);

                    initSelectize();
                },
                error: function () {
                    //stateWidget.html(previousState);
                }
            })
        };

        $(globalModal).on('click', 'button[data-team-id]', function() {
            let self = $(this);
            let prevState = null;

            $.ajax({
                url: '/tournaments/widget-state',
                method: 'get',
                data: {id: options.tournament, team: self.data('team-id')},
                dataType: 'html',
                beforeSend: function() {
                    prevState = $self.html();
                    $self.html(loader());
                },
                complete: function() {
                    globalModal.modal('hide');
                },
                success: function(response) {
                    $self.html(response);
                    initSelectize();
                },
                error: function () {
                    $self.html(prevState);
                }
            })
        });

        $self.on('click', '#tournamentJoin', function (e) {
            e.preventDefault();

            var el = $(this);
            var endpoint = el.data('endpoint');

            $.ajax({
                url: endpoint, method: 'POST', dataType: 'json',

                beforeSend: function () {
                    el.attr('disabled', 'disabled');
                },
                success: function (data) {
                    if (data.success) {
                        updateState(options.team);
                    } else {
                        if (data.message) {
                            toastr.error(data.message)
                        }
                    }
                },
            });
        });

        $self.on('click', '#tournamentCancel', function (e) {
            e.preventDefault();

            var endpoint = $(this).data('endpoint');

            yii.confirm('Вы действительно желаете отменить регистрацию на турнир? Повторная регистрация не возможна!', function () {
                $.ajax({
                    url: endpoint,
                    method: 'post',
                    success: function (response) {
                        if (response.success) {
                            updateState()
                        }
                    }
                })
            });
        });

        $self.on('click', '#tournamentSync', function (e) {
            e.preventDefault();

            var endpoint = $(this).data('endpoint');

            yii.confirm('У Вас действительно произошли изменения в составе команды и вы желаете синхронизировать информацию о участниках команды зарегистрированной на текущий турнир?', function () {
                $.ajax({
                    url: endpoint,
                    method: 'post',
                    success: function (response) {
                        if (response.success) {
                            toastr.success('Информация о составе игроков успешно синхронизирована.');

                            updateState()
                        } else {
                            if (response.message) {
                                toastr.error(response.message)
                            }
                        }
                    }
                })
            });
        });

        $self.on('click', '#tournamentCheckin', function (e) {
            e.preventDefault();
            let self = $(this);

            let endpoint = self.data('endpoint');
            //let tournament = self.data('id');
            let team = self.data('team-id');
            let deposit = parseInt(self.data("deposit"));

            if (deposit) {
                let message = 'Напоминаем, что стоимость взноса в данном турнире <b>' + deposit +
                    ' Vcoin </b>, вы уверены, что готовы принять участие? <hr>' +
                    '<b>Взносы возврату не подлежат!</b>';

                bootbox.confirm({
                        title: "Подтвердите действие",
                        message: message,
                        buttons: {
                            cancel: {
                                label: '<i class="fa fa-times"></i> Отмена'
                            },
                            confirm: {
                                label: '<i class="fa fa-check"></i> Оплатить'
                            }
                        },
                        callback: function (result) {
                            if (result) {
                                checkin(self, endpoint, team)
                            }
                        }
                    }
                );
            } else  {
                checkin(self, endpoint, team)
            }
        });

        var checkin = function(self, endpoint, team) {
            $.ajax({
                url: endpoint,
                method: 'post',
                beforeSend: function () {
                    self.attr('disabled', true);
                },
                success: function (response) {
                    self.attr('disabled', false);
                    if (response.success) {
                        updateState(team);
                    } else if (response.message) {
                        //$(self).before('<p id="error-message" class="text-danger">' + data.message + '</p>');
                        toastr.error(response.message)
                    }
                }
            });
        };

        $self.on('click', '#teamPicker', function(e) {
            e.preventDefault();
            $.ajax({
                url: '/tournaments/widget-available-teams',
                data: {game: $(this).data('game')},
                method: 'get',
                dataType: 'html',
                beforeSend: function () {
                    modalBody.html(loader());
                    modalHeader.hide();
                    globalModal.modal('show');

                    $(this).attr('disabled', 'disabled');
                },
                success: function(data) {
                    modalBody.html(data);
                    modalTitle.text('Выберите команду');
                    modalHeader.show();
                }
            })
        });

        $self.on('change', 'select', function () {
            updateState($(this)[0].selectize.getValue());
        });

    };


    $('.video[data-role="streams"]').each(function(idx) {
        let self = $(this);

        let url = self.data('url');
        let screen = self.find('.screen');
        let osd = self.find('.osd');
        let title = self.find('.title');

        let urlParts = url.match(/(clips\.)?twitch\.tv\/(?:(?:videos\/(\d+))|(\w+))?/i);
        let channel  = urlParts[3];

        if (channel.length === 0) {
            return;
        }

        $.ajax({
            //url: "https://api.twitch.tv/kraken/streams/" + channel,
            url: "https://api.twitch.tv/helix/streams",
            dataType: 'json',
            type: 'get',
            data: {
                user_login: channel
            },
            headers: {
                'Client-ID': 'j4kcl4kel6gpu2qusk2qayjen3tr2vu'
            },
            crossDomain: true,
            success: function (res) {
                if (res.stream === null) {
                    return;
                }

                let stream = res.data;

                if (!stream.length) {
                    return;
                }

                let channel = stream[0];

                var preview = channel.thumbnail_url.replace('{width}', 250);
                    preview = preview.replace('{height}', 140);

                title.text(channel.title);
                osd.html('<i class="fa fa-eye"></i> ' + channel.viewer_count);
                screen.prepend('<img src="' + preview + '">');
                //screen.prepend('<img src="' + preview + '">');

                if (channel.type === 'live') {
                    osd.removeClass('offline');
                    osd.addClass('live');
                } else {
                    osd.removeClass('live');
                }
            }
        });

    });
});









jQuery(function($) {
    "use strict";


    /*
    $('.account-form').find('input[name="value"]').on('input', function () {
        var self = $(this);
        var btn = self.parents('form').find('.ga-update');
        if (self.val().length) {
            btn.removeAttr('disabled');
        } else {
            btn.attr('disabled', 'disabled');
        }
    });

    $('.ga-update').on('click', function(e) {
        e.preventDefault();

        var el = $(this);
        var form = el.parents('form');
        var endpoint = el.data('endpoint');

        $.ajax({
            url: endpoint,
            method: 'PUT',
            data: form.serialize(),
            beforeSend: function() {
                el.attr('disabled', true).addClass('active').prepend("<i class='fa fa-spinner fa-spin'></i> ");
            },
            complete: function() {
                setTimeout(function() {
                    el.text('Отправить').removeClass('active').removeAttr('disabled');
                }, 300);
            },
            success: function(data) {
                if (data.success) {
                    toastr.success('Аккаунт ' + data.attributes.value + ' успешно добавлен.');

                    var text = data.attributes.steam ? data.attributes.steam : data.attributes.value;
                    var link = data.attributes.link ? data.attributes.link : null;

                    var control = form.find('.form-control-static');

                    link
                        ? control.html('<a href="' + link +'" target="_blank">' + text + '</a>')
                        : control.text(text);

                    control.show();

                    form.find('a').show();
                    form.find('button[type=button]').attr('hidden', true);
                    form.find('input[name="value"]').prop('type', 'hidden');
                } else {
                    toastr.error(data.message, null, {
                        timeOut: 8000, closeButton: true
                    });
                }
            },
            error: function (data) {
                toastr.error(data.responseJSON.message);
            }
        });

    });

    $('.game-accounts').on('click', 'a.btn', function(e) {
        e.preventDefault();

        var el = $(this);

        var parent = el.parent();

        var accounts = $('.game-accounts');

        accounts.find('.form-control-static, a').show();
        accounts.find('input[name="value"]').prop('type', 'hidden').val('');
        accounts.find('button[type=button]').attr('hidden', true).attr('disabled', 'disabled');

        el.hide();

        parent.find('.form-control-static').hide();
        parent.find('input[name="value"]').prop('type', 'text');
        parent.find('button[type=button]').attr('hidden', false);
    });

    ../../../_/default.htm

    /*
    $('#userpic').fileapi({
        url: '/file/upload-avatar',
        accept: 'image/*',
        imageSize: { minWidth: 200, minHeight: 200 },
        elements: {
            active: { show: '.js-upload', hide: '.js-browse' },
            preview: {
                el: '.js-preview',
                width: 200,
                height: 200
            },
            progress: '.js-progress'
        },
        onSelect: function (evt, ui){
            var file = ui.files[0];
            if( !FileAPI.support.transform ) {
                alert('Your browser does not support Flash :(');
            }
            else if( file ){
                $('#popup').modal({
                    closeOnEsc: true,
                    closeOnOverlayClick: false,
                    onOpen: function (overlay){
                        $(overlay).on('click', '.js-upload', function (){
                            $.modal().close();
                            $('#userpic').fileapi('upload');
                        });
                        $('.js-img', overlay).cropper({
                            file: file,
                            bgColor: '#fff',
                            maxSize: [$(window).width()-100, $(window).height()-100],
                            minSize: [200, 200],
                            selection: '90%',
                            onSelect: function (coords){
                                $('#userpic').fileapi('crop', file, coords);
                            }
                        });
                    }
                }).open();
            }
        }
    });
    ../../../_/default.htm


});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5qcyIsInNlbGVjdGl6ZS5qcyIsIi4uLy4uL2pzL3NyYy91dGlsLmpzIiwiLi4vLi4vanMvc3JjL2FsZXJ0LmpzIiwiLi4vLi4vanMvc3JjL2J1dHRvbi5qcyIsIi4uLy4uL2pzL3NyYy9jYXJvdXNlbC5qcyIsIi4uLy4uL2pzL3NyYy9jb2xsYXBzZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9wb3BwZXIuanMvZGlzdC9lc20vcG9wcGVyLmpzIiwiLi4vLi4vanMvc3JjL2Ryb3Bkb3duLmpzIiwiLi4vLi4vanMvc3JjL21vZGFsLmpzIiwiLi4vLi4vanMvc3JjL3Rvb2xzL3Nhbml0aXplci5qcyIsIi4uLy4uL2pzL3NyYy90b29sdGlwLmpzIiwiLi4vLi4vanMvc3JjL3BvcG92ZXIuanMiLCIuLi8uLi9qcy9zcmMvc2Nyb2xsc3B5LmpzIiwiLi4vLi4vanMvc3JjL3RhYi5qcyIsIi4uLy4uL2pzL3NyYy90b2FzdC5qcyIsIi4uLy4uL2pzL3NyYy9pbmRleC5qcyIsInlpaS5qcyIsInlpaS52YWxpZGF0aW9uLmpzIiwieWlpLmFjdGl2ZUZvcm0uanMiLCJhdXRoY2hvaWNlLmpzIiwianF1ZXJ5Lm11bHRpcGxlSW5wdXQuanMiLCJzaW1wbGViYXIuanMiLCJkcmFnc2Nyb2xsLmpzIiwidG9hc3RyLmpzIiwiYm9vdGJveC5qcyIsImNyb3BwaWUuanMiLCJGaWxlQVBJLmpzIiwiY2FsbGJhY2tzLmpzIiwianF1ZXJ5LWlhcy5qcyIsImhpc3RvcnkuanMiLCJub25lbGVmdC5qcyIsInBhZ2luZy5qcyIsInNwaW5uZXIuanMiLCJ0cmlnZ2VyLmpzIiwianF1ZXJ5LmZhbmN5Ym94LmpzIiwiMS5nbG9iYWwuanMiLCJjb21tdW5pdHkuanMiLCJjb252ZXJzYXRpb24uanMiLCJnYW1lc2ZpbHRlci5qcyIsImxvYmJ5LmpzIiwibG9jYXRpb24uanMiLCJub3RpZmljYXRpb24uanMiLCJzZXJ2ZXIuanMiLCJzcXVhZC5qcyIsInRlYW0uanMiLCJ0b3VybmFtZW50LmpzIiwidXNlci1zZXR0aW5ncy5qcyJdLCJuYW1lcyI6WyJUUkFOU0lUSU9OX0VORCIsIk1BWF9VSUQiLCJNSUxMSVNFQ09ORFNfTVVMVElQTElFUiIsInRvVHlwZSIsIm9iaiIsInRvU3RyaW5nIiwiY2FsbCIsIm1hdGNoIiwidG9Mb3dlckNhc2UiLCJnZXRTcGVjaWFsVHJhbnNpdGlvbkVuZEV2ZW50IiwiYmluZFR5cGUiLCJkZWxlZ2F0ZVR5cGUiLCJoYW5kbGUiLCJldmVudCIsIiQiLCJ0YXJnZXQiLCJpcyIsImhhbmRsZU9iaiIsImhhbmRsZXIiLCJhcHBseSIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsInRyYW5zaXRpb25FbmRFbXVsYXRvciIsImR1cmF0aW9uIiwiY2FsbGVkIiwib25lIiwiVXRpbCIsInNldFRpbWVvdXQiLCJ0cmlnZ2VyVHJhbnNpdGlvbkVuZCIsInNldFRyYW5zaXRpb25FbmRTdXBwb3J0IiwiZm4iLCJlbXVsYXRlVHJhbnNpdGlvbkVuZCIsInNwZWNpYWwiLCJnZXRVSUQiLCJwcmVmaXgiLCJNYXRoIiwicmFuZG9tIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImdldFNlbGVjdG9yRnJvbUVsZW1lbnQiLCJlbGVtZW50Iiwic2VsZWN0b3IiLCJnZXRBdHRyaWJ1dGUiLCJocmVmQXR0ciIsInRyaW0iLCJxdWVyeVNlbGVjdG9yIiwiZXJyIiwiZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJjc3MiLCJ0cmFuc2l0aW9uRGVsYXkiLCJmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiIsInBhcnNlRmxvYXQiLCJmbG9hdFRyYW5zaXRpb25EZWxheSIsInNwbGl0IiwicmVmbG93Iiwib2Zmc2V0SGVpZ2h0IiwidHJpZ2dlciIsInN1cHBvcnRzVHJhbnNpdGlvbkVuZCIsIkJvb2xlYW4iLCJpc0VsZW1lbnQiLCJub2RlVHlwZSIsInR5cGVDaGVja0NvbmZpZyIsImNvbXBvbmVudE5hbWUiLCJjb25maWciLCJjb25maWdUeXBlcyIsInByb3BlcnR5IiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJleHBlY3RlZFR5cGVzIiwidmFsdWUiLCJ2YWx1ZVR5cGUiLCJSZWdFeHAiLCJ0ZXN0IiwiRXJyb3IiLCJ0b1VwcGVyQ2FzZSIsImZpbmRTaGFkb3dSb290IiwiZG9jdW1lbnRFbGVtZW50IiwiYXR0YWNoU2hhZG93IiwiZ2V0Um9vdE5vZGUiLCJyb290IiwiU2hhZG93Um9vdCIsInBhcmVudE5vZGUiLCJOQU1FIiwiVkVSU0lPTiIsIkRBVEFfS0VZIiwiRVZFTlRfS0VZIiwiREFUQV9BUElfS0VZIiwiSlFVRVJZX05PX0NPTkZMSUNUIiwiU2VsZWN0b3IiLCJESVNNSVNTIiwiRXZlbnQiLCJDTE9TRSIsIkNMT1NFRCIsIkNMSUNLX0RBVEFfQVBJIiwiQ2xhc3NOYW1lIiwiQUxFUlQiLCJGQURFIiwiU0hPVyIsIkFsZXJ0IiwiX2VsZW1lbnQiLCJjbG9zZSIsInJvb3RFbGVtZW50IiwiX2dldFJvb3RFbGVtZW50IiwiY3VzdG9tRXZlbnQiLCJfdHJpZ2dlckNsb3NlRXZlbnQiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJfcmVtb3ZlRWxlbWVudCIsImRpc3Bvc2UiLCJyZW1vdmVEYXRhIiwicGFyZW50IiwiY2xvc2VzdCIsImNsb3NlRXZlbnQiLCJyZW1vdmVDbGFzcyIsImhhc0NsYXNzIiwiX2Rlc3Ryb3lFbGVtZW50IiwiZGV0YWNoIiwicmVtb3ZlIiwiX2pRdWVyeUludGVyZmFjZSIsImVhY2giLCIkZWxlbWVudCIsImRhdGEiLCJfaGFuZGxlRGlzbWlzcyIsImFsZXJ0SW5zdGFuY2UiLCJwcmV2ZW50RGVmYXVsdCIsIm9uIiwiQ29uc3RydWN0b3IiLCJub0NvbmZsaWN0IiwiQUNUSVZFIiwiQlVUVE9OIiwiRk9DVVMiLCJEQVRBX1RPR0dMRV9DQVJST1QiLCJEQVRBX1RPR0dMRSIsIklOUFVUIiwiRk9DVVNfQkxVUl9EQVRBX0FQSSIsIkJ1dHRvbiIsInRvZ2dsZSIsInRyaWdnZXJDaGFuZ2VFdmVudCIsImFkZEFyaWFQcmVzc2VkIiwiaW5wdXQiLCJ0eXBlIiwiY2hlY2tlZCIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwiYWN0aXZlRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsImZvY3VzIiwic2V0QXR0cmlidXRlIiwidG9nZ2xlQ2xhc3MiLCJidXR0b24iLCJBUlJPV19MRUZUX0tFWUNPREUiLCJBUlJPV19SSUdIVF9LRVlDT0RFIiwiVE9VQ0hFVkVOVF9DT01QQVRfV0FJVCIsIlNXSVBFX1RIUkVTSE9MRCIsIkRlZmF1bHQiLCJpbnRlcnZhbCIsImtleWJvYXJkIiwic2xpZGUiLCJwYXVzZSIsIndyYXAiLCJ0b3VjaCIsIkRlZmF1bHRUeXBlIiwiRGlyZWN0aW9uIiwiTkVYVCIsIlBSRVYiLCJMRUZUIiwiUklHSFQiLCJTTElERSIsIlNMSUQiLCJLRVlET1dOIiwiTU9VU0VFTlRFUiIsIk1PVVNFTEVBVkUiLCJUT1VDSFNUQVJUIiwiVE9VQ0hNT1ZFIiwiVE9VQ0hFTkQiLCJQT0lOVEVSRE9XTiIsIlBPSU5URVJVUCIsIkRSQUdfU1RBUlQiLCJMT0FEX0RBVEFfQVBJIiwiQ0FST1VTRUwiLCJJVEVNIiwiUE9JTlRFUl9FVkVOVCIsIkFDVElWRV9JVEVNIiwiSVRFTV9JTUciLCJORVhUX1BSRVYiLCJJTkRJQ0FUT1JTIiwiREFUQV9TTElERSIsIkRBVEFfUklERSIsIlBvaW50ZXJUeXBlIiwiVE9VQ0giLCJQRU4iLCJDYXJvdXNlbCIsIl9pdGVtcyIsIl9pbnRlcnZhbCIsIl9hY3RpdmVFbGVtZW50IiwiX2lzUGF1c2VkIiwiX2lzU2xpZGluZyIsInRvdWNoVGltZW91dCIsInRvdWNoU3RhcnRYIiwidG91Y2hEZWx0YVgiLCJfY29uZmlnIiwiX2dldENvbmZpZyIsIl9pbmRpY2F0b3JzRWxlbWVudCIsIl90b3VjaFN1cHBvcnRlZCIsIm5hdmlnYXRvciIsIm1heFRvdWNoUG9pbnRzIiwiX3BvaW50ZXJFdmVudCIsIndpbmRvdyIsIlBvaW50ZXJFdmVudCIsIk1TUG9pbnRlckV2ZW50IiwiX2FkZEV2ZW50TGlzdGVuZXJzIiwibmV4dCIsIl9zbGlkZSIsIm5leHRXaGVuVmlzaWJsZSIsImhpZGRlbiIsInByZXYiLCJjeWNsZSIsImNsZWFySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInZpc2liaWxpdHlTdGF0ZSIsImJpbmQiLCJ0byIsImluZGV4IiwiYWN0aXZlSW5kZXgiLCJfZ2V0SXRlbUluZGV4IiwibGVuZ3RoIiwiZGlyZWN0aW9uIiwib2ZmIiwiX2hhbmRsZVN3aXBlIiwiYWJzRGVsdGF4IiwiYWJzIiwiX2tleWRvd24iLCJfYWRkVG91Y2hFdmVudExpc3RlbmVycyIsInN0YXJ0Iiwib3JpZ2luYWxFdmVudCIsInBvaW50ZXJUeXBlIiwiY2xpZW50WCIsInRvdWNoZXMiLCJtb3ZlIiwiZW5kIiwiY2xlYXJUaW1lb3V0IiwicXVlcnlTZWxlY3RvckFsbCIsImUiLCJhZGQiLCJ0YWdOYW1lIiwid2hpY2giLCJzbGljZSIsImluZGV4T2YiLCJfZ2V0SXRlbUJ5RGlyZWN0aW9uIiwiaXNOZXh0RGlyZWN0aW9uIiwiaXNQcmV2RGlyZWN0aW9uIiwibGFzdEl0ZW1JbmRleCIsImlzR29pbmdUb1dyYXAiLCJkZWx0YSIsIml0ZW1JbmRleCIsIl90cmlnZ2VyU2xpZGVFdmVudCIsInJlbGF0ZWRUYXJnZXQiLCJldmVudERpcmVjdGlvbk5hbWUiLCJ0YXJnZXRJbmRleCIsImZyb21JbmRleCIsInNsaWRlRXZlbnQiLCJmcm9tIiwiX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQiLCJpbmRpY2F0b3JzIiwibmV4dEluZGljYXRvciIsImNoaWxkcmVuIiwiYWRkQ2xhc3MiLCJhY3RpdmVFbGVtZW50SW5kZXgiLCJuZXh0RWxlbWVudCIsIm5leHRFbGVtZW50SW5kZXgiLCJpc0N5Y2xpbmciLCJkaXJlY3Rpb25hbENsYXNzTmFtZSIsIm9yZGVyQ2xhc3NOYW1lIiwic2xpZEV2ZW50IiwibmV4dEVsZW1lbnRJbnRlcnZhbCIsInBhcnNlSW50IiwiZGVmYXVsdEludGVydmFsIiwiYWN0aW9uIiwiVHlwZUVycm9yIiwicmlkZSIsIl9kYXRhQXBpQ2xpY2tIYW5kbGVyIiwic2xpZGVJbmRleCIsImNhcm91c2VscyIsImkiLCJsZW4iLCIkY2Fyb3VzZWwiLCJTSE9XTiIsIkhJREUiLCJISURERU4iLCJDT0xMQVBTRSIsIkNPTExBUFNJTkciLCJDT0xMQVBTRUQiLCJEaW1lbnNpb24iLCJXSURUSCIsIkhFSUdIVCIsIkFDVElWRVMiLCJDb2xsYXBzZSIsIl9pc1RyYW5zaXRpb25pbmciLCJfdHJpZ2dlckFycmF5IiwiaWQiLCJ0b2dnbGVMaXN0IiwiZWxlbSIsImZpbHRlckVsZW1lbnQiLCJmaWx0ZXIiLCJmb3VuZEVsZW0iLCJfc2VsZWN0b3IiLCJwdXNoIiwiX3BhcmVudCIsIl9nZXRQYXJlbnQiLCJfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzIiwiaGlkZSIsInNob3ciLCJhY3RpdmVzIiwiYWN0aXZlc0RhdGEiLCJub3QiLCJzdGFydEV2ZW50IiwiZGltZW5zaW9uIiwiX2dldERpbWVuc2lvbiIsInN0eWxlIiwiYXR0ciIsInNldFRyYW5zaXRpb25pbmciLCJjb21wbGV0ZSIsImNhcGl0YWxpemVkRGltZW5zaW9uIiwic2Nyb2xsU2l6ZSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInRyaWdnZXJBcnJheUxlbmd0aCIsIiRlbGVtIiwiaXNUcmFuc2l0aW9uaW5nIiwiaGFzV2lkdGgiLCJqcXVlcnkiLCJfZ2V0VGFyZ2V0RnJvbUVsZW1lbnQiLCJ0cmlnZ2VyQXJyYXkiLCJpc09wZW4iLCIkdGhpcyIsImN1cnJlbnRUYXJnZXQiLCIkdHJpZ2dlciIsInNlbGVjdG9ycyIsIiR0YXJnZXQiLCJFU0NBUEVfS0VZQ09ERSIsIlNQQUNFX0tFWUNPREUiLCJUQUJfS0VZQ09ERSIsIkFSUk9XX1VQX0tFWUNPREUiLCJBUlJPV19ET1dOX0tFWUNPREUiLCJSSUdIVF9NT1VTRV9CVVRUT05fV0hJQ0giLCJSRUdFWFBfS0VZRE9XTiIsIkNMSUNLIiwiS0VZRE9XTl9EQVRBX0FQSSIsIktFWVVQX0RBVEFfQVBJIiwiRElTQUJMRUQiLCJEUk9QVVAiLCJEUk9QUklHSFQiLCJEUk9QTEVGVCIsIk1FTlVSSUdIVCIsIk1FTlVMRUZUIiwiUE9TSVRJT05fU1RBVElDIiwiRk9STV9DSElMRCIsIk1FTlUiLCJOQVZCQVJfTkFWIiwiVklTSUJMRV9JVEVNUyIsIkF0dGFjaG1lbnRNYXAiLCJUT1AiLCJUT1BFTkQiLCJCT1RUT00iLCJCT1RUT01FTkQiLCJSSUdIVEVORCIsIkxFRlRFTkQiLCJvZmZzZXQiLCJmbGlwIiwiYm91bmRhcnkiLCJyZWZlcmVuY2UiLCJkaXNwbGF5IiwiRHJvcGRvd24iLCJfcG9wcGVyIiwiX21lbnUiLCJfZ2V0TWVudUVsZW1lbnQiLCJfaW5OYXZiYXIiLCJfZGV0ZWN0TmF2YmFyIiwiZGlzYWJsZWQiLCJfZ2V0UGFyZW50RnJvbUVsZW1lbnQiLCJpc0FjdGl2ZSIsIl9jbGVhck1lbnVzIiwic2hvd0V2ZW50IiwiUG9wcGVyIiwicmVmZXJlbmNlRWxlbWVudCIsIl9nZXRQb3BwZXJDb25maWciLCJib2R5Iiwibm9vcCIsImhpZGVFdmVudCIsImRlc3Ryb3kiLCJ1cGRhdGUiLCJzY2hlZHVsZVVwZGF0ZSIsInN0b3BQcm9wYWdhdGlvbiIsImNvbnN0cnVjdG9yIiwiX2dldFBsYWNlbWVudCIsIiRwYXJlbnREcm9wZG93biIsInBsYWNlbWVudCIsIl9nZXRPZmZzZXQiLCJvZmZzZXRzIiwicG9wcGVyQ29uZmlnIiwibW9kaWZpZXJzIiwiZW5hYmxlZCIsInByZXZlbnRPdmVyZmxvdyIsImJvdW5kYXJpZXNFbGVtZW50IiwiYXBwbHlTdHlsZSIsInRvZ2dsZXMiLCJjb250ZXh0IiwiY2xpY2tFdmVudCIsImRyb3Bkb3duTWVudSIsIl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIiLCJpdGVtcyIsImJhY2tkcm9wIiwiRk9DVVNJTiIsIlJFU0laRSIsIkNMSUNLX0RJU01JU1MiLCJLRVlET1dOX0RJU01JU1MiLCJNT1VTRVVQX0RJU01JU1MiLCJNT1VTRURPV05fRElTTUlTUyIsIlNDUk9MTEFCTEUiLCJTQ1JPTExCQVJfTUVBU1VSRVIiLCJCQUNLRFJPUCIsIk9QRU4iLCJESUFMT0ciLCJNT0RBTF9CT0RZIiwiREFUQV9ESVNNSVNTIiwiRklYRURfQ09OVEVOVCIsIlNUSUNLWV9DT05URU5UIiwiTW9kYWwiLCJfZGlhbG9nIiwiX2JhY2tkcm9wIiwiX2lzU2hvd24iLCJfaXNCb2R5T3ZlcmZsb3dpbmciLCJfaWdub3JlQmFja2Ryb3BDbGljayIsIl9zY3JvbGxiYXJXaWR0aCIsIl9jaGVja1Njcm9sbGJhciIsIl9zZXRTY3JvbGxiYXIiLCJfYWRqdXN0RGlhbG9nIiwiX3NldEVzY2FwZUV2ZW50IiwiX3NldFJlc2l6ZUV2ZW50IiwiX3Nob3dCYWNrZHJvcCIsIl9zaG93RWxlbWVudCIsInRyYW5zaXRpb24iLCJfaGlkZU1vZGFsIiwiZm9yRWFjaCIsImh0bWxFbGVtZW50IiwiaGFuZGxlVXBkYXRlIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsImFwcGVuZENoaWxkIiwicmVtb3ZlQXR0cmlidXRlIiwic2Nyb2xsVG9wIiwiX2VuZm9yY2VGb2N1cyIsInNob3duRXZlbnQiLCJ0cmFuc2l0aW9uQ29tcGxldGUiLCJoYXMiLCJfcmVzZXRBZGp1c3RtZW50cyIsIl9yZXNldFNjcm9sbGJhciIsIl9yZW1vdmVCYWNrZHJvcCIsImNhbGxiYWNrIiwiYW5pbWF0ZSIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJhcHBlbmRUbyIsImJhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uIiwiY2FsbGJhY2tSZW1vdmUiLCJpc01vZGFsT3ZlcmZsb3dpbmciLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsInJlY3QiLCJsZWZ0IiwicmlnaHQiLCJpbm5lcldpZHRoIiwiX2dldFNjcm9sbGJhcldpZHRoIiwiZml4ZWRDb250ZW50Iiwic3RpY2t5Q29udGVudCIsImFjdHVhbFBhZGRpbmciLCJjYWxjdWxhdGVkUGFkZGluZyIsImFjdHVhbE1hcmdpbiIsIm1hcmdpblJpZ2h0IiwiY2FsY3VsYXRlZE1hcmdpbiIsInBhZGRpbmciLCJlbGVtZW50cyIsIm1hcmdpbiIsInNjcm9sbERpdiIsInNjcm9sbGJhcldpZHRoIiwid2lkdGgiLCJjbGllbnRXaWR0aCIsInJlbW92ZUNoaWxkIiwidXJpQXR0cnMiLCJBUklBX0FUVFJJQlVURV9QQVRURVJOIiwiRGVmYXVsdFdoaXRlbGlzdCIsImEiLCJhcmVhIiwiYiIsImJyIiwiY29sIiwiY29kZSIsImRpdiIsImVtIiwiaHIiLCJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiLCJpbWciLCJsaSIsIm9sIiwicCIsInByZSIsInMiLCJzbWFsbCIsInNwYW4iLCJzdWIiLCJzdXAiLCJzdHJvbmciLCJ1IiwidWwiLCJTQUZFX1VSTF9QQVRURVJOIiwiREFUQV9VUkxfUEFUVEVSTiIsImFsbG93ZWRBdHRyaWJ1dGUiLCJhbGxvd2VkQXR0cmlidXRlTGlzdCIsImF0dHJOYW1lIiwibm9kZU5hbWUiLCJub2RlVmFsdWUiLCJyZWdFeHAiLCJhdHRyUmVnZXgiLCJsIiwic2FuaXRpemVIdG1sIiwidW5zYWZlSHRtbCIsIndoaXRlTGlzdCIsInNhbml0aXplRm4iLCJkb21QYXJzZXIiLCJET01QYXJzZXIiLCJjcmVhdGVkRG9jdW1lbnQiLCJwYXJzZUZyb21TdHJpbmciLCJ3aGl0ZWxpc3RLZXlzIiwia2V5cyIsImVsIiwiZWxOYW1lIiwiYXR0cmlidXRlTGlzdCIsImF0dHJpYnV0ZXMiLCJ3aGl0ZWxpc3RlZEF0dHJpYnV0ZXMiLCJjb25jYXQiLCJpbm5lckhUTUwiLCJDTEFTU19QUkVGSVgiLCJCU0NMU19QUkVGSVhfUkVHRVgiLCJESVNBTExPV0VEX0FUVFJJQlVURVMiLCJhbmltYXRpb24iLCJ0ZW1wbGF0ZSIsInRpdGxlIiwiZGVsYXkiLCJodG1sIiwiY29udGFpbmVyIiwiZmFsbGJhY2tQbGFjZW1lbnQiLCJzYW5pdGl6ZSIsIkFVVE8iLCJIb3ZlclN0YXRlIiwiT1VUIiwiSU5TRVJURUQiLCJGT0NVU09VVCIsIlRPT0xUSVAiLCJUT09MVElQX0lOTkVSIiwiQVJST1ciLCJUcmlnZ2VyIiwiSE9WRVIiLCJNQU5VQUwiLCJUb29sdGlwIiwiX2lzRW5hYmxlZCIsIl90aW1lb3V0IiwiX2hvdmVyU3RhdGUiLCJfYWN0aXZlVHJpZ2dlciIsInRpcCIsIl9zZXRMaXN0ZW5lcnMiLCJlbmFibGUiLCJkaXNhYmxlIiwidG9nZ2xlRW5hYmxlZCIsImRhdGFLZXkiLCJfZ2V0RGVsZWdhdGVDb25maWciLCJjbGljayIsIl9pc1dpdGhBY3RpdmVUcmlnZ2VyIiwiX2VudGVyIiwiX2xlYXZlIiwiZ2V0VGlwRWxlbWVudCIsImlzV2l0aENvbnRlbnQiLCJzaGFkb3dSb290IiwiaXNJblRoZURvbSIsIm93bmVyRG9jdW1lbnQiLCJ0aXBJZCIsInNldENvbnRlbnQiLCJhdHRhY2htZW50IiwiX2dldEF0dGFjaG1lbnQiLCJhZGRBdHRhY2htZW50Q2xhc3MiLCJfZ2V0Q29udGFpbmVyIiwiYmVoYXZpb3IiLCJhcnJvdyIsIm9uQ3JlYXRlIiwib3JpZ2luYWxQbGFjZW1lbnQiLCJfaGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlIiwib25VcGRhdGUiLCJfZml4VHJhbnNpdGlvbiIsInByZXZIb3ZlclN0YXRlIiwiX2NsZWFuVGlwQ2xhc3MiLCJnZXRUaXRsZSIsInNldEVsZW1lbnRDb250ZW50IiwiY29udGVudCIsImVtcHR5IiwiYXBwZW5kIiwidGV4dCIsImZpbmQiLCJ0cmlnZ2VycyIsImV2ZW50SW4iLCJldmVudE91dCIsIl9maXhUaXRsZSIsInRpdGxlVHlwZSIsImRhdGFBdHRyaWJ1dGVzIiwiZGF0YUF0dHIiLCJrZXkiLCIkdGlwIiwidGFiQ2xhc3MiLCJqb2luIiwicG9wcGVyRGF0YSIsInBvcHBlckluc3RhbmNlIiwiaW5zdGFuY2UiLCJwb3BwZXIiLCJpbml0Q29uZmlnQW5pbWF0aW9uIiwiVElUTEUiLCJDT05URU5UIiwiUG9wb3ZlciIsIl9nZXRDb250ZW50IiwibWV0aG9kIiwiQUNUSVZBVEUiLCJTQ1JPTEwiLCJEUk9QRE9XTl9JVEVNIiwiRFJPUERPV05fTUVOVSIsIkRBVEFfU1BZIiwiTkFWX0xJU1RfR1JPVVAiLCJOQVZfTElOS1MiLCJOQVZfSVRFTVMiLCJMSVNUX0lURU1TIiwiRFJPUERPV04iLCJEUk9QRE9XTl9JVEVNUyIsIkRST1BET1dOX1RPR0dMRSIsIk9mZnNldE1ldGhvZCIsIk9GRlNFVCIsIlBPU0lUSU9OIiwiU2Nyb2xsU3B5IiwiX3Njcm9sbEVsZW1lbnQiLCJfb2Zmc2V0cyIsIl90YXJnZXRzIiwiX2FjdGl2ZVRhcmdldCIsIl9zY3JvbGxIZWlnaHQiLCJfcHJvY2VzcyIsInJlZnJlc2giLCJhdXRvTWV0aG9kIiwib2Zmc2V0TWV0aG9kIiwib2Zmc2V0QmFzZSIsIl9nZXRTY3JvbGxUb3AiLCJfZ2V0U2Nyb2xsSGVpZ2h0IiwidGFyZ2V0cyIsIm1hcCIsInRhcmdldFNlbGVjdG9yIiwidGFyZ2V0QkNSIiwiaGVpZ2h0IiwidG9wIiwiaXRlbSIsInNvcnQiLCJwYWdlWU9mZnNldCIsIm1heCIsIl9nZXRPZmZzZXRIZWlnaHQiLCJpbm5lckhlaWdodCIsIm1heFNjcm9sbCIsIl9hY3RpdmF0ZSIsIl9jbGVhciIsIm9mZnNldExlbmd0aCIsImlzQWN0aXZlVGFyZ2V0IiwicXVlcmllcyIsIiRsaW5rIiwicGFyZW50cyIsIm5vZGUiLCJzY3JvbGxTcHlzIiwic2Nyb2xsU3B5c0xlbmd0aCIsIiRzcHkiLCJBQ1RJVkVfVUwiLCJEUk9QRE9XTl9BQ1RJVkVfQ0hJTEQiLCJUYWIiLCJwcmV2aW91cyIsImxpc3RFbGVtZW50IiwiaXRlbVNlbGVjdG9yIiwibWFrZUFycmF5IiwiaGlkZGVuRXZlbnQiLCJhY3RpdmVFbGVtZW50cyIsImFjdGl2ZSIsIl90cmFuc2l0aW9uQ29tcGxldGUiLCJkcm9wZG93bkNoaWxkIiwiZHJvcGRvd25FbGVtZW50IiwiZHJvcGRvd25Ub2dnbGVMaXN0IiwiU0hPV0lORyIsImF1dG9oaWRlIiwiVG9hc3QiLCJ3aXRob3V0VGltZW91dCIsIl9jbG9zZSIsInZlcnNpb24iLCJtaW5NYWpvciIsImx0TWFqb3IiLCJtaW5NaW5vciIsIm1pblBhdGNoIiwibWF4TWFqb3IiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3QyVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Rzs7RUFFSDtFQUNBO0VBQ0EsRUFBRSxJQUFJLFVBQVUsR0FBRyxhQUFhLENBQUM7RUFDakMsRUFBRSxJQUFJLEdBQUcsR0FBRyxPQUFPLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7O0VBRTNNO0VBQ0EsRUFBRSxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsRUFBRSxLQUFLLEVBQUU7RUFDckM7RUFDQSxJQUFJLElBQUksV0FBVyxHQUFHLENBQUMsS0FBSyxLQUFLLENBQUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxTQUFTLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQztFQUNsRixJQUFJLElBQUksaUJBQWlCLEdBQUcsS0FBSyxDQUFDO0VBQ2xDLElBQUksT0FBTyxFQUFFO0VBQ2I7RUFDQTtFQUNBLEtBQUssTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRTtFQUM1QixNQUFNLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtFQUNsRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztFQUM1QixR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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQy9jQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2g1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ1hBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6OUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVpREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2x6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL3FCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQy8vS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FyQjNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QXNCNWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuNC4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxOS0wNS0wMVQyMTowNFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG4gIH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vbmNlOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgbm9kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLCB2YWwsXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDY0KywgRWRnZSAxOCtcblx0XHRcdFx0Ly8gU29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBcIm5vbmNlXCIgcHJvcGVydHkgb24gc2NyaXB0cy5cblx0XHRcdFx0Ly8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xuXHRcdFx0XHQvLyB0aGUgYG5vbmNlYCBhdHRyaWJ1dGUgaXMgcmVzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHdoZW5ldmVyIGl0XG5cdFx0XHRcdC8vIGJlY29tZXMgYnJvd3NpbmctY29udGV4dCBjb25uZWN0ZWQuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI25vbmNlLWF0dHJpYnV0ZXNcblx0XHRcdFx0Ly8gVGhlIGBub2RlLmdldEF0dHJpYnV0ZWAgY2hlY2sgd2FzIGFkZGVkIGZvciB0aGUgc2FrZSBvZlxuXHRcdFx0XHQvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcblx0XHRcdFx0Ly8gdmlhIGFuIG9iamVjdC5cblx0XHRcdFx0dmFsID0gbm9kZVsgaSBdIHx8IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCBpICk7XG5cdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoIGksIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy40LjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0ge307XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlLCBvcHRpb25zICkge1xuXHRcdERPTUV2YWwoIGNvZGUsIHsgbm9uY2U6IG9wdGlvbnMgJiYgb3B0aW9ucy5ub25jZSB9ICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjRcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xuICpcbiAqIERhdGU6IDIwMTktMDQtMDhcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJkZXNjZW5kID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwifD5cIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJodG1sID0gL0hUTUwkL2ksXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0aW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWVsZHNldFwiO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDggb25seVxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHQobm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiKSApIHtcblxuXHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblxuXHRcdFx0XHQvLyBxU0EgY29uc2lkZXJzIGVsZW1lbnRzIG91dHNpZGUgYSBzY29waW5nIHJvb3Qgd2hlbiBldmFsdWF0aW5nIGNoaWxkIG9yXG5cdFx0XHRcdC8vIGRlc2NlbmRhbnQgY29tYmluYXRvcnMsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuXG5cdFx0XHRcdC8vIEluIHN1Y2ggY2FzZXMsIHdlIHdvcmsgYXJvdW5kIHRoZSBiZWhhdmlvciBieSBwcmVmaXhpbmcgZXZlcnkgc2VsZWN0b3IgaW4gdGhlXG5cdFx0XHRcdC8vIGxpc3Qgd2l0aCBhbiBJRCBzZWxlY3RvciByZWZlcmVuY2luZyB0aGUgc2NvcGUgY29udGV4dC5cblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgdGVjaG5pcXVlLlxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSAxICYmIHJkZXNjZW5kLnRlc3QoIHNlbGVjdG9yICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRpbkRpc2FibGVkRmllbGRzZXQoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbmFtZXNwYWNlID0gZWxlbS5uYW1lc3BhY2VVUkksXG5cdFx0ZG9jRWxlbSA9IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHQvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGUgbG9hZGluZyBpZnJhbWVzXG5cdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC80ODMzXG5cdHJldHVybiAhcmh0bWwudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIGV4cHIsIHRydWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/XG5cdFx0XHRcdGFyZ3VtZW50ICsgbGVuZ3RoIDpcblx0XHRcdFx0YXJndW1lbnQgPiBsZW5ndGggP1xuXHRcdFx0XHRcdGxlbmd0aCA6XG5cdFx0XHRcdFx0YXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmNvbnRlbnREb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0XHQvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0XHQvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHRcdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBhbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cblx0dmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHRcdH0sXG5cdFx0Y29tcG9zZWQgPSB7IGNvbXBvc2VkOiB0cnVlIH07XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcblx0Ly8gQ2hlY2sgYXR0YWNobWVudCBhY3Jvc3Mgc2hhZG93IERPTSBib3VuZGFyaWVzIHdoZW4gcG9zc2libGUgKGdoLTM1MDQpXG5cdC8vIFN1cHBvcnQ6IGlPUyAxMC4wLTEwLjIgb25seVxuXHQvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXG5cdC8vIGxlYWRpbmcgdG8gZXJyb3JzLiBXZSBuZWVkIHRvIGNoZWNrIGZvciBgZ2V0Um9vdE5vZGVgLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSApIHtcblx0XHRpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSB8fFxuXHRcdFx0XHRlbGVtLmdldFJvb3ROb2RlKCBjb21wb3NlZCApID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0fTtcblx0fVxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGlzQXR0YWNoZWQoIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmXG5cdFx0XHQoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0YXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGF0dGFjaGVkICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4vLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91cywgZXhjZXB0IHdoZW4gdGhleSBhcmUgbm8tb3AuXG4vLyBTbyBleHBlY3QgZm9jdXMgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGFjdGl2ZSxcbi8vIGFuZCBibHVyIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90IGFscmVhZHkgYWN0aXZlLlxuLy8gKGZvY3VzIGFuZCBibHVyIGFyZSBhbHdheXMgc3luY2hyb25vdXMgaW4gb3RoZXIgc3VwcG9ydGVkIGJyb3dzZXJzLFxuLy8gdGhpcyBqdXN0IGRlZmluZXMgd2hlbiB3ZSBjYW4gY291bnQgb24gaXQpLlxuZnVuY3Rpb24gZXhwZWN0U3luYyggZWxlbSwgdHlwZSApIHtcblx0cmV0dXJuICggZWxlbSA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSApID09PSAoIHR5cGUgPT09IFwiZm9jdXNcIiApO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZSBldmVudCBpcyBuYW1lc3BhY2VkLCB0aGVuIGVhY2ggaGFuZGxlciBpcyBvbmx5IGludm9rZWQgaWYgaXQgaXNcblx0XHRcdFx0Ly8gc3BlY2lhbGx5IHVuaXZlcnNhbCBvciBpdHMgbmFtZXNwYWNlcyBhcmUgYSBzdXBlcnNldCBvZiB0aGUgZXZlbnQncy5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBoYW5kbGVPYmoubmFtZXNwYWNlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCByZXR1cm5UcnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0Ly8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRyZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuXHRcdFx0XHRcdHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGFyZ2V0LCBcImNsaWNrXCIgKSB8fFxuXHRcdFx0XHRcdG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoIGVsLCB0eXBlLCBleHBlY3RTeW5jICkge1xuXG5cdC8vIE1pc3NpbmcgZXhwZWN0U3luYyBpbmRpY2F0ZXMgYSB0cmlnZ2VyIGNhbGwsIHdoaWNoIG11c3QgZm9yY2Ugc2V0dXAgdGhyb3VnaCBqUXVlcnkuZXZlbnQuYWRkXG5cdGlmICggIWV4cGVjdFN5bmMgKSB7XG5cdFx0aWYgKCBkYXRhUHJpdi5nZXQoIGVsLCB0eXBlICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCByZXR1cm5UcnVlICk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcblx0ZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcblx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHtcblx0XHRuYW1lc3BhY2U6IGZhbHNlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBub3RBc3luYywgcmVzdWx0LFxuXHRcdFx0XHRzYXZlZCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuXHRcdFx0XHQvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuXHRcdFx0XHQvLyBTYXZlZCBkYXRhIHNob3VsZCBiZSBmYWxzZSBpbiBzdWNoIGNhc2VzLCBidXQgbWlnaHQgYmUgYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdFxuXHRcdFx0XHQvLyBmcm9tIGFuIGFzeW5jIG5hdGl2ZSBoYW5kbGVyIChnaC00MzUwKVxuXHRcdFx0XHRpZiAoICFzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG5cdFx0XHRcdFx0c2F2ZWQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXG5cdFx0XHRcdFx0bm90QXN5bmMgPSBleHBlY3RTeW5jKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0dGhpc1sgdHlwZSBdKCk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jICkge1xuXHRcdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcblx0XHRcdFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmcgdGhlXG5cdFx0XHRcdC8vIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG5cdFx0XHRcdC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG5cdFx0XHRcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcblx0XHRcdFx0Ly8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblx0XHRcdFx0fSBlbHNlIGlmICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9ICkuZGVsZWdhdGVUeXBlICkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuXHRcdFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGNhcHR1cmUgdGhlIHJlc3VsdFxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHtcblx0XHRcdFx0XHR2YWx1ZTogalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdFx0Ly8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcblx0XHRcdFx0XHRcdGpRdWVyeS5leHRlbmQoIHNhdmVkWyAwIF0sIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgKSxcblx0XHRcdFx0XHRcdHNhdmVkLnNsaWNlKCAxICksXG5cdFx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjb2RlOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbmpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCB0eXBlLCBkZWxlZ2F0ZVR5cGUgKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gPSB7XG5cblx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiZm9jdXNcIiwgLi4uIClcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgZXhwZWN0U3luYyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSApO1xuXG5cdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0ZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGVcblx0fTtcbn0gKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYywge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG5cdFx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBub2RlLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGlzQXR0YWNoZWQoIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxuXHRcdC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXYub2Zmc2V0V2lkdGggLyAzICkgPT09IDEyO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhaXNBdHRhY2hlZCggZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXIgY3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlLFxuXHR2ZW5kb3JQcm9wcyA9IHt9O1xuXG4vLyBSZXR1cm4gYSB2ZW5kb3ItcHJlZml4ZWQgcHJvcGVydHkgb3IgdW5kZWZpbmVkXG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcG90ZW50aWFsbHktbWFwcGVkIGpRdWVyeS5jc3NQcm9wcyBvciB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciBmaW5hbCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdIHx8IHZlbmRvclByb3BzWyBuYW1lIF07XG5cblx0aWYgKCBmaW5hbCApIHtcblx0XHRyZXR1cm4gZmluYWw7XG5cdH1cblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblx0cmV0dXJuIHZlbmRvclByb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cmN1c3RvbVByb3AgPSAvXi0tLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH07XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cblx0XHQvLyBJZiBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgdW5rbm93biwgdGhlbiB3ZSBjYW4ndCBkZXRlcm1pbmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlclxuXHRcdC8vIFVzZSBhbiBleHBsaWNpdCB6ZXJvIHRvIGF2b2lkIE5hTiAoZ2gtMzk2NClcblx0XHQpICkgfHwgMDtcblx0fVxuXG5cdHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuXHRcdC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuXHRcdGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG5cdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94LFxuXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cblx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEgb25seVxuXHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlXG5cdC8vIFdlIHVzZSBnZXRDbGllbnRSZWN0cygpIHRvIGNoZWNrIGZvciBoaWRkZW4vZGlzY29ubmVjdGVkLlxuXHQvLyBJbiB0aG9zZSBjYXNlcywgdGhlIGNvbXB1dGVkIHZhbHVlIGNhbiBiZSB0cnVzdGVkIHRvIGJlIGJvcmRlci1ib3hcblx0aWYgKCAoICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3ggfHxcblx0XHR2YWwgPT09IFwiYXV0b1wiIHx8XG5cdFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiaW5saW5lXCIgKSAmJlxuXHRcdGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHQvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG5cdFx0Ly8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuXHRcdC8vIHJldHJpZXZlZCB2YWx1ZSBhcyBhIGNvbnRlbnQgYm94IGRpbWVuc2lvbi5cblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuXHRcdGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcblx0XHRcdHZhbCA9IGVsZW1bIG9mZnNldFByb3AgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwiZ3JpZEFyZWFcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5cIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5FbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5TdGFydFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1wiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd0VuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1N0YXJ0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHQvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG5cdFx0XHQvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdFx0XHQvLyBPbmx5IHJlYWQgc3R5bGVzLnBvc2l0aW9uIGlmIHRoZSB0ZXN0IGhhcyBhIGNoYW5jZSB0byBmYWlsXG5cdFx0XHRcdC8vIHRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3cuXG5cdFx0XHRcdHNjcm9sbGJveFNpemVCdWdneSA9ICFzdXBwb3J0LnNjcm9sbGJveFNpemUoKSAmJlxuXHRcdFx0XHRcdHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuXG5cdFx0XHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTM5OTEpXG5cdFx0XHRcdGJveFNpemluZ05lZWRlZCA9IHNjcm9sbGJveFNpemVCdWdneSB8fCBleHRyYSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhID9cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdDA7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5ICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdIHx8XG5cdFx0XHRcdFx0dHdlZW4uZWxlbS5zdHlsZVsgZmluYWxQcm9wTmFtZSggdHdlZW4ucHJvcCApIF0gIT0gbnVsbCApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBEYXRlLm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0gRGF0ZS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0aWYgKCBhID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSA9XG5cdFx0XHRcdFx0XHRcdFx0XHQoIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSB8fCBbXSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5jb25jYXQoIG1hdGNoWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2guam9pbiggXCIsIFwiICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblxuXHRcdC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG5cdFx0Ly8gZGF0YUZpbHRlciBpcyBub3QgaW52b2tlZCBmb3IgZmFpbHVyZSByZXNwb25zZXMsIHNvIHVzaW5nIGl0IGluc3RlYWRcblx0XHQvLyBvZiB0aGUgZGVmYXVsdCBjb252ZXJ0ZXIgaXMga2x1ZGd5IGJ1dCBpdCB3b3Jrcy5cblx0XHRjb252ZXJ0ZXJzOiB7XG5cdFx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCkge31cblx0XHR9LFxuXHRcdGRhdGFGaWx0ZXI6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCByZXNwb25zZSwgb3B0aW9ucyApO1xuXHRcdH1cblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluIHx8IHMuc2NyaXB0QXR0cnMgKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKVxuXHRcdFx0XHRcdC5hdHRyKCBzLnNjcmlwdEF0dHJzIHx8IHt9IClcblx0XHRcdFx0XHQucHJvcCggeyBjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsIHNyYzogcy51cmwgfSApXG5cdFx0XHRcdFx0Lm9uKCBcImxvYWQgZXJyb3JcIiwgY2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdGNvbnRleHQgPSBmbjtcblx0XHRmbiA9IHRtcDtcblx0fVxuXG5cdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNpbXVsYXRlZCBiaW5kXG5cdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0fTtcblxuXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0cmV0dXJuIHByb3h5O1xufTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xufTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iLCIvKipcbiAqIHNpZnRlci5qc1xuICogQ29weXJpZ2h0IChjKSAyMDEzIEJyaWFuIFJlYXZpcyAmIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAYXV0aG9yIEJyaWFuIFJlYXZpcyA8YnJpYW5AdGhpcmRyb3V0ZS5jb20+XG4gKi9cblxuKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZSgnc2lmdGVyJywgZmFjdG9yeSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH0gZWxzZSB7XG5cdFx0cm9vdC5TaWZ0ZXIgPSBmYWN0b3J5KCk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG5cblx0LyoqXG5cdCAqIFRleHR1YWxseSBzZWFyY2hlcyBhcnJheXMgYW5kIGhhc2hlcyBvZiBvYmplY3RzXG5cdCAqIGJ5IHByb3BlcnR5IChvciBtdWx0aXBsZSBwcm9wZXJ0aWVzKS4gRGVzaWduZWRcblx0ICogc3BlY2lmaWNhbGx5IGZvciBhdXRvY29tcGxldGUuXG5cdCAqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge2FycmF5fG9iamVjdH0gaXRlbXNcblx0ICogQHBhcmFtIHtvYmplY3R9IGl0ZW1zXG5cdCAqL1xuXHR2YXIgU2lmdGVyID0gZnVuY3Rpb24oaXRlbXMsIHNldHRpbmdzKSB7XG5cdFx0dGhpcy5pdGVtcyA9IGl0ZW1zO1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7ZGlhY3JpdGljczogdHJ1ZX07XG5cdH07XG5cblx0LyoqXG5cdCAqIFNwbGl0cyBhIHNlYXJjaCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBpbmRpdmlkdWFsXG5cdCAqIHJlZ2V4cHMgdG8gYmUgdXNlZCB0byBtYXRjaCByZXN1bHRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlcblx0ICogQHJldHVybnMge2FycmF5fVxuXHQgKi9cblx0U2lmdGVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG5cdFx0cXVlcnkgPSB0cmltKFN0cmluZyhxdWVyeSB8fCAnJykudG9Mb3dlckNhc2UoKSk7XG5cdFx0aWYgKCFxdWVyeSB8fCAhcXVlcnkubGVuZ3RoKSByZXR1cm4gW107XG5cblx0XHR2YXIgaSwgbiwgcmVnZXgsIGxldHRlcjtcblx0XHR2YXIgdG9rZW5zID0gW107XG5cdFx0dmFyIHdvcmRzID0gcXVlcnkuc3BsaXQoLyArLyk7XG5cblx0XHRmb3IgKGkgPSAwLCBuID0gd29yZHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRyZWdleCA9IGVzY2FwZV9yZWdleCh3b3Jkc1tpXSk7XG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5kaWFjcml0aWNzKSB7XG5cdFx0XHRcdGZvciAobGV0dGVyIGluIERJQUNSSVRJQ1MpIHtcblx0XHRcdFx0XHRpZiAoRElBQ1JJVElDUy5oYXNPd25Qcm9wZXJ0eShsZXR0ZXIpKSB7XG5cdFx0XHRcdFx0XHRyZWdleCA9IHJlZ2V4LnJlcGxhY2UobmV3IFJlZ0V4cChsZXR0ZXIsICdnJyksIERJQUNSSVRJQ1NbbGV0dGVyXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHN0cmluZyA6IHdvcmRzW2ldLFxuXHRcdFx0XHRyZWdleCAgOiBuZXcgUmVnRXhwKHJlZ2V4LCAnaScpXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdG9rZW5zO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJdGVyYXRlcyBvdmVyIGFycmF5cyBhbmQgaGFzaGVzLlxuXHQgKlxuXHQgKiBgYGBcblx0ICogdGhpcy5pdGVyYXRvcih0aGlzLml0ZW1zLCBmdW5jdGlvbihpdGVtLCBpZCkge1xuXHQgKiAgICAvLyBpbnZva2VkIGZvciBlYWNoIGl0ZW1cblx0ICogfSk7XG5cdCAqIGBgYFxuXHQgKlxuXHQgKiBAcGFyYW0ge2FycmF5fG9iamVjdH0gb2JqZWN0XG5cdCAqL1xuXHRTaWZ0ZXIucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuXHRcdHZhciBpdGVyYXRvcjtcblx0XHRpZiAoaXNfYXJyYXkob2JqZWN0KSkge1xuXHRcdFx0aXRlcmF0b3IgPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCB8fCBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sodGhpc1tpXSwgaSwgdGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGl0ZXJhdG9yID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHRoaXMpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayh0aGlzW2tleV0sIGtleSwgdGhpcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGl0ZXJhdG9yLmFwcGx5KG9iamVjdCwgW2NhbGxiYWNrXSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIHRvIHNjb3JlIGluZGl2aWR1YWwgcmVzdWx0cy5cblx0ICpcblx0ICogR29vZCBtYXRjaGVzIHdpbGwgaGF2ZSBhIGhpZ2hlciBzY29yZSB0aGFuIHBvb3IgbWF0Y2hlcy5cblx0ICogSWYgYW4gaXRlbSBpcyBub3QgYSBtYXRjaCwgMCB3aWxsIGJlIHJldHVybmVkIGJ5IHRoZSBmdW5jdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBzZWFyY2hcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgKG9wdGlvbmFsKVxuXHQgKiBAcmV0dXJucyB7ZnVuY3Rpb259XG5cdCAqL1xuXHRTaWZ0ZXIucHJvdG90eXBlLmdldFNjb3JlRnVuY3Rpb24gPSBmdW5jdGlvbihzZWFyY2gsIG9wdGlvbnMpIHtcblx0XHR2YXIgc2VsZiwgZmllbGRzLCB0b2tlbnMsIHRva2VuX2NvdW50LCBuZXN0aW5nO1xuXG5cdFx0c2VsZiAgICAgICAgPSB0aGlzO1xuXHRcdHNlYXJjaCAgICAgID0gc2VsZi5wcmVwYXJlU2VhcmNoKHNlYXJjaCwgb3B0aW9ucyk7XG5cdFx0dG9rZW5zICAgICAgPSBzZWFyY2gudG9rZW5zO1xuXHRcdGZpZWxkcyAgICAgID0gc2VhcmNoLm9wdGlvbnMuZmllbGRzO1xuXHRcdHRva2VuX2NvdW50ID0gdG9rZW5zLmxlbmd0aDtcblx0XHRuZXN0aW5nICAgICA9IHNlYXJjaC5vcHRpb25zLm5lc3Rpbmc7XG5cblx0XHQvKipcblx0XHQgKiBDYWxjdWxhdGVzIGhvdyBjbG9zZSBvZiBhIG1hdGNoIHRoZVxuXHRcdCAqIGdpdmVuIHZhbHVlIGlzIGFnYWluc3QgYSBzZWFyY2ggdG9rZW4uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge21peGVkfSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSB0b2tlblxuXHRcdCAqIEByZXR1cm4ge251bWJlcn1cblx0XHQgKi9cblx0XHR2YXIgc2NvcmVWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCB0b2tlbikge1xuXHRcdFx0dmFyIHNjb3JlLCBwb3M7XG5cblx0XHRcdGlmICghdmFsdWUpIHJldHVybiAwO1xuXHRcdFx0dmFsdWUgPSBTdHJpbmcodmFsdWUgfHwgJycpO1xuXHRcdFx0cG9zID0gdmFsdWUuc2VhcmNoKHRva2VuLnJlZ2V4KTtcblx0XHRcdGlmIChwb3MgPT09IC0xKSByZXR1cm4gMDtcblx0XHRcdHNjb3JlID0gdG9rZW4uc3RyaW5nLmxlbmd0aCAvIHZhbHVlLmxlbmd0aDtcblx0XHRcdGlmIChwb3MgPT09IDApIHNjb3JlICs9IDAuNTtcblx0XHRcdHJldHVybiBzY29yZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQ2FsY3VsYXRlcyB0aGUgc2NvcmUgb2YgYW4gb2JqZWN0XG5cdFx0ICogYWdhaW5zdCB0aGUgc2VhcmNoIHF1ZXJ5LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IHRva2VuXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGFcblx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdFx0ICovXG5cdFx0dmFyIHNjb3JlT2JqZWN0ID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGZpZWxkX2NvdW50ID0gZmllbGRzLmxlbmd0aDtcblx0XHRcdGlmICghZmllbGRfY291bnQpIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblx0XHRcdH1cblx0XHRcdGlmIChmaWVsZF9jb3VudCA9PT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24odG9rZW4sIGRhdGEpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2NvcmVWYWx1ZShnZXRhdHRyKGRhdGEsIGZpZWxkc1swXSwgbmVzdGluZyksIHRva2VuKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmdW5jdGlvbih0b2tlbiwgZGF0YSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgc3VtID0gMDsgaSA8IGZpZWxkX2NvdW50OyBpKyspIHtcblx0XHRcdFx0XHRzdW0gKz0gc2NvcmVWYWx1ZShnZXRhdHRyKGRhdGEsIGZpZWxkc1tpXSwgbmVzdGluZyksIHRva2VuKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc3VtIC8gZmllbGRfY291bnQ7XG5cdFx0XHR9O1xuXHRcdH0pKCk7XG5cblx0XHRpZiAoIXRva2VuX2NvdW50KSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXHRcdH1cblx0XHRpZiAodG9rZW5fY291bnQgPT09IDEpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdHJldHVybiBzY29yZU9iamVjdCh0b2tlbnNbMF0sIGRhdGEpO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiAoc2VhcmNoLm9wdGlvbnMuY29uanVuY3Rpb24gPT09ICdhbmQnKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHR2YXIgc2NvcmU7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBzdW0gPSAwOyBpIDwgdG9rZW5fY291bnQ7IGkrKykge1xuXHRcdFx0XHRcdHNjb3JlID0gc2NvcmVPYmplY3QodG9rZW5zW2ldLCBkYXRhKTtcblx0XHRcdFx0XHRpZiAoc2NvcmUgPD0gMCkgcmV0dXJuIDA7XG5cdFx0XHRcdFx0c3VtICs9IHNjb3JlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzdW0gLyB0b2tlbl9jb3VudDtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBzdW0gPSAwOyBpIDwgdG9rZW5fY291bnQ7IGkrKykge1xuXHRcdFx0XHRcdHN1bSArPSBzY29yZU9iamVjdCh0b2tlbnNbaV0sIGRhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzdW0gLyB0b2tlbl9jb3VudDtcblx0XHRcdH07XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjb21wYXJlIHR3b1xuXHQgKiByZXN1bHRzLCBmb3Igc29ydGluZyBwdXJwb3Nlcy4gSWYgbm8gc29ydGluZyBzaG91bGRcblx0ICogYmUgcGVyZm9ybWVkLCBgbnVsbGAgd2lsbCBiZSByZXR1cm5lZC5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzZWFyY2hcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcblx0ICogQHJldHVybiBmdW5jdGlvbihhLGIpXG5cdCAqL1xuXHRTaWZ0ZXIucHJvdG90eXBlLmdldFNvcnRGdW5jdGlvbiA9IGZ1bmN0aW9uKHNlYXJjaCwgb3B0aW9ucykge1xuXHRcdHZhciBpLCBuLCBzZWxmLCBmaWVsZCwgZmllbGRzLCBmaWVsZHNfY291bnQsIG11bHRpcGxpZXIsIG11bHRpcGxpZXJzLCBnZXRfZmllbGQsIGltcGxpY2l0X3Njb3JlLCBzb3J0O1xuXG5cdFx0c2VsZiAgID0gdGhpcztcblx0XHRzZWFyY2ggPSBzZWxmLnByZXBhcmVTZWFyY2goc2VhcmNoLCBvcHRpb25zKTtcblx0XHRzb3J0ICAgPSAoIXNlYXJjaC5xdWVyeSAmJiBvcHRpb25zLnNvcnRfZW1wdHkpIHx8IG9wdGlvbnMuc29ydDtcblxuXHRcdC8qKlxuXHRcdCAqIEZldGNoZXMgdGhlIHNwZWNpZmllZCBzb3J0IGZpZWxkIHZhbHVlXG5cdFx0ICogZnJvbSBhIHNlYXJjaCByZXN1bHQgaXRlbS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuXHRcdCAqIEBwYXJhbSAge29iamVjdH0gcmVzdWx0XG5cdFx0ICogQHJldHVybiB7bWl4ZWR9XG5cdFx0ICovXG5cdFx0Z2V0X2ZpZWxkID0gZnVuY3Rpb24obmFtZSwgcmVzdWx0KSB7XG5cdFx0XHRpZiAobmFtZSA9PT0gJyRzY29yZScpIHJldHVybiByZXN1bHQuc2NvcmU7XG5cdFx0XHRyZXR1cm4gZ2V0YXR0cihzZWxmLml0ZW1zW3Jlc3VsdC5pZF0sIG5hbWUsIG9wdGlvbnMubmVzdGluZyk7XG5cdFx0fTtcblxuXHRcdC8vIHBhcnNlIG9wdGlvbnNcblx0XHRmaWVsZHMgPSBbXTtcblx0XHRpZiAoc29ydCkge1xuXHRcdFx0Zm9yIChpID0gMCwgbiA9IHNvcnQubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdGlmIChzZWFyY2gucXVlcnkgfHwgc29ydFtpXS5maWVsZCAhPT0gJyRzY29yZScpIHtcblx0XHRcdFx0XHRmaWVsZHMucHVzaChzb3J0W2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRoZSBcIiRzY29yZVwiIGZpZWxkIGlzIGltcGxpZWQgdG8gYmUgdGhlIHByaW1hcnlcblx0XHQvLyBzb3J0IGZpZWxkLCB1bmxlc3MgaXQncyBtYW51YWxseSBzcGVjaWZpZWRcblx0XHRpZiAoc2VhcmNoLnF1ZXJ5KSB7XG5cdFx0XHRpbXBsaWNpdF9zY29yZSA9IHRydWU7XG5cdFx0XHRmb3IgKGkgPSAwLCBuID0gZmllbGRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRpZiAoZmllbGRzW2ldLmZpZWxkID09PSAnJHNjb3JlJykge1xuXHRcdFx0XHRcdGltcGxpY2l0X3Njb3JlID0gZmFsc2U7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChpbXBsaWNpdF9zY29yZSkge1xuXHRcdFx0XHRmaWVsZHMudW5zaGlmdCh7ZmllbGQ6ICckc2NvcmUnLCBkaXJlY3Rpb246ICdkZXNjJ30pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGkgPSAwLCBuID0gZmllbGRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRpZiAoZmllbGRzW2ldLmZpZWxkID09PSAnJHNjb3JlJykge1xuXHRcdFx0XHRcdGZpZWxkcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRtdWx0aXBsaWVycyA9IFtdO1xuXHRcdGZvciAoaSA9IDAsIG4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRtdWx0aXBsaWVycy5wdXNoKGZpZWxkc1tpXS5kaXJlY3Rpb24gPT09ICdkZXNjJyA/IC0xIDogMSk7XG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZnVuY3Rpb25cblx0XHRmaWVsZHNfY291bnQgPSBmaWVsZHMubGVuZ3RoO1xuXHRcdGlmICghZmllbGRzX2NvdW50KSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGVsc2UgaWYgKGZpZWxkc19jb3VudCA9PT0gMSkge1xuXHRcdFx0ZmllbGQgPSBmaWVsZHNbMF0uZmllbGQ7XG5cdFx0XHRtdWx0aXBsaWVyID0gbXVsdGlwbGllcnNbMF07XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gbXVsdGlwbGllciAqIGNtcChcblx0XHRcdFx0XHRnZXRfZmllbGQoZmllbGQsIGEpLFxuXHRcdFx0XHRcdGdldF9maWVsZChmaWVsZCwgYilcblx0XHRcdFx0KTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdHZhciBpLCByZXN1bHQsIGFfdmFsdWUsIGJfdmFsdWUsIGZpZWxkO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZmllbGRzX2NvdW50OyBpKyspIHtcblx0XHRcdFx0XHRmaWVsZCA9IGZpZWxkc1tpXS5maWVsZDtcblx0XHRcdFx0XHRyZXN1bHQgPSBtdWx0aXBsaWVyc1tpXSAqIGNtcChcblx0XHRcdFx0XHRcdGdldF9maWVsZChmaWVsZCwgYSksXG5cdFx0XHRcdFx0XHRnZXRfZmllbGQoZmllbGQsIGIpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhcnNlcyBhIHNlYXJjaCBxdWVyeSBhbmQgcmV0dXJucyBhbiBvYmplY3Rcblx0ICogd2l0aCB0b2tlbnMgYW5kIGZpZWxkcyByZWFkeSB0byBiZSBwb3B1bGF0ZWRcblx0ICogd2l0aCByZXN1bHRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcblx0ICogQHJldHVybnMge29iamVjdH1cblx0ICovXG5cdFNpZnRlci5wcm90b3R5cGUucHJlcGFyZVNlYXJjaCA9IGZ1bmN0aW9uKHF1ZXJ5LCBvcHRpb25zKSB7XG5cdFx0aWYgKHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcpIHJldHVybiBxdWVyeTtcblxuXHRcdG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuXG5cdFx0dmFyIG9wdGlvbl9maWVsZHMgICAgID0gb3B0aW9ucy5maWVsZHM7XG5cdFx0dmFyIG9wdGlvbl9zb3J0ICAgICAgID0gb3B0aW9ucy5zb3J0O1xuXHRcdHZhciBvcHRpb25fc29ydF9lbXB0eSA9IG9wdGlvbnMuc29ydF9lbXB0eTtcblxuXHRcdGlmIChvcHRpb25fZmllbGRzICYmICFpc19hcnJheShvcHRpb25fZmllbGRzKSkgb3B0aW9ucy5maWVsZHMgPSBbb3B0aW9uX2ZpZWxkc107XG5cdFx0aWYgKG9wdGlvbl9zb3J0ICYmICFpc19hcnJheShvcHRpb25fc29ydCkpIG9wdGlvbnMuc29ydCA9IFtvcHRpb25fc29ydF07XG5cdFx0aWYgKG9wdGlvbl9zb3J0X2VtcHR5ICYmICFpc19hcnJheShvcHRpb25fc29ydF9lbXB0eSkpIG9wdGlvbnMuc29ydF9lbXB0eSA9IFtvcHRpb25fc29ydF9lbXB0eV07XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0b3B0aW9ucyA6IG9wdGlvbnMsXG5cdFx0XHRxdWVyeSAgIDogU3RyaW5nKHF1ZXJ5IHx8ICcnKS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0dG9rZW5zICA6IHRoaXMudG9rZW5pemUocXVlcnkpLFxuXHRcdFx0dG90YWwgICA6IDAsXG5cdFx0XHRpdGVtcyAgIDogW11cblx0XHR9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZWFyY2hlcyB0aHJvdWdoIGFsbCBpdGVtcyBhbmQgcmV0dXJucyBhIHNvcnRlZCBhcnJheSBvZiBtYXRjaGVzLlxuXHQgKlxuXHQgKiBUaGUgYG9wdGlvbnNgIHBhcmFtZXRlciBjYW4gY29udGFpbjpcblx0ICpcblx0ICogICAtIGZpZWxkcyB7c3RyaW5nfGFycmF5fVxuXHQgKiAgIC0gc29ydCB7YXJyYXl9XG5cdCAqICAgLSBzY29yZSB7ZnVuY3Rpb259XG5cdCAqICAgLSBmaWx0ZXIge2Jvb2x9XG5cdCAqICAgLSBsaW1pdCB7aW50ZWdlcn1cblx0ICpcblx0ICogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZzpcblx0ICpcblx0ICogICAtIG9wdGlvbnMge29iamVjdH1cblx0ICogICAtIHF1ZXJ5IHtzdHJpbmd9XG5cdCAqICAgLSB0b2tlbnMge2FycmF5fVxuXHQgKiAgIC0gdG90YWwge2ludH1cblx0ICogICAtIGl0ZW1zIHthcnJheX1cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9XG5cdCAqL1xuXHRTaWZ0ZXIucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKHF1ZXJ5LCBvcHRpb25zKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCB2YWx1ZSwgc2NvcmUsIHNlYXJjaCwgY2FsY3VsYXRlU2NvcmU7XG5cdFx0dmFyIGZuX3NvcnQ7XG5cdFx0dmFyIGZuX3Njb3JlO1xuXG5cdFx0c2VhcmNoICA9IHRoaXMucHJlcGFyZVNlYXJjaChxdWVyeSwgb3B0aW9ucyk7XG5cdFx0b3B0aW9ucyA9IHNlYXJjaC5vcHRpb25zO1xuXHRcdHF1ZXJ5ICAgPSBzZWFyY2gucXVlcnk7XG5cblx0XHQvLyBnZW5lcmF0ZSByZXN1bHQgc2NvcmluZyBmdW5jdGlvblxuXHRcdGZuX3Njb3JlID0gb3B0aW9ucy5zY29yZSB8fCBzZWxmLmdldFNjb3JlRnVuY3Rpb24oc2VhcmNoKTtcblxuXHRcdC8vIHBlcmZvcm0gc2VhcmNoIGFuZCBzb3J0XG5cdFx0aWYgKHF1ZXJ5Lmxlbmd0aCkge1xuXHRcdFx0c2VsZi5pdGVyYXRvcihzZWxmLml0ZW1zLCBmdW5jdGlvbihpdGVtLCBpZCkge1xuXHRcdFx0XHRzY29yZSA9IGZuX3Njb3JlKGl0ZW0pO1xuXHRcdFx0XHRpZiAob3B0aW9ucy5maWx0ZXIgPT09IGZhbHNlIHx8IHNjb3JlID4gMCkge1xuXHRcdFx0XHRcdHNlYXJjaC5pdGVtcy5wdXNoKHsnc2NvcmUnOiBzY29yZSwgJ2lkJzogaWR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlbGYuaXRlcmF0b3Ioc2VsZi5pdGVtcywgZnVuY3Rpb24oaXRlbSwgaWQpIHtcblx0XHRcdFx0c2VhcmNoLml0ZW1zLnB1c2goeydzY29yZSc6IDEsICdpZCc6IGlkfSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmbl9zb3J0ID0gc2VsZi5nZXRTb3J0RnVuY3Rpb24oc2VhcmNoLCBvcHRpb25zKTtcblx0XHRpZiAoZm5fc29ydCkgc2VhcmNoLml0ZW1zLnNvcnQoZm5fc29ydCk7XG5cblx0XHQvLyBhcHBseSBsaW1pdHNcblx0XHRzZWFyY2gudG90YWwgPSBzZWFyY2guaXRlbXMubGVuZ3RoO1xuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucy5saW1pdCA9PT0gJ251bWJlcicpIHtcblx0XHRcdHNlYXJjaC5pdGVtcyA9IHNlYXJjaC5pdGVtcy5zbGljZSgwLCBvcHRpb25zLmxpbWl0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2VhcmNoO1xuXHR9O1xuXG5cdC8vIHV0aWxpdGllc1xuXHQvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cblx0dmFyIGNtcCA9IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRpZiAodHlwZW9mIGEgPT09ICdudW1iZXInICYmIHR5cGVvZiBiID09PSAnbnVtYmVyJykge1xuXHRcdFx0cmV0dXJuIGEgPiBiID8gMSA6IChhIDwgYiA/IC0xIDogMCk7XG5cdFx0fVxuXHRcdGEgPSBhc2NpaWZvbGQoU3RyaW5nKGEgfHwgJycpKTtcblx0XHRiID0gYXNjaWlmb2xkKFN0cmluZyhiIHx8ICcnKSk7XG5cdFx0aWYgKGEgPiBiKSByZXR1cm4gMTtcblx0XHRpZiAoYiA+IGEpIHJldHVybiAtMTtcblx0XHRyZXR1cm4gMDtcblx0fTtcblxuXHR2YXIgZXh0ZW5kID0gZnVuY3Rpb24oYSwgYikge1xuXHRcdHZhciBpLCBuLCBrLCBvYmplY3Q7XG5cdFx0Zm9yIChpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdG9iamVjdCA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghb2JqZWN0KSBjb250aW51ZTtcblx0XHRcdGZvciAoayBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrKSkge1xuXHRcdFx0XHRcdGFba10gPSBvYmplY3Rba107XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGE7XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgcHJvcGVydHkgZ2V0dGVyIHJlc29sdmluZyBkb3Qtbm90YXRpb25cblx0ICogQHBhcmFtICB7T2JqZWN0fSAgb2JqICAgICBUaGUgcm9vdCBvYmplY3QgdG8gZmV0Y2ggcHJvcGVydHkgb25cblx0ICogQHBhcmFtICB7U3RyaW5nfSAgbmFtZSAgICBUaGUgb3B0aW9uYWxseSBkb3R0ZWQgcHJvcGVydHkgbmFtZSB0byBmZXRjaFxuXHQgKiBAcGFyYW0gIHtCb29sZWFufSBuZXN0aW5nIEhhbmRsZSBuZXN0aW5nIG9yIG5vdFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgIFRoZSByZXNvbHZlZCBwcm9wZXJ0eSB2YWx1ZVxuXHQgKi9cblx0dmFyIGdldGF0dHIgPSBmdW5jdGlvbihvYmosIG5hbWUsIG5lc3RpbmcpIHtcblx0ICAgIGlmICghb2JqIHx8ICFuYW1lKSByZXR1cm47XG5cdCAgICBpZiAoIW5lc3RpbmcpIHJldHVybiBvYmpbbmFtZV07XG5cdCAgICB2YXIgbmFtZXMgPSBuYW1lLnNwbGl0KFwiLlwiKTtcblx0ICAgIHdoaWxlKG5hbWVzLmxlbmd0aCAmJiAob2JqID0gb2JqW25hbWVzLnNoaWZ0KCldKSk7XG5cdCAgICByZXR1cm4gb2JqO1xuXHR9O1xuXG5cdHZhciB0cmltID0gZnVuY3Rpb24oc3RyKSB7XG5cdFx0cmV0dXJuIChzdHIgKyAnJykucmVwbGFjZSgvXlxccyt8XFxzKyR8L2csICcnKTtcblx0fTtcblxuXHR2YXIgZXNjYXBlX3JlZ2V4ID0gZnVuY3Rpb24oc3RyKSB7XG5cdFx0cmV0dXJuIChzdHIgKyAnJykucmVwbGFjZSgvKFsuPyorXiRbXFxdXFxcXCgpe318LV0pL2csICdcXFxcJDEnKTtcblx0fTtcblxuXHR2YXIgaXNfYXJyYXkgPSBBcnJheS5pc0FycmF5IHx8ICh0eXBlb2YgJCAhPT0gJ3VuZGVmaW5lZCcgJiYgJC5pc0FycmF5KSB8fCBmdW5jdGlvbihvYmplY3QpIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH07XG5cblx0dmFyIERJQUNSSVRJQ1MgPSB7XG5cdFx0J2EnOiAnW2HhuIDhuIHEgsSDw4LDoseNx47IuuKxpcimyKfhuqDhuqHDhMOkw4DDoMOBw6HEgMSBw4PDo8OFw6XEhcSEw4PEhcSEXScsXG5cdFx0J2InOiAnW2LikKLOss6SQuC4v/CQjIHhm5JdJyxcblx0XHQnYyc6ICdbY8SGxIfEiMSJxIzEjcSKxItDzIRjzITDh8On4biI4biJyLvIvMaHxojJleG0hO+8o++9g10nLFxuXHRcdCdkJzogJ1tkxI7Ej+G4iuG4i+G4kOG4keG4jOG4jeG4kuG4k+G4juG4j8SQxJFEzKZkzKbGicmWxorJl8aLxozhta3htoHhtpHIoeG0he+8pO+9hMOwXScsXG5cdFx0J2UnOiAnW2XDicOpw4jDqMOKw6rhuJjhuJnEmsSbxJTEleG6vOG6veG4muG4m+G6uuG6u8SWxJfDi8OrxJLEk8ioyKnEmMSZ4baSyYbJh8iEyIXhur7hur/hu4Dhu4Hhu4Thu4Xhu4Lhu4PhuJzhuJ3huJbhuJfhuJThuJXIhsiH4bq44bq54buG4buH4rG44bSH77yl772FyZjHncaPxpDOtV0nLFxuXHRcdCdmJzogJ1tmxpHGkuG4nuG4n10nLFxuXHRcdCdnJzogJ1tnyaLigrLHpMelxJzEncSexJ/EosSjxpPJoMSgxKFdJyxcblx0XHQnaCc6ICdbaMSkxKXEpsSn4bio4bip4bqW4bqW4bik4bil4bii4bijyabKsMe2xpVdJyxcblx0XHQnaSc6ICdbacONw63DjMOsxKzErcOOw67Hj8eQw4/Dr+G4ruG4r8SoxKnErsSvxKrEq+G7iOG7iciIyInIisiL4buK4buL4bis4bitxpfJqMmozIbhtbvhtpbEsGlJxLHJqu+8qe+9iV0nLFxuXHRcdCdqJzogJ1tqyLfEtMS1yYjJicqdyZ/Ksl0nLFxuXHRcdCdrJzogJ1trxpjGmeqdgOqdgeG4sOG4sceox6nhuLLhuLPhuLThuLXOus+w4oKtXScsXG5cdFx0J2wnOiAnW2zFgcWCxL3EvsS7xLzEucS64bi24bi34bi44bi54bi84bi94bi64bi7xL/FgMi9xprisaDisaHisaLJq8ms4baFya3ItMqf77ys772MXScsXG5cdFx0J24nOiAnW27Fg8WEx7jHucWHxYjDkcOx4bmE4bmFxYXFhuG5huG5h+G5iuG5i+G5iOG5iU7MiG7MiMadybLIoMae4bWw4baHybPItcm077yu772OxYrFi10nLFxuXHRcdCdvJzogJ1tvw5jDuMOWw7bDk8Ozw5LDssOUw7THkceSxZDFkcWOxY/Irsiv4buM4buNxp/JtcagxqHhu47hu4/FjMWNw5XDtceqx6vIjMiN1ZXWhV0nLFxuXHRcdCdwJzogJ1tw4bmU4bmV4bmW4bmX4rGj4bW9xqTGpeG1sV0nLFxuXHRcdCdxJzogJ1tx6p2W6p2XyqDJismL6p2Y6p2ZccyDXScsXG5cdFx0J3InOiAnW3LFlMWVyYzJjcWYxZnFlsWX4bmY4bmZyJDIkciSyJPhuZrhuZvisaTJvV0nLFxuXHRcdCdzJzogJ1tzxZrFm+G5oOG5oeG5ouG5o+qeqOqeqcWcxZ3FoMWhxZ7Fn8iYyJlTzIhzzIhdJyxcblx0XHQndCc6ICdbdMWkxaXhuarhuavFosWj4bms4bmtxq7KiMiayJvhubDhubHhua7hua/GrMatXScsXG5cdFx0J3UnOiAnW3XFrMWtyYTKieG7pOG7pcOcw7zDmsO6w5nDucObw7vHk8eUxbDFscWsxa3Gr8aw4bum4bunxarFq8WoxanFssWzyJTIleKIql0nLFxuXHRcdCd2JzogJ1t24bm84bm94bm+4bm/xrLKi+qdnuqdn+KxscqLXScsXG5cdFx0J3cnOiAnW3fhuoLhuoPhuoDhuoHFtMW14bqE4bqF4bqG4bqH4bqI4bqJXScsXG5cdFx0J3gnOiAnW3jhuozhuo3huorhuovPh10nLFxuXHRcdCd5JzogJ1t5w53DveG7suG7s8W2xbfFuMO/4bu44bu54bqO4bqP4bu04bu1yY7Jj8azxrRdJyxcblx0XHQneic6ICdbesW5xbrhupDhupHFvcW+xbvFvOG6kuG6k+G6lOG6lca1xrZdJ1xuXHR9O1xuXG5cdHZhciBhc2NpaWZvbGQgPSAoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGksIG4sIGssIGNodW5rO1xuXHRcdHZhciBmb3JlaWdubGV0dGVycyA9ICcnO1xuXHRcdHZhciBsb29rdXAgPSB7fTtcblx0XHRmb3IgKGsgaW4gRElBQ1JJVElDUykge1xuXHRcdFx0aWYgKERJQUNSSVRJQ1MuaGFzT3duUHJvcGVydHkoaykpIHtcblx0XHRcdFx0Y2h1bmsgPSBESUFDUklUSUNTW2tdLnN1YnN0cmluZygyLCBESUFDUklUSUNTW2tdLmxlbmd0aCAtIDEpO1xuXHRcdFx0XHRmb3JlaWdubGV0dGVycyArPSBjaHVuaztcblx0XHRcdFx0Zm9yIChpID0gMCwgbiA9IGNodW5rLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRcdGxvb2t1cFtjaHVuay5jaGFyQXQoaSldID0gaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnWycgKyAgZm9yZWlnbmxldHRlcnMgKyAnXScsICdnJyk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKHJlZ2V4cCwgZnVuY3Rpb24oZm9yZWlnbmxldHRlcikge1xuXHRcdFx0XHRyZXR1cm4gbG9va3VwW2ZvcmVpZ25sZXR0ZXJdO1xuXHRcdFx0fSkudG9Mb3dlckNhc2UoKTtcblx0XHR9O1xuXHR9KSgpO1xuXG5cblx0Ly8gZXhwb3J0XG5cdC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblxuXHRyZXR1cm4gU2lmdGVyO1xufSkpO1xuXG5cblxuLyoqXG4gKiBtaWNyb3BsdWdpbi5qc1xuICogQ29weXJpZ2h0IChjKSAyMDEzIEJyaWFuIFJlYXZpcyAmIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAYXV0aG9yIEJyaWFuIFJlYXZpcyA8YnJpYW5AdGhpcmRyb3V0ZS5jb20+XG4gKi9cblxuKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZSgnbWljcm9wbHVnaW4nLCBmYWN0b3J5KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fSBlbHNlIHtcblx0XHRyb290Lk1pY3JvUGx1Z2luID0gZmFjdG9yeSgpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uKCkge1xuXHR2YXIgTWljcm9QbHVnaW4gPSB7fTtcblxuXHRNaWNyb1BsdWdpbi5taXhpbiA9IGZ1bmN0aW9uKEludGVyZmFjZSkge1xuXHRcdEludGVyZmFjZS5wbHVnaW5zID0ge307XG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplcyB0aGUgbGlzdGVkIHBsdWdpbnMgKHdpdGggb3B0aW9ucykuXG5cdFx0ICogQWNjZXB0YWJsZSBmb3JtYXRzOlxuXHRcdCAqXG5cdFx0ICogTGlzdCAod2l0aG91dCBvcHRpb25zKTpcblx0XHQgKiAgIFsnYScsICdiJywgJ2MnXVxuXHRcdCAqXG5cdFx0ICogTGlzdCAod2l0aCBvcHRpb25zKTpcblx0XHQgKiAgIFt7J25hbWUnOiAnYScsIG9wdGlvbnM6IHt9fSwgeyduYW1lJzogJ2InLCBvcHRpb25zOiB7fX1dXG5cdFx0ICpcblx0XHQgKiBIYXNoICh3aXRoIG9wdGlvbnMpOlxuXHRcdCAqICAgeydhJzogeyAuLi4gfSwgJ2InOiB7IC4uLiB9LCAnYyc6IHsgLi4uIH19XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge21peGVkfSBwbHVnaW5zXG5cdFx0ICovXG5cdFx0SW50ZXJmYWNlLnByb3RvdHlwZS5pbml0aWFsaXplUGx1Z2lucyA9IGZ1bmN0aW9uKHBsdWdpbnMpIHtcblx0XHRcdHZhciBpLCBuLCBrZXk7XG5cdFx0XHR2YXIgc2VsZiAgPSB0aGlzO1xuXHRcdFx0dmFyIHF1ZXVlID0gW107XG5cblx0XHRcdHNlbGYucGx1Z2lucyA9IHtcblx0XHRcdFx0bmFtZXMgICAgIDogW10sXG5cdFx0XHRcdHNldHRpbmdzICA6IHt9LFxuXHRcdFx0XHRyZXF1ZXN0ZWQgOiB7fSxcblx0XHRcdFx0bG9hZGVkICAgIDoge31cblx0XHRcdH07XG5cblx0XHRcdGlmICh1dGlscy5pc0FycmF5KHBsdWdpbnMpKSB7XG5cdFx0XHRcdGZvciAoaSA9IDAsIG4gPSBwbHVnaW5zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgcGx1Z2luc1tpXSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2gocGx1Z2luc1tpXSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYucGx1Z2lucy5zZXR0aW5nc1twbHVnaW5zW2ldLm5hbWVdID0gcGx1Z2luc1tpXS5vcHRpb25zO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaChwbHVnaW5zW2ldLm5hbWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChwbHVnaW5zKSB7XG5cdFx0XHRcdGZvciAoa2V5IGluIHBsdWdpbnMpIHtcblx0XHRcdFx0XHRpZiAocGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnBsdWdpbnMuc2V0dGluZ3Nba2V5XSA9IHBsdWdpbnNba2V5XTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0d2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuXHRcdFx0XHRzZWxmLnJlcXVpcmUocXVldWUuc2hpZnQoKSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdEludGVyZmFjZS5wcm90b3R5cGUubG9hZFBsdWdpbiA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHZhciBzZWxmICAgID0gdGhpcztcblx0XHRcdHZhciBwbHVnaW5zID0gc2VsZi5wbHVnaW5zO1xuXHRcdFx0dmFyIHBsdWdpbiAgPSBJbnRlcmZhY2UucGx1Z2luc1tuYW1lXTtcblxuXHRcdFx0aWYgKCFJbnRlcmZhY2UucGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIFwiJyArICBuYW1lICsgJ1wiIHBsdWdpbicpO1xuXHRcdFx0fVxuXG5cdFx0XHRwbHVnaW5zLnJlcXVlc3RlZFtuYW1lXSA9IHRydWU7XG5cdFx0XHRwbHVnaW5zLmxvYWRlZFtuYW1lXSA9IHBsdWdpbi5mbi5hcHBseShzZWxmLCBbc2VsZi5wbHVnaW5zLnNldHRpbmdzW25hbWVdIHx8IHt9XSk7XG5cdFx0XHRwbHVnaW5zLm5hbWVzLnB1c2gobmFtZSk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemVzIGEgcGx1Z2luLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0XHQgKi9cblx0XHRJbnRlcmZhY2UucHJvdG90eXBlLnJlcXVpcmUgPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR2YXIgcGx1Z2lucyA9IHNlbGYucGx1Z2lucztcblxuXHRcdFx0aWYgKCFzZWxmLnBsdWdpbnMubG9hZGVkLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRcdGlmIChwbHVnaW5zLnJlcXVlc3RlZFtuYW1lXSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignUGx1Z2luIGhhcyBjaXJjdWxhciBkZXBlbmRlbmN5IChcIicgKyBuYW1lICsgJ1wiKScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYubG9hZFBsdWdpbihuYW1lKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBsdWdpbnMubG9hZGVkW25hbWVdO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZWdpc3RlcnMgYSBwbHVnaW4uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG5cdFx0ICovXG5cdFx0SW50ZXJmYWNlLmRlZmluZSA9IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG5cdFx0XHRJbnRlcmZhY2UucGx1Z2luc1tuYW1lXSA9IHtcblx0XHRcdFx0J25hbWUnIDogbmFtZSxcblx0XHRcdFx0J2ZuJyAgIDogZm5cblx0XHRcdH07XG5cdFx0fTtcblx0fTtcblxuXHR2YXIgdXRpbHMgPSB7XG5cdFx0aXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih2QXJnKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZBcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gTWljcm9QbHVnaW47XG59KSk7XG5cbi8qKlxuICogc2VsZWN0aXplLmpzICh2MC4xMi42KVxuICogQ29weXJpZ2h0IChjKSAyMDEz4oCTMjAxNSBCcmlhbiBSZWF2aXMgJiBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQGF1dGhvciBCcmlhbiBSZWF2aXMgPGJyaWFuQHRoaXJkcm91dGUuY29tPlxuICovXG5cbi8qanNoaW50IGN1cmx5OmZhbHNlICovXG4vKmpzaGludCBicm93c2VyOnRydWUgKi9cblxuKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZSgnc2VsZWN0aXplJywgWydqcXVlcnknLCdzaWZ0ZXInLCdtaWNyb3BsdWdpbiddLCBmYWN0b3J5KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JyksIHJlcXVpcmUoJ3NpZnRlcicpLCByZXF1aXJlKCdtaWNyb3BsdWdpbicpKTtcblx0fSBlbHNlIHtcblx0XHRyb290LlNlbGVjdGl6ZSA9IGZhY3Rvcnkocm9vdC5qUXVlcnksIHJvb3QuU2lmdGVyLCByb290Lk1pY3JvUGx1Z2luKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbigkLCBTaWZ0ZXIsIE1pY3JvUGx1Z2luKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGlnaGxpZ2h0ID0gZnVuY3Rpb24oJGVsZW1lbnQsIHBhdHRlcm4pIHtcblx0XHRpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnICYmICFwYXR0ZXJuLmxlbmd0aCkgcmV0dXJuO1xuXHRcdHZhciByZWdleCA9ICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpID8gbmV3IFJlZ0V4cChwYXR0ZXJuLCAnaScpIDogcGF0dGVybjtcblx0XG5cdFx0dmFyIGhpZ2hsaWdodCA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciBza2lwID0gMDtcblx0XHRcdC8vIFdyYXAgbWF0Y2hpbmcgcGFydCBvZiB0ZXh0IG5vZGUgd2l0aCBoaWdobGlnaHRpbmcgPHNwYW4+LCBlLmcuXG5cdFx0XHQvLyBTb2NjZXIgIC0+ICA8c3BhbiBjbGFzcz1cImhpZ2hsaWdodFwiPlNvYzwvc3Bhbj5jZXIgIGZvciByZWdleCA9IC9zb2MvaVxuXHRcdFx0aWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcblx0XHRcdFx0dmFyIHBvcyA9IG5vZGUuZGF0YS5zZWFyY2gocmVnZXgpO1xuXHRcdFx0XHRpZiAocG9zID49IDAgJiYgbm9kZS5kYXRhLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2ggPSBub2RlLmRhdGEubWF0Y2gocmVnZXgpO1xuXHRcdFx0XHRcdHZhciBzcGFubm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblx0XHRcdFx0XHRzcGFubm9kZS5jbGFzc05hbWUgPSAnaGlnaGxpZ2h0Jztcblx0XHRcdFx0XHR2YXIgbWlkZGxlYml0ID0gbm9kZS5zcGxpdFRleHQocG9zKTtcblx0XHRcdFx0XHR2YXIgZW5kYml0ID0gbWlkZGxlYml0LnNwbGl0VGV4dChtYXRjaFswXS5sZW5ndGgpO1xuXHRcdFx0XHRcdHZhciBtaWRkbGVjbG9uZSA9IG1pZGRsZWJpdC5jbG9uZU5vZGUodHJ1ZSk7XG5cdFx0XHRcdFx0c3Bhbm5vZGUuYXBwZW5kQ2hpbGQobWlkZGxlY2xvbmUpO1xuXHRcdFx0XHRcdG1pZGRsZWJpdC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChzcGFubm9kZSwgbWlkZGxlYml0KTtcblx0XHRcdFx0XHRza2lwID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fSBcblx0XHRcdC8vIFJlY3Vyc2UgZWxlbWVudCBub2RlLCBsb29raW5nIGZvciBjaGlsZCB0ZXh0IG5vZGVzIHRvIGhpZ2hsaWdodCwgdW5sZXNzIGVsZW1lbnQgXG5cdFx0XHQvLyBpcyBjaGlsZGxlc3MsIDxzY3JpcHQ+LCA8c3R5bGU+LCBvciBhbHJlYWR5IGhpZ2hsaWdodGVkOiA8c3BhbiBjbGFzcz1cImhpZ2h0bGlnaHRcIj5cblx0XHRcdGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZS5jaGlsZE5vZGVzICYmICEvKHNjcmlwdHxzdHlsZSkvaS50ZXN0KG5vZGUudGFnTmFtZSkgJiYgKCBub2RlLmNsYXNzTmFtZSAhPT0gJ2hpZ2hsaWdodCcgfHwgbm9kZS50YWdOYW1lICE9PSAnU1BBTicgKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdGkgKz0gaGlnaGxpZ2h0KG5vZGUuY2hpbGROb2Rlc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBza2lwO1xuXHRcdH07XG5cdFxuXHRcdHJldHVybiAkZWxlbWVudC5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aGlnaGxpZ2h0KHRoaXMpO1xuXHRcdH0pO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIHJlbW92ZUhpZ2hsaWdodCBmbiBjb3BpZWQgZnJvbSBoaWdobGlnaHQgdjUgYW5kXG5cdCAqIGVkaXRlZCB0byByZW1vdmUgd2l0aCgpIGFuZCBwYXNzIGpzIHN0cmljdCBtb2RlXG5cdCAqL1xuXHQkLmZuLnJlbW92ZUhpZ2hsaWdodCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmZpbmQoXCJzcGFuLmhpZ2hsaWdodFwiKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQubm9kZU5hbWU7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLmZpcnN0Q2hpbGQsIHRoaXMpO1xuXHRcdFx0cGFyZW50Lm5vcm1hbGl6ZSgpO1xuXHRcdH0pLmVuZCgpO1xuXHR9O1xuXHRcblx0XG5cdHZhciBNaWNyb0V2ZW50ID0gZnVuY3Rpb24oKSB7fTtcblx0TWljcm9FdmVudC5wcm90b3R5cGUgPSB7XG5cdFx0b246IGZ1bmN0aW9uKGV2ZW50LCBmY3Qpe1xuXHRcdFx0dGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuXHRcdFx0dGhpcy5fZXZlbnRzW2V2ZW50XSA9IHRoaXMuX2V2ZW50c1tldmVudF0gfHwgW107XG5cdFx0XHR0aGlzLl9ldmVudHNbZXZlbnRdLnB1c2goZmN0KTtcblx0XHR9LFxuXHRcdG9mZjogZnVuY3Rpb24oZXZlbnQsIGZjdCl7XG5cdFx0XHR2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0XHRpZiAobiA9PT0gMCkgcmV0dXJuIGRlbGV0ZSB0aGlzLl9ldmVudHM7XG5cdFx0XHRpZiAobiA9PT0gMSkgcmV0dXJuIGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuXHRcblx0XHRcdHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcblx0XHRcdGlmIChldmVudCBpbiB0aGlzLl9ldmVudHMgPT09IGZhbHNlKSByZXR1cm47XG5cdFx0XHR0aGlzLl9ldmVudHNbZXZlbnRdLnNwbGljZSh0aGlzLl9ldmVudHNbZXZlbnRdLmluZGV4T2YoZmN0KSwgMSk7XG5cdFx0fSxcblx0XHR0cmlnZ2VyOiBmdW5jdGlvbihldmVudCAvKiAsIGFyZ3MuLi4gKi8pe1xuXHRcdFx0dGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuXHRcdFx0aWYgKGV2ZW50IGluIHRoaXMuX2V2ZW50cyA9PT0gZmFsc2UpIHJldHVybjtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRzW2V2ZW50XS5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdHRoaXMuX2V2ZW50c1tldmVudF1baV0uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIE1peGluIHdpbGwgZGVsZWdhdGUgYWxsIE1pY3JvRXZlbnQuanMgZnVuY3Rpb24gaW4gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cblx0ICpcblx0ICogLSBNaWNyb0V2ZW50Lm1peGluKEZvb2Jhcikgd2lsbCBtYWtlIEZvb2JhciBhYmxlIHRvIHVzZSBNaWNyb0V2ZW50XG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0aGUgb2JqZWN0IHdoaWNoIHdpbGwgc3VwcG9ydCBNaWNyb0V2ZW50XG5cdCAqL1xuXHRNaWNyb0V2ZW50Lm1peGluID0gZnVuY3Rpb24oZGVzdE9iamVjdCl7XG5cdFx0dmFyIHByb3BzID0gWydvbicsICdvZmYnLCAndHJpZ2dlciddO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuXHRcdFx0ZGVzdE9iamVjdC5wcm90b3R5cGVbcHJvcHNbaV1dID0gTWljcm9FdmVudC5wcm90b3R5cGVbcHJvcHNbaV1dO1xuXHRcdH1cblx0fTtcblx0XG5cdHZhciBJU19NQUMgICAgICAgID0gL01hYy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblx0XG5cdHZhciBLRVlfQSAgICAgICAgID0gNjU7XG5cdHZhciBLRVlfQ09NTUEgICAgID0gMTg4O1xuXHR2YXIgS0VZX1JFVFVSTiAgICA9IDEzO1xuXHR2YXIgS0VZX0VTQyAgICAgICA9IDI3O1xuXHR2YXIgS0VZX0xFRlQgICAgICA9IDM3O1xuXHR2YXIgS0VZX1VQICAgICAgICA9IDM4O1xuXHR2YXIgS0VZX1AgICAgICAgICA9IDgwO1xuXHR2YXIgS0VZX1JJR0hUICAgICA9IDM5O1xuXHR2YXIgS0VZX0RPV04gICAgICA9IDQwO1xuXHR2YXIgS0VZX04gICAgICAgICA9IDc4O1xuXHR2YXIgS0VZX0JBQ0tTUEFDRSA9IDg7XG5cdHZhciBLRVlfREVMRVRFICAgID0gNDY7XG5cdHZhciBLRVlfU0hJRlQgICAgID0gMTY7XG5cdHZhciBLRVlfQ01EICAgICAgID0gSVNfTUFDID8gOTEgOiAxNztcblx0dmFyIEtFWV9DVFJMICAgICAgPSBJU19NQUMgPyAxOCA6IDE3O1xuXHR2YXIgS0VZX1RBQiAgICAgICA9IDk7XG5cdFxuXHR2YXIgVEFHX1NFTEVDVCAgICA9IDE7XG5cdHZhciBUQUdfSU5QVVQgICAgID0gMjtcblx0XG5cdC8vIGZvciBub3csIGFuZHJvaWQgc3VwcG9ydCBpbiBnZW5lcmFsIGlzIHRvbyBzcG90dHkgdG8gc3VwcG9ydCB2YWxpZGl0eVxuXHR2YXIgU1VQUE9SVFNfVkFMSURJVFlfQVBJID0gIS9hbmRyb2lkL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpLnZhbGlkaXR5O1xuXHRcblx0XG5cdHZhciBpc3NldCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuXHRcdHJldHVybiB0eXBlb2Ygb2JqZWN0ICE9PSAndW5kZWZpbmVkJztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHNjYWxhciB0byBpdHMgYmVzdCBzdHJpbmcgcmVwcmVzZW50YXRpb25cblx0ICogZm9yIGhhc2gga2V5cyBhbmQgSFRNTCBhdHRyaWJ1dGUgdmFsdWVzLlxuXHQgKlxuXHQgKiBUcmFuc2Zvcm1hdGlvbnM6XG5cdCAqICAgJ3N0cicgICAgIC0+ICdzdHInXG5cdCAqICAgbnVsbCAgICAgIC0+ICcnXG5cdCAqICAgdW5kZWZpbmVkIC0+ICcnXG5cdCAqICAgdHJ1ZSAgICAgIC0+ICcxJ1xuXHQgKiAgIGZhbHNlICAgICAtPiAnMCdcblx0ICogICAwICAgICAgICAgLT4gJzAnXG5cdCAqICAgMSAgICAgICAgIC0+ICcxJ1xuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0ICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuXHQgKi9cblx0dmFyIGhhc2hfa2V5ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gdmFsdWUgPyAnMScgOiAnMCc7XG5cdFx0cmV0dXJuIHZhbHVlICsgJyc7XG5cdH07XG5cdFxuXHQvKipcblx0ICogRXNjYXBlcyBhIHN0cmluZyBmb3IgdXNlIHdpdGhpbiBIVE1MLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR2YXIgZXNjYXBlX2h0bWwgPSBmdW5jdGlvbihzdHIpIHtcblx0XHRyZXR1cm4gKHN0ciArICcnKVxuXHRcdFx0LnJlcGxhY2UoLyYvZywgJyZhbXA7Jylcblx0XHRcdC5yZXBsYWNlKC88L2csICcmbHQ7Jylcblx0XHRcdC5yZXBsYWNlKC8+L2csICcmZ3Q7Jylcblx0XHRcdC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogRXNjYXBlcyBcIiRcIiBjaGFyYWN0ZXJzIGluIHJlcGxhY2VtZW50IHN0cmluZ3MuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHZhciBlc2NhcGVfcmVwbGFjZSA9IGZ1bmN0aW9uKHN0cikge1xuXHRcdHJldHVybiAoc3RyICsgJycpLnJlcGxhY2UoL1xcJC9nLCAnJCQkJCcpO1xuXHR9O1xuXHRcblx0dmFyIGhvb2sgPSB7fTtcblx0XG5cdC8qKlxuXHQgKiBXcmFwcyBgbWV0aG9kYCBvbiBgc2VsZmAgc28gdGhhdCBgZm5gXG5cdCAqIGlzIGludm9rZWQgYmVmb3JlIHRoZSBvcmlnaW5hbCBtZXRob2QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBzZWxmXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2Rcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm5cblx0ICovXG5cdGhvb2suYmVmb3JlID0gZnVuY3Rpb24oc2VsZiwgbWV0aG9kLCBmbikge1xuXHRcdHZhciBvcmlnaW5hbCA9IHNlbGZbbWV0aG9kXTtcblx0XHRzZWxmW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGZuLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gb3JpZ2luYWwuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFdyYXBzIGBtZXRob2RgIG9uIGBzZWxmYCBzbyB0aGF0IGBmbmBcblx0ICogaXMgaW52b2tlZCBhZnRlciB0aGUgb3JpZ2luYWwgbWV0aG9kLlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gc2VsZlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG5cdCAqL1xuXHRob29rLmFmdGVyID0gZnVuY3Rpb24oc2VsZiwgbWV0aG9kLCBmbikge1xuXHRcdHZhciBvcmlnaW5hbCA9IHNlbGZbbWV0aG9kXTtcblx0XHRzZWxmW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXHRcdFx0Zm4uYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBXcmFwcyBgZm5gIHNvIHRoYXQgaXQgY2FuIG9ubHkgYmUgaW52b2tlZCBvbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmblxuXHQgKiBAcmV0dXJucyB7ZnVuY3Rpb259XG5cdCAqL1xuXHR2YXIgb25jZSA9IGZ1bmN0aW9uKGZuKSB7XG5cdFx0dmFyIGNhbGxlZCA9IGZhbHNlO1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChjYWxsZWQpIHJldHVybjtcblx0XHRcdGNhbGxlZCA9IHRydWU7XG5cdFx0XHRmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH07XG5cdFxuXHQvKipcblx0ICogV3JhcHMgYGZuYCBzbyB0aGF0IGl0IGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlXG5cdCAqIGV2ZXJ5IGBkZWxheWAgbWlsbGlzZWNvbmRzIChpbnZva2VkIG9uIHRoZSBmYWxsaW5nIGVkZ2UpLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmblxuXHQgKiBAcGFyYW0ge2ludH0gZGVsYXlcblx0ICogQHJldHVybnMge2Z1bmN0aW9ufVxuXHQgKi9cblx0dmFyIGRlYm91bmNlID0gZnVuY3Rpb24oZm4sIGRlbGF5KSB7XG5cdFx0dmFyIHRpbWVvdXQ7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdFx0dGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHRcdH0sIGRlbGF5KTtcblx0XHR9O1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIERlYm91bmNlIGFsbCBmaXJlZCBldmVudHMgdHlwZXMgbGlzdGVkIGluIGB0eXBlc2Bcblx0ICogd2hpbGUgZXhlY3V0aW5nIHRoZSBwcm92aWRlZCBgZm5gLlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gc2VsZlxuXHQgKiBAcGFyYW0ge2FycmF5fSB0eXBlc1xuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmblxuXHQgKi9cblx0dmFyIGRlYm91bmNlX2V2ZW50cyA9IGZ1bmN0aW9uKHNlbGYsIHR5cGVzLCBmbikge1xuXHRcdHZhciB0eXBlO1xuXHRcdHZhciB0cmlnZ2VyID0gc2VsZi50cmlnZ2VyO1xuXHRcdHZhciBldmVudF9hcmdzID0ge307XG5cdFxuXHRcdC8vIG92ZXJyaWRlIHRyaWdnZXIgbWV0aG9kXG5cdFx0c2VsZi50cmlnZ2VyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IGFyZ3VtZW50c1swXTtcblx0XHRcdGlmICh0eXBlcy5pbmRleE9mKHR5cGUpICE9PSAtMSkge1xuXHRcdFx0XHRldmVudF9hcmdzW3R5cGVdID0gYXJndW1lbnRzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRyaWdnZXIuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcblx0XHQvLyBpbnZva2UgcHJvdmlkZWQgZnVuY3Rpb25cblx0XHRmbi5hcHBseShzZWxmLCBbXSk7XG5cdFx0c2VsZi50cmlnZ2VyID0gdHJpZ2dlcjtcblx0XG5cdFx0Ly8gdHJpZ2dlciBxdWV1ZWQgZXZlbnRzXG5cdFx0Zm9yICh0eXBlIGluIGV2ZW50X2FyZ3MpIHtcblx0XHRcdGlmIChldmVudF9hcmdzLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG5cdFx0XHRcdHRyaWdnZXIuYXBwbHkoc2VsZiwgZXZlbnRfYXJnc1t0eXBlXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEEgd29ya2Fyb3VuZCBmb3IgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNjY5NlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gJHBhcmVudCAtIFBhcmVudCBlbGVtZW50IHRvIGxpc3RlbiBvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gRXZlbnQgbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gRGVzY2VuZGFudCBzZWxlY3RvciB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gRXZlbnQgaGFuZGxlci5cblx0ICovXG5cdHZhciB3YXRjaENoaWxkRXZlbnQgPSBmdW5jdGlvbigkcGFyZW50LCBldmVudCwgc2VsZWN0b3IsIGZuKSB7XG5cdFx0JHBhcmVudC5vbihldmVudCwgc2VsZWN0b3IsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBjaGlsZCA9IGUudGFyZ2V0O1xuXHRcdFx0d2hpbGUgKGNoaWxkICYmIGNoaWxkLnBhcmVudE5vZGUgIT09ICRwYXJlbnRbMF0pIHtcblx0XHRcdFx0Y2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0ZS5jdXJyZW50VGFyZ2V0ID0gY2hpbGQ7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkodGhpcywgW2VdKTtcblx0XHR9KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB3aXRoaW4gYSB0ZXh0IGlucHV0IGNvbnRyb2wuXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmc6XG5cdCAqICAgLSBzdGFydFxuXHQgKiAgIC0gbGVuZ3RoXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fVxuXHQgKi9cblx0dmFyIGdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdFx0dmFyIHJlc3VsdCA9IHt9O1xuXHRcdGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG5cdFx0XHRyZXN1bHQuc3RhcnQgPSBpbnB1dC5zZWxlY3Rpb25TdGFydDtcblx0XHRcdHJlc3VsdC5sZW5ndGggPSBpbnB1dC5zZWxlY3Rpb25FbmQgLSByZXN1bHQuc3RhcnQ7XG5cdFx0fSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcblx0XHRcdGlucHV0LmZvY3VzKCk7XG5cdFx0XHR2YXIgc2VsID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG5cdFx0XHR2YXIgc2VsTGVuID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkudGV4dC5sZW5ndGg7XG5cdFx0XHRzZWwubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKTtcblx0XHRcdHJlc3VsdC5zdGFydCA9IHNlbC50ZXh0Lmxlbmd0aCAtIHNlbExlbjtcblx0XHRcdHJlc3VsdC5sZW5ndGggPSBzZWxMZW47XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ29waWVzIENTUyBwcm9wZXJ0aWVzIGZyb20gb25lIGVsZW1lbnQgdG8gYW5vdGhlci5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9ICRmcm9tXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSAkdG9cblx0ICogQHBhcmFtIHthcnJheX0gcHJvcGVydGllc1xuXHQgKi9cblx0dmFyIHRyYW5zZmVyU3R5bGVzID0gZnVuY3Rpb24oJGZyb20sICR0bywgcHJvcGVydGllcykge1xuXHRcdHZhciBpLCBuLCBzdHlsZXMgPSB7fTtcblx0XHRpZiAocHJvcGVydGllcykge1xuXHRcdFx0Zm9yIChpID0gMCwgbiA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHN0eWxlc1twcm9wZXJ0aWVzW2ldXSA9ICRmcm9tLmNzcyhwcm9wZXJ0aWVzW2ldKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGVzID0gJGZyb20uY3NzKCk7XG5cdFx0fVxuXHRcdCR0by5jc3Moc3R5bGVzKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBNZWFzdXJlcyB0aGUgd2lkdGggb2YgYSBzdHJpbmcgd2l0aGluIGFcblx0ICogcGFyZW50IGVsZW1lbnQgKGluIHBpeGVscykuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcblx0ICogQHBhcmFtIHtvYmplY3R9ICRwYXJlbnRcblx0ICogQHJldHVybnMge2ludH1cblx0ICovXG5cdHZhciBtZWFzdXJlU3RyaW5nID0gZnVuY3Rpb24oc3RyLCAkcGFyZW50KSB7XG5cdFx0aWYgKCFzdHIpIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0XG5cdFx0aWYgKCFTZWxlY3RpemUuJHRlc3RJbnB1dCkge1xuXHRcdFx0U2VsZWN0aXplLiR0ZXN0SW5wdXQgPSAkKCc8c3BhbiAvPicpLmNzcyh7XG5cdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHR0b3A6IC05OTk5OSxcblx0XHRcdFx0bGVmdDogLTk5OTk5LFxuXHRcdFx0XHR3aWR0aDogJ2F1dG8nLFxuXHRcdFx0XHRwYWRkaW5nOiAwLFxuXHRcdFx0XHR3aGl0ZVNwYWNlOiAncHJlJ1xuXHRcdFx0fSkuYXBwZW5kVG8oJ2JvZHknKTtcblx0XHR9XG5cdFxuXHRcdFNlbGVjdGl6ZS4kdGVzdElucHV0LnRleHQoc3RyKTtcblx0XG5cdFx0dHJhbnNmZXJTdHlsZXMoJHBhcmVudCwgU2VsZWN0aXplLiR0ZXN0SW5wdXQsIFtcblx0XHRcdCdsZXR0ZXJTcGFjaW5nJyxcblx0XHRcdCdmb250U2l6ZScsXG5cdFx0XHQnZm9udEZhbWlseScsXG5cdFx0XHQnZm9udFdlaWdodCcsXG5cdFx0XHQndGV4dFRyYW5zZm9ybSdcblx0XHRdKTtcblx0XG5cdFx0cmV0dXJuIFNlbGVjdGl6ZS4kdGVzdElucHV0LndpZHRoKCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0cyB1cCBhbiBpbnB1dCB0byBncm93IGhvcml6b250YWxseSBhcyB0aGUgdXNlclxuXHQgKiB0eXBlcy4gSWYgdGhlIHZhbHVlIGlzIGNoYW5nZWQgbWFudWFsbHksIHlvdSBjYW5cblx0ICogdHJpZ2dlciB0aGUgXCJ1cGRhdGVcIiBoYW5kbGVyIHRvIHJlc2l6ZTpcblx0ICpcblx0ICogJGlucHV0LnRyaWdnZXIoJ3VwZGF0ZScpO1xuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gJGlucHV0XG5cdCAqL1xuXHR2YXIgYXV0b0dyb3cgPSBmdW5jdGlvbigkaW5wdXQpIHtcblx0XHR2YXIgY3VycmVudFdpZHRoID0gbnVsbDtcblx0XG5cdFx0dmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciB2YWx1ZSwga2V5Q29kZSwgcHJpbnRhYmxlLCBwbGFjZWhvbGRlciwgd2lkdGg7XG5cdFx0XHR2YXIgc2hpZnQsIGNoYXJhY3Rlciwgc2VsZWN0aW9uO1xuXHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50IHx8IHt9O1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFxuXHRcdFx0aWYgKGUubWV0YUtleSB8fCBlLmFsdEtleSkgcmV0dXJuO1xuXHRcdFx0aWYgKCFvcHRpb25zLmZvcmNlICYmICRpbnB1dC5kYXRhKCdncm93JykgPT09IGZhbHNlKSByZXR1cm47XG5cdFxuXHRcdFx0dmFsdWUgPSAkaW5wdXQudmFsKCk7XG5cdFx0XHRpZiAoZS50eXBlICYmIGUudHlwZS50b0xvd2VyQ2FzZSgpID09PSAna2V5ZG93bicpIHtcblx0XHRcdFx0a2V5Q29kZSA9IGUua2V5Q29kZTtcblx0XHRcdFx0cHJpbnRhYmxlID0gKFxuXHRcdFx0XHRcdChrZXlDb2RlID49IDQ4ICYmIGtleUNvZGUgPD0gNTcpICB8fCAvLyAwLTlcblx0XHRcdFx0XHQoa2V5Q29kZSA+PSA2NSAmJiBrZXlDb2RlIDw9IDkwKSAgIHx8IC8vIGEtelxuXHRcdFx0XHRcdChrZXlDb2RlID49IDk2ICYmIGtleUNvZGUgPD0gMTExKSAgfHwgLy8gbnVtcGFkIDAtOSwgbnVtZXJpYyBvcGVyYXRvcnNcblx0XHRcdFx0XHQoa2V5Q29kZSA+PSAxODYgJiYga2V5Q29kZSA8PSAyMjIpIHx8IC8vIHNlbWljb2xvbiwgZXF1YWwsIGNvbW1hLCBkYXNoLCBldGMuXG5cdFx0XHRcdFx0a2V5Q29kZSA9PT0gMzIgLy8gc3BhY2Vcblx0XHRcdFx0KTtcblx0XG5cdFx0XHRcdGlmIChrZXlDb2RlID09PSBLRVlfREVMRVRFIHx8IGtleUNvZGUgPT09IEtFWV9CQUNLU1BBQ0UpIHtcblx0XHRcdFx0XHRzZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oJGlucHV0WzBdKTtcblx0XHRcdFx0XHRpZiAoc2VsZWN0aW9uLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uLnN0YXJ0KSArIHZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb24uc3RhcnQgKyBzZWxlY3Rpb24ubGVuZ3RoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGtleUNvZGUgPT09IEtFWV9CQUNLU1BBQ0UgJiYgc2VsZWN0aW9uLnN0YXJ0KSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb24uc3RhcnQgLSAxKSArIHZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb24uc3RhcnQgKyAxKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGtleUNvZGUgPT09IEtFWV9ERUxFVEUgJiYgdHlwZW9mIHNlbGVjdGlvbi5zdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHNlbGVjdGlvbi5zdGFydCkgKyB2YWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uLnN0YXJ0ICsgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHByaW50YWJsZSkge1xuXHRcdFx0XHRcdHNoaWZ0ID0gZS5zaGlmdEtleTtcblx0XHRcdFx0XHRjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUua2V5Q29kZSk7XG5cdFx0XHRcdFx0aWYgKHNoaWZ0KSBjaGFyYWN0ZXIgPSBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcblx0XHRcdFx0XHRlbHNlIGNoYXJhY3RlciA9IGNoYXJhY3Rlci50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdHZhbHVlICs9IGNoYXJhY3Rlcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdHBsYWNlaG9sZGVyID0gJGlucHV0LmF0dHIoJ3BsYWNlaG9sZGVyJyk7XG5cdFx0XHRpZiAoIXZhbHVlICYmIHBsYWNlaG9sZGVyKSB7XG5cdFx0XHRcdHZhbHVlID0gcGxhY2Vob2xkZXI7XG5cdFx0XHR9XG5cdFxuXHRcdFx0d2lkdGggPSBtZWFzdXJlU3RyaW5nKHZhbHVlLCAkaW5wdXQpICsgNDtcblx0XHRcdGlmICh3aWR0aCAhPT0gY3VycmVudFdpZHRoKSB7XG5cdFx0XHRcdGN1cnJlbnRXaWR0aCA9IHdpZHRoO1xuXHRcdFx0XHQkaW5wdXQud2lkdGgod2lkdGgpO1xuXHRcdFx0XHQkaW5wdXQudHJpZ2dlckhhbmRsZXIoJ3Jlc2l6ZScpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdCRpbnB1dC5vbigna2V5ZG93biBrZXl1cCB1cGRhdGUgYmx1cicsIHVwZGF0ZSk7XG5cdFx0dXBkYXRlKCk7XG5cdH07XG5cdFxuXHR2YXIgZG9tVG9TdHJpbmcgPSBmdW5jdGlvbihkKSB7XG5cdFx0dmFyIHRtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcblx0XHR0bXAuYXBwZW5kQ2hpbGQoZC5jbG9uZU5vZGUodHJ1ZSkpO1xuXHRcblx0XHRyZXR1cm4gdG1wLmlubmVySFRNTDtcblx0fTtcblx0XG5cdHZhciBsb2dFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG9wdGlvbnMpe1xuXHRcdGlmKCFvcHRpb25zKSBvcHRpb25zID0ge307XG5cdFx0dmFyIGNvbXBvbmVudCA9IFwiU2VsZWN0aXplXCI7XG5cdFxuXHRcdGNvbnNvbGUuZXJyb3IoY29tcG9uZW50ICsgXCI6IFwiICsgbWVzc2FnZSlcblx0XG5cdFx0aWYob3B0aW9ucy5leHBsYW5hdGlvbil7XG5cdFx0XHQvLyBjb25zb2xlLmdyb3VwIGlzIHVuZGVmaW5lZCBpbiA8SUUxMVxuXHRcdFx0aWYoY29uc29sZS5ncm91cCkgY29uc29sZS5ncm91cCgpO1xuXHRcdFx0Y29uc29sZS5lcnJvcihvcHRpb25zLmV4cGxhbmF0aW9uKTtcblx0XHRcdGlmKGNvbnNvbGUuZ3JvdXApIGNvbnNvbGUuZ3JvdXBFbmQoKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHR2YXIgU2VsZWN0aXplID0gZnVuY3Rpb24oJGlucHV0LCBzZXR0aW5ncykge1xuXHRcdHZhciBrZXksIGksIG4sIGRpciwgaW5wdXQsIHNlbGYgPSB0aGlzO1xuXHRcdGlucHV0ID0gJGlucHV0WzBdO1xuXHRcdGlucHV0LnNlbGVjdGl6ZSA9IHNlbGY7XG5cdFxuXHRcdC8vIGRldGVjdCBydGwgZW52aXJvbm1lbnRcblx0XHR2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGlucHV0LCBudWxsKTtcblx0XHRkaXIgPSBjb21wdXRlZFN0eWxlID8gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSA6IGlucHV0LmN1cnJlbnRTdHlsZSAmJiBpbnB1dC5jdXJyZW50U3R5bGUuZGlyZWN0aW9uO1xuXHRcdGRpciA9IGRpciB8fCAkaW5wdXQucGFyZW50cygnW2Rpcl06Zmlyc3QnKS5hdHRyKCdkaXInKSB8fCAnJztcblx0XG5cdFx0Ly8gc2V0dXAgZGVmYXVsdCBzdGF0ZVxuXHRcdCQuZXh0ZW5kKHNlbGYsIHtcblx0XHRcdG9yZGVyICAgICAgICAgICAgOiAwLFxuXHRcdFx0c2V0dGluZ3MgICAgICAgICA6IHNldHRpbmdzLFxuXHRcdFx0JGlucHV0ICAgICAgICAgICA6ICRpbnB1dCxcblx0XHRcdHRhYkluZGV4ICAgICAgICAgOiAkaW5wdXQuYXR0cigndGFiaW5kZXgnKSB8fCAnJyxcblx0XHRcdHRhZ1R5cGUgICAgICAgICAgOiBpbnB1dC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnID8gVEFHX1NFTEVDVCA6IFRBR19JTlBVVCxcblx0XHRcdHJ0bCAgICAgICAgICAgICAgOiAvcnRsL2kudGVzdChkaXIpLFxuXHRcblx0XHRcdGV2ZW50TlMgICAgICAgICAgOiAnLnNlbGVjdGl6ZScgKyAoKytTZWxlY3RpemUuY291bnQpLFxuXHRcdFx0aGlnaGxpZ2h0ZWRWYWx1ZSA6IG51bGwsXG5cdFx0XHRpc0JsdXJyaW5nICAgICAgIDogZmFsc2UsXG5cdFx0XHRpc09wZW4gICAgICAgICAgIDogZmFsc2UsXG5cdFx0XHRpc0Rpc2FibGVkICAgICAgIDogZmFsc2UsXG5cdFx0XHRpc1JlcXVpcmVkICAgICAgIDogJGlucHV0LmlzKCdbcmVxdWlyZWRdJyksXG5cdFx0XHRpc0ludmFsaWQgICAgICAgIDogZmFsc2UsXG5cdFx0XHRpc0xvY2tlZCAgICAgICAgIDogZmFsc2UsXG5cdFx0XHRpc0ZvY3VzZWQgICAgICAgIDogZmFsc2UsXG5cdFx0XHRpc0lucHV0SGlkZGVuICAgIDogZmFsc2UsXG5cdFx0XHRpc1NldHVwICAgICAgICAgIDogZmFsc2UsXG5cdFx0XHRpc1NoaWZ0RG93biAgICAgIDogZmFsc2UsXG5cdFx0XHRpc0NtZERvd24gICAgICAgIDogZmFsc2UsXG5cdFx0XHRpc0N0cmxEb3duICAgICAgIDogZmFsc2UsXG5cdFx0XHRpZ25vcmVGb2N1cyAgICAgIDogZmFsc2UsXG5cdFx0XHRpZ25vcmVCbHVyICAgICAgIDogZmFsc2UsXG5cdFx0XHRpZ25vcmVIb3ZlciAgICAgIDogZmFsc2UsXG5cdFx0XHRoYXNPcHRpb25zICAgICAgIDogZmFsc2UsXG5cdFx0XHRjdXJyZW50UmVzdWx0cyAgIDogbnVsbCxcblx0XHRcdGxhc3RWYWx1ZSAgICAgICAgOiAnJyxcblx0XHRcdGNhcmV0UG9zICAgICAgICAgOiAwLFxuXHRcdFx0bG9hZGluZyAgICAgICAgICA6IDAsXG5cdFx0XHRsb2FkZWRTZWFyY2hlcyAgIDoge30sXG5cdFxuXHRcdFx0JGFjdGl2ZU9wdGlvbiAgICA6IG51bGwsXG5cdFx0XHQkYWN0aXZlSXRlbXMgICAgIDogW10sXG5cdFxuXHRcdFx0b3B0Z3JvdXBzICAgICAgICA6IHt9LFxuXHRcdFx0b3B0aW9ucyAgICAgICAgICA6IHt9LFxuXHRcdFx0dXNlck9wdGlvbnMgICAgICA6IHt9LFxuXHRcdFx0aXRlbXMgICAgICAgICAgICA6IFtdLFxuXHRcdFx0cmVuZGVyQ2FjaGUgICAgICA6IHt9LFxuXHRcdFx0b25TZWFyY2hDaGFuZ2UgICA6IHNldHRpbmdzLmxvYWRUaHJvdHRsZSA9PT0gbnVsbCA/IHNlbGYub25TZWFyY2hDaGFuZ2UgOiBkZWJvdW5jZShzZWxmLm9uU2VhcmNoQ2hhbmdlLCBzZXR0aW5ncy5sb2FkVGhyb3R0bGUpXG5cdFx0fSk7XG5cdFxuXHRcdC8vIHNlYXJjaCBzeXN0ZW1cblx0XHRzZWxmLnNpZnRlciA9IG5ldyBTaWZ0ZXIodGhpcy5vcHRpb25zLCB7ZGlhY3JpdGljczogc2V0dGluZ3MuZGlhY3JpdGljc30pO1xuXHRcblx0XHQvLyBidWlsZCBvcHRpb25zIHRhYmxlXG5cdFx0aWYgKHNlbGYuc2V0dGluZ3Mub3B0aW9ucykge1xuXHRcdFx0Zm9yIChpID0gMCwgbiA9IHNlbGYuc2V0dGluZ3Mub3B0aW9ucy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0c2VsZi5yZWdpc3Rlck9wdGlvbihzZWxmLnNldHRpbmdzLm9wdGlvbnNbaV0pO1xuXHRcdFx0fVxuXHRcdFx0ZGVsZXRlIHNlbGYuc2V0dGluZ3Mub3B0aW9ucztcblx0XHR9XG5cdFxuXHRcdC8vIGJ1aWxkIG9wdGdyb3VwIHRhYmxlXG5cdFx0aWYgKHNlbGYuc2V0dGluZ3Mub3B0Z3JvdXBzKSB7XG5cdFx0XHRmb3IgKGkgPSAwLCBuID0gc2VsZi5zZXR0aW5ncy5vcHRncm91cHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHNlbGYucmVnaXN0ZXJPcHRpb25Hcm91cChzZWxmLnNldHRpbmdzLm9wdGdyb3Vwc1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgc2VsZi5zZXR0aW5ncy5vcHRncm91cHM7XG5cdFx0fVxuXHRcblx0XHQvLyBvcHRpb24tZGVwZW5kZW50IGRlZmF1bHRzXG5cdFx0c2VsZi5zZXR0aW5ncy5tb2RlID0gc2VsZi5zZXR0aW5ncy5tb2RlIHx8IChzZWxmLnNldHRpbmdzLm1heEl0ZW1zID09PSAxID8gJ3NpbmdsZScgOiAnbXVsdGknKTtcblx0XHRpZiAodHlwZW9mIHNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkICE9PSAnYm9vbGVhbicpIHtcblx0XHRcdHNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkID0gc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnbXVsdGknO1xuXHRcdH1cblx0XG5cdFx0c2VsZi5pbml0aWFsaXplUGx1Z2lucyhzZWxmLnNldHRpbmdzLnBsdWdpbnMpO1xuXHRcdHNlbGYuc2V0dXBDYWxsYmFja3MoKTtcblx0XHRzZWxmLnNldHVwVGVtcGxhdGVzKCk7XG5cdFx0c2VsZi5zZXR1cCgpO1xuXHR9O1xuXHRcblx0Ly8gbWl4aW5zXG5cdC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cdFxuXHRNaWNyb0V2ZW50Lm1peGluKFNlbGVjdGl6ZSk7XG5cdFxuXHRpZih0eXBlb2YgTWljcm9QbHVnaW4gIT09IFwidW5kZWZpbmVkXCIpe1xuXHRcdE1pY3JvUGx1Z2luLm1peGluKFNlbGVjdGl6ZSk7XG5cdH1lbHNle1xuXHRcdGxvZ0Vycm9yKFwiRGVwZW5kZW5jeSBNaWNyb1BsdWdpbiBpcyBtaXNzaW5nXCIsXG5cdFx0XHR7ZXhwbGFuYXRpb246XG5cdFx0XHRcdFwiTWFrZSBzdXJlIHlvdSBlaXRoZXI6ICgxKSBhcmUgdXNpbmcgdGhlIFxcXCJzdGFuZGFsb25lXFxcIiBcIitcblx0XHRcdFx0XCJ2ZXJzaW9uIG9mIFNlbGVjdGl6ZSwgb3IgKDIpIHJlcXVpcmUgTWljcm9QbHVnaW4gYmVmb3JlIHlvdSBcIitcblx0XHRcdFx0XCJsb2FkIFNlbGVjdGl6ZS5cIn1cblx0XHQpO1xuXHR9XG5cdFxuXHRcblx0Ly8gbWV0aG9kc1xuXHQvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuXHRcblx0JC5leHRlbmQoU2VsZWN0aXplLnByb3RvdHlwZSwge1xuXHRcblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGFsbCBlbGVtZW50cyBhbmQgc2V0cyB1cCBldmVudCBiaW5kaW5ncy5cblx0XHQgKi9cblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiAgICAgID0gdGhpcztcblx0XHRcdHZhciBzZXR0aW5ncyAgPSBzZWxmLnNldHRpbmdzO1xuXHRcdFx0dmFyIGV2ZW50TlMgICA9IHNlbGYuZXZlbnROUztcblx0XHRcdHZhciAkd2luZG93ICAgPSAkKHdpbmRvdyk7XG5cdFx0XHR2YXIgJGRvY3VtZW50ID0gJChkb2N1bWVudCk7XG5cdFx0XHR2YXIgJGlucHV0ICAgID0gc2VsZi4kaW5wdXQ7XG5cdFxuXHRcdFx0dmFyICR3cmFwcGVyO1xuXHRcdFx0dmFyICRjb250cm9sO1xuXHRcdFx0dmFyICRjb250cm9sX2lucHV0O1xuXHRcdFx0dmFyICRkcm9wZG93bjtcblx0XHRcdHZhciAkZHJvcGRvd25fY29udGVudDtcblx0XHRcdHZhciAkZHJvcGRvd25fcGFyZW50O1xuXHRcdFx0dmFyIGlucHV0TW9kZTtcblx0XHRcdHZhciB0aW1lb3V0X2JsdXI7XG5cdFx0XHR2YXIgdGltZW91dF9mb2N1cztcblx0XHRcdHZhciBjbGFzc2VzO1xuXHRcdFx0dmFyIGNsYXNzZXNfcGx1Z2lucztcblx0XHRcdHZhciBpbnB1dElkO1xuXHRcblx0XHRcdGlucHV0TW9kZSAgICAgICAgID0gc2VsZi5zZXR0aW5ncy5tb2RlO1xuXHRcdFx0Y2xhc3NlcyAgICAgICAgICAgPSAkaW5wdXQuYXR0cignY2xhc3MnKSB8fCAnJztcblx0XG5cdFx0XHQkd3JhcHBlciAgICAgICAgICA9ICQoJzxkaXY+JykuYWRkQ2xhc3Moc2V0dGluZ3Mud3JhcHBlckNsYXNzKS5hZGRDbGFzcyhjbGFzc2VzKS5hZGRDbGFzcyhpbnB1dE1vZGUpO1xuXHRcdFx0JGNvbnRyb2wgICAgICAgICAgPSAkKCc8ZGl2PicpLmFkZENsYXNzKHNldHRpbmdzLmlucHV0Q2xhc3MpLmFkZENsYXNzKCdpdGVtcycpLmFwcGVuZFRvKCR3cmFwcGVyKTtcblx0XHRcdCRjb250cm9sX2lucHV0ICAgID0gJCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgLz4nKS5hcHBlbmRUbygkY29udHJvbCkuYXR0cigndGFiaW5kZXgnLCAkaW5wdXQuaXMoJzpkaXNhYmxlZCcpID8gJy0xJyA6IHNlbGYudGFiSW5kZXgpO1xuXHRcdFx0JGRyb3Bkb3duX3BhcmVudCAgPSAkKHNldHRpbmdzLmRyb3Bkb3duUGFyZW50IHx8ICR3cmFwcGVyKTtcblx0XHRcdCRkcm9wZG93biAgICAgICAgID0gJCgnPGRpdj4nKS5hZGRDbGFzcyhzZXR0aW5ncy5kcm9wZG93bkNsYXNzKS5hZGRDbGFzcyhpbnB1dE1vZGUpLmhpZGUoKS5hcHBlbmRUbygkZHJvcGRvd25fcGFyZW50KTtcblx0XHRcdCRkcm9wZG93bl9jb250ZW50ID0gJCgnPGRpdj4nKS5hZGRDbGFzcyhzZXR0aW5ncy5kcm9wZG93bkNvbnRlbnRDbGFzcykuYXBwZW5kVG8oJGRyb3Bkb3duKTtcblx0XG5cdFx0XHRpZihpbnB1dElkID0gJGlucHV0LmF0dHIoJ2lkJykpIHtcblx0XHRcdFx0JGNvbnRyb2xfaW5wdXQuYXR0cignaWQnLCBpbnB1dElkICsgJy1zZWxlY3RpemVkJyk7XG5cdFx0XHRcdCQoXCJsYWJlbFtmb3I9J1wiK2lucHV0SWQrXCInXVwiKS5hdHRyKCdmb3InLCBpbnB1dElkICsgJy1zZWxlY3RpemVkJyk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYoc2VsZi5zZXR0aW5ncy5jb3B5Q2xhc3Nlc1RvRHJvcGRvd24pIHtcblx0XHRcdFx0JGRyb3Bkb3duLmFkZENsYXNzKGNsYXNzZXMpO1xuXHRcdFx0fVxuXHRcblx0XHRcdCR3cmFwcGVyLmNzcyh7XG5cdFx0XHRcdHdpZHRoOiAkaW5wdXRbMF0uc3R5bGUud2lkdGhcblx0XHRcdH0pO1xuXHRcblx0XHRcdGlmIChzZWxmLnBsdWdpbnMubmFtZXMubGVuZ3RoKSB7XG5cdFx0XHRcdGNsYXNzZXNfcGx1Z2lucyA9ICdwbHVnaW4tJyArIHNlbGYucGx1Z2lucy5uYW1lcy5qb2luKCcgcGx1Z2luLScpO1xuXHRcdFx0XHQkd3JhcHBlci5hZGRDbGFzcyhjbGFzc2VzX3BsdWdpbnMpO1xuXHRcdFx0XHQkZHJvcGRvd24uYWRkQ2xhc3MoY2xhc3Nlc19wbHVnaW5zKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoKHNldHRpbmdzLm1heEl0ZW1zID09PSBudWxsIHx8IHNldHRpbmdzLm1heEl0ZW1zID4gMSkgJiYgc2VsZi50YWdUeXBlID09PSBUQUdfU0VMRUNUKSB7XG5cdFx0XHRcdCRpbnB1dC5hdHRyKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmIChzZWxmLnNldHRpbmdzLnBsYWNlaG9sZGVyKSB7XG5cdFx0XHRcdCRjb250cm9sX2lucHV0LmF0dHIoJ3BsYWNlaG9sZGVyJywgc2V0dGluZ3MucGxhY2Vob2xkZXIpO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIGlmIHNwbGl0T24gd2FzIG5vdCBwYXNzZWQgaW4sIGNvbnN0cnVjdCBpdCBmcm9tIHRoZSBkZWxpbWl0ZXIgdG8gYWxsb3cgcGFzdGluZyB1bml2ZXJzYWxseVxuXHRcdFx0aWYgKCFzZWxmLnNldHRpbmdzLnNwbGl0T24gJiYgc2VsZi5zZXR0aW5ncy5kZWxpbWl0ZXIpIHtcblx0XHRcdFx0dmFyIGRlbGltaXRlckVzY2FwZWQgPSBzZWxmLnNldHRpbmdzLmRlbGltaXRlci5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcblx0XHRcdFx0c2VsZi5zZXR0aW5ncy5zcGxpdE9uID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGRlbGltaXRlckVzY2FwZWQgKyAnK1xcXFxzKicpO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICgkaW5wdXQuYXR0cignYXV0b2NvcnJlY3QnKSkge1xuXHRcdFx0XHQkY29udHJvbF9pbnB1dC5hdHRyKCdhdXRvY29ycmVjdCcsICRpbnB1dC5hdHRyKCdhdXRvY29ycmVjdCcpKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoJGlucHV0LmF0dHIoJ2F1dG9jYXBpdGFsaXplJykpIHtcblx0XHRcdFx0JGNvbnRyb2xfaW5wdXQuYXR0cignYXV0b2NhcGl0YWxpemUnLCAkaW5wdXQuYXR0cignYXV0b2NhcGl0YWxpemUnKSk7XG5cdFx0XHR9XG5cdFx0XHQkY29udHJvbF9pbnB1dFswXS50eXBlID0gJGlucHV0WzBdLnR5cGU7XG5cdFxuXHRcdFx0c2VsZi4kd3JhcHBlciAgICAgICAgICA9ICR3cmFwcGVyO1xuXHRcdFx0c2VsZi4kY29udHJvbCAgICAgICAgICA9ICRjb250cm9sO1xuXHRcdFx0c2VsZi4kY29udHJvbF9pbnB1dCAgICA9ICRjb250cm9sX2lucHV0O1xuXHRcdFx0c2VsZi4kZHJvcGRvd24gICAgICAgICA9ICRkcm9wZG93bjtcblx0XHRcdHNlbGYuJGRyb3Bkb3duX2NvbnRlbnQgPSAkZHJvcGRvd25fY29udGVudDtcblx0XG5cdFx0XHQkZHJvcGRvd24ub24oJ21vdXNlZW50ZXIgbW91c2Vkb3duIGNsaWNrJywgJ1tkYXRhLWRpc2FibGVkXT5bZGF0YS1zZWxlY3RhYmxlXScsIGZ1bmN0aW9uKGUpIHsgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTsgfSk7XG5cdFx0XHQkZHJvcGRvd24ub24oJ21vdXNlZW50ZXInLCAnW2RhdGEtc2VsZWN0YWJsZV0nLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYub25PcHRpb25Ib3Zlci5hcHBseShzZWxmLCBhcmd1bWVudHMpOyB9KTtcblx0XHRcdCRkcm9wZG93bi5vbignbW91c2Vkb3duIGNsaWNrJywgJ1tkYXRhLXNlbGVjdGFibGVdJywgZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLm9uT3B0aW9uU2VsZWN0LmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7IH0pO1xuXHRcdFx0d2F0Y2hDaGlsZEV2ZW50KCRjb250cm9sLCAnbW91c2Vkb3duJywgJyo6bm90KGlucHV0KScsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5vbkl0ZW1TZWxlY3QuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTsgfSk7XG5cdFx0XHRhdXRvR3JvdygkY29udHJvbF9pbnB1dCk7XG5cdFxuXHRcdFx0JGNvbnRyb2wub24oe1xuXHRcdFx0XHRtb3VzZWRvd24gOiBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYub25Nb3VzZURvd24uYXBwbHkoc2VsZiwgYXJndW1lbnRzKTsgfSxcblx0XHRcdFx0Y2xpY2sgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLm9uQ2xpY2suYXBwbHkoc2VsZiwgYXJndW1lbnRzKTsgfVxuXHRcdFx0fSk7XG5cdFxuXHRcdFx0JGNvbnRyb2xfaW5wdXQub24oe1xuXHRcdFx0XHRtb3VzZWRvd24gOiBmdW5jdGlvbihlKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCk7IH0sXG5cdFx0XHRcdGtleWRvd24gICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5vbktleURvd24uYXBwbHkoc2VsZiwgYXJndW1lbnRzKTsgfSxcblx0XHRcdFx0a2V5dXAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLm9uS2V5VXAuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTsgfSxcblx0XHRcdFx0a2V5cHJlc3MgIDogZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLm9uS2V5UHJlc3MuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTsgfSxcblx0XHRcdFx0cmVzaXplICAgIDogZnVuY3Rpb24oKSB7IHNlbGYucG9zaXRpb25Ecm9wZG93bi5hcHBseShzZWxmLCBbXSk7IH0sXG5cdFx0XHRcdGJsdXIgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5vbkJsdXIuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTsgfSxcblx0XHRcdFx0Zm9jdXMgICAgIDogZnVuY3Rpb24oKSB7IHNlbGYuaWdub3JlQmx1ciA9IGZhbHNlOyByZXR1cm4gc2VsZi5vbkZvY3VzLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7IH0sXG5cdFx0XHRcdHBhc3RlICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5vblBhc3RlLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7IH1cblx0XHRcdH0pO1xuXHRcblx0XHRcdCRkb2N1bWVudC5vbigna2V5ZG93bicgKyBldmVudE5TLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHNlbGYuaXNDbWREb3duID0gZVtJU19NQUMgPyAnbWV0YUtleScgOiAnY3RybEtleSddO1xuXHRcdFx0XHRzZWxmLmlzQ3RybERvd24gPSBlW0lTX01BQyA/ICdhbHRLZXknIDogJ2N0cmxLZXknXTtcblx0XHRcdFx0c2VsZi5pc1NoaWZ0RG93biA9IGUuc2hpZnRLZXk7XG5cdFx0XHR9KTtcblx0XG5cdFx0XHQkZG9jdW1lbnQub24oJ2tleXVwJyArIGV2ZW50TlMsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0aWYgKGUua2V5Q29kZSA9PT0gS0VZX0NUUkwpIHNlbGYuaXNDdHJsRG93biA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoZS5rZXlDb2RlID09PSBLRVlfU0hJRlQpIHNlbGYuaXNTaGlmdERvd24gPSBmYWxzZTtcblx0XHRcdFx0aWYgKGUua2V5Q29kZSA9PT0gS0VZX0NNRCkgc2VsZi5pc0NtZERvd24gPSBmYWxzZTtcblx0XHRcdH0pO1xuXHRcblx0XHRcdCRkb2N1bWVudC5vbignbW91c2Vkb3duJyArIGV2ZW50TlMsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0aWYgKHNlbGYuaXNGb2N1c2VkKSB7XG5cdFx0XHRcdFx0Ly8gcHJldmVudCBldmVudHMgb24gdGhlIGRyb3Bkb3duIHNjcm9sbGJhciBmcm9tIGNhdXNpbmcgdGhlIGNvbnRyb2wgdG8gYmx1clxuXHRcdFx0XHRcdGlmIChlLnRhcmdldCA9PT0gc2VsZi4kZHJvcGRvd25bMF0gfHwgZS50YXJnZXQucGFyZW50Tm9kZSA9PT0gc2VsZi4kZHJvcGRvd25bMF0pIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gYmx1ciBvbiBjbGljayBvdXRzaWRlXG5cdFx0XHRcdFx0aWYgKCFzZWxmLiRjb250cm9sLmhhcyhlLnRhcmdldCkubGVuZ3RoICYmIGUudGFyZ2V0ICE9PSBzZWxmLiRjb250cm9sWzBdKSB7XG5cdFx0XHRcdFx0XHRzZWxmLmJsdXIoZS50YXJnZXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFxuXHRcdFx0JHdpbmRvdy5vbihbJ3Njcm9sbCcgKyBldmVudE5TLCAncmVzaXplJyArIGV2ZW50TlNdLmpvaW4oJyAnKSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChzZWxmLmlzT3Blbikge1xuXHRcdFx0XHRcdHNlbGYucG9zaXRpb25Ecm9wZG93bi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdCR3aW5kb3cub24oJ21vdXNlbW92ZScgKyBldmVudE5TLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5pZ25vcmVIb3ZlciA9IGZhbHNlO1xuXHRcdFx0fSk7XG5cdFxuXHRcdFx0Ly8gc3RvcmUgb3JpZ2luYWwgY2hpbGRyZW4gYW5kIHRhYiBpbmRleCBzbyB0aGF0IHRoZXkgY2FuIGJlXG5cdFx0XHQvLyByZXN0b3JlZCB3aGVuIHRoZSBkZXN0cm95KCkgbWV0aG9kIGlzIGNhbGxlZC5cblx0XHRcdHRoaXMucmV2ZXJ0U2V0dGluZ3MgPSB7XG5cdFx0XHRcdCRjaGlsZHJlbiA6ICRpbnB1dC5jaGlsZHJlbigpLmRldGFjaCgpLFxuXHRcdFx0XHR0YWJpbmRleCAgOiAkaW5wdXQuYXR0cigndGFiaW5kZXgnKVxuXHRcdFx0fTtcblx0XG5cdFx0XHQkaW5wdXQuYXR0cigndGFiaW5kZXgnLCAtMSkuaGlkZSgpLmFmdGVyKHNlbGYuJHdyYXBwZXIpO1xuXHRcblx0XHRcdGlmICgkLmlzQXJyYXkoc2V0dGluZ3MuaXRlbXMpKSB7XG5cdFx0XHRcdHNlbGYuc2V0VmFsdWUoc2V0dGluZ3MuaXRlbXMpO1xuXHRcdFx0XHRkZWxldGUgc2V0dGluZ3MuaXRlbXM7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gZmVhdHVyZSBkZXRlY3QgZm9yIHRoZSB2YWxpZGF0aW9uIEFQSVxuXHRcdFx0aWYgKFNVUFBPUlRTX1ZBTElESVRZX0FQSSkge1xuXHRcdFx0XHQkaW5wdXQub24oJ2ludmFsaWQnICsgZXZlbnROUywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRzZWxmLmlzSW52YWxpZCA9IHRydWU7XG5cdFx0XHRcdFx0c2VsZi5yZWZyZXNoU3RhdGUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0c2VsZi51cGRhdGVPcmlnaW5hbElucHV0KCk7XG5cdFx0XHRzZWxmLnJlZnJlc2hJdGVtcygpO1xuXHRcdFx0c2VsZi5yZWZyZXNoU3RhdGUoKTtcblx0XHRcdHNlbGYudXBkYXRlUGxhY2Vob2xkZXIoKTtcblx0XHRcdHNlbGYuaXNTZXR1cCA9IHRydWU7XG5cdFxuXHRcdFx0aWYgKCRpbnB1dC5pcygnOmRpc2FibGVkJykpIHtcblx0XHRcdFx0c2VsZi5kaXNhYmxlKCk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0c2VsZi5vbignY2hhbmdlJywgdGhpcy5vbkNoYW5nZSk7XG5cdFxuXHRcdFx0JGlucHV0LmRhdGEoJ3NlbGVjdGl6ZScsIHNlbGYpO1xuXHRcdFx0JGlucHV0LmFkZENsYXNzKCdzZWxlY3RpemVkJyk7XG5cdFx0XHRzZWxmLnRyaWdnZXIoJ2luaXRpYWxpemUnKTtcblx0XG5cdFx0XHQvLyBwcmVsb2FkIG9wdGlvbnNcblx0XHRcdGlmIChzZXR0aW5ncy5wcmVsb2FkID09PSB0cnVlKSB7XG5cdFx0XHRcdHNlbGYub25TZWFyY2hDaGFuZ2UoJycpO1xuXHRcdFx0fVxuXHRcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBTZXRzIHVwIGRlZmF1bHQgcmVuZGVyaW5nIGZ1bmN0aW9ucy5cblx0XHQgKi9cblx0XHRzZXR1cFRlbXBsYXRlczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR2YXIgZmllbGRfbGFiZWwgPSBzZWxmLnNldHRpbmdzLmxhYmVsRmllbGQ7XG5cdFx0XHR2YXIgZmllbGRfb3B0Z3JvdXAgPSBzZWxmLnNldHRpbmdzLm9wdGdyb3VwTGFiZWxGaWVsZDtcblx0XG5cdFx0XHR2YXIgdGVtcGxhdGVzID0ge1xuXHRcdFx0XHQnb3B0Z3JvdXAnOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdFx0cmV0dXJuICc8ZGl2IGNsYXNzPVwib3B0Z3JvdXBcIj4nICsgZGF0YS5odG1sICsgJzwvZGl2Pic7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdvcHRncm91cF9oZWFkZXInOiBmdW5jdGlvbihkYXRhLCBlc2NhcGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gJzxkaXYgY2xhc3M9XCJvcHRncm91cC1oZWFkZXJcIj4nICsgZXNjYXBlKGRhdGFbZmllbGRfb3B0Z3JvdXBdKSArICc8L2Rpdj4nO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQnb3B0aW9uJzogZnVuY3Rpb24oZGF0YSwgZXNjYXBlKSB7XG5cdFx0XHRcdFx0cmV0dXJuICc8ZGl2IGNsYXNzPVwib3B0aW9uXCI+JyArIGVzY2FwZShkYXRhW2ZpZWxkX2xhYmVsXSkgKyAnPC9kaXY+Jztcblx0XHRcdFx0fSxcblx0XHRcdFx0J2l0ZW0nOiBmdW5jdGlvbihkYXRhLCBlc2NhcGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gJzxkaXYgY2xhc3M9XCJpdGVtXCI+JyArIGVzY2FwZShkYXRhW2ZpZWxkX2xhYmVsXSkgKyAnPC9kaXY+Jztcblx0XHRcdFx0fSxcblx0XHRcdFx0J29wdGlvbl9jcmVhdGUnOiBmdW5jdGlvbihkYXRhLCBlc2NhcGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gJzxkaXYgY2xhc3M9XCJjcmVhdGVcIj5BZGQgPHN0cm9uZz4nICsgZXNjYXBlKGRhdGEuaW5wdXQpICsgJzwvc3Ryb25nPiZoZWxsaXA7PC9kaXY+Jztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XG5cdFx0XHRzZWxmLnNldHRpbmdzLnJlbmRlciA9ICQuZXh0ZW5kKHt9LCB0ZW1wbGF0ZXMsIHNlbGYuc2V0dGluZ3MucmVuZGVyKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBNYXBzIGZpcmVkIGV2ZW50cyB0byBjYWxsYmFja3MgcHJvdmlkZWRcblx0XHQgKiBpbiB0aGUgc2V0dGluZ3MgdXNlZCB3aGVuIGNyZWF0aW5nIHRoZSBjb250cm9sLlxuXHRcdCAqL1xuXHRcdHNldHVwQ2FsbGJhY2tzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBrZXksIGZuLCBjYWxsYmFja3MgPSB7XG5cdFx0XHRcdCdpbml0aWFsaXplJyAgICAgIDogJ29uSW5pdGlhbGl6ZScsXG5cdFx0XHRcdCdjaGFuZ2UnICAgICAgICAgIDogJ29uQ2hhbmdlJyxcblx0XHRcdFx0J2l0ZW1fYWRkJyAgICAgICAgOiAnb25JdGVtQWRkJyxcblx0XHRcdFx0J2l0ZW1fcmVtb3ZlJyAgICAgOiAnb25JdGVtUmVtb3ZlJyxcblx0XHRcdFx0J2NsZWFyJyAgICAgICAgICAgOiAnb25DbGVhcicsXG5cdFx0XHRcdCdvcHRpb25fYWRkJyAgICAgIDogJ29uT3B0aW9uQWRkJyxcblx0XHRcdFx0J29wdGlvbl9yZW1vdmUnICAgOiAnb25PcHRpb25SZW1vdmUnLFxuXHRcdFx0XHQnb3B0aW9uX2NsZWFyJyAgICA6ICdvbk9wdGlvbkNsZWFyJyxcblx0XHRcdFx0J29wdGdyb3VwX2FkZCcgICAgOiAnb25PcHRpb25Hcm91cEFkZCcsXG5cdFx0XHRcdCdvcHRncm91cF9yZW1vdmUnIDogJ29uT3B0aW9uR3JvdXBSZW1vdmUnLFxuXHRcdFx0XHQnb3B0Z3JvdXBfY2xlYXInICA6ICdvbk9wdGlvbkdyb3VwQ2xlYXInLFxuXHRcdFx0XHQnZHJvcGRvd25fb3BlbicgICA6ICdvbkRyb3Bkb3duT3BlbicsXG5cdFx0XHRcdCdkcm9wZG93bl9jbG9zZScgIDogJ29uRHJvcGRvd25DbG9zZScsXG5cdFx0XHRcdCd0eXBlJyAgICAgICAgICAgIDogJ29uVHlwZScsXG5cdFx0XHRcdCdsb2FkJyAgICAgICAgICAgIDogJ29uTG9hZCcsXG5cdFx0XHRcdCdmb2N1cycgICAgICAgICAgIDogJ29uRm9jdXMnLFxuXHRcdFx0XHQnYmx1cicgICAgICAgICAgICA6ICdvbkJsdXInXG5cdFx0XHR9O1xuXHRcblx0XHRcdGZvciAoa2V5IGluIGNhbGxiYWNrcykge1xuXHRcdFx0XHRpZiAoY2FsbGJhY2tzLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRmbiA9IHRoaXMuc2V0dGluZ3NbY2FsbGJhY2tzW2tleV1dO1xuXHRcdFx0XHRcdGlmIChmbikgdGhpcy5vbihrZXksIGZuKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRyaWdnZXJlZCB3aGVuIHRoZSBtYWluIGNvbnRyb2wgZWxlbWVudFxuXHRcdCAqIGhhcyBhIGNsaWNrIGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGVcblx0XHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdG9uQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XG5cdFx0XHQvLyBuZWNlc3NhcnkgZm9yIG1vYmlsZSB3ZWJraXQgZGV2aWNlcyAobWFudWFsIGZvY3VzIHRyaWdnZXJpbmdcblx0XHRcdC8vIGlzIGlnbm9yZWQgdW5sZXNzIGludm9rZWQgd2l0aGluIGEgY2xpY2sgZXZlbnQpXG5cdCAgICAvLyBhbHNvIG5lY2Vzc2FyeSB0byByZW9wZW4gYSBkcm9wZG93biB0aGF0IGhhcyBiZWVuIGNsb3NlZCBieVxuXHQgICAgLy8gY2xvc2VBZnRlclNlbGVjdFxuXHRcdFx0aWYgKCFzZWxmLmlzRm9jdXNlZCB8fCAhc2VsZi5pc09wZW4pIHtcblx0XHRcdFx0c2VsZi5mb2N1cygpO1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlcmVkIHdoZW4gdGhlIG1haW4gY29udHJvbCBlbGVtZW50XG5cdFx0ICogaGFzIGEgbW91c2UgZG93biBldmVudC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBlXG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHRvbk1vdXNlRG93bjogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBlLmlzRGVmYXVsdFByZXZlbnRlZCgpO1xuXHRcdFx0dmFyICR0YXJnZXQgPSAkKGUudGFyZ2V0KTtcblx0XG5cdFx0XHRpZiAoc2VsZi5pc0ZvY3VzZWQpIHtcblx0XHRcdFx0Ly8gcmV0YWluIGZvY3VzIGJ5IHByZXZlbnRpbmcgbmF0aXZlIGhhbmRsaW5nLiBpZiB0aGVcblx0XHRcdFx0Ly8gZXZlbnQgdGFyZ2V0IGlzIHRoZSBpbnB1dCBpdCBzaG91bGQgbm90IGJlIG1vZGlmaWVkLlxuXHRcdFx0XHQvLyBvdGhlcndpc2UsIHRleHQgc2VsZWN0aW9uIHdpdGhpbiB0aGUgaW5wdXQgd29uJ3Qgd29yay5cblx0XHRcdFx0aWYgKGUudGFyZ2V0ICE9PSBzZWxmLiRjb250cm9sX2lucHV0WzBdKSB7XG5cdFx0XHRcdFx0aWYgKHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScpIHtcblx0XHRcdFx0XHRcdC8vIHRvZ2dsZSBkcm9wZG93blxuXHRcdFx0XHRcdFx0c2VsZi5pc09wZW4gPyBzZWxmLmNsb3NlKCkgOiBzZWxmLm9wZW4oKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFkZWZhdWx0UHJldmVudGVkKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW0obnVsbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gZ2l2ZSBjb250cm9sIGZvY3VzXG5cdFx0XHRcdGlmICghZGVmYXVsdFByZXZlbnRlZCkge1xuXHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c2VsZi5mb2N1cygpO1xuXHRcdFx0XHRcdH0sIDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlcmVkIHdoZW4gdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sIGhhcyBiZWVuIGNoYW5nZWQuXG5cdFx0ICogVGhpcyBzaG91bGQgcHJvcGFnYXRlIHRoZSBldmVudCB0byB0aGUgb3JpZ2luYWwgRE9NXG5cdFx0ICogaW5wdXQgLyBzZWxlY3QgZWxlbWVudC5cblx0XHQgKi9cblx0XHRvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLiRpbnB1dC50cmlnZ2VyKCdjaGFuZ2UnKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBUcmlnZ2VyZWQgb24gPGlucHV0PiBwYXN0ZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBlXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0b25QYXN0ZTogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0XHRcdGlmIChzZWxmLmlzRnVsbCgpIHx8IHNlbGYuaXNJbnB1dEhpZGRlbiB8fCBzZWxmLmlzTG9ja2VkKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIElmIGEgcmVnZXggb3Igc3RyaW5nIGlzIGluY2x1ZGVkLCB0aGlzIHdpbGwgc3BsaXQgdGhlIHBhc3RlZFxuXHRcdFx0Ly8gaW5wdXQgYW5kIGNyZWF0ZSBJdGVtcyBmb3IgZWFjaCBzZXBhcmF0ZSB2YWx1ZVxuXHRcdFx0aWYgKHNlbGYuc2V0dGluZ3Muc3BsaXRPbikge1xuXHRcblx0XHRcdFx0Ly8gV2FpdCBmb3IgcGFzdGVkIHRleHQgdG8gYmUgcmVjb2duaXplZCBpbiB2YWx1ZVxuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBwYXN0ZWRUZXh0ID0gc2VsZi4kY29udHJvbF9pbnB1dC52YWwoKTtcblx0XHRcdFx0XHRpZighcGFzdGVkVGV4dC5tYXRjaChzZWxmLnNldHRpbmdzLnNwbGl0T24pKXsgcmV0dXJuIH1cblx0XG5cdFx0XHRcdFx0dmFyIHNwbGl0SW5wdXQgPSAkLnRyaW0ocGFzdGVkVGV4dCkuc3BsaXQoc2VsZi5zZXR0aW5ncy5zcGxpdE9uKTtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHNwbGl0SW5wdXQubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRzZWxmLmNyZWF0ZUl0ZW0oc3BsaXRJbnB1dFtpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCAwKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBUcmlnZ2VyZWQgb24gPGlucHV0PiBrZXlwcmVzcy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBlXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0b25LZXlQcmVzczogZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKHRoaXMuaXNMb2NrZWQpIHJldHVybiBlICYmIGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHZhciBjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUua2V5Q29kZSB8fCBlLndoaWNoKTtcblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmNyZWF0ZSAmJiB0aGlzLnNldHRpbmdzLm1vZGUgPT09ICdtdWx0aScgJiYgY2hhcmFjdGVyID09PSB0aGlzLnNldHRpbmdzLmRlbGltaXRlcikge1xuXHRcdFx0XHR0aGlzLmNyZWF0ZUl0ZW0oKTtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4ga2V5ZG93bi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBlXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0b25LZXlEb3duOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgaXNJbnB1dCA9IGUudGFyZ2V0ID09PSB0aGlzLiRjb250cm9sX2lucHV0WzBdO1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0XHRcdGlmIChzZWxmLmlzTG9ja2VkKSB7XG5cdFx0XHRcdGlmIChlLmtleUNvZGUgIT09IEtFWV9UQUIpIHtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcblx0XHRcdHN3aXRjaCAoZS5rZXlDb2RlKSB7XG5cdFx0XHRcdGNhc2UgS0VZX0E6XG5cdFx0XHRcdFx0aWYgKHNlbGYuaXNDbWREb3duKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnNlbGVjdEFsbCgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBLRVlfRVNDOlxuXHRcdFx0XHRcdGlmIChzZWxmLmlzT3Blbikge1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRjYXNlIEtFWV9OOlxuXHRcdFx0XHRcdGlmICghZS5jdHJsS2V5IHx8IGUuYWx0S2V5KSBicmVhaztcblx0XHRcdFx0Y2FzZSBLRVlfRE9XTjpcblx0XHRcdFx0XHRpZiAoIXNlbGYuaXNPcGVuICYmIHNlbGYuaGFzT3B0aW9ucykge1xuXHRcdFx0XHRcdFx0c2VsZi5vcGVuKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChzZWxmLiRhY3RpdmVPcHRpb24pIHtcblx0XHRcdFx0XHRcdHNlbGYuaWdub3JlSG92ZXIgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dmFyICRuZXh0ID0gc2VsZi5nZXRBZGphY2VudE9wdGlvbihzZWxmLiRhY3RpdmVPcHRpb24sIDEpO1xuXHRcdFx0XHRcdFx0aWYgKCRuZXh0Lmxlbmd0aCkgc2VsZi5zZXRBY3RpdmVPcHRpb24oJG5leHQsIHRydWUsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRjYXNlIEtFWV9QOlxuXHRcdFx0XHRcdGlmICghZS5jdHJsS2V5IHx8IGUuYWx0S2V5KSBicmVhaztcblx0XHRcdFx0Y2FzZSBLRVlfVVA6XG5cdFx0XHRcdFx0aWYgKHNlbGYuJGFjdGl2ZU9wdGlvbikge1xuXHRcdFx0XHRcdFx0c2VsZi5pZ25vcmVIb3ZlciA9IHRydWU7XG5cdFx0XHRcdFx0XHR2YXIgJHByZXYgPSBzZWxmLmdldEFkamFjZW50T3B0aW9uKHNlbGYuJGFjdGl2ZU9wdGlvbiwgLTEpO1xuXHRcdFx0XHRcdFx0aWYgKCRwcmV2Lmxlbmd0aCkgc2VsZi5zZXRBY3RpdmVPcHRpb24oJHByZXYsIHRydWUsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRjYXNlIEtFWV9SRVRVUk46XG5cdFx0XHRcdFx0aWYgKHNlbGYuaXNPcGVuICYmIHNlbGYuJGFjdGl2ZU9wdGlvbikge1xuXHRcdFx0XHRcdFx0c2VsZi5vbk9wdGlvblNlbGVjdCh7Y3VycmVudFRhcmdldDogc2VsZi4kYWN0aXZlT3B0aW9ufSk7XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0Y2FzZSBLRVlfTEVGVDpcblx0XHRcdFx0XHRzZWxmLmFkdmFuY2VTZWxlY3Rpb24oLTEsIGUpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0Y2FzZSBLRVlfUklHSFQ6XG5cdFx0XHRcdFx0c2VsZi5hZHZhbmNlU2VsZWN0aW9uKDEsIGUpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0Y2FzZSBLRVlfVEFCOlxuXHRcdFx0XHRcdGlmIChzZWxmLnNldHRpbmdzLnNlbGVjdE9uVGFiICYmIHNlbGYuaXNPcGVuICYmIHNlbGYuJGFjdGl2ZU9wdGlvbikge1xuXHRcdFx0XHRcdFx0c2VsZi5vbk9wdGlvblNlbGVjdCh7Y3VycmVudFRhcmdldDogc2VsZi4kYWN0aXZlT3B0aW9ufSk7XG5cdFxuXHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBiZWhhdmlvdXIgaXMgdG8ganVtcCB0byB0aGUgbmV4dCBmaWVsZCwgd2Ugb25seSB3YW50IHRoaXNcblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBjdXJyZW50IGZpZWxkIGRvZXNuJ3QgYWNjZXB0IGFueSBtb3JlIGVudHJpZXNcblx0XHRcdFx0XHRcdGlmICghc2VsZi5pc0Z1bGwoKSkge1xuXHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzZWxmLnNldHRpbmdzLmNyZWF0ZSAmJiBzZWxmLmNyZWF0ZUl0ZW0oKSkge1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdGNhc2UgS0VZX0JBQ0tTUEFDRTpcblx0XHRcdFx0Y2FzZSBLRVlfREVMRVRFOlxuXHRcdFx0XHRcdHNlbGYuZGVsZXRlU2VsZWN0aW9uKGUpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoKHNlbGYuaXNGdWxsKCkgfHwgc2VsZi5pc0lucHV0SGlkZGVuKSAmJiAhKElTX01BQyA/IGUubWV0YUtleSA6IGUuY3RybEtleSkpIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4ga2V5dXAuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZVxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdG9uS2V5VXA6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XG5cdFx0XHRpZiAoc2VsZi5pc0xvY2tlZCkgcmV0dXJuIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dmFyIHZhbHVlID0gc2VsZi4kY29udHJvbF9pbnB1dC52YWwoKSB8fCAnJztcblx0XHRcdGlmIChzZWxmLmxhc3RWYWx1ZSAhPT0gdmFsdWUpIHtcblx0XHRcdFx0c2VsZi5sYXN0VmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0c2VsZi5vblNlYXJjaENoYW5nZSh2YWx1ZSk7XG5cdFx0XHRcdHNlbGYucmVmcmVzaE9wdGlvbnMoKTtcblx0XHRcdFx0c2VsZi50cmlnZ2VyKCd0eXBlJywgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEludm9rZXMgdGhlIHVzZXItcHJvdmlkZSBvcHRpb24gcHJvdmlkZXIgLyBsb2FkZXIuXG5cdFx0ICpcblx0XHQgKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIGlzIGRlYm91bmNlZCBpbiB0aGUgU2VsZWN0aXplXG5cdFx0ICogY29uc3RydWN0b3IgKGJ5IGBzZXR0aW5ncy5sb2FkVGhyb3R0bGVgIG1pbGxpc2Vjb25kcylcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHRcdCAqL1xuXHRcdG9uU2VhcmNoQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIGZuID0gc2VsZi5zZXR0aW5ncy5sb2FkO1xuXHRcdFx0aWYgKCFmbikgcmV0dXJuO1xuXHRcdFx0aWYgKHNlbGYubG9hZGVkU2VhcmNoZXMuaGFzT3duUHJvcGVydHkodmFsdWUpKSByZXR1cm47XG5cdFx0XHRzZWxmLmxvYWRlZFNlYXJjaGVzW3ZhbHVlXSA9IHRydWU7XG5cdFx0XHRzZWxmLmxvYWQoZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0Zm4uYXBwbHkoc2VsZiwgW3ZhbHVlLCBjYWxsYmFja10pO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4gZm9jdXMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZSAob3B0aW9uYWwpXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0b25Gb2N1czogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIHdhc0ZvY3VzZWQgPSBzZWxmLmlzRm9jdXNlZDtcblx0XG5cdFx0XHRpZiAoc2VsZi5pc0Rpc2FibGVkKSB7XG5cdFx0XHRcdHNlbGYuYmx1cigpO1xuXHRcdFx0XHRlICYmIGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmIChzZWxmLmlnbm9yZUZvY3VzKSByZXR1cm47XG5cdFx0XHRzZWxmLmlzRm9jdXNlZCA9IHRydWU7XG5cdFx0XHRpZiAoc2VsZi5zZXR0aW5ncy5wcmVsb2FkID09PSAnZm9jdXMnKSBzZWxmLm9uU2VhcmNoQ2hhbmdlKCcnKTtcblx0XG5cdFx0XHRpZiAoIXdhc0ZvY3VzZWQpIHNlbGYudHJpZ2dlcignZm9jdXMnKTtcblx0XG5cdFx0XHRpZiAoIXNlbGYuJGFjdGl2ZUl0ZW1zLmxlbmd0aCkge1xuXHRcdFx0XHRzZWxmLnNob3dJbnB1dCgpO1xuXHRcdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW0obnVsbCk7XG5cdFx0XHRcdHNlbGYucmVmcmVzaE9wdGlvbnMoISFzZWxmLnNldHRpbmdzLm9wZW5PbkZvY3VzKTtcblx0XHRcdH1cblx0XG5cdFx0XHRzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRyaWdnZXJlZCBvbiA8aW5wdXQ+IGJsdXIuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZVxuXHRcdCAqIEBwYXJhbSB7RWxlbWVudH0gZGVzdFxuXHRcdCAqL1xuXHRcdG9uQmx1cjogZnVuY3Rpb24oZSwgZGVzdCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0aWYgKCFzZWxmLmlzRm9jdXNlZCkgcmV0dXJuO1xuXHRcdFx0c2VsZi5pc0ZvY3VzZWQgPSBmYWxzZTtcblx0XG5cdFx0XHRpZiAoc2VsZi5pZ25vcmVGb2N1cykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2UgaWYgKCFzZWxmLmlnbm9yZUJsdXIgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gc2VsZi4kZHJvcGRvd25fY29udGVudFswXSkge1xuXHRcdFx0XHQvLyBuZWNlc3NhcnkgdG8gcHJldmVudCBJRSBjbG9zaW5nIHRoZSBkcm9wZG93biB3aGVuIHRoZSBzY3JvbGxiYXIgaXMgY2xpY2tlZFxuXHRcdFx0XHRzZWxmLmlnbm9yZUJsdXIgPSB0cnVlO1xuXHRcdFx0XHRzZWxmLm9uRm9jdXMoZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHR2YXIgZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmNsb3NlKCk7XG5cdFx0XHRcdHNlbGYuc2V0VGV4dGJveFZhbHVlKCcnKTtcblx0XHRcdFx0c2VsZi5zZXRBY3RpdmVJdGVtKG51bGwpO1xuXHRcdFx0XHRzZWxmLnNldEFjdGl2ZU9wdGlvbihudWxsKTtcblx0XHRcdFx0c2VsZi5zZXRDYXJldChzZWxmLml0ZW1zLmxlbmd0aCk7XG5cdFx0XHRcdHNlbGYucmVmcmVzaFN0YXRlKCk7XG5cdFxuXHRcdFx0XHQvLyBJRTExIGJ1ZzogZWxlbWVudCBzdGlsbCBtYXJrZWQgYXMgYWN0aXZlXG5cdFx0XHRcdGRlc3QgJiYgZGVzdC5mb2N1cyAmJiBkZXN0LmZvY3VzKCk7XG5cdFxuXHRcdFx0XHRzZWxmLmlzQmx1cnJpbmcgPSBmYWxzZTtcblx0XHRcdFx0c2VsZi5pZ25vcmVGb2N1cyA9IGZhbHNlO1xuXHRcdFx0XHRzZWxmLnRyaWdnZXIoJ2JsdXInKTtcblx0XHRcdH07XG5cdFxuXHRcdFx0c2VsZi5pc0JsdXJyaW5nID0gdHJ1ZTtcblx0XHRcdHNlbGYuaWdub3JlRm9jdXMgPSB0cnVlO1xuXHRcdFx0aWYgKHNlbGYuc2V0dGluZ3MuY3JlYXRlICYmIHNlbGYuc2V0dGluZ3MuY3JlYXRlT25CbHVyKSB7XG5cdFx0XHRcdHNlbGYuY3JlYXRlSXRlbShudWxsLCBmYWxzZSwgZGVhY3RpdmF0ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWFjdGl2YXRlKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgcm9sbHMgb3ZlclxuXHRcdCAqIGFuIG9wdGlvbiBpbiB0aGUgYXV0b2NvbXBsZXRlIGRyb3Bkb3duIG1lbnUuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZVxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdG9uT3B0aW9uSG92ZXI6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdGlmICh0aGlzLmlnbm9yZUhvdmVyKSByZXR1cm47XG5cdFx0XHR0aGlzLnNldEFjdGl2ZU9wdGlvbihlLmN1cnJlbnRUYXJnZXQsIGZhbHNlKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW4gb3B0aW9uXG5cdFx0ICogaW4gdGhlIGF1dG9jb21wbGV0ZSBkcm9wZG93biBtZW51LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGVcblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHRvbk9wdGlvblNlbGVjdDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHZhbHVlLCAkdGFyZ2V0LCAkb3B0aW9uLCBzZWxmID0gdGhpcztcblx0XG5cdFx0XHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0JHRhcmdldCA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcblx0XHRcdGlmICgkdGFyZ2V0Lmhhc0NsYXNzKCdjcmVhdGUnKSkge1xuXHRcdFx0XHRzZWxmLmNyZWF0ZUl0ZW0obnVsbCwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKHNlbGYuc2V0dGluZ3MuY2xvc2VBZnRlclNlbGVjdCkge1xuXHRcdFx0XHRcdFx0c2VsZi5jbG9zZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWx1ZSA9ICR0YXJnZXQuYXR0cignZGF0YS12YWx1ZScpO1xuXHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdHNlbGYubGFzdFF1ZXJ5ID0gbnVsbDtcblx0XHRcdFx0XHRzZWxmLnNldFRleHRib3hWYWx1ZSgnJyk7XG5cdFx0XHRcdFx0c2VsZi5hZGRJdGVtKHZhbHVlKTtcblx0XHRcdFx0XHRpZiAoc2VsZi5zZXR0aW5ncy5jbG9zZUFmdGVyU2VsZWN0KSB7XG5cdFx0XHRcdFx0XHRzZWxmLmNsb3NlKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghc2VsZi5zZXR0aW5ncy5oaWRlU2VsZWN0ZWQgJiYgZS50eXBlICYmIC9tb3VzZS8udGVzdChlLnR5cGUpKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnNldEFjdGl2ZU9wdGlvbihzZWxmLmdldE9wdGlvbih2YWx1ZSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBpdGVtXG5cdFx0ICogdGhhdCBoYXMgYmVlbiBzZWxlY3RlZC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBlXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0b25JdGVtU2VsZWN0OiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFxuXHRcdFx0aWYgKHNlbGYuaXNMb2NrZWQpIHJldHVybjtcblx0XHRcdGlmIChzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdtdWx0aScpIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW0oZS5jdXJyZW50VGFyZ2V0LCBlKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBJbnZva2VzIHRoZSBwcm92aWRlZCBtZXRob2QgdGhhdCBwcm92aWRlc1xuXHRcdCAqIHJlc3VsdHMgdG8gYSBjYWxsYmFjay0tLXdoaWNoIGFyZSB0aGVuIGFkZGVkXG5cdFx0ICogYXMgb3B0aW9ucyB0byB0aGUgY29udHJvbC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG5cdFx0ICovXG5cdFx0bG9hZDogZnVuY3Rpb24oZm4pIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciAkd3JhcHBlciA9IHNlbGYuJHdyYXBwZXIuYWRkQ2xhc3Moc2VsZi5zZXR0aW5ncy5sb2FkaW5nQ2xhc3MpO1xuXHRcblx0XHRcdHNlbGYubG9hZGluZysrO1xuXHRcdFx0Zm4uYXBwbHkoc2VsZiwgW2Z1bmN0aW9uKHJlc3VsdHMpIHtcblx0XHRcdFx0c2VsZi5sb2FkaW5nID0gTWF0aC5tYXgoc2VsZi5sb2FkaW5nIC0gMSwgMCk7XG5cdFx0XHRcdGlmIChyZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0c2VsZi5hZGRPcHRpb24ocmVzdWx0cyk7XG5cdFx0XHRcdFx0c2VsZi5yZWZyZXNoT3B0aW9ucyhzZWxmLmlzRm9jdXNlZCAmJiAhc2VsZi5pc0lucHV0SGlkZGVuKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXNlbGYubG9hZGluZykge1xuXHRcdFx0XHRcdCR3cmFwcGVyLnJlbW92ZUNsYXNzKHNlbGYuc2V0dGluZ3MubG9hZGluZ0NsYXNzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnRyaWdnZXIoJ2xvYWQnLCByZXN1bHRzKTtcblx0XHRcdH1dKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBTZXRzIHRoZSBpbnB1dCBmaWVsZCBvZiB0aGUgY29udHJvbCB0byB0aGUgc3BlY2lmaWVkIHZhbHVlLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG5cdFx0ICovXG5cdFx0c2V0VGV4dGJveFZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyICRpbnB1dCA9IHRoaXMuJGNvbnRyb2xfaW5wdXQ7XG5cdFx0XHR2YXIgY2hhbmdlZCA9ICRpbnB1dC52YWwoKSAhPT0gdmFsdWU7XG5cdFx0XHRpZiAoY2hhbmdlZCkge1xuXHRcdFx0XHQkaW5wdXQudmFsKHZhbHVlKS50cmlnZ2VySGFuZGxlcigndXBkYXRlJyk7XG5cdFx0XHRcdHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wuIElmIG11bHRpcGxlIGl0ZW1zXG5cdFx0ICogY2FuIGJlIHNlbGVjdGVkIChlLmcuIDxzZWxlY3QgbXVsdGlwbGU+KSwgdGhpcyByZXR1cm5zXG5cdFx0ICogYW4gYXJyYXkuIElmIG9ubHkgb25lIGl0ZW0gY2FuIGJlIHNlbGVjdGVkLCB0aGlzXG5cdFx0ICogcmV0dXJucyBhIHN0cmluZy5cblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHttaXhlZH1cblx0XHQgKi9cblx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy50YWdUeXBlID09PSBUQUdfU0VMRUNUICYmIHRoaXMuJGlucHV0LmF0dHIoJ211bHRpcGxlJykpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuaXRlbXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5pdGVtcy5qb2luKHRoaXMuc2V0dGluZ3MuZGVsaW1pdGVyKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBSZXNldHMgdGhlIHNlbGVjdGVkIGl0ZW1zIHRvIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IHZhbHVlXG5cdFx0ICovXG5cdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBzaWxlbnQpIHtcblx0XHRcdHZhciBldmVudHMgPSBzaWxlbnQgPyBbXSA6IFsnY2hhbmdlJ107XG5cdFxuXHRcdFx0ZGVib3VuY2VfZXZlbnRzKHRoaXMsIGV2ZW50cywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuY2xlYXIoc2lsZW50KTtcblx0XHRcdFx0dGhpcy5hZGRJdGVtcyh2YWx1ZSwgc2lsZW50KTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNldHMgdGhlIHNlbGVjdGVkIGl0ZW0uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gJGl0ZW1cblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZSAob3B0aW9uYWwpXG5cdFx0ICovXG5cdFx0c2V0QWN0aXZlSXRlbTogZnVuY3Rpb24oJGl0ZW0sIGUpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciBldmVudE5hbWU7XG5cdFx0XHR2YXIgaSwgaWR4LCBiZWdpbiwgZW5kLCBpdGVtLCBzd2FwO1xuXHRcdFx0dmFyICRsYXN0O1xuXHRcblx0XHRcdGlmIChzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdzaW5nbGUnKSByZXR1cm47XG5cdFx0XHQkaXRlbSA9ICQoJGl0ZW0pO1xuXHRcblx0XHRcdC8vIGNsZWFyIHRoZSBhY3RpdmUgc2VsZWN0aW9uXG5cdFx0XHRpZiAoISRpdGVtLmxlbmd0aCkge1xuXHRcdFx0XHQkKHNlbGYuJGFjdGl2ZUl0ZW1zKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG5cdFx0XHRcdHNlbGYuJGFjdGl2ZUl0ZW1zID0gW107XG5cdFx0XHRcdGlmIChzZWxmLmlzRm9jdXNlZCkge1xuXHRcdFx0XHRcdHNlbGYuc2hvd0lucHV0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIG1vZGlmeSBzZWxlY3Rpb25cblx0XHRcdGV2ZW50TmFtZSA9IGUgJiYgZS50eXBlLnRvTG93ZXJDYXNlKCk7XG5cdFxuXHRcdFx0aWYgKGV2ZW50TmFtZSA9PT0gJ21vdXNlZG93bicgJiYgc2VsZi5pc1NoaWZ0RG93biAmJiBzZWxmLiRhY3RpdmVJdGVtcy5sZW5ndGgpIHtcblx0XHRcdFx0JGxhc3QgPSBzZWxmLiRjb250cm9sLmNoaWxkcmVuKCcuYWN0aXZlOmxhc3QnKTtcblx0XHRcdFx0YmVnaW4gPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5hcHBseShzZWxmLiRjb250cm9sWzBdLmNoaWxkTm9kZXMsIFskbGFzdFswXV0pO1xuXHRcdFx0XHRlbmQgICA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmFwcGx5KHNlbGYuJGNvbnRyb2xbMF0uY2hpbGROb2RlcywgWyRpdGVtWzBdXSk7XG5cdFx0XHRcdGlmIChiZWdpbiA+IGVuZCkge1xuXHRcdFx0XHRcdHN3YXAgID0gYmVnaW47XG5cdFx0XHRcdFx0YmVnaW4gPSBlbmQ7XG5cdFx0XHRcdFx0ZW5kICAgPSBzd2FwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoaSA9IGJlZ2luOyBpIDw9IGVuZDsgaSsrKSB7XG5cdFx0XHRcdFx0aXRlbSA9IHNlbGYuJGNvbnRyb2xbMF0uY2hpbGROb2Rlc1tpXTtcblx0XHRcdFx0XHRpZiAoc2VsZi4kYWN0aXZlSXRlbXMuaW5kZXhPZihpdGVtKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdCQoaXRlbSkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcdFx0XHRcdFx0c2VsZi4kYWN0aXZlSXRlbXMucHVzaChpdGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fSBlbHNlIGlmICgoZXZlbnROYW1lID09PSAnbW91c2Vkb3duJyAmJiBzZWxmLmlzQ3RybERvd24pIHx8IChldmVudE5hbWUgPT09ICdrZXlkb3duJyAmJiB0aGlzLmlzU2hpZnREb3duKSkge1xuXHRcdFx0XHRpZiAoJGl0ZW0uaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XG5cdFx0XHRcdFx0aWR4ID0gc2VsZi4kYWN0aXZlSXRlbXMuaW5kZXhPZigkaXRlbVswXSk7XG5cdFx0XHRcdFx0c2VsZi4kYWN0aXZlSXRlbXMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcdFx0JGl0ZW0ucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuJGFjdGl2ZUl0ZW1zLnB1c2goJGl0ZW0uYWRkQ2xhc3MoJ2FjdGl2ZScpWzBdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JChzZWxmLiRhY3RpdmVJdGVtcykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcdFx0XHRzZWxmLiRhY3RpdmVJdGVtcyA9IFskaXRlbS5hZGRDbGFzcygnYWN0aXZlJylbMF1dO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIGVuc3VyZSBjb250cm9sIGhhcyBmb2N1c1xuXHRcdFx0c2VsZi5oaWRlSW5wdXQoKTtcblx0XHRcdGlmICghdGhpcy5pc0ZvY3VzZWQpIHtcblx0XHRcdFx0c2VsZi5mb2N1cygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNldHMgdGhlIHNlbGVjdGVkIGl0ZW0gaW4gdGhlIGRyb3Bkb3duIG1lbnVcblx0XHQgKiBvZiBhdmFpbGFibGUgb3B0aW9ucy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSAkb2JqZWN0XG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBzY3JvbGxcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IGFuaW1hdGVcblx0XHQgKi9cblx0XHRzZXRBY3RpdmVPcHRpb246IGZ1bmN0aW9uKCRvcHRpb24sIHNjcm9sbCwgYW5pbWF0ZSkge1xuXHRcdFx0dmFyIGhlaWdodF9tZW51LCBoZWlnaHRfaXRlbSwgeTtcblx0XHRcdHZhciBzY3JvbGxfdG9wLCBzY3JvbGxfYm90dG9tO1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0XHRcdGlmIChzZWxmLiRhY3RpdmVPcHRpb24pIHNlbGYuJGFjdGl2ZU9wdGlvbi5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG5cdFx0XHRzZWxmLiRhY3RpdmVPcHRpb24gPSBudWxsO1xuXHRcblx0XHRcdCRvcHRpb24gPSAkKCRvcHRpb24pO1xuXHRcdFx0aWYgKCEkb3B0aW9uLmxlbmd0aCkgcmV0dXJuO1xuXHRcblx0XHRcdHNlbGYuJGFjdGl2ZU9wdGlvbiA9ICRvcHRpb24uYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcblx0XHRcdGlmIChzY3JvbGwgfHwgIWlzc2V0KHNjcm9sbCkpIHtcblx0XG5cdFx0XHRcdGhlaWdodF9tZW51ICAgPSBzZWxmLiRkcm9wZG93bl9jb250ZW50LmhlaWdodCgpO1xuXHRcdFx0XHRoZWlnaHRfaXRlbSAgID0gc2VsZi4kYWN0aXZlT3B0aW9uLm91dGVySGVpZ2h0KHRydWUpO1xuXHRcdFx0XHRzY3JvbGwgICAgICAgID0gc2VsZi4kZHJvcGRvd25fY29udGVudC5zY3JvbGxUb3AoKSB8fCAwO1xuXHRcdFx0XHR5ICAgICAgICAgICAgID0gc2VsZi4kYWN0aXZlT3B0aW9uLm9mZnNldCgpLnRvcCAtIHNlbGYuJGRyb3Bkb3duX2NvbnRlbnQub2Zmc2V0KCkudG9wICsgc2Nyb2xsO1xuXHRcdFx0XHRzY3JvbGxfdG9wICAgID0geTtcblx0XHRcdFx0c2Nyb2xsX2JvdHRvbSA9IHkgLSBoZWlnaHRfbWVudSArIGhlaWdodF9pdGVtO1xuXHRcblx0XHRcdFx0aWYgKHkgKyBoZWlnaHRfaXRlbSA+IGhlaWdodF9tZW51ICsgc2Nyb2xsKSB7XG5cdFx0XHRcdFx0c2VsZi4kZHJvcGRvd25fY29udGVudC5zdG9wKCkuYW5pbWF0ZSh7c2Nyb2xsVG9wOiBzY3JvbGxfYm90dG9tfSwgYW5pbWF0ZSA/IHNlbGYuc2V0dGluZ3Muc2Nyb2xsRHVyYXRpb24gOiAwKTtcblx0XHRcdFx0fSBlbHNlIGlmICh5IDwgc2Nyb2xsKSB7XG5cdFx0XHRcdFx0c2VsZi4kZHJvcGRvd25fY29udGVudC5zdG9wKCkuYW5pbWF0ZSh7c2Nyb2xsVG9wOiBzY3JvbGxfdG9wfSwgYW5pbWF0ZSA/IHNlbGYuc2V0dGluZ3Muc2Nyb2xsRHVyYXRpb24gOiAwKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBTZWxlY3RzIGFsbCBpdGVtcyAoQ1RSTCArIEEpLlxuXHRcdCAqL1xuXHRcdHNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZiAoc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJykgcmV0dXJuO1xuXHRcblx0XHRcdHNlbGYuJGFjdGl2ZUl0ZW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHNlbGYuJGNvbnRyb2wuY2hpbGRyZW4oJzpub3QoaW5wdXQpJykuYWRkQ2xhc3MoJ2FjdGl2ZScpKTtcblx0XHRcdGlmIChzZWxmLiRhY3RpdmVJdGVtcy5sZW5ndGgpIHtcblx0XHRcdFx0c2VsZi5oaWRlSW5wdXQoKTtcblx0XHRcdFx0c2VsZi5jbG9zZSgpO1xuXHRcdFx0fVxuXHRcdFx0c2VsZi5mb2N1cygpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEhpZGVzIHRoZSBpbnB1dCBlbGVtZW50IG91dCBvZiB2aWV3LCB3aGlsZVxuXHRcdCAqIHJldGFpbmluZyBpdHMgZm9jdXMuXG5cdFx0ICovXG5cdFx0aGlkZUlucHV0OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XG5cdFx0XHRzZWxmLnNldFRleHRib3hWYWx1ZSgnJyk7XG5cdFx0XHRzZWxmLiRjb250cm9sX2lucHV0LmNzcyh7b3BhY2l0eTogMCwgcG9zaXRpb246ICdhYnNvbHV0ZScsIGxlZnQ6IHNlbGYucnRsID8gMTAwMDAgOiAtMTAwMDB9KTtcblx0XHRcdHNlbGYuaXNJbnB1dEhpZGRlbiA9IHRydWU7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUmVzdG9yZXMgaW5wdXQgdmlzaWJpbGl0eS5cblx0XHQgKi9cblx0XHRzaG93SW5wdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy4kY29udHJvbF9pbnB1dC5jc3Moe29wYWNpdHk6IDEsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBsZWZ0OiAwfSk7XG5cdFx0XHR0aGlzLmlzSW5wdXRIaWRkZW4gPSBmYWxzZTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBHaXZlcyB0aGUgY29udHJvbCBmb2N1cy5cblx0XHQgKi9cblx0XHRmb2N1czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZiAoc2VsZi5pc0Rpc2FibGVkKSByZXR1cm47XG5cdFxuXHRcdFx0c2VsZi5pZ25vcmVGb2N1cyA9IHRydWU7XG5cdFx0XHRzZWxmLiRjb250cm9sX2lucHV0WzBdLmZvY3VzKCk7XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5pZ25vcmVGb2N1cyA9IGZhbHNlO1xuXHRcdFx0XHRzZWxmLm9uRm9jdXMoKTtcblx0XHRcdH0sIDApO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZvcmNlcyB0aGUgY29udHJvbCBvdXQgb2YgZm9jdXMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0VsZW1lbnR9IGRlc3Rcblx0XHQgKi9cblx0XHRibHVyOiBmdW5jdGlvbihkZXN0KSB7XG5cdFx0XHR0aGlzLiRjb250cm9sX2lucHV0WzBdLmJsdXIoKTtcblx0XHRcdHRoaXMub25CbHVyKG51bGwsIGRlc3QpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHNjb3JlcyBhbiBvYmplY3Rcblx0XHQgKiB0byBzaG93IGhvdyBnb29kIG9mIGEgbWF0Y2ggaXQgaXMgdG8gdGhlXG5cdFx0ICogcHJvdmlkZWQgcXVlcnkuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuXHRcdCAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuXHRcdCAqL1xuXHRcdGdldFNjb3JlRnVuY3Rpb246IGZ1bmN0aW9uKHF1ZXJ5KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zaWZ0ZXIuZ2V0U2NvcmVGdW5jdGlvbihxdWVyeSwgdGhpcy5nZXRTZWFyY2hPcHRpb25zKCkpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgc2VhcmNoIG9wdGlvbnMgZm9yIHNpZnRlciAodGhlIHN5c3RlbVxuXHRcdCAqIGZvciBzY29yaW5nIGFuZCBzb3J0aW5nIHJlc3VsdHMpLlxuXHRcdCAqXG5cdFx0ICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJpYW5yZWF2aXMvc2lmdGVyLmpzXG5cdFx0ICogQHJldHVybiB7b2JqZWN0fVxuXHRcdCAqL1xuXHRcdGdldFNlYXJjaE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcblx0XHRcdHZhciBzb3J0ID0gc2V0dGluZ3Muc29ydEZpZWxkO1xuXHRcdFx0aWYgKHR5cGVvZiBzb3J0ID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRzb3J0ID0gW3tmaWVsZDogc29ydH1dO1xuXHRcdFx0fVxuXHRcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGZpZWxkcyAgICAgIDogc2V0dGluZ3Muc2VhcmNoRmllbGQsXG5cdFx0XHRcdGNvbmp1bmN0aW9uIDogc2V0dGluZ3Muc2VhcmNoQ29uanVuY3Rpb24sXG5cdFx0XHRcdHNvcnQgICAgICAgIDogc29ydCxcblx0XHRcdFx0bmVzdGluZyAgICAgOiBzZXR0aW5ncy5uZXN0aW5nXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlYXJjaGVzIHRocm91Z2ggYXZhaWxhYmxlIG9wdGlvbnMgYW5kIHJldHVybnNcblx0XHQgKiBhIHNvcnRlZCBhcnJheSBvZiBtYXRjaGVzLlxuXHRcdCAqXG5cdFx0ICogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZzpcblx0XHQgKlxuXHRcdCAqICAgLSBxdWVyeSB7c3RyaW5nfVxuXHRcdCAqICAgLSB0b2tlbnMge2FycmF5fVxuXHRcdCAqICAgLSB0b3RhbCB7aW50fVxuXHRcdCAqICAgLSBpdGVtcyB7YXJyYXl9XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlcblx0XHQgKiBAcmV0dXJucyB7b2JqZWN0fVxuXHRcdCAqL1xuXHRcdHNlYXJjaDogZnVuY3Rpb24ocXVlcnkpIHtcblx0XHRcdHZhciBpLCB2YWx1ZSwgc2NvcmUsIHJlc3VsdCwgY2FsY3VsYXRlU2NvcmU7XG5cdFx0XHR2YXIgc2VsZiAgICAgPSB0aGlzO1xuXHRcdFx0dmFyIHNldHRpbmdzID0gc2VsZi5zZXR0aW5ncztcblx0XHRcdHZhciBvcHRpb25zICA9IHRoaXMuZ2V0U2VhcmNoT3B0aW9ucygpO1xuXHRcblx0XHRcdC8vIHZhbGlkYXRlIHVzZXItcHJvdmlkZWQgcmVzdWx0IHNjb3JpbmcgZnVuY3Rpb25cblx0XHRcdGlmIChzZXR0aW5ncy5zY29yZSkge1xuXHRcdFx0XHRjYWxjdWxhdGVTY29yZSA9IHNlbGYuc2V0dGluZ3Muc2NvcmUuYXBwbHkodGhpcywgW3F1ZXJ5XSk7XG5cdFx0XHRcdGlmICh0eXBlb2YgY2FsY3VsYXRlU2NvcmUgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NlbGVjdGl6ZSBcInNjb3JlXCIgc2V0dGluZyBtdXN0IGJlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdC8vIHBlcmZvcm0gc2VhcmNoXG5cdFx0XHRpZiAocXVlcnkgIT09IHNlbGYubGFzdFF1ZXJ5KSB7XG5cdFx0XHRcdHNlbGYubGFzdFF1ZXJ5ID0gcXVlcnk7XG5cdFx0XHRcdHJlc3VsdCA9IHNlbGYuc2lmdGVyLnNlYXJjaChxdWVyeSwgJC5leHRlbmQob3B0aW9ucywge3Njb3JlOiBjYWxjdWxhdGVTY29yZX0pKTtcblx0XHRcdFx0c2VsZi5jdXJyZW50UmVzdWx0cyA9IHJlc3VsdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdCA9ICQuZXh0ZW5kKHRydWUsIHt9LCBzZWxmLmN1cnJlbnRSZXN1bHRzKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBmaWx0ZXIgb3V0IHNlbGVjdGVkIGl0ZW1zXG5cdFx0XHRpZiAoc2V0dGluZ3MuaGlkZVNlbGVjdGVkKSB7XG5cdFx0XHRcdGZvciAoaSA9IHJlc3VsdC5pdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdGlmIChzZWxmLml0ZW1zLmluZGV4T2YoaGFzaF9rZXkocmVzdWx0Lml0ZW1zW2ldLmlkKSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQuaXRlbXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUmVmcmVzaGVzIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb25zIHNob3duXG5cdFx0ICogaW4gdGhlIGF1dG9jb21wbGV0ZSBkcm9wZG93biBtZW51LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSB0cmlnZ2VyRHJvcGRvd25cblx0XHQgKi9cblx0XHRyZWZyZXNoT3B0aW9uczogZnVuY3Rpb24odHJpZ2dlckRyb3Bkb3duKSB7XG5cdFx0XHR2YXIgaSwgaiwgaywgbiwgZ3JvdXBzLCBncm91cHNfb3JkZXIsIG9wdGlvbiwgb3B0aW9uX2h0bWwsIG9wdGdyb3VwLCBvcHRncm91cHMsIGh0bWwsIGh0bWxfY2hpbGRyZW4sIGhhc19jcmVhdGVfb3B0aW9uO1xuXHRcdFx0dmFyICRhY3RpdmUsICRhY3RpdmVfYmVmb3JlLCAkY3JlYXRlO1xuXHRcblx0XHRcdGlmICh0eXBlb2YgdHJpZ2dlckRyb3Bkb3duID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHR0cmlnZ2VyRHJvcGRvd24gPSB0cnVlO1xuXHRcdFx0fVxuXHRcblx0XHRcdHZhciBzZWxmICAgICAgICAgICAgICA9IHRoaXM7XG5cdFx0XHR2YXIgcXVlcnkgICAgICAgICAgICAgPSAkLnRyaW0oc2VsZi4kY29udHJvbF9pbnB1dC52YWwoKSk7XG5cdFx0XHR2YXIgcmVzdWx0cyAgICAgICAgICAgPSBzZWxmLnNlYXJjaChxdWVyeSk7XG5cdFx0XHR2YXIgJGRyb3Bkb3duX2NvbnRlbnQgPSBzZWxmLiRkcm9wZG93bl9jb250ZW50O1xuXHRcdFx0dmFyIGFjdGl2ZV9iZWZvcmUgICAgID0gc2VsZi4kYWN0aXZlT3B0aW9uICYmIGhhc2hfa2V5KHNlbGYuJGFjdGl2ZU9wdGlvbi5hdHRyKCdkYXRhLXZhbHVlJykpO1xuXHRcblx0XHRcdC8vIGJ1aWxkIG1hcmt1cFxuXHRcdFx0biA9IHJlc3VsdHMuaXRlbXMubGVuZ3RoO1xuXHRcdFx0aWYgKHR5cGVvZiBzZWxmLnNldHRpbmdzLm1heE9wdGlvbnMgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdG4gPSBNYXRoLm1pbihuLCBzZWxmLnNldHRpbmdzLm1heE9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIHJlbmRlciBhbmQgZ3JvdXAgYXZhaWxhYmxlIG9wdGlvbnMgaW5kaXZpZHVhbGx5XG5cdFx0XHRncm91cHMgPSB7fTtcblx0XHRcdGdyb3Vwc19vcmRlciA9IFtdO1xuXHRcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0b3B0aW9uICAgICAgPSBzZWxmLm9wdGlvbnNbcmVzdWx0cy5pdGVtc1tpXS5pZF07XG5cdFx0XHRcdG9wdGlvbl9odG1sID0gc2VsZi5yZW5kZXIoJ29wdGlvbicsIG9wdGlvbik7XG5cdFx0XHRcdG9wdGdyb3VwICAgID0gb3B0aW9uW3NlbGYuc2V0dGluZ3Mub3B0Z3JvdXBGaWVsZF0gfHwgJyc7XG5cdFx0XHRcdG9wdGdyb3VwcyAgID0gJC5pc0FycmF5KG9wdGdyb3VwKSA/IG9wdGdyb3VwIDogW29wdGdyb3VwXTtcblx0XG5cdFx0XHRcdGZvciAoaiA9IDAsIGsgPSBvcHRncm91cHMgJiYgb3B0Z3JvdXBzLmxlbmd0aDsgaiA8IGs7IGorKykge1xuXHRcdFx0XHRcdG9wdGdyb3VwID0gb3B0Z3JvdXBzW2pdO1xuXHRcdFx0XHRcdGlmICghc2VsZi5vcHRncm91cHMuaGFzT3duUHJvcGVydHkob3B0Z3JvdXApKSB7XG5cdFx0XHRcdFx0XHRvcHRncm91cCA9ICcnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIWdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShvcHRncm91cCkpIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tvcHRncm91cF0gPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRcdFx0XHRncm91cHNfb3JkZXIucHVzaChvcHRncm91cCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGdyb3Vwc1tvcHRncm91cF0uYXBwZW5kQ2hpbGQob3B0aW9uX2h0bWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gc29ydCBvcHRncm91cHNcblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmxvY2tPcHRncm91cE9yZGVyKSB7XG5cdFx0XHRcdGdyb3Vwc19vcmRlci5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0XHR2YXIgYV9vcmRlciA9IHNlbGYub3B0Z3JvdXBzW2FdLiRvcmRlciB8fCAwO1xuXHRcdFx0XHRcdHZhciBiX29yZGVyID0gc2VsZi5vcHRncm91cHNbYl0uJG9yZGVyIHx8IDA7XG5cdFx0XHRcdFx0cmV0dXJuIGFfb3JkZXIgLSBiX29yZGVyO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyByZW5kZXIgb3B0Z3JvdXAgaGVhZGVycyAmIGpvaW4gZ3JvdXBzXG5cdFx0XHRodG1sID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0Zm9yIChpID0gMCwgbiA9IGdyb3Vwc19vcmRlci5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0b3B0Z3JvdXAgPSBncm91cHNfb3JkZXJbaV07XG5cdFx0XHRcdGlmIChzZWxmLm9wdGdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShvcHRncm91cCkgJiYgZ3JvdXBzW29wdGdyb3VwXS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdC8vIHJlbmRlciB0aGUgb3B0Z3JvdXAgaGVhZGVyIGFuZCBvcHRpb25zIHdpdGhpbiBpdCxcblx0XHRcdFx0XHQvLyB0aGVuIHBhc3MgaXQgdG8gdGhlIHdyYXBwZXIgdGVtcGxhdGVcblx0XHRcdFx0XHRodG1sX2NoaWxkcmVuID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0XHRcdGh0bWxfY2hpbGRyZW4uYXBwZW5kQ2hpbGQoc2VsZi5yZW5kZXIoJ29wdGdyb3VwX2hlYWRlcicsIHNlbGYub3B0Z3JvdXBzW29wdGdyb3VwXSkpO1xuXHRcdFx0XHRcdGh0bWxfY2hpbGRyZW4uYXBwZW5kQ2hpbGQoZ3JvdXBzW29wdGdyb3VwXSk7XG5cdFxuXHRcdFx0XHRcdGh0bWwuYXBwZW5kQ2hpbGQoc2VsZi5yZW5kZXIoJ29wdGdyb3VwJywgJC5leHRlbmQoe30sIHNlbGYub3B0Z3JvdXBzW29wdGdyb3VwXSwge1xuXHRcdFx0XHRcdFx0aHRtbDogZG9tVG9TdHJpbmcoaHRtbF9jaGlsZHJlbiksXG5cdFx0XHRcdFx0XHRkb206ICBodG1sX2NoaWxkcmVuXG5cdFx0XHRcdFx0fSkpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRodG1sLmFwcGVuZENoaWxkKGdyb3Vwc1tvcHRncm91cF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0JGRyb3Bkb3duX2NvbnRlbnQuaHRtbChodG1sKTtcblx0XG5cdFx0XHQvLyBoaWdobGlnaHQgbWF0Y2hpbmcgdGVybXMgaW5saW5lXG5cdFx0XHRpZiAoc2VsZi5zZXR0aW5ncy5oaWdobGlnaHQpIHtcblx0XHRcdFx0JGRyb3Bkb3duX2NvbnRlbnQucmVtb3ZlSGlnaGxpZ2h0KCk7XG5cdFx0XHRcdGlmIChyZXN1bHRzLnF1ZXJ5Lmxlbmd0aCAmJiByZXN1bHRzLnRva2Vucy5sZW5ndGgpIHtcblx0XHRcdFx0XHRmb3IgKGkgPSAwLCBuID0gcmVzdWx0cy50b2tlbnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRoaWdobGlnaHQoJGRyb3Bkb3duX2NvbnRlbnQsIHJlc3VsdHMudG9rZW5zW2ldLnJlZ2V4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBhZGQgXCJzZWxlY3RlZFwiIGNsYXNzIHRvIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdGlmICghc2VsZi5zZXR0aW5ncy5oaWRlU2VsZWN0ZWQpIHtcblx0XHRcdFx0Zm9yIChpID0gMCwgbiA9IHNlbGYuaXRlbXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdFx0c2VsZi5nZXRPcHRpb24oc2VsZi5pdGVtc1tpXSkuYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBhZGQgY3JlYXRlIG9wdGlvblxuXHRcdFx0aGFzX2NyZWF0ZV9vcHRpb24gPSBzZWxmLmNhbkNyZWF0ZShxdWVyeSk7XG5cdFx0XHRpZiAoaGFzX2NyZWF0ZV9vcHRpb24pIHtcblx0XHRcdFx0JGRyb3Bkb3duX2NvbnRlbnQucHJlcGVuZChzZWxmLnJlbmRlcignb3B0aW9uX2NyZWF0ZScsIHtpbnB1dDogcXVlcnl9KSk7XG5cdFx0XHRcdCRjcmVhdGUgPSAkKCRkcm9wZG93bl9jb250ZW50WzBdLmNoaWxkTm9kZXNbMF0pO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIGFjdGl2YXRlXG5cdFx0XHRzZWxmLmhhc09wdGlvbnMgPSByZXN1bHRzLml0ZW1zLmxlbmd0aCA+IDAgfHwgaGFzX2NyZWF0ZV9vcHRpb247XG5cdFx0XHRpZiAoc2VsZi5oYXNPcHRpb25zKSB7XG5cdFx0XHRcdGlmIChyZXN1bHRzLml0ZW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHQkYWN0aXZlX2JlZm9yZSA9IGFjdGl2ZV9iZWZvcmUgJiYgc2VsZi5nZXRPcHRpb24oYWN0aXZlX2JlZm9yZSk7XG5cdFx0XHRcdFx0aWYgKCRhY3RpdmVfYmVmb3JlICYmICRhY3RpdmVfYmVmb3JlLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0JGFjdGl2ZSA9ICRhY3RpdmVfYmVmb3JlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJyAmJiBzZWxmLml0ZW1zLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0JGFjdGl2ZSA9IHNlbGYuZ2V0T3B0aW9uKHNlbGYuaXRlbXNbMF0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoISRhY3RpdmUgfHwgISRhY3RpdmUubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoJGNyZWF0ZSAmJiAhc2VsZi5zZXR0aW5ncy5hZGRQcmVjZWRlbmNlKSB7XG5cdFx0XHRcdFx0XHRcdCRhY3RpdmUgPSBzZWxmLmdldEFkamFjZW50T3B0aW9uKCRjcmVhdGUsIDEpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0JGFjdGl2ZSA9ICRkcm9wZG93bl9jb250ZW50LmZpbmQoJ1tkYXRhLXNlbGVjdGFibGVdOmZpcnN0Jyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCRhY3RpdmUgPSAkY3JlYXRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuc2V0QWN0aXZlT3B0aW9uKCRhY3RpdmUpO1xuXHRcdFx0XHRpZiAodHJpZ2dlckRyb3Bkb3duICYmICFzZWxmLmlzT3BlbikgeyBzZWxmLm9wZW4oKTsgfVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5zZXRBY3RpdmVPcHRpb24obnVsbCk7XG5cdFx0XHRcdGlmICh0cmlnZ2VyRHJvcGRvd24gJiYgc2VsZi5pc09wZW4pIHsgc2VsZi5jbG9zZSgpOyB9XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQWRkcyBhbiBhdmFpbGFibGUgb3B0aW9uLiBJZiBpdCBhbHJlYWR5IGV4aXN0cyxcblx0XHQgKiBub3RoaW5nIHdpbGwgaGFwcGVuLiBOb3RlOiB0aGlzIGRvZXMgbm90IHJlZnJlc2hcblx0XHQgKiB0aGUgb3B0aW9ucyBsaXN0IGRyb3Bkb3duICh1c2UgYHJlZnJlc2hPcHRpb25zYFxuXHRcdCAqIGZvciB0aGF0KS5cblx0XHQgKlxuXHRcdCAqIFVzYWdlOlxuXHRcdCAqXG5cdFx0ICogICB0aGlzLmFkZE9wdGlvbihkYXRhKVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R8YXJyYXl9IGRhdGFcblx0XHQgKi9cblx0XHRhZGRPcHRpb246IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdHZhciBpLCBuLCB2YWx1ZSwgc2VsZiA9IHRoaXM7XG5cdFxuXHRcdFx0aWYgKCQuaXNBcnJheShkYXRhKSkge1xuXHRcdFx0XHRmb3IgKGkgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0XHRzZWxmLmFkZE9wdGlvbihkYXRhW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKHZhbHVlID0gc2VsZi5yZWdpc3Rlck9wdGlvbihkYXRhKSkge1xuXHRcdFx0XHRzZWxmLnVzZXJPcHRpb25zW3ZhbHVlXSA9IHRydWU7XG5cdFx0XHRcdHNlbGYubGFzdFF1ZXJ5ID0gbnVsbDtcblx0XHRcdFx0c2VsZi50cmlnZ2VyKCdvcHRpb25fYWRkJywgdmFsdWUsIGRhdGEpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJlZ2lzdGVycyBhbiBvcHRpb24gdG8gdGhlIHBvb2wgb2Ygb3B0aW9ucy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbnxzdHJpbmd9XG5cdFx0ICovXG5cdFx0cmVnaXN0ZXJPcHRpb246IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdHZhciBrZXkgPSBoYXNoX2tleShkYXRhW3RoaXMuc2V0dGluZ3MudmFsdWVGaWVsZF0pO1xuXHRcdFx0aWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnIHx8IGtleSA9PT0gbnVsbCB8fCB0aGlzLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0ZGF0YS4kb3JkZXIgPSBkYXRhLiRvcmRlciB8fCArK3RoaXMub3JkZXI7XG5cdFx0XHR0aGlzLm9wdGlvbnNba2V5XSA9IGRhdGE7XG5cdFx0XHRyZXR1cm4ga2V5O1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJlZ2lzdGVycyBhbiBvcHRpb24gZ3JvdXAgdG8gdGhlIHBvb2wgb2Ygb3B0aW9uIGdyb3Vwcy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbnxzdHJpbmd9XG5cdFx0ICovXG5cdFx0cmVnaXN0ZXJPcHRpb25Hcm91cDogZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0dmFyIGtleSA9IGhhc2hfa2V5KGRhdGFbdGhpcy5zZXR0aW5ncy5vcHRncm91cFZhbHVlRmllbGRdKTtcblx0XHRcdGlmICgha2V5KSByZXR1cm4gZmFsc2U7XG5cdFxuXHRcdFx0ZGF0YS4kb3JkZXIgPSBkYXRhLiRvcmRlciB8fCArK3RoaXMub3JkZXI7XG5cdFx0XHR0aGlzLm9wdGdyb3Vwc1trZXldID0gZGF0YTtcblx0XHRcdHJldHVybiBrZXk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXJzIGEgbmV3IG9wdGdyb3VwIGZvciBvcHRpb25zXG5cdFx0ICogdG8gYmUgYnVja2V0ZWQgaW50by5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG5cdFx0ICovXG5cdFx0YWRkT3B0aW9uR3JvdXA6IGZ1bmN0aW9uKGlkLCBkYXRhKSB7XG5cdFx0XHRkYXRhW3RoaXMuc2V0dGluZ3Mub3B0Z3JvdXBWYWx1ZUZpZWxkXSA9IGlkO1xuXHRcdFx0aWYgKGlkID0gdGhpcy5yZWdpc3Rlck9wdGlvbkdyb3VwKGRhdGEpKSB7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcignb3B0Z3JvdXBfYWRkJywgaWQsIGRhdGEpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgYW4gZXhpc3Rpbmcgb3B0aW9uIGdyb3VwLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdFx0ICovXG5cdFx0cmVtb3ZlT3B0aW9uR3JvdXA6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0XHRpZiAodGhpcy5vcHRncm91cHMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLm9wdGdyb3Vwc1tpZF07XG5cdFx0XHRcdHRoaXMucmVuZGVyQ2FjaGUgPSB7fTtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdvcHRncm91cF9yZW1vdmUnLCBpZCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2xlYXJzIGFsbCBleGlzdGluZyBvcHRpb24gZ3JvdXBzLlxuXHRcdCAqL1xuXHRcdGNsZWFyT3B0aW9uR3JvdXBzOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMub3B0Z3JvdXBzID0ge307XG5cdFx0XHR0aGlzLnJlbmRlckNhY2hlID0ge307XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ29wdGdyb3VwX2NsZWFyJyk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyBhbiBvcHRpb24gYXZhaWxhYmxlIGZvciBzZWxlY3Rpb24uIElmXG5cdFx0ICogaXQgaXMgdmlzaWJsZSBpbiB0aGUgc2VsZWN0ZWQgaXRlbXMgb3Igb3B0aW9uc1xuXHRcdCAqIGRyb3Bkb3duLCBpdCB3aWxsIGJlIHJlLXJlbmRlcmVkIGF1dG9tYXRpY2FsbHkuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuXHRcdCAqL1xuXHRcdHVwZGF0ZU9wdGlvbjogZnVuY3Rpb24odmFsdWUsIGRhdGEpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciAkaXRlbSwgJGl0ZW1fbmV3O1xuXHRcdFx0dmFyIHZhbHVlX25ldywgaW5kZXhfaXRlbSwgY2FjaGVfaXRlbXMsIGNhY2hlX29wdGlvbnMsIG9yZGVyX29sZDtcblx0XG5cdFx0XHR2YWx1ZSAgICAgPSBoYXNoX2tleSh2YWx1ZSk7XG5cdFx0XHR2YWx1ZV9uZXcgPSBoYXNoX2tleShkYXRhW3NlbGYuc2V0dGluZ3MudmFsdWVGaWVsZF0pO1xuXHRcblx0XHRcdC8vIHNhbml0eSBjaGVja3Ncblx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuO1xuXHRcdFx0aWYgKCFzZWxmLm9wdGlvbnMuaGFzT3duUHJvcGVydHkodmFsdWUpKSByZXR1cm47XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlX25ldyAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcignVmFsdWUgbXVzdCBiZSBzZXQgaW4gb3B0aW9uIGRhdGEnKTtcblx0XG5cdFx0XHRvcmRlcl9vbGQgPSBzZWxmLm9wdGlvbnNbdmFsdWVdLiRvcmRlcjtcblx0XG5cdFx0XHQvLyB1cGRhdGUgcmVmZXJlbmNlc1xuXHRcdFx0aWYgKHZhbHVlX25ldyAhPT0gdmFsdWUpIHtcblx0XHRcdFx0ZGVsZXRlIHNlbGYub3B0aW9uc1t2YWx1ZV07XG5cdFx0XHRcdGluZGV4X2l0ZW0gPSBzZWxmLml0ZW1zLmluZGV4T2YodmFsdWUpO1xuXHRcdFx0XHRpZiAoaW5kZXhfaXRlbSAhPT0gLTEpIHtcblx0XHRcdFx0XHRzZWxmLml0ZW1zLnNwbGljZShpbmRleF9pdGVtLCAxLCB2YWx1ZV9uZXcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRkYXRhLiRvcmRlciA9IGRhdGEuJG9yZGVyIHx8IG9yZGVyX29sZDtcblx0XHRcdHNlbGYub3B0aW9uc1t2YWx1ZV9uZXddID0gZGF0YTtcblx0XG5cdFx0XHQvLyBpbnZhbGlkYXRlIHJlbmRlciBjYWNoZVxuXHRcdFx0Y2FjaGVfaXRlbXMgPSBzZWxmLnJlbmRlckNhY2hlWydpdGVtJ107XG5cdFx0XHRjYWNoZV9vcHRpb25zID0gc2VsZi5yZW5kZXJDYWNoZVsnb3B0aW9uJ107XG5cdFxuXHRcdFx0aWYgKGNhY2hlX2l0ZW1zKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZV9pdGVtc1t2YWx1ZV07XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZV9pdGVtc1t2YWx1ZV9uZXddO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNhY2hlX29wdGlvbnMpIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlX29wdGlvbnNbdmFsdWVdO1xuXHRcdFx0XHRkZWxldGUgY2FjaGVfb3B0aW9uc1t2YWx1ZV9uZXddO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIHVwZGF0ZSB0aGUgaXRlbSBpZiBpdCdzIHNlbGVjdGVkXG5cdFx0XHRpZiAoc2VsZi5pdGVtcy5pbmRleE9mKHZhbHVlX25ldykgIT09IC0xKSB7XG5cdFx0XHRcdCRpdGVtID0gc2VsZi5nZXRJdGVtKHZhbHVlKTtcblx0XHRcdFx0JGl0ZW1fbmV3ID0gJChzZWxmLnJlbmRlcignaXRlbScsIGRhdGEpKTtcblx0XHRcdFx0aWYgKCRpdGVtLmhhc0NsYXNzKCdhY3RpdmUnKSkgJGl0ZW1fbmV3LmFkZENsYXNzKCdhY3RpdmUnKTtcblx0XHRcdFx0JGl0ZW0ucmVwbGFjZVdpdGgoJGl0ZW1fbmV3KTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBpbnZhbGlkYXRlIGxhc3QgcXVlcnkgYmVjYXVzZSB3ZSBtaWdodCBoYXZlIHVwZGF0ZWQgdGhlIHNvcnRGaWVsZFxuXHRcdFx0c2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuXHRcblx0XHRcdC8vIHVwZGF0ZSBkcm9wZG93biBjb250ZW50c1xuXHRcdFx0aWYgKHNlbGYuaXNPcGVuKSB7XG5cdFx0XHRcdHNlbGYucmVmcmVzaE9wdGlvbnMoZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgYSBzaW5nbGUgb3B0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBzaWxlbnRcblx0XHQgKi9cblx0XHRyZW1vdmVPcHRpb246IGZ1bmN0aW9uKHZhbHVlLCBzaWxlbnQpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhbHVlID0gaGFzaF9rZXkodmFsdWUpO1xuXHRcblx0XHRcdHZhciBjYWNoZV9pdGVtcyA9IHNlbGYucmVuZGVyQ2FjaGVbJ2l0ZW0nXTtcblx0XHRcdHZhciBjYWNoZV9vcHRpb25zID0gc2VsZi5yZW5kZXJDYWNoZVsnb3B0aW9uJ107XG5cdFx0XHRpZiAoY2FjaGVfaXRlbXMpIGRlbGV0ZSBjYWNoZV9pdGVtc1t2YWx1ZV07XG5cdFx0XHRpZiAoY2FjaGVfb3B0aW9ucykgZGVsZXRlIGNhY2hlX29wdGlvbnNbdmFsdWVdO1xuXHRcblx0XHRcdGRlbGV0ZSBzZWxmLnVzZXJPcHRpb25zW3ZhbHVlXTtcblx0XHRcdGRlbGV0ZSBzZWxmLm9wdGlvbnNbdmFsdWVdO1xuXHRcdFx0c2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuXHRcdFx0c2VsZi50cmlnZ2VyKCdvcHRpb25fcmVtb3ZlJywgdmFsdWUpO1xuXHRcdFx0c2VsZi5yZW1vdmVJdGVtKHZhbHVlLCBzaWxlbnQpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENsZWFycyBhbGwgb3B0aW9ucy5cblx0XHQgKi9cblx0XHRjbGVhck9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0XHRcdHNlbGYubG9hZGVkU2VhcmNoZXMgPSB7fTtcblx0XHRcdHNlbGYudXNlck9wdGlvbnMgPSB7fTtcblx0XHRcdHNlbGYucmVuZGVyQ2FjaGUgPSB7fTtcblx0XHRcdHZhciBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuXHRcdFx0JC5lYWNoKHNlbGYub3B0aW9ucywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHRcdFx0XHRpZihzZWxmLml0ZW1zLmluZGV4T2Yoa2V5KSA9PSAtMSkge1xuXHRcdFx0XHRcdGRlbGV0ZSBvcHRpb25zW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0c2VsZi5vcHRpb25zID0gc2VsZi5zaWZ0ZXIuaXRlbXMgPSBvcHRpb25zO1xuXHRcdFx0c2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuXHRcdFx0c2VsZi50cmlnZ2VyKCdvcHRpb25fY2xlYXInKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBqUXVlcnkgZWxlbWVudCBvZiB0aGUgb3B0aW9uXG5cdFx0ICogbWF0Y2hpbmcgdGhlIGdpdmVuIHZhbHVlLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG5cdFx0ICogQHJldHVybnMge29iamVjdH1cblx0XHQgKi9cblx0XHRnZXRPcHRpb246IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRFbGVtZW50V2l0aFZhbHVlKHZhbHVlLCB0aGlzLiRkcm9wZG93bl9jb250ZW50LmZpbmQoJ1tkYXRhLXNlbGVjdGFibGVdJykpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIGpRdWVyeSBlbGVtZW50IG9mIHRoZSBuZXh0IG9yXG5cdFx0ICogcHJldmlvdXMgc2VsZWN0YWJsZSBvcHRpb24uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gJG9wdGlvblxuXHRcdCAqIEBwYXJhbSB7aW50fSBkaXJlY3Rpb24gIGNhbiBiZSAxIGZvciBuZXh0IG9yIC0xIGZvciBwcmV2aW91c1xuXHRcdCAqIEByZXR1cm4ge29iamVjdH1cblx0XHQgKi9cblx0XHRnZXRBZGphY2VudE9wdGlvbjogZnVuY3Rpb24oJG9wdGlvbiwgZGlyZWN0aW9uKSB7XG5cdFx0XHR2YXIgJG9wdGlvbnMgPSB0aGlzLiRkcm9wZG93bi5maW5kKCdbZGF0YS1zZWxlY3RhYmxlXScpO1xuXHRcdFx0dmFyIGluZGV4ICAgID0gJG9wdGlvbnMuaW5kZXgoJG9wdGlvbikgKyBkaXJlY3Rpb247XG5cdFxuXHRcdFx0cmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPCAkb3B0aW9ucy5sZW5ndGggPyAkb3B0aW9ucy5lcShpbmRleCkgOiAkKCk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmluZHMgdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCBhIFwiZGF0YS12YWx1ZVwiIGF0dHJpYnV0ZVxuXHRcdCAqIHRoYXQgbWF0Y2hlcyB0aGUgZ2l2ZW4gdmFsdWUuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge21peGVkfSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSAkZWxzXG5cdFx0ICogQHJldHVybiB7b2JqZWN0fVxuXHRcdCAqL1xuXHRcdGdldEVsZW1lbnRXaXRoVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCAkZWxzKSB7XG5cdFx0XHR2YWx1ZSA9IGhhc2hfa2V5KHZhbHVlKTtcblx0XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9ICRlbHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKCRlbHNbaV0uZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJykgPT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJCgkZWxzW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gJCgpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIGpRdWVyeSBlbGVtZW50IG9mIHRoZSBpdGVtXG5cdFx0ICogbWF0Y2hpbmcgdGhlIGdpdmVuIHZhbHVlLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG5cdFx0ICogQHJldHVybnMge29iamVjdH1cblx0XHQgKi9cblx0XHRnZXRJdGVtOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0RWxlbWVudFdpdGhWYWx1ZSh2YWx1ZSwgdGhpcy4kY29udHJvbC5jaGlsZHJlbigpKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBcIlNlbGVjdHNcIiBtdWx0aXBsZSBpdGVtcyBhdCBvbmNlLiBBZGRzIHRoZW0gdG8gdGhlIGxpc3Rcblx0XHQgKiBhdCB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50XG5cdFx0ICovXG5cdFx0YWRkSXRlbXM6IGZ1bmN0aW9uKHZhbHVlcywgc2lsZW50KSB7XG5cdFx0XHR0aGlzLmJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XG5cdFx0XHR2YXIgY2hpbGROb2RlcyA9IHRoaXMuJGNvbnRyb2xbMF0uY2hpbGROb2Rlcztcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLmJ1ZmZlci5hcHBlbmRDaGlsZChjaGlsZE5vZGVzW2ldKTtcblx0XHRcdH1cblx0XG5cdFx0XHR2YXIgaXRlbXMgPSAkLmlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcyA6IFt2YWx1ZXNdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0dGhpcy5pc1BlbmRpbmcgPSAoaSA8IG4gLSAxKTtcblx0XHRcdFx0dGhpcy5hZGRJdGVtKGl0ZW1zW2ldLCBzaWxlbnQpO1xuXHRcdFx0fVxuXHRcblx0XHRcdHZhciBjb250cm9sID0gdGhpcy4kY29udHJvbFswXTtcblx0XHRcdGNvbnRyb2wuaW5zZXJ0QmVmb3JlKHRoaXMuYnVmZmVyLCBjb250cm9sLmZpcnN0Q2hpbGQpO1xuXHRcblx0XHRcdHRoaXMuYnVmZmVyID0gbnVsbDtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBcIlNlbGVjdHNcIiBhbiBpdGVtLiBBZGRzIGl0IHRvIHRoZSBsaXN0XG5cdFx0ICogYXQgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudFxuXHRcdCAqL1xuXHRcdGFkZEl0ZW06IGZ1bmN0aW9uKHZhbHVlLCBzaWxlbnQpIHtcblx0XHRcdHZhciBldmVudHMgPSBzaWxlbnQgPyBbXSA6IFsnY2hhbmdlJ107XG5cdFxuXHRcdFx0ZGVib3VuY2VfZXZlbnRzKHRoaXMsIGV2ZW50cywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciAkaXRlbSwgJG9wdGlvbiwgJG9wdGlvbnM7XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdFx0dmFyIGlucHV0TW9kZSA9IHNlbGYuc2V0dGluZ3MubW9kZTtcblx0XHRcdFx0dmFyIGksIGFjdGl2ZSwgdmFsdWVfbmV4dCwgd2FzRnVsbDtcblx0XHRcdFx0dmFsdWUgPSBoYXNoX2tleSh2YWx1ZSk7XG5cdFxuXHRcdFx0XHRpZiAoc2VsZi5pdGVtcy5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRpZiAoaW5wdXRNb2RlID09PSAnc2luZ2xlJykgc2VsZi5jbG9zZSgpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0aWYgKCFzZWxmLm9wdGlvbnMuaGFzT3duUHJvcGVydHkodmFsdWUpKSByZXR1cm47XG5cdFx0XHRcdGlmIChpbnB1dE1vZGUgPT09ICdzaW5nbGUnKSBzZWxmLmNsZWFyKHNpbGVudCk7XG5cdFx0XHRcdGlmIChpbnB1dE1vZGUgPT09ICdtdWx0aScgJiYgc2VsZi5pc0Z1bGwoKSkgcmV0dXJuO1xuXHRcblx0XHRcdFx0JGl0ZW0gPSAkKHNlbGYucmVuZGVyKCdpdGVtJywgc2VsZi5vcHRpb25zW3ZhbHVlXSkpO1xuXHRcdFx0XHR3YXNGdWxsID0gc2VsZi5pc0Z1bGwoKTtcblx0XHRcdFx0c2VsZi5pdGVtcy5zcGxpY2Uoc2VsZi5jYXJldFBvcywgMCwgdmFsdWUpO1xuXHRcdFx0XHRzZWxmLmluc2VydEF0Q2FyZXQoJGl0ZW0pO1xuXHRcdFx0XHRpZiAoIXNlbGYuaXNQZW5kaW5nIHx8ICghd2FzRnVsbCAmJiBzZWxmLmlzRnVsbCgpKSkge1xuXHRcdFx0XHRcdHNlbGYucmVmcmVzaFN0YXRlKCk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGlmIChzZWxmLmlzU2V0dXApIHtcblx0XHRcdFx0XHQkb3B0aW9ucyA9IHNlbGYuJGRyb3Bkb3duX2NvbnRlbnQuZmluZCgnW2RhdGEtc2VsZWN0YWJsZV0nKTtcblx0XG5cdFx0XHRcdFx0Ly8gdXBkYXRlIG1lbnUgLyByZW1vdmUgdGhlIG9wdGlvbiAoaWYgdGhpcyBpcyBub3Qgb25lIGl0ZW0gYmVpbmcgYWRkZWQgYXMgcGFydCBvZiBzZXJpZXMpXG5cdFx0XHRcdFx0aWYgKCFzZWxmLmlzUGVuZGluZykge1xuXHRcdFx0XHRcdFx0JG9wdGlvbiA9IHNlbGYuZ2V0T3B0aW9uKHZhbHVlKTtcblx0XHRcdFx0XHRcdHZhbHVlX25leHQgPSBzZWxmLmdldEFkamFjZW50T3B0aW9uKCRvcHRpb24sIDEpLmF0dHIoJ2RhdGEtdmFsdWUnKTtcblx0XHRcdFx0XHRcdHNlbGYucmVmcmVzaE9wdGlvbnMoc2VsZi5pc0ZvY3VzZWQgJiYgaW5wdXRNb2RlICE9PSAnc2luZ2xlJyk7XG5cdFx0XHRcdFx0XHRpZiAodmFsdWVfbmV4dCkge1xuXHRcdFx0XHRcdFx0XHRzZWxmLnNldEFjdGl2ZU9wdGlvbihzZWxmLmdldE9wdGlvbih2YWx1ZV9uZXh0KSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvLyBoaWRlIHRoZSBtZW51IGlmIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyBoYXZlIGJlZW4gc2VsZWN0ZWQgb3Igbm8gb3B0aW9ucyBhcmUgbGVmdFxuXHRcdFx0XHRcdGlmICghJG9wdGlvbnMubGVuZ3RoIHx8IHNlbGYuaXNGdWxsKCkpIHtcblx0XHRcdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFzZWxmLmlzUGVuZGluZykge1xuXHRcdFx0XHRcdFx0c2VsZi5wb3NpdGlvbkRyb3Bkb3duKCk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRzZWxmLnVwZGF0ZVBsYWNlaG9sZGVyKCk7XG5cdFx0XHRcdFx0c2VsZi50cmlnZ2VyKCdpdGVtX2FkZCcsIHZhbHVlLCAkaXRlbSk7XG5cdFxuXHRcdFx0XHRcdGlmICghc2VsZi5pc1BlbmRpbmcpIHtcblx0XHRcdFx0XHRcdHNlbGYudXBkYXRlT3JpZ2luYWxJbnB1dCh7c2lsZW50OiBzaWxlbnR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgdGhlIHNlbGVjdGVkIGl0ZW0gbWF0Y2hpbmdcblx0XHQgKiB0aGUgcHJvdmlkZWQgdmFsdWUuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0XHQgKi9cblx0XHRyZW1vdmVJdGVtOiBmdW5jdGlvbih2YWx1ZSwgc2lsZW50KSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR2YXIgJGl0ZW0sIGksIGlkeDtcblx0XG5cdFx0XHQkaXRlbSA9ICh2YWx1ZSBpbnN0YW5jZW9mICQpID8gdmFsdWUgOiBzZWxmLmdldEl0ZW0odmFsdWUpO1xuXHRcdFx0dmFsdWUgPSBoYXNoX2tleSgkaXRlbS5hdHRyKCdkYXRhLXZhbHVlJykpO1xuXHRcdFx0aSA9IHNlbGYuaXRlbXMuaW5kZXhPZih2YWx1ZSk7XG5cdFxuXHRcdFx0aWYgKGkgIT09IC0xKSB7XG5cdFx0XHRcdCRpdGVtLnJlbW92ZSgpO1xuXHRcdFx0XHRpZiAoJGl0ZW0uaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XG5cdFx0XHRcdFx0aWR4ID0gc2VsZi4kYWN0aXZlSXRlbXMuaW5kZXhPZigkaXRlbVswXSk7XG5cdFx0XHRcdFx0c2VsZi4kYWN0aXZlSXRlbXMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHNlbGYuaXRlbXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG5cdFx0XHRcdGlmICghc2VsZi5zZXR0aW5ncy5wZXJzaXN0ICYmIHNlbGYudXNlck9wdGlvbnMuaGFzT3duUHJvcGVydHkodmFsdWUpKSB7XG5cdFx0XHRcdFx0c2VsZi5yZW1vdmVPcHRpb24odmFsdWUsIHNpbGVudCk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGlmIChpIDwgc2VsZi5jYXJldFBvcykge1xuXHRcdFx0XHRcdHNlbGYuc2V0Q2FyZXQoc2VsZi5jYXJldFBvcyAtIDEpO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHRcdFx0XHRzZWxmLnVwZGF0ZVBsYWNlaG9sZGVyKCk7XG5cdFx0XHRcdHNlbGYudXBkYXRlT3JpZ2luYWxJbnB1dCh7c2lsZW50OiBzaWxlbnR9KTtcblx0XHRcdFx0c2VsZi5wb3NpdGlvbkRyb3Bkb3duKCk7XG5cdFx0XHRcdHNlbGYudHJpZ2dlcignaXRlbV9yZW1vdmUnLCB2YWx1ZSwgJGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEludm9rZXMgdGhlIGBjcmVhdGVgIG1ldGhvZCBwcm92aWRlZCBpbiB0aGVcblx0XHQgKiBzZWxlY3RpemUgb3B0aW9ucyB0aGF0IHNob3VsZCBwcm92aWRlIHRoZSBkYXRhXG5cdFx0ICogZm9yIHRoZSBuZXcgaXRlbSwgZ2l2ZW4gdGhlIHVzZXIgaW5wdXQuXG5cdFx0ICpcblx0XHQgKiBPbmNlIHRoaXMgY29tcGxldGVzLCBpdCB3aWxsIGJlIGFkZGVkXG5cdFx0ICogdG8gdGhlIGl0ZW0gbGlzdC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3RyaWdnZXJEcm9wZG93bl1cblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdXG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHRjcmVhdGVJdGVtOiBmdW5jdGlvbihpbnB1dCwgdHJpZ2dlckRyb3Bkb3duKSB7XG5cdFx0XHR2YXIgc2VsZiAgPSB0aGlzO1xuXHRcdFx0dmFyIGNhcmV0ID0gc2VsZi5jYXJldFBvcztcblx0XHRcdGlucHV0ID0gaW5wdXQgfHwgJC50cmltKHNlbGYuJGNvbnRyb2xfaW5wdXQudmFsKCkgfHwgJycpO1xuXHRcblx0XHRcdHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG5cdFx0XHRpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSBjYWxsYmFjayA9IGZ1bmN0aW9uKCkge307XG5cdFxuXHRcdFx0aWYgKHR5cGVvZiB0cmlnZ2VyRHJvcGRvd24gIT09ICdib29sZWFuJykge1xuXHRcdFx0XHR0cmlnZ2VyRHJvcGRvd24gPSB0cnVlO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICghc2VsZi5jYW5DcmVhdGUoaW5wdXQpKSB7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XG5cdFx0XHRzZWxmLmxvY2soKTtcblx0XG5cdFx0XHR2YXIgc2V0dXAgPSAodHlwZW9mIHNlbGYuc2V0dGluZ3MuY3JlYXRlID09PSAnZnVuY3Rpb24nKSA/IHRoaXMuc2V0dGluZ3MuY3JlYXRlIDogZnVuY3Rpb24oaW5wdXQpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSB7fTtcblx0XHRcdFx0ZGF0YVtzZWxmLnNldHRpbmdzLmxhYmVsRmllbGRdID0gaW5wdXQ7XG5cdFx0XHRcdGRhdGFbc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXSA9IGlucHV0O1xuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH07XG5cdFxuXHRcdFx0dmFyIGNyZWF0ZSA9IG9uY2UoZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRzZWxmLnVubG9jaygpO1xuXHRcblx0XHRcdFx0aWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JykgcmV0dXJuIGNhbGxiYWNrKCk7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IGhhc2hfa2V5KGRhdGFbc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXSk7XG5cdFx0XHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSByZXR1cm4gY2FsbGJhY2soKTtcblx0XG5cdFx0XHRcdHNlbGYuc2V0VGV4dGJveFZhbHVlKCcnKTtcblx0XHRcdFx0c2VsZi5hZGRPcHRpb24oZGF0YSk7XG5cdFx0XHRcdHNlbGYuc2V0Q2FyZXQoY2FyZXQpO1xuXHRcdFx0XHRzZWxmLmFkZEl0ZW0odmFsdWUpO1xuXHRcdFx0XHRzZWxmLnJlZnJlc2hPcHRpb25zKHRyaWdnZXJEcm9wZG93biAmJiBzZWxmLnNldHRpbmdzLm1vZGUgIT09ICdzaW5nbGUnKTtcblx0XHRcdFx0Y2FsbGJhY2soZGF0YSk7XG5cdFx0XHR9KTtcblx0XG5cdFx0XHR2YXIgb3V0cHV0ID0gc2V0dXAuYXBwbHkodGhpcywgW2lucHV0LCBjcmVhdGVdKTtcblx0XHRcdGlmICh0eXBlb2Ygb3V0cHV0ICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRjcmVhdGUob3V0cHV0KTtcblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBSZS1yZW5kZXJzIHRoZSBzZWxlY3RlZCBpdGVtIGxpc3RzLlxuXHRcdCAqL1xuXHRcdHJlZnJlc2hJdGVtczogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmxhc3RRdWVyeSA9IG51bGw7XG5cdFxuXHRcdFx0aWYgKHRoaXMuaXNTZXR1cCkge1xuXHRcdFx0XHR0aGlzLmFkZEl0ZW0odGhpcy5pdGVtcyk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0dGhpcy5yZWZyZXNoU3RhdGUoKTtcblx0XHRcdHRoaXMudXBkYXRlT3JpZ2luYWxJbnB1dCgpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgYWxsIHN0YXRlLWRlcGVuZGVudCBhdHRyaWJ1dGVzXG5cdFx0ICogYW5kIENTUyBjbGFzc2VzLlxuXHRcdCAqL1xuXHRcdHJlZnJlc2hTdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlZnJlc2hWYWxpZGl0eVN0YXRlKCk7XG5cdFx0XHR0aGlzLnJlZnJlc2hDbGFzc2VzKCk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIHRoZSBgcmVxdWlyZWRgIGF0dHJpYnV0ZSBvZiBib3RoIGlucHV0IGFuZCBjb250cm9sIGlucHV0LlxuXHRcdCAqXG5cdFx0ICogVGhlIGByZXF1aXJlZGAgcHJvcGVydHkgbmVlZHMgdG8gYmUgYWN0aXZhdGVkIG9uIHRoZSBjb250cm9sIGlucHV0XG5cdFx0ICogZm9yIHRoZSBlcnJvciB0byBiZSBkaXNwbGF5ZWQgYXQgdGhlIHJpZ2h0IHBsYWNlLiBgcmVxdWlyZWRgIGFsc29cblx0XHQgKiBuZWVkcyB0byBiZSB0ZW1wb3JhcmlseSBkZWFjdGl2YXRlZCBvbiB0aGUgaW5wdXQgc2luY2UgdGhlIGlucHV0IGlzXG5cdFx0ICogaGlkZGVuIGFuZCBjYW4ndCBzaG93IGVycm9ycy5cblx0XHQgKi9cblx0XHRyZWZyZXNoVmFsaWRpdHlTdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXRoaXMuaXNSZXF1aXJlZCkgcmV0dXJuIGZhbHNlO1xuXHRcblx0XHRcdHZhciBpbnZhbGlkID0gIXRoaXMuaXRlbXMubGVuZ3RoO1xuXHRcblx0XHRcdHRoaXMuaXNJbnZhbGlkID0gaW52YWxpZDtcblx0XHRcdHRoaXMuJGNvbnRyb2xfaW5wdXQucHJvcCgncmVxdWlyZWQnLCBpbnZhbGlkKTtcblx0XHRcdHRoaXMuJGlucHV0LnByb3AoJ3JlcXVpcmVkJywgIWludmFsaWQpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgYWxsIHN0YXRlLWRlcGVuZGVudCBDU1MgY2xhc3Nlcy5cblx0XHQgKi9cblx0XHRyZWZyZXNoQ2xhc3NlczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiAgICAgPSB0aGlzO1xuXHRcdFx0dmFyIGlzRnVsbCAgID0gc2VsZi5pc0Z1bGwoKTtcblx0XHRcdHZhciBpc0xvY2tlZCA9IHNlbGYuaXNMb2NrZWQ7XG5cdFxuXHRcdFx0c2VsZi4kd3JhcHBlclxuXHRcdFx0XHQudG9nZ2xlQ2xhc3MoJ3J0bCcsIHNlbGYucnRsKTtcblx0XG5cdFx0XHRzZWxmLiRjb250cm9sXG5cdFx0XHRcdC50b2dnbGVDbGFzcygnZm9jdXMnLCBzZWxmLmlzRm9jdXNlZClcblx0XHRcdFx0LnRvZ2dsZUNsYXNzKCdkaXNhYmxlZCcsIHNlbGYuaXNEaXNhYmxlZClcblx0XHRcdFx0LnRvZ2dsZUNsYXNzKCdyZXF1aXJlZCcsIHNlbGYuaXNSZXF1aXJlZClcblx0XHRcdFx0LnRvZ2dsZUNsYXNzKCdpbnZhbGlkJywgc2VsZi5pc0ludmFsaWQpXG5cdFx0XHRcdC50b2dnbGVDbGFzcygnbG9ja2VkJywgaXNMb2NrZWQpXG5cdFx0XHRcdC50b2dnbGVDbGFzcygnZnVsbCcsIGlzRnVsbCkudG9nZ2xlQ2xhc3MoJ25vdC1mdWxsJywgIWlzRnVsbClcblx0XHRcdFx0LnRvZ2dsZUNsYXNzKCdpbnB1dC1hY3RpdmUnLCBzZWxmLmlzRm9jdXNlZCAmJiAhc2VsZi5pc0lucHV0SGlkZGVuKVxuXHRcdFx0XHQudG9nZ2xlQ2xhc3MoJ2Ryb3Bkb3duLWFjdGl2ZScsIHNlbGYuaXNPcGVuKVxuXHRcdFx0XHQudG9nZ2xlQ2xhc3MoJ2hhcy1vcHRpb25zJywgISQuaXNFbXB0eU9iamVjdChzZWxmLm9wdGlvbnMpKVxuXHRcdFx0XHQudG9nZ2xlQ2xhc3MoJ2hhcy1pdGVtcycsIHNlbGYuaXRlbXMubGVuZ3RoID4gMCk7XG5cdFxuXHRcdFx0c2VsZi4kY29udHJvbF9pbnB1dC5kYXRhKCdncm93JywgIWlzRnVsbCAmJiAhaXNMb2NrZWQpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgbW9yZSBpdGVtcyBjYW4gYmUgYWRkZWRcblx0XHQgKiB0byB0aGUgY29udHJvbCB3aXRob3V0IGV4Y2VlZGluZyB0aGUgdXNlci1kZWZpbmVkIG1heGltdW0uXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHRpc0Z1bGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0dGluZ3MubWF4SXRlbXMgIT09IG51bGwgJiYgdGhpcy5pdGVtcy5sZW5ndGggPj0gdGhpcy5zZXR0aW5ncy5tYXhJdGVtcztcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBSZWZyZXNoZXMgdGhlIG9yaWdpbmFsIDxzZWxlY3Q+IG9yIDxpbnB1dD5cblx0XHQgKiBlbGVtZW50IHRvIHJlZmxlY3QgdGhlIGN1cnJlbnQgc3RhdGUuXG5cdFx0ICovXG5cdFx0dXBkYXRlT3JpZ2luYWxJbnB1dDogZnVuY3Rpb24ob3B0cykge1xuXHRcdFx0dmFyIGksIG4sIG9wdGlvbnMsIGxhYmVsLCBzZWxmID0gdGhpcztcblx0XHRcdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHRcblx0XHRcdGlmIChzZWxmLnRhZ1R5cGUgPT09IFRBR19TRUxFQ1QpIHtcblx0XHRcdFx0b3B0aW9ucyA9IFtdO1xuXHRcdFx0XHRmb3IgKGkgPSAwLCBuID0gc2VsZi5pdGVtcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0XHRsYWJlbCA9IHNlbGYub3B0aW9uc1tzZWxmLml0ZW1zW2ldXVtzZWxmLnNldHRpbmdzLmxhYmVsRmllbGRdIHx8ICcnO1xuXHRcdFx0XHRcdG9wdGlvbnMucHVzaCgnPG9wdGlvbiB2YWx1ZT1cIicgKyBlc2NhcGVfaHRtbChzZWxmLml0ZW1zW2ldKSArICdcIiBzZWxlY3RlZD1cInNlbGVjdGVkXCI+JyArIGVzY2FwZV9odG1sKGxhYmVsKSArICc8L29wdGlvbj4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIW9wdGlvbnMubGVuZ3RoICYmICF0aGlzLiRpbnB1dC5hdHRyKCdtdWx0aXBsZScpKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5wdXNoKCc8b3B0aW9uIHZhbHVlPVwiXCIgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiPjwvb3B0aW9uPicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuJGlucHV0Lmh0bWwob3B0aW9ucy5qb2luKCcnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLiRpbnB1dC52YWwoc2VsZi5nZXRWYWx1ZSgpKTtcblx0XHRcdFx0c2VsZi4kaW5wdXQuYXR0cigndmFsdWUnLHNlbGYuJGlucHV0LnZhbCgpKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoc2VsZi5pc1NldHVwKSB7XG5cdFx0XHRcdGlmICghb3B0cy5zaWxlbnQpIHtcblx0XHRcdFx0XHRzZWxmLnRyaWdnZXIoJ2NoYW5nZScsIHNlbGYuJGlucHV0LnZhbCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNob3dzL2hpZGUgdGhlIGlucHV0IHBsYWNlaG9sZGVyIGRlcGVuZGluZ1xuXHRcdCAqIG9uIGlmIHRoZXJlIGl0ZW1zIGluIHRoZSBsaXN0IGFscmVhZHkuXG5cdFx0ICovXG5cdFx0dXBkYXRlUGxhY2Vob2xkZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLnNldHRpbmdzLnBsYWNlaG9sZGVyKSByZXR1cm47XG5cdFx0XHR2YXIgJGlucHV0ID0gdGhpcy4kY29udHJvbF9pbnB1dDtcblx0XG5cdFx0XHRpZiAodGhpcy5pdGVtcy5sZW5ndGgpIHtcblx0XHRcdFx0JGlucHV0LnJlbW92ZUF0dHIoJ3BsYWNlaG9sZGVyJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkaW5wdXQuYXR0cigncGxhY2Vob2xkZXInLCB0aGlzLnNldHRpbmdzLnBsYWNlaG9sZGVyKTtcblx0XHRcdH1cblx0XHRcdCRpbnB1dC50cmlnZ2VySGFuZGxlcigndXBkYXRlJywge2ZvcmNlOiB0cnVlfSk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU2hvd3MgdGhlIGF1dG9jb21wbGV0ZSBkcm9wZG93biBjb250YWluaW5nXG5cdFx0ICogdGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuXHRcdCAqL1xuXHRcdG9wZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0XHRcdGlmIChzZWxmLmlzTG9ja2VkIHx8IHNlbGYuaXNPcGVuIHx8IChzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdtdWx0aScgJiYgc2VsZi5pc0Z1bGwoKSkpIHJldHVybjtcblx0XHRcdHNlbGYuZm9jdXMoKTtcblx0XHRcdHNlbGYuaXNPcGVuID0gdHJ1ZTtcblx0XHRcdHNlbGYucmVmcmVzaFN0YXRlKCk7XG5cdFx0XHRzZWxmLiRkcm9wZG93bi5jc3Moe3Zpc2liaWxpdHk6ICdoaWRkZW4nLCBkaXNwbGF5OiAnYmxvY2snfSk7XG5cdFx0XHRzZWxmLnBvc2l0aW9uRHJvcGRvd24oKTtcblx0XHRcdHNlbGYuJGRyb3Bkb3duLmNzcyh7dmlzaWJpbGl0eTogJ3Zpc2libGUnfSk7XG5cdFx0XHRzZWxmLnRyaWdnZXIoJ2Ryb3Bkb3duX29wZW4nLCBzZWxmLiRkcm9wZG93bik7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2xvc2VzIHRoZSBhdXRvY29tcGxldGUgZHJvcGRvd24gbWVudS5cblx0XHQgKi9cblx0XHRjbG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR2YXIgdHJpZ2dlciA9IHNlbGYuaXNPcGVuO1xuXHRcblx0XHRcdGlmIChzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdzaW5nbGUnICYmIHNlbGYuaXRlbXMubGVuZ3RoKSB7XG5cdFx0XHRcdHNlbGYuaGlkZUlucHV0KCk7XG5cdFxuXHRcdFx0XHQvLyBEbyBub3QgdHJpZ2dlciBibHVyIHdoaWxlIGluc2lkZSBhIGJsdXIgZXZlbnQsXG5cdFx0XHRcdC8vIHRoaXMgZml4ZXMgc29tZSB3ZWlyZCB0YWJiaW5nIGJlaGF2aW9yIGluIEZGIGFuZCBJRS5cblx0XHRcdFx0Ly8gU2VlICMxMTY0XG5cdFx0XHRcdGlmICghc2VsZi5pc0JsdXJyaW5nKSB7XG5cdFx0XHRcdFx0c2VsZi4kY29udHJvbF9pbnB1dC5ibHVyKCk7IC8vIGNsb3NlIGtleWJvYXJkIG9uIGlPU1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0c2VsZi5pc09wZW4gPSBmYWxzZTtcblx0XHRcdHNlbGYuJGRyb3Bkb3duLmhpZGUoKTtcblx0XHRcdHNlbGYuc2V0QWN0aXZlT3B0aW9uKG51bGwpO1xuXHRcdFx0c2VsZi5yZWZyZXNoU3RhdGUoKTtcblx0XG5cdFx0XHRpZiAodHJpZ2dlcikgc2VsZi50cmlnZ2VyKCdkcm9wZG93bl9jbG9zZScsIHNlbGYuJGRyb3Bkb3duKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxjdWxhdGVzIGFuZCBhcHBsaWVzIHRoZSBhcHByb3ByaWF0ZVxuXHRcdCAqIHBvc2l0aW9uIG9mIHRoZSBkcm9wZG93bi5cblx0XHQgKi9cblx0XHRwb3NpdGlvbkRyb3Bkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciAkY29udHJvbCA9IHRoaXMuJGNvbnRyb2w7XG5cdFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5zZXR0aW5ncy5kcm9wZG93blBhcmVudCA9PT0gJ2JvZHknID8gJGNvbnRyb2wub2Zmc2V0KCkgOiAkY29udHJvbC5wb3NpdGlvbigpO1xuXHRcdFx0b2Zmc2V0LnRvcCArPSAkY29udHJvbC5vdXRlckhlaWdodCh0cnVlKTtcblx0XG5cdFx0XHR0aGlzLiRkcm9wZG93bi5jc3Moe1xuXHRcdFx0XHR3aWR0aCA6ICRjb250cm9sWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLFxuXHRcdFx0XHR0b3AgICA6IG9mZnNldC50b3AsXG5cdFx0XHRcdGxlZnQgIDogb2Zmc2V0LmxlZnRcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJlc2V0cyAvIGNsZWFycyBhbGwgc2VsZWN0ZWQgaXRlbXNcblx0XHQgKiBmcm9tIHRoZSBjb250cm9sLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBzaWxlbnRcblx0XHQgKi9cblx0XHRjbGVhcjogZnVuY3Rpb24oc2lsZW50KSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFxuXHRcdFx0aWYgKCFzZWxmLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuXHRcdFx0c2VsZi4kY29udHJvbC5jaGlsZHJlbignOm5vdChpbnB1dCknKS5yZW1vdmUoKTtcblx0XHRcdHNlbGYuaXRlbXMgPSBbXTtcblx0XHRcdHNlbGYubGFzdFF1ZXJ5ID0gbnVsbDtcblx0XHRcdHNlbGYuc2V0Q2FyZXQoMCk7XG5cdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW0obnVsbCk7XG5cdFx0XHRzZWxmLnVwZGF0ZVBsYWNlaG9sZGVyKCk7XG5cdFx0XHRzZWxmLnVwZGF0ZU9yaWdpbmFsSW5wdXQoe3NpbGVudDogc2lsZW50fSk7XG5cdFx0XHRzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHRcdFx0c2VsZi5zaG93SW5wdXQoKTtcblx0XHRcdHNlbGYudHJpZ2dlcignY2xlYXInKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBBIGhlbHBlciBtZXRob2QgZm9yIGluc2VydGluZyBhbiBlbGVtZW50XG5cdFx0ICogYXQgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gJGVsXG5cdFx0ICovXG5cdFx0aW5zZXJ0QXRDYXJldDogZnVuY3Rpb24oJGVsKSB7XG5cdFx0XHR2YXIgY2FyZXQgPSBNYXRoLm1pbih0aGlzLmNhcmV0UG9zLCB0aGlzLml0ZW1zLmxlbmd0aCk7XG5cdFx0XHR2YXIgZWwgPSAkZWxbMF07XG5cdFx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5idWZmZXIgfHwgdGhpcy4kY29udHJvbFswXTtcblx0XG5cdFx0XHRpZiAoY2FyZXQgPT09IDApIHtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShlbCwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShlbCwgdGFyZ2V0LmNoaWxkTm9kZXNbY2FyZXRdKTtcblx0XHRcdH1cblx0XG5cdFx0XHR0aGlzLnNldENhcmV0KGNhcmV0ICsgMSk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyB0aGUgY3VycmVudCBzZWxlY3RlZCBpdGVtKHMpLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGUgKG9wdGlvbmFsKVxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdGRlbGV0ZVNlbGVjdGlvbjogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIGksIG4sIGRpcmVjdGlvbiwgc2VsZWN0aW9uLCB2YWx1ZXMsIGNhcmV0LCBvcHRpb25fc2VsZWN0LCAkb3B0aW9uX3NlbGVjdCwgJHRhaWw7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFxuXHRcdFx0ZGlyZWN0aW9uID0gKGUgJiYgZS5rZXlDb2RlID09PSBLRVlfQkFDS1NQQUNFKSA/IC0xIDogMTtcblx0XHRcdHNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihzZWxmLiRjb250cm9sX2lucHV0WzBdKTtcblx0XG5cdFx0XHRpZiAoc2VsZi4kYWN0aXZlT3B0aW9uICYmICFzZWxmLnNldHRpbmdzLmhpZGVTZWxlY3RlZCkge1xuXHRcdFx0XHRvcHRpb25fc2VsZWN0ID0gc2VsZi5nZXRBZGphY2VudE9wdGlvbihzZWxmLiRhY3RpdmVPcHRpb24sIC0xKS5hdHRyKCdkYXRhLXZhbHVlJyk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gZGV0ZXJtaW5lIGl0ZW1zIHRoYXQgd2lsbCBiZSByZW1vdmVkXG5cdFx0XHR2YWx1ZXMgPSBbXTtcblx0XG5cdFx0XHRpZiAoc2VsZi4kYWN0aXZlSXRlbXMubGVuZ3RoKSB7XG5cdFx0XHRcdCR0YWlsID0gc2VsZi4kY29udHJvbC5jaGlsZHJlbignLmFjdGl2ZTonICsgKGRpcmVjdGlvbiA+IDAgPyAnbGFzdCcgOiAnZmlyc3QnKSk7XG5cdFx0XHRcdGNhcmV0ID0gc2VsZi4kY29udHJvbC5jaGlsZHJlbignOm5vdChpbnB1dCknKS5pbmRleCgkdGFpbCk7XG5cdFx0XHRcdGlmIChkaXJlY3Rpb24gPiAwKSB7IGNhcmV0Kys7IH1cblx0XG5cdFx0XHRcdGZvciAoaSA9IDAsIG4gPSBzZWxmLiRhY3RpdmVJdGVtcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0XHR2YWx1ZXMucHVzaCgkKHNlbGYuJGFjdGl2ZUl0ZW1zW2ldKS5hdHRyKCdkYXRhLXZhbHVlJykpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlKSB7XG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoKHNlbGYuaXNGb2N1c2VkIHx8IHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScpICYmIHNlbGYuaXRlbXMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmIChkaXJlY3Rpb24gPCAwICYmIHNlbGVjdGlvbi5zdGFydCA9PT0gMCAmJiBzZWxlY3Rpb24ubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goc2VsZi5pdGVtc1tzZWxmLmNhcmV0UG9zIC0gMV0pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA+IDAgJiYgc2VsZWN0aW9uLnN0YXJ0ID09PSBzZWxmLiRjb250cm9sX2lucHV0LnZhbCgpLmxlbmd0aCkge1xuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKHNlbGYuaXRlbXNbc2VsZi5jYXJldFBvc10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gYWxsb3cgdGhlIGNhbGxiYWNrIHRvIGFib3J0XG5cdFx0XHRpZiAoIXZhbHVlcy5sZW5ndGggfHwgKHR5cGVvZiBzZWxmLnNldHRpbmdzLm9uRGVsZXRlID09PSAnZnVuY3Rpb24nICYmIHNlbGYuc2V0dGluZ3Mub25EZWxldGUuYXBwbHkoc2VsZiwgW3ZhbHVlc10pID09PSBmYWxzZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIHBlcmZvcm0gcmVtb3ZhbFxuXHRcdFx0aWYgKHR5cGVvZiBjYXJldCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0c2VsZi5zZXRDYXJldChjYXJldCk7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAodmFsdWVzLmxlbmd0aCkge1xuXHRcdFx0XHRzZWxmLnJlbW92ZUl0ZW0odmFsdWVzLnBvcCgpKTtcblx0XHRcdH1cblx0XG5cdFx0XHRzZWxmLnNob3dJbnB1dCgpO1xuXHRcdFx0c2VsZi5wb3NpdGlvbkRyb3Bkb3duKCk7XG5cdFx0XHRzZWxmLnJlZnJlc2hPcHRpb25zKHRydWUpO1xuXHRcblx0XHRcdC8vIHNlbGVjdCBwcmV2aW91cyBvcHRpb25cblx0XHRcdGlmIChvcHRpb25fc2VsZWN0KSB7XG5cdFx0XHRcdCRvcHRpb25fc2VsZWN0ID0gc2VsZi5nZXRPcHRpb24ob3B0aW9uX3NlbGVjdCk7XG5cdFx0XHRcdGlmICgkb3B0aW9uX3NlbGVjdC5sZW5ndGgpIHtcblx0XHRcdFx0XHRzZWxmLnNldEFjdGl2ZU9wdGlvbigkb3B0aW9uX3NlbGVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBTZWxlY3RzIHRoZSBwcmV2aW91cyAvIG5leHQgaXRlbSAoZGVwZW5kaW5nXG5cdFx0ICogb24gdGhlIGBkaXJlY3Rpb25gIGFyZ3VtZW50KS5cblx0XHQgKlxuXHRcdCAqID4gMCAtIHJpZ2h0XG5cdFx0ICogPCAwIC0gbGVmdFxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtpbnR9IGRpcmVjdGlvblxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBlIChvcHRpb25hbClcblx0XHQgKi9cblx0XHRhZHZhbmNlU2VsZWN0aW9uOiBmdW5jdGlvbihkaXJlY3Rpb24sIGUpIHtcblx0XHRcdHZhciB0YWlsLCBzZWxlY3Rpb24sIGlkeCwgdmFsdWVMZW5ndGgsIGN1cnNvckF0RWRnZSwgJHRhaWw7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFxuXHRcdFx0aWYgKGRpcmVjdGlvbiA9PT0gMCkgcmV0dXJuO1xuXHRcdFx0aWYgKHNlbGYucnRsKSBkaXJlY3Rpb24gKj0gLTE7XG5cdFxuXHRcdFx0dGFpbCA9IGRpcmVjdGlvbiA+IDAgPyAnbGFzdCcgOiAnZmlyc3QnO1xuXHRcdFx0c2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKHNlbGYuJGNvbnRyb2xfaW5wdXRbMF0pO1xuXHRcblx0XHRcdGlmIChzZWxmLmlzRm9jdXNlZCAmJiAhc2VsZi5pc0lucHV0SGlkZGVuKSB7XG5cdFx0XHRcdHZhbHVlTGVuZ3RoID0gc2VsZi4kY29udHJvbF9pbnB1dC52YWwoKS5sZW5ndGg7XG5cdFx0XHRcdGN1cnNvckF0RWRnZSA9IGRpcmVjdGlvbiA8IDBcblx0XHRcdFx0XHQ/IHNlbGVjdGlvbi5zdGFydCA9PT0gMCAmJiBzZWxlY3Rpb24ubGVuZ3RoID09PSAwXG5cdFx0XHRcdFx0OiBzZWxlY3Rpb24uc3RhcnQgPT09IHZhbHVlTGVuZ3RoO1xuXHRcblx0XHRcdFx0aWYgKGN1cnNvckF0RWRnZSAmJiAhdmFsdWVMZW5ndGgpIHtcblx0XHRcdFx0XHRzZWxmLmFkdmFuY2VDYXJldChkaXJlY3Rpb24sIGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkdGFpbCA9IHNlbGYuJGNvbnRyb2wuY2hpbGRyZW4oJy5hY3RpdmU6JyArIHRhaWwpO1xuXHRcdFx0XHRpZiAoJHRhaWwubGVuZ3RoKSB7XG5cdFx0XHRcdFx0aWR4ID0gc2VsZi4kY29udHJvbC5jaGlsZHJlbignOm5vdChpbnB1dCknKS5pbmRleCgkdGFpbCk7XG5cdFx0XHRcdFx0c2VsZi5zZXRBY3RpdmVJdGVtKG51bGwpO1xuXHRcdFx0XHRcdHNlbGYuc2V0Q2FyZXQoZGlyZWN0aW9uID4gMCA/IGlkeCArIDEgOiBpZHgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogTW92ZXMgdGhlIGNhcmV0IGxlZnQgLyByaWdodC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7aW50fSBkaXJlY3Rpb25cblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZSAob3B0aW9uYWwpXG5cdFx0ICovXG5cdFx0YWR2YW5jZUNhcmV0OiBmdW5jdGlvbihkaXJlY3Rpb24sIGUpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcywgZm4sICRhZGo7XG5cdFxuXHRcdFx0aWYgKGRpcmVjdGlvbiA9PT0gMCkgcmV0dXJuO1xuXHRcblx0XHRcdGZuID0gZGlyZWN0aW9uID4gMCA/ICduZXh0JyA6ICdwcmV2Jztcblx0XHRcdGlmIChzZWxmLmlzU2hpZnREb3duKSB7XG5cdFx0XHRcdCRhZGogPSBzZWxmLiRjb250cm9sX2lucHV0W2ZuXSgpO1xuXHRcdFx0XHRpZiAoJGFkai5sZW5ndGgpIHtcblx0XHRcdFx0XHRzZWxmLmhpZGVJbnB1dCgpO1xuXHRcdFx0XHRcdHNlbGYuc2V0QWN0aXZlSXRlbSgkYWRqKTtcblx0XHRcdFx0XHRlICYmIGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5zZXRDYXJldChzZWxmLmNhcmV0UG9zICsgZGlyZWN0aW9uKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBNb3ZlcyB0aGUgY2FyZXQgdG8gdGhlIHNwZWNpZmllZCBpbmRleC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7aW50fSBpXG5cdFx0ICovXG5cdFx0c2V0Q2FyZXQ6IGZ1bmN0aW9uKGkpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XG5cdFx0XHRpZiAoc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJykge1xuXHRcdFx0XHRpID0gc2VsZi5pdGVtcy5sZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc2VsZi5pdGVtcy5sZW5ndGgsIGkpKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZighc2VsZi5pc1BlbmRpbmcpIHtcblx0XHRcdFx0Ly8gdGhlIGlucHV0IG11c3QgYmUgbW92ZWQgYnkgbGVhdmluZyBpdCBpbiBwbGFjZSBhbmQgbW92aW5nIHRoZVxuXHRcdFx0XHQvLyBzaWJsaW5ncywgZHVlIHRvIHRoZSBmYWN0IHRoYXQgZm9jdXMgY2Fubm90IGJlIHJlc3RvcmVkIG9uY2UgbG9zdFxuXHRcdFx0XHQvLyBvbiBtb2JpbGUgd2Via2l0IGRldmljZXNcblx0XHRcdFx0dmFyIGosIG4sIGZuLCAkY2hpbGRyZW4sICRjaGlsZDtcblx0XHRcdFx0JGNoaWxkcmVuID0gc2VsZi4kY29udHJvbC5jaGlsZHJlbignOm5vdChpbnB1dCknKTtcblx0XHRcdFx0Zm9yIChqID0gMCwgbiA9ICRjaGlsZHJlbi5sZW5ndGg7IGogPCBuOyBqKyspIHtcblx0XHRcdFx0XHQkY2hpbGQgPSAkKCRjaGlsZHJlbltqXSkuZGV0YWNoKCk7XG5cdFx0XHRcdFx0aWYgKGogPCAgaSkge1xuXHRcdFx0XHRcdFx0c2VsZi4kY29udHJvbF9pbnB1dC5iZWZvcmUoJGNoaWxkKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi4kY29udHJvbC5hcHBlbmQoJGNoaWxkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRzZWxmLmNhcmV0UG9zID0gaTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBEaXNhYmxlcyB1c2VyIGlucHV0IG9uIHRoZSBjb250cm9sLiBVc2VkIHdoaWxlXG5cdFx0ICogaXRlbXMgYXJlIGJlaW5nIGFzeW5jaHJvbm91c2x5IGNyZWF0ZWQuXG5cdFx0ICovXG5cdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmNsb3NlKCk7XG5cdFx0XHR0aGlzLmlzTG9ja2VkID0gdHJ1ZTtcblx0XHRcdHRoaXMucmVmcmVzaFN0YXRlKCk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUmUtZW5hYmxlcyB1c2VyIGlucHV0IG9uIHRoZSBjb250cm9sLlxuXHRcdCAqL1xuXHRcdHVubG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmlzTG9ja2VkID0gZmFsc2U7XG5cdFx0XHR0aGlzLnJlZnJlc2hTdGF0ZSgpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERpc2FibGVzIHVzZXIgaW5wdXQgb24gdGhlIGNvbnRyb2wgY29tcGxldGVseS5cblx0XHQgKiBXaGlsZSBkaXNhYmxlZCwgaXQgY2Fubm90IHJlY2VpdmUgZm9jdXMuXG5cdFx0ICovXG5cdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRzZWxmLiRpbnB1dC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xuXHRcdFx0c2VsZi4kY29udHJvbF9pbnB1dC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpLnByb3AoJ3RhYmluZGV4JywgLTEpO1xuXHRcdFx0c2VsZi5pc0Rpc2FibGVkID0gdHJ1ZTtcblx0XHRcdHNlbGYubG9jaygpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZXMgdGhlIGNvbnRyb2wgc28gdGhhdCBpdCBjYW4gcmVzcG9uZFxuXHRcdCAqIHRvIGZvY3VzIGFuZCB1c2VyIGlucHV0LlxuXHRcdCAqL1xuXHRcdGVuYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRzZWxmLiRpbnB1dC5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcblx0XHRcdHNlbGYuJGNvbnRyb2xfaW5wdXQucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSkucHJvcCgndGFiaW5kZXgnLCBzZWxmLnRhYkluZGV4KTtcblx0XHRcdHNlbGYuaXNEaXNhYmxlZCA9IGZhbHNlO1xuXHRcdFx0c2VsZi51bmxvY2soKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBDb21wbGV0ZWx5IGRlc3Ryb3lzIHRoZSBjb250cm9sIGFuZFxuXHRcdCAqIHVuYmluZHMgYWxsIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0IGl0IGNhblxuXHRcdCAqIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIGV2ZW50TlMgPSBzZWxmLmV2ZW50TlM7XG5cdFx0XHR2YXIgcmV2ZXJ0U2V0dGluZ3MgPSBzZWxmLnJldmVydFNldHRpbmdzO1xuXHRcblx0XHRcdHNlbGYudHJpZ2dlcignZGVzdHJveScpO1xuXHRcdFx0c2VsZi5vZmYoKTtcblx0XHRcdHNlbGYuJHdyYXBwZXIucmVtb3ZlKCk7XG5cdFx0XHRzZWxmLiRkcm9wZG93bi5yZW1vdmUoKTtcblx0XG5cdFx0XHRzZWxmLiRpbnB1dFxuXHRcdFx0XHQuaHRtbCgnJylcblx0XHRcdFx0LmFwcGVuZChyZXZlcnRTZXR0aW5ncy4kY2hpbGRyZW4pXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCd0YWJpbmRleCcpXG5cdFx0XHRcdC5yZW1vdmVDbGFzcygnc2VsZWN0aXplZCcpXG5cdFx0XHRcdC5hdHRyKHt0YWJpbmRleDogcmV2ZXJ0U2V0dGluZ3MudGFiaW5kZXh9KVxuXHRcdFx0XHQuc2hvdygpO1xuXHRcblx0XHRcdHNlbGYuJGNvbnRyb2xfaW5wdXQucmVtb3ZlRGF0YSgnZ3JvdycpO1xuXHRcdFx0c2VsZi4kaW5wdXQucmVtb3ZlRGF0YSgnc2VsZWN0aXplJyk7XG5cdFxuXHRcdFx0aWYgKC0tU2VsZWN0aXplLmNvdW50ID09IDAgJiYgU2VsZWN0aXplLiR0ZXN0SW5wdXQpIHtcblx0XHRcdFx0U2VsZWN0aXplLiR0ZXN0SW5wdXQucmVtb3ZlKCk7XG5cdFx0XHRcdFNlbGVjdGl6ZS4kdGVzdElucHV0ID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcblx0XHRcdCQod2luZG93KS5vZmYoZXZlbnROUyk7XG5cdFx0XHQkKGRvY3VtZW50KS5vZmYoZXZlbnROUyk7XG5cdFx0XHQkKGRvY3VtZW50LmJvZHkpLm9mZihldmVudE5TKTtcblx0XG5cdFx0XHRkZWxldGUgc2VsZi4kaW5wdXRbMF0uc2VsZWN0aXplO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEEgaGVscGVyIG1ldGhvZCBmb3IgcmVuZGVyaW5nIFwiaXRlbVwiIGFuZFxuXHRcdCAqIFwib3B0aW9uXCIgdGVtcGxhdGVzLCBnaXZlbiB0aGUgZGF0YS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZU5hbWVcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuXHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0cmVuZGVyOiBmdW5jdGlvbih0ZW1wbGF0ZU5hbWUsIGRhdGEpIHtcblx0XHRcdHZhciB2YWx1ZSwgaWQsIGxhYmVsO1xuXHRcdFx0dmFyIGh0bWwgPSAnJztcblx0XHRcdHZhciBjYWNoZSA9IGZhbHNlO1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIHJlZ2V4X3RhZyA9IC9eW1xcdCBcXHJcXG5dKjwoW2Etel1bYS16MC05XFwtX10qKD86XFw6W2Etel1bYS16MC05XFwtX10qKT8pL2k7XG5cdFxuXHRcdFx0aWYgKHRlbXBsYXRlTmFtZSA9PT0gJ29wdGlvbicgfHwgdGVtcGxhdGVOYW1lID09PSAnaXRlbScpIHtcblx0XHRcdFx0dmFsdWUgPSBoYXNoX2tleShkYXRhW3NlbGYuc2V0dGluZ3MudmFsdWVGaWVsZF0pO1xuXHRcdFx0XHRjYWNoZSA9ICEhdmFsdWU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gcHVsbCBtYXJrdXAgZnJvbSBjYWNoZSBpZiBpdCBleGlzdHNcblx0XHRcdGlmIChjYWNoZSkge1xuXHRcdFx0XHRpZiAoIWlzc2V0KHNlbGYucmVuZGVyQ2FjaGVbdGVtcGxhdGVOYW1lXSkpIHtcblx0XHRcdFx0XHRzZWxmLnJlbmRlckNhY2hlW3RlbXBsYXRlTmFtZV0gPSB7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc2VsZi5yZW5kZXJDYWNoZVt0ZW1wbGF0ZU5hbWVdLmhhc093blByb3BlcnR5KHZhbHVlKSkge1xuXHRcdFx0XHRcdHJldHVybiBzZWxmLnJlbmRlckNhY2hlW3RlbXBsYXRlTmFtZV1bdmFsdWVdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gcmVuZGVyIG1hcmt1cFxuXHRcdFx0aHRtbCA9ICQoc2VsZi5zZXR0aW5ncy5yZW5kZXJbdGVtcGxhdGVOYW1lXS5hcHBseSh0aGlzLCBbZGF0YSwgZXNjYXBlX2h0bWxdKSk7XG5cdFxuXHRcdFx0Ly8gYWRkIG1hbmRhdG9yeSBhdHRyaWJ1dGVzXG5cdFx0XHRpZiAodGVtcGxhdGVOYW1lID09PSAnb3B0aW9uJyB8fCB0ZW1wbGF0ZU5hbWUgPT09ICdvcHRpb25fY3JlYXRlJykge1xuXHRcdFx0XHRpZiAoIWRhdGFbc2VsZi5zZXR0aW5ncy5kaXNhYmxlZEZpZWxkXSkge1xuXHRcdFx0XHRcdGh0bWwuYXR0cignZGF0YS1zZWxlY3RhYmxlJywgJycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0ZW1wbGF0ZU5hbWUgPT09ICdvcHRncm91cCcpIHtcblx0XHRcdFx0aWQgPSBkYXRhW3NlbGYuc2V0dGluZ3Mub3B0Z3JvdXBWYWx1ZUZpZWxkXSB8fCAnJztcblx0XHRcdFx0aHRtbC5hdHRyKCdkYXRhLWdyb3VwJywgaWQpO1xuXHRcdFx0XHRpZihkYXRhW3NlbGYuc2V0dGluZ3MuZGlzYWJsZWRGaWVsZF0pIHtcblx0XHRcdFx0XHRodG1sLmF0dHIoJ2RhdGEtZGlzYWJsZWQnLCAnJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0ZW1wbGF0ZU5hbWUgPT09ICdvcHRpb24nIHx8IHRlbXBsYXRlTmFtZSA9PT0gJ2l0ZW0nKSB7XG5cdFx0XHRcdGh0bWwuYXR0cignZGF0YS12YWx1ZScsIHZhbHVlIHx8ICcnKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyB1cGRhdGUgY2FjaGVcblx0XHRcdGlmIChjYWNoZSkge1xuXHRcdFx0XHRzZWxmLnJlbmRlckNhY2hlW3RlbXBsYXRlTmFtZV1bdmFsdWVdID0gaHRtbFswXTtcblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gaHRtbFswXTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBDbGVhcnMgdGhlIHJlbmRlciBjYWNoZSBmb3IgYSB0ZW1wbGF0ZS4gSWZcblx0XHQgKiBubyB0ZW1wbGF0ZSBpcyBnaXZlbiwgY2xlYXJzIGFsbCByZW5kZXJcblx0XHQgKiBjYWNoZXMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVOYW1lXG5cdFx0ICovXG5cdFx0Y2xlYXJDYWNoZTogZnVuY3Rpb24odGVtcGxhdGVOYW1lKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZiAodHlwZW9mIHRlbXBsYXRlTmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0c2VsZi5yZW5kZXJDYWNoZSA9IHt9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIHNlbGYucmVuZGVyQ2FjaGVbdGVtcGxhdGVOYW1lXTtcblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRvIGRpc3BsYXkgdGhlXG5cdFx0ICogY3JlYXRlIGl0ZW0gcHJvbXB0LCBnaXZlbiBhIHVzZXIgaW5wdXQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcblx0XHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdGNhbkNyZWF0ZTogZnVuY3Rpb24oaW5wdXQpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGlmICghc2VsZi5zZXR0aW5ncy5jcmVhdGUpIHJldHVybiBmYWxzZTtcblx0XHRcdHZhciBmaWx0ZXIgPSBzZWxmLnNldHRpbmdzLmNyZWF0ZUZpbHRlcjtcblx0XHRcdHJldHVybiBpbnB1dC5sZW5ndGhcblx0XHRcdFx0JiYgKHR5cGVvZiBmaWx0ZXIgIT09ICdmdW5jdGlvbicgfHwgZmlsdGVyLmFwcGx5KHNlbGYsIFtpbnB1dF0pKVxuXHRcdFx0XHQmJiAodHlwZW9mIGZpbHRlciAhPT0gJ3N0cmluZycgfHwgbmV3IFJlZ0V4cChmaWx0ZXIpLnRlc3QoaW5wdXQpKVxuXHRcdFx0XHQmJiAoIShmaWx0ZXIgaW5zdGFuY2VvZiBSZWdFeHApIHx8IGZpbHRlci50ZXN0KGlucHV0KSk7XG5cdFx0fVxuXHRcblx0fSk7XG5cdFxuXHRcblx0U2VsZWN0aXplLmNvdW50ID0gMDtcblx0U2VsZWN0aXplLmRlZmF1bHRzID0ge1xuXHRcdG9wdGlvbnM6IFtdLFxuXHRcdG9wdGdyb3VwczogW10sXG5cdFxuXHRcdHBsdWdpbnM6IFtdLFxuXHRcdGRlbGltaXRlcjogJywnLFxuXHRcdHNwbGl0T246IG51bGwsIC8vIHJlZ2V4cCBvciBzdHJpbmcgZm9yIHNwbGl0dGluZyB1cCB2YWx1ZXMgZnJvbSBhIHBhc3RlIGNvbW1hbmRcblx0XHRwZXJzaXN0OiB0cnVlLFxuXHRcdGRpYWNyaXRpY3M6IHRydWUsXG5cdFx0Y3JlYXRlOiBmYWxzZSxcblx0XHRjcmVhdGVPbkJsdXI6IGZhbHNlLFxuXHRcdGNyZWF0ZUZpbHRlcjogbnVsbCxcblx0XHRoaWdobGlnaHQ6IHRydWUsXG5cdFx0b3Blbk9uRm9jdXM6IHRydWUsXG5cdFx0bWF4T3B0aW9uczogMTAwMCxcblx0XHRtYXhJdGVtczogbnVsbCxcblx0XHRoaWRlU2VsZWN0ZWQ6IG51bGwsXG5cdFx0YWRkUHJlY2VkZW5jZTogZmFsc2UsXG5cdFx0c2VsZWN0T25UYWI6IGZhbHNlLFxuXHRcdHByZWxvYWQ6IGZhbHNlLFxuXHRcdGFsbG93RW1wdHlPcHRpb246IGZhbHNlLFxuXHRcdGNsb3NlQWZ0ZXJTZWxlY3Q6IGZhbHNlLFxuXHRcblx0XHRzY3JvbGxEdXJhdGlvbjogNjAsXG5cdFx0bG9hZFRocm90dGxlOiAzMDAsXG5cdFx0bG9hZGluZ0NsYXNzOiAnbG9hZGluZycsXG5cdFxuXHRcdGRhdGFBdHRyOiAnZGF0YS1kYXRhJyxcblx0XHRvcHRncm91cEZpZWxkOiAnb3B0Z3JvdXAnLFxuXHRcdHZhbHVlRmllbGQ6ICd2YWx1ZScsXG5cdFx0bGFiZWxGaWVsZDogJ3RleHQnLFxuXHRcdGRpc2FibGVkRmllbGQ6ICdkaXNhYmxlZCcsXG5cdFx0b3B0Z3JvdXBMYWJlbEZpZWxkOiAnbGFiZWwnLFxuXHRcdG9wdGdyb3VwVmFsdWVGaWVsZDogJ3ZhbHVlJyxcblx0XHRsb2NrT3B0Z3JvdXBPcmRlcjogZmFsc2UsXG5cdFxuXHRcdHNvcnRGaWVsZDogJyRvcmRlcicsXG5cdFx0c2VhcmNoRmllbGQ6IFsndGV4dCddLFxuXHRcdHNlYXJjaENvbmp1bmN0aW9uOiAnYW5kJyxcblx0XG5cdFx0bW9kZTogbnVsbCxcblx0XHR3cmFwcGVyQ2xhc3M6ICdzZWxlY3RpemUtY29udHJvbCcsXG5cdFx0aW5wdXRDbGFzczogJ3NlbGVjdGl6ZS1pbnB1dCcsXG5cdFx0ZHJvcGRvd25DbGFzczogJ3NlbGVjdGl6ZS1kcm9wZG93bicsXG5cdFx0ZHJvcGRvd25Db250ZW50Q2xhc3M6ICdzZWxlY3RpemUtZHJvcGRvd24tY29udGVudCcsXG5cdFxuXHRcdGRyb3Bkb3duUGFyZW50OiBudWxsLFxuXHRcblx0XHRjb3B5Q2xhc3Nlc1RvRHJvcGRvd246IHRydWUsXG5cdFxuXHRcdC8qXG5cdFx0bG9hZCAgICAgICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbihxdWVyeSwgY2FsbGJhY2spIHsgLi4uIH1cblx0XHRzY29yZSAgICAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHNlYXJjaCkgeyAuLi4gfVxuXHRcdG9uSW5pdGlhbGl6ZSAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oKSB7IC4uLiB9XG5cdFx0b25DaGFuZ2UgICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbih2YWx1ZSkgeyAuLi4gfVxuXHRcdG9uSXRlbUFkZCAgICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWUsICRpdGVtKSB7IC4uLiB9XG5cdFx0b25JdGVtUmVtb3ZlICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbih2YWx1ZSkgeyAuLi4gfVxuXHRcdG9uQ2xlYXIgICAgICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oKSB7IC4uLiB9XG5cdFx0b25PcHRpb25BZGQgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbih2YWx1ZSwgZGF0YSkgeyAuLi4gfVxuXHRcdG9uT3B0aW9uUmVtb3ZlICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWUpIHsgLi4uIH1cblx0XHRvbk9wdGlvbkNsZWFyICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKCkgeyAuLi4gfVxuXHRcdG9uT3B0aW9uR3JvdXBBZGQgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oaWQsIGRhdGEpIHsgLi4uIH1cblx0XHRvbk9wdGlvbkdyb3VwUmVtb3ZlICA6IG51bGwsIC8vIGZ1bmN0aW9uKGlkKSB7IC4uLiB9XG5cdFx0b25PcHRpb25Hcm91cENsZWFyICAgOiBudWxsLCAvLyBmdW5jdGlvbigpIHsgLi4uIH1cblx0XHRvbkRyb3Bkb3duT3BlbiAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKCRkcm9wZG93bikgeyAuLi4gfVxuXHRcdG9uRHJvcGRvd25DbG9zZSAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oJGRyb3Bkb3duKSB7IC4uLiB9XG5cdFx0b25UeXBlICAgICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbihzdHIpIHsgLi4uIH1cblx0XHRvbkRlbGV0ZSAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHZhbHVlcykgeyAuLi4gfVxuXHRcdCovXG5cdFxuXHRcdHJlbmRlcjoge1xuXHRcdFx0Lypcblx0XHRcdGl0ZW06IG51bGwsXG5cdFx0XHRvcHRncm91cDogbnVsbCxcblx0XHRcdG9wdGdyb3VwX2hlYWRlcjogbnVsbCxcblx0XHRcdG9wdGlvbjogbnVsbCxcblx0XHRcdG9wdGlvbl9jcmVhdGU6IG51bGxcblx0XHRcdCovXG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdCQuZm4uc2VsZWN0aXplID0gZnVuY3Rpb24oc2V0dGluZ3NfdXNlcikge1xuXHRcdHZhciBkZWZhdWx0cyAgICAgICAgICAgICA9ICQuZm4uc2VsZWN0aXplLmRlZmF1bHRzO1xuXHRcdHZhciBzZXR0aW5ncyAgICAgICAgICAgICA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgc2V0dGluZ3NfdXNlcik7XG5cdFx0dmFyIGF0dHJfZGF0YSAgICAgICAgICAgID0gc2V0dGluZ3MuZGF0YUF0dHI7XG5cdFx0dmFyIGZpZWxkX2xhYmVsICAgICAgICAgID0gc2V0dGluZ3MubGFiZWxGaWVsZDtcblx0XHR2YXIgZmllbGRfdmFsdWUgICAgICAgICAgPSBzZXR0aW5ncy52YWx1ZUZpZWxkO1xuXHRcdHZhciBmaWVsZF9kaXNhYmxlZCAgICAgICA9IHNldHRpbmdzLmRpc2FibGVkRmllbGQ7XG5cdFx0dmFyIGZpZWxkX29wdGdyb3VwICAgICAgID0gc2V0dGluZ3Mub3B0Z3JvdXBGaWVsZDtcblx0XHR2YXIgZmllbGRfb3B0Z3JvdXBfbGFiZWwgPSBzZXR0aW5ncy5vcHRncm91cExhYmVsRmllbGQ7XG5cdFx0dmFyIGZpZWxkX29wdGdyb3VwX3ZhbHVlID0gc2V0dGluZ3Mub3B0Z3JvdXBWYWx1ZUZpZWxkO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplcyBzZWxlY3RpemUgZnJvbSBhIDxpbnB1dCB0eXBlPVwidGV4dFwiPiBlbGVtZW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9ICRpbnB1dFxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc19lbGVtZW50XG5cdFx0ICovXG5cdFx0dmFyIGluaXRfdGV4dGJveCA9IGZ1bmN0aW9uKCRpbnB1dCwgc2V0dGluZ3NfZWxlbWVudCkge1xuXHRcdFx0dmFyIGksIG4sIHZhbHVlcywgb3B0aW9uO1xuXHRcblx0XHRcdHZhciBkYXRhX3JhdyA9ICRpbnB1dC5hdHRyKGF0dHJfZGF0YSk7XG5cdFxuXHRcdFx0aWYgKCFkYXRhX3Jhdykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSAkLnRyaW0oJGlucHV0LnZhbCgpIHx8ICcnKTtcblx0XHRcdFx0aWYgKCFzZXR0aW5ncy5hbGxvd0VtcHR5T3B0aW9uICYmICF2YWx1ZS5sZW5ndGgpIHJldHVybjtcblx0XHRcdFx0dmFsdWVzID0gdmFsdWUuc3BsaXQoc2V0dGluZ3MuZGVsaW1pdGVyKTtcblx0XHRcdFx0Zm9yIChpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0XHRvcHRpb24gPSB7fTtcblx0XHRcdFx0XHRvcHRpb25bZmllbGRfbGFiZWxdID0gdmFsdWVzW2ldO1xuXHRcdFx0XHRcdG9wdGlvbltmaWVsZF92YWx1ZV0gPSB2YWx1ZXNbaV07XG5cdFx0XHRcdFx0c2V0dGluZ3NfZWxlbWVudC5vcHRpb25zLnB1c2gob3B0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZXR0aW5nc19lbGVtZW50Lml0ZW1zID0gdmFsdWVzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2V0dGluZ3NfZWxlbWVudC5vcHRpb25zID0gSlNPTi5wYXJzZShkYXRhX3Jhdyk7XG5cdFx0XHRcdGZvciAoaSA9IDAsIG4gPSBzZXR0aW5nc19lbGVtZW50Lm9wdGlvbnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdFx0c2V0dGluZ3NfZWxlbWVudC5pdGVtcy5wdXNoKHNldHRpbmdzX2VsZW1lbnQub3B0aW9uc1tpXVtmaWVsZF92YWx1ZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZXMgc2VsZWN0aXplIGZyb20gYSA8c2VsZWN0PiBlbGVtZW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9ICRpbnB1dFxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc19lbGVtZW50XG5cdFx0ICovXG5cdFx0dmFyIGluaXRfc2VsZWN0ID0gZnVuY3Rpb24oJGlucHV0LCBzZXR0aW5nc19lbGVtZW50KSB7XG5cdFx0XHR2YXIgaSwgbiwgdGFnTmFtZSwgJGNoaWxkcmVuLCBvcmRlciA9IDA7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHNldHRpbmdzX2VsZW1lbnQub3B0aW9ucztcblx0XHRcdHZhciBvcHRpb25zTWFwID0ge307XG5cdFxuXHRcdFx0dmFyIHJlYWREYXRhID0gZnVuY3Rpb24oJGVsKSB7XG5cdFx0XHRcdHZhciBkYXRhID0gYXR0cl9kYXRhICYmICRlbC5hdHRyKGF0dHJfZGF0YSk7XG5cdFx0XHRcdGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiYgZGF0YS5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH07XG5cdFxuXHRcdFx0dmFyIGFkZE9wdGlvbiA9IGZ1bmN0aW9uKCRvcHRpb24sIGdyb3VwKSB7XG5cdFx0XHRcdCRvcHRpb24gPSAkKCRvcHRpb24pO1xuXHRcblx0XHRcdFx0dmFyIHZhbHVlID0gaGFzaF9rZXkoJG9wdGlvbi52YWwoKSk7XG5cdFx0XHRcdGlmICghdmFsdWUgJiYgIXNldHRpbmdzLmFsbG93RW1wdHlPcHRpb24pIHJldHVybjtcblx0XG5cdFx0XHRcdC8vIGlmIHRoZSBvcHRpb24gYWxyZWFkeSBleGlzdHMsIGl0J3MgcHJvYmFibHkgYmVlblxuXHRcdFx0XHQvLyBkdXBsaWNhdGVkIGluIGFub3RoZXIgb3B0Z3JvdXAuIGluIHRoaXMgY2FzZSwgcHVzaFxuXHRcdFx0XHQvLyB0aGUgY3VycmVudCBncm91cCB0byB0aGUgXCJvcHRncm91cFwiIHByb3BlcnR5IG9uIHRoZVxuXHRcdFx0XHQvLyBleGlzdGluZyBvcHRpb24gc28gdGhhdCBpdCdzIHJlbmRlcmVkIGluIGJvdGggcGxhY2VzLlxuXHRcdFx0XHRpZiAob3B0aW9uc01hcC5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRpZiAoZ3JvdXApIHtcblx0XHRcdFx0XHRcdHZhciBhcnIgPSBvcHRpb25zTWFwW3ZhbHVlXVtmaWVsZF9vcHRncm91cF07XG5cdFx0XHRcdFx0XHRpZiAoIWFycikge1xuXHRcdFx0XHRcdFx0XHRvcHRpb25zTWFwW3ZhbHVlXVtmaWVsZF9vcHRncm91cF0gPSBncm91cDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoISQuaXNBcnJheShhcnIpKSB7XG5cdFx0XHRcdFx0XHRcdG9wdGlvbnNNYXBbdmFsdWVdW2ZpZWxkX29wdGdyb3VwXSA9IFthcnIsIGdyb3VwXTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGFyci5wdXNoKGdyb3VwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHR2YXIgb3B0aW9uICAgICAgICAgICAgID0gcmVhZERhdGEoJG9wdGlvbikgfHwge307XG5cdFx0XHRcdG9wdGlvbltmaWVsZF9sYWJlbF0gICAgPSBvcHRpb25bZmllbGRfbGFiZWxdIHx8ICRvcHRpb24udGV4dCgpO1xuXHRcdFx0XHRvcHRpb25bZmllbGRfdmFsdWVdICAgID0gb3B0aW9uW2ZpZWxkX3ZhbHVlXSB8fCB2YWx1ZTtcblx0XHRcdFx0b3B0aW9uW2ZpZWxkX2Rpc2FibGVkXSA9IG9wdGlvbltmaWVsZF9kaXNhYmxlZF0gfHwgJG9wdGlvbi5wcm9wKCdkaXNhYmxlZCcpO1xuXHRcdFx0XHRvcHRpb25bZmllbGRfb3B0Z3JvdXBdID0gb3B0aW9uW2ZpZWxkX29wdGdyb3VwXSB8fCBncm91cDtcblx0XG5cdFx0XHRcdG9wdGlvbnNNYXBbdmFsdWVdID0gb3B0aW9uO1xuXHRcdFx0XHRvcHRpb25zLnB1c2gob3B0aW9uKTtcblx0XG5cdFx0XHRcdGlmICgkb3B0aW9uLmlzKCc6c2VsZWN0ZWQnKSkge1xuXHRcdFx0XHRcdHNldHRpbmdzX2VsZW1lbnQuaXRlbXMucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFxuXHRcdFx0dmFyIGFkZEdyb3VwID0gZnVuY3Rpb24oJG9wdGdyb3VwKSB7XG5cdFx0XHRcdHZhciBpLCBuLCBpZCwgb3B0Z3JvdXAsICRvcHRpb25zO1xuXHRcblx0XHRcdFx0JG9wdGdyb3VwID0gJCgkb3B0Z3JvdXApO1xuXHRcdFx0XHRpZCA9ICRvcHRncm91cC5hdHRyKCdsYWJlbCcpO1xuXHRcblx0XHRcdFx0aWYgKGlkKSB7XG5cdFx0XHRcdFx0b3B0Z3JvdXAgPSByZWFkRGF0YSgkb3B0Z3JvdXApIHx8IHt9O1xuXHRcdFx0XHRcdG9wdGdyb3VwW2ZpZWxkX29wdGdyb3VwX2xhYmVsXSA9IGlkO1xuXHRcdFx0XHRcdG9wdGdyb3VwW2ZpZWxkX29wdGdyb3VwX3ZhbHVlXSA9IGlkO1xuXHRcdFx0XHRcdG9wdGdyb3VwW2ZpZWxkX2Rpc2FibGVkXSA9ICRvcHRncm91cC5wcm9wKCdkaXNhYmxlZCcpO1xuXHRcdFx0XHRcdHNldHRpbmdzX2VsZW1lbnQub3B0Z3JvdXBzLnB1c2gob3B0Z3JvdXApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQkb3B0aW9ucyA9ICQoJ29wdGlvbicsICRvcHRncm91cCk7XG5cdFx0XHRcdGZvciAoaSA9IDAsIG4gPSAkb3B0aW9ucy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0XHRhZGRPcHRpb24oJG9wdGlvbnNbaV0sIGlkKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XG5cdFx0XHRzZXR0aW5nc19lbGVtZW50Lm1heEl0ZW1zID0gJGlucHV0LmF0dHIoJ211bHRpcGxlJykgPyBudWxsIDogMTtcblx0XG5cdFx0XHQkY2hpbGRyZW4gPSAkaW5wdXQuY2hpbGRyZW4oKTtcblx0XHRcdGZvciAoaSA9IDAsIG4gPSAkY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHRhZ05hbWUgPSAkY2hpbGRyZW5baV0udGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRpZiAodGFnTmFtZSA9PT0gJ29wdGdyb3VwJykge1xuXHRcdFx0XHRcdGFkZEdyb3VwKCRjaGlsZHJlbltpXSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ29wdGlvbicpIHtcblx0XHRcdFx0XHRhZGRPcHRpb24oJGNoaWxkcmVuW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5zZWxlY3RpemUpIHJldHVybjtcblx0XG5cdFx0XHR2YXIgaW5zdGFuY2U7XG5cdFx0XHR2YXIgJGlucHV0ID0gJCh0aGlzKTtcblx0XHRcdHZhciB0YWdfbmFtZSA9IHRoaXMudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0dmFyIHBsYWNlaG9sZGVyID0gJGlucHV0LmF0dHIoJ3BsYWNlaG9sZGVyJykgfHwgJGlucHV0LmF0dHIoJ2RhdGEtcGxhY2Vob2xkZXInKTtcblx0XHRcdGlmICghcGxhY2Vob2xkZXIgJiYgIXNldHRpbmdzLmFsbG93RW1wdHlPcHRpb24pIHtcblx0XHRcdFx0cGxhY2Vob2xkZXIgPSAkaW5wdXQuY2hpbGRyZW4oJ29wdGlvblt2YWx1ZT1cIlwiXScpLnRleHQoKTtcblx0XHRcdH1cblx0XG5cdFx0XHR2YXIgc2V0dGluZ3NfZWxlbWVudCA9IHtcblx0XHRcdFx0J3BsYWNlaG9sZGVyJyA6IHBsYWNlaG9sZGVyLFxuXHRcdFx0XHQnb3B0aW9ucycgICAgIDogW10sXG5cdFx0XHRcdCdvcHRncm91cHMnICAgOiBbXSxcblx0XHRcdFx0J2l0ZW1zJyAgICAgICA6IFtdXG5cdFx0XHR9O1xuXHRcblx0XHRcdGlmICh0YWdfbmFtZSA9PT0gJ3NlbGVjdCcpIHtcblx0XHRcdFx0aW5pdF9zZWxlY3QoJGlucHV0LCBzZXR0aW5nc19lbGVtZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluaXRfdGV4dGJveCgkaW5wdXQsIHNldHRpbmdzX2VsZW1lbnQpO1xuXHRcdFx0fVxuXHRcblx0XHRcdGluc3RhbmNlID0gbmV3IFNlbGVjdGl6ZSgkaW5wdXQsICQuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgc2V0dGluZ3NfZWxlbWVudCwgc2V0dGluZ3NfdXNlcikpO1xuXHRcdH0pO1xuXHR9O1xuXHRcblx0JC5mbi5zZWxlY3RpemUuZGVmYXVsdHMgPSBTZWxlY3RpemUuZGVmYXVsdHM7XG5cdCQuZm4uc2VsZWN0aXplLnN1cHBvcnQgPSB7XG5cdFx0dmFsaWRpdHk6IFNVUFBPUlRTX1ZBTElESVRZX0FQSVxuXHR9O1xuXHRcblx0XG5cdFNlbGVjdGl6ZS5kZWZpbmUoJ2RyYWdfZHJvcCcsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRpZiAoISQuZm4uc29ydGFibGUpIHRocm93IG5ldyBFcnJvcignVGhlIFwiZHJhZ19kcm9wXCIgcGx1Z2luIHJlcXVpcmVzIGpRdWVyeSBVSSBcInNvcnRhYmxlXCIuJyk7XG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MubW9kZSAhPT0gJ211bHRpJykgcmV0dXJuO1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XG5cdFx0c2VsZi5sb2NrID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9yaWdpbmFsID0gc2VsZi5sb2NrO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc29ydGFibGUgPSBzZWxmLiRjb250cm9sLmRhdGEoJ3NvcnRhYmxlJyk7XG5cdFx0XHRcdGlmIChzb3J0YWJsZSkgc29ydGFibGUuZGlzYWJsZSgpO1xuXHRcdFx0XHRyZXR1cm4gb3JpZ2luYWwuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcblx0XHRcdH07XG5cdFx0fSkoKTtcblx0XG5cdFx0c2VsZi51bmxvY2sgPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWwgPSBzZWxmLnVubG9jaztcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHNvcnRhYmxlID0gc2VsZi4kY29udHJvbC5kYXRhKCdzb3J0YWJsZScpO1xuXHRcdFx0XHRpZiAoc29ydGFibGUpIHNvcnRhYmxlLmVuYWJsZSgpO1xuXHRcdFx0XHRyZXR1cm4gb3JpZ2luYWwuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcblx0XHRcdH07XG5cdFx0fSkoKTtcblx0XG5cdFx0c2VsZi5zZXR1cCA9IChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvcmlnaW5hbCA9IHNlbGYuc2V0dXA7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFxuXHRcdFx0XHR2YXIgJGNvbnRyb2wgPSBzZWxmLiRjb250cm9sLnNvcnRhYmxlKHtcblx0XHRcdFx0XHRpdGVtczogJ1tkYXRhLXZhbHVlXScsXG5cdFx0XHRcdFx0Zm9yY2VQbGFjZWhvbGRlclNpemU6IHRydWUsXG5cdFx0XHRcdFx0ZGlzYWJsZWQ6IHNlbGYuaXNMb2NrZWQsXG5cdFx0XHRcdFx0c3RhcnQ6IGZ1bmN0aW9uKGUsIHVpKSB7XG5cdFx0XHRcdFx0XHR1aS5wbGFjZWhvbGRlci5jc3MoJ3dpZHRoJywgdWkuaGVscGVyLmNzcygnd2lkdGgnKSk7XG5cdFx0XHRcdFx0XHQkY29udHJvbC5jc3Moe292ZXJmbG93OiAndmlzaWJsZSd9KTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0JGNvbnRyb2wuY3NzKHtvdmVyZmxvdzogJ2hpZGRlbid9KTtcblx0XHRcdFx0XHRcdHZhciBhY3RpdmUgPSBzZWxmLiRhY3RpdmVJdGVtcyA/IHNlbGYuJGFjdGl2ZUl0ZW1zLnNsaWNlKCkgOiBudWxsO1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xuXHRcdFx0XHRcdFx0JGNvbnRyb2wuY2hpbGRyZW4oJ1tkYXRhLXZhbHVlXScpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCQodGhpcykuYXR0cignZGF0YS12YWx1ZScpKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0c2VsZi5zZXRWYWx1ZSh2YWx1ZXMpO1xuXHRcdFx0XHRcdFx0c2VsZi5zZXRBY3RpdmVJdGVtKGFjdGl2ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0fSkoKTtcblx0XG5cdH0pO1xuXHRcblx0U2VsZWN0aXplLmRlZmluZSgnZHJvcGRvd25faGVhZGVyJywgZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XG5cdFx0b3B0aW9ucyA9ICQuZXh0ZW5kKHtcblx0XHRcdHRpdGxlICAgICAgICAgOiAnVW50aXRsZWQnLFxuXHRcdFx0aGVhZGVyQ2xhc3MgICA6ICdzZWxlY3RpemUtZHJvcGRvd24taGVhZGVyJyxcblx0XHRcdHRpdGxlUm93Q2xhc3MgOiAnc2VsZWN0aXplLWRyb3Bkb3duLWhlYWRlci10aXRsZScsXG5cdFx0XHRsYWJlbENsYXNzICAgIDogJ3NlbGVjdGl6ZS1kcm9wZG93bi1oZWFkZXItbGFiZWwnLFxuXHRcdFx0Y2xvc2VDbGFzcyAgICA6ICdzZWxlY3RpemUtZHJvcGRvd24taGVhZGVyLWNsb3NlJyxcblx0XG5cdFx0XHRodG1sOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCInICsgZGF0YS5oZWFkZXJDbGFzcyArICdcIj4nICtcblx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiJyArIGRhdGEudGl0bGVSb3dDbGFzcyArICdcIj4nICtcblx0XHRcdFx0XHRcdFx0JzxzcGFuIGNsYXNzPVwiJyArIGRhdGEubGFiZWxDbGFzcyArICdcIj4nICsgZGF0YS50aXRsZSArICc8L3NwYW4+JyArXG5cdFx0XHRcdFx0XHRcdCc8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCIgY2xhc3M9XCInICsgZGF0YS5jbG9zZUNsYXNzICsgJ1wiPiZ0aW1lczs8L2E+JyArXG5cdFx0XHRcdFx0XHQnPC9kaXY+JyArXG5cdFx0XHRcdFx0JzwvZGl2Pidcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9LCBvcHRpb25zKTtcblx0XG5cdFx0c2VsZi5zZXR1cCA9IChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvcmlnaW5hbCA9IHNlbGYuc2V0dXA7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdG9yaWdpbmFsLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdHNlbGYuJGRyb3Bkb3duX2hlYWRlciA9ICQob3B0aW9ucy5odG1sKG9wdGlvbnMpKTtcblx0XHRcdFx0c2VsZi4kZHJvcGRvd24ucHJlcGVuZChzZWxmLiRkcm9wZG93bl9oZWFkZXIpO1xuXHRcdFx0fTtcblx0XHR9KSgpO1xuXHRcblx0fSk7XG5cdFxuXHRTZWxlY3RpemUuZGVmaW5lKCdvcHRncm91cF9jb2x1bW5zJywgZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XG5cdFx0b3B0aW9ucyA9ICQuZXh0ZW5kKHtcblx0XHRcdGVxdWFsaXplV2lkdGggIDogdHJ1ZSxcblx0XHRcdGVxdWFsaXplSGVpZ2h0IDogdHJ1ZVxuXHRcdH0sIG9wdGlvbnMpO1xuXHRcblx0XHR0aGlzLmdldEFkamFjZW50T3B0aW9uID0gZnVuY3Rpb24oJG9wdGlvbiwgZGlyZWN0aW9uKSB7XG5cdFx0XHR2YXIgJG9wdGlvbnMgPSAkb3B0aW9uLmNsb3Nlc3QoJ1tkYXRhLWdyb3VwXScpLmZpbmQoJ1tkYXRhLXNlbGVjdGFibGVdJyk7XG5cdFx0XHR2YXIgaW5kZXggICAgPSAkb3B0aW9ucy5pbmRleCgkb3B0aW9uKSArIGRpcmVjdGlvbjtcblx0XG5cdFx0XHRyZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8ICRvcHRpb25zLmxlbmd0aCA/ICRvcHRpb25zLmVxKGluZGV4KSA6ICQoKTtcblx0XHR9O1xuXHRcblx0XHR0aGlzLm9uS2V5RG93biA9IChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvcmlnaW5hbCA9IHNlbGYub25LZXlEb3duO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0dmFyIGluZGV4LCAkb3B0aW9uLCAkb3B0aW9ucywgJG9wdGdyb3VwO1xuXHRcblx0XHRcdFx0aWYgKHRoaXMuaXNPcGVuICYmIChlLmtleUNvZGUgPT09IEtFWV9MRUZUIHx8IGUua2V5Q29kZSA9PT0gS0VZX1JJR0hUKSkge1xuXHRcdFx0XHRcdHNlbGYuaWdub3JlSG92ZXIgPSB0cnVlO1xuXHRcdFx0XHRcdCRvcHRncm91cCA9IHRoaXMuJGFjdGl2ZU9wdGlvbi5jbG9zZXN0KCdbZGF0YS1ncm91cF0nKTtcblx0XHRcdFx0XHRpbmRleCA9ICRvcHRncm91cC5maW5kKCdbZGF0YS1zZWxlY3RhYmxlXScpLmluZGV4KHRoaXMuJGFjdGl2ZU9wdGlvbik7XG5cdFxuXHRcdFx0XHRcdGlmKGUua2V5Q29kZSA9PT0gS0VZX0xFRlQpIHtcblx0XHRcdFx0XHRcdCRvcHRncm91cCA9ICRvcHRncm91cC5wcmV2KCdbZGF0YS1ncm91cF0nKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0JG9wdGdyb3VwID0gJG9wdGdyb3VwLm5leHQoJ1tkYXRhLWdyb3VwXScpO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0JG9wdGlvbnMgPSAkb3B0Z3JvdXAuZmluZCgnW2RhdGEtc2VsZWN0YWJsZV0nKTtcblx0XHRcdFx0XHQkb3B0aW9uICA9ICRvcHRpb25zLmVxKE1hdGgubWluKCRvcHRpb25zLmxlbmd0aCAtIDEsIGluZGV4KSk7XG5cdFx0XHRcdFx0aWYgKCRvcHRpb24ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldEFjdGl2ZU9wdGlvbigkb3B0aW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRyZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH07XG5cdFx0fSkoKTtcblx0XG5cdFx0dmFyIGdldFNjcm9sbGJhcldpZHRoID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGl2O1xuXHRcdFx0dmFyIHdpZHRoID0gZ2V0U2Nyb2xsYmFyV2lkdGgud2lkdGg7XG5cdFx0XHR2YXIgZG9jID0gZG9jdW1lbnQ7XG5cdFxuXHRcdFx0aWYgKHR5cGVvZiB3aWR0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0ZGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0XHRkaXYuaW5uZXJIVE1MID0gJzxkaXYgc3R5bGU9XCJ3aWR0aDo1MHB4O2hlaWdodDo1MHB4O3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTUwcHg7dG9wOi01MHB4O292ZXJmbG93OmF1dG87XCI+PGRpdiBzdHlsZT1cIndpZHRoOjFweDtoZWlnaHQ6MTAwcHg7XCI+PC9kaXY+PC9kaXY+Jztcblx0XHRcdFx0ZGl2ID0gZGl2LmZpcnN0Q2hpbGQ7XG5cdFx0XHRcdGRvYy5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG5cdFx0XHRcdHdpZHRoID0gZ2V0U2Nyb2xsYmFyV2lkdGgud2lkdGggPSBkaXYub2Zmc2V0V2lkdGggLSBkaXYuY2xpZW50V2lkdGg7XG5cdFx0XHRcdGRvYy5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gd2lkdGg7XG5cdFx0fTtcblx0XG5cdFx0dmFyIGVxdWFsaXplU2l6ZXMgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpLCBuLCBoZWlnaHRfbWF4LCB3aWR0aCwgd2lkdGhfbGFzdCwgd2lkdGhfcGFyZW50LCAkb3B0Z3JvdXBzO1xuXHRcblx0XHRcdCRvcHRncm91cHMgPSAkKCdbZGF0YS1ncm91cF0nLCBzZWxmLiRkcm9wZG93bl9jb250ZW50KTtcblx0XHRcdG4gPSAkb3B0Z3JvdXBzLmxlbmd0aDtcblx0XHRcdGlmICghbiB8fCAhc2VsZi4kZHJvcGRvd25fY29udGVudC53aWR0aCgpKSByZXR1cm47XG5cdFxuXHRcdFx0aWYgKG9wdGlvbnMuZXF1YWxpemVIZWlnaHQpIHtcblx0XHRcdFx0aGVpZ2h0X21heCA9IDA7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0XHRoZWlnaHRfbWF4ID0gTWF0aC5tYXgoaGVpZ2h0X21heCwgJG9wdGdyb3Vwcy5lcShpKS5oZWlnaHQoKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0JG9wdGdyb3Vwcy5jc3Moe2hlaWdodDogaGVpZ2h0X21heH0pO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmIChvcHRpb25zLmVxdWFsaXplV2lkdGgpIHtcblx0XHRcdFx0d2lkdGhfcGFyZW50ID0gc2VsZi4kZHJvcGRvd25fY29udGVudC5pbm5lcldpZHRoKCkgLSBnZXRTY3JvbGxiYXJXaWR0aCgpO1xuXHRcdFx0XHR3aWR0aCA9IE1hdGgucm91bmQod2lkdGhfcGFyZW50IC8gbik7XG5cdFx0XHRcdCRvcHRncm91cHMuY3NzKHt3aWR0aDogd2lkdGh9KTtcblx0XHRcdFx0aWYgKG4gPiAxKSB7XG5cdFx0XHRcdFx0d2lkdGhfbGFzdCA9IHdpZHRoX3BhcmVudCAtIHdpZHRoICogKG4gLSAxKTtcblx0XHRcdFx0XHQkb3B0Z3JvdXBzLmVxKG4gLSAxKS5jc3Moe3dpZHRoOiB3aWR0aF9sYXN0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcblx0XHRpZiAob3B0aW9ucy5lcXVhbGl6ZUhlaWdodCB8fCBvcHRpb25zLmVxdWFsaXplV2lkdGgpIHtcblx0XHRcdGhvb2suYWZ0ZXIodGhpcywgJ3Bvc2l0aW9uRHJvcGRvd24nLCBlcXVhbGl6ZVNpemVzKTtcblx0XHRcdGhvb2suYWZ0ZXIodGhpcywgJ3JlZnJlc2hPcHRpb25zJywgZXF1YWxpemVTaXplcyk7XG5cdFx0fVxuXHRcblx0XG5cdH0pO1xuXHRcblx0U2VsZWN0aXplLmRlZmluZSgncmVtb3ZlX2J1dHRvbicsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRvcHRpb25zID0gJC5leHRlbmQoe1xuXHRcdFx0XHRsYWJlbCAgICAgOiAnJnRpbWVzOycsXG5cdFx0XHRcdHRpdGxlICAgICA6ICdSZW1vdmUnLFxuXHRcdFx0XHRjbGFzc05hbWUgOiAncmVtb3ZlJyxcblx0XHRcdFx0YXBwZW5kICAgIDogdHJ1ZVxuXHRcdFx0fSwgb3B0aW9ucyk7XG5cdFxuXHRcdFx0dmFyIHNpbmdsZUNsb3NlID0gZnVuY3Rpb24odGhpc1JlZiwgb3B0aW9ucykge1xuXHRcblx0XHRcdFx0b3B0aW9ucy5jbGFzc05hbWUgPSAncmVtb3ZlLXNpbmdsZSc7XG5cdFxuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXNSZWY7XG5cdFx0XHRcdHZhciBodG1sID0gJzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBjbGFzcz1cIicgKyBvcHRpb25zLmNsYXNzTmFtZSArICdcIiB0YWJpbmRleD1cIi0xXCIgdGl0bGU9XCInICsgZXNjYXBlX2h0bWwob3B0aW9ucy50aXRsZSkgKyAnXCI+JyArIG9wdGlvbnMubGFiZWwgKyAnPC9hPic7XG5cdFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogQXBwZW5kcyBhbiBlbGVtZW50IGFzIGEgY2hpbGQgKHdpdGggcmF3IEhUTUwpLlxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbF9jb250YWluZXJcblx0XHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxfZWxlbWVudFxuXHRcdFx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR2YXIgYXBwZW5kID0gZnVuY3Rpb24oaHRtbF9jb250YWluZXIsIGh0bWxfZWxlbWVudCkge1xuXHRcdFx0XHRcdHJldHVybiAkKCc8c3Bhbj4nKS5hcHBlbmQoaHRtbF9jb250YWluZXIpXG5cdFx0XHRcdFx0XHQuYXBwZW5kKGh0bWxfZWxlbWVudCk7XG5cdFx0XHRcdH07XG5cdFxuXHRcdFx0XHR0aGlzUmVmLnNldHVwID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBvcmlnaW5hbCA9IHNlbGYuc2V0dXA7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0Ly8gb3ZlcnJpZGUgdGhlIGl0ZW0gcmVuZGVyaW5nIG1ldGhvZCB0byBhZGQgdGhlIGJ1dHRvbiB0byBlYWNoXG5cdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5hcHBlbmQpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGlkID0gJChzZWxmLiRpbnB1dC5jb250ZXh0KS5hdHRyKCdpZCcpO1xuXHRcdFx0XHRcdFx0XHR2YXIgc2VsZWN0aXplciA9ICQoJyMnK2lkKTtcblx0XG5cdFx0XHRcdFx0XHRcdHZhciByZW5kZXJfaXRlbSA9IHNlbGYuc2V0dGluZ3MucmVuZGVyLml0ZW07XG5cdFx0XHRcdFx0XHRcdHNlbGYuc2V0dGluZ3MucmVuZGVyLml0ZW0gPSBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGFwcGVuZChyZW5kZXJfaXRlbS5hcHBseSh0aGlzUmVmLCBhcmd1bWVudHMpLCBodG1sKTtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRvcmlnaW5hbC5hcHBseSh0aGlzUmVmLCBhcmd1bWVudHMpO1xuXHRcblx0XHRcdFx0XHRcdC8vIGFkZCBldmVudCBsaXN0ZW5lclxuXHRcdFx0XHRcdFx0dGhpc1JlZi4kY29udHJvbC5vbignY2xpY2snLCAnLicgKyBvcHRpb25zLmNsYXNzTmFtZSwgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGlmIChzZWxmLmlzTG9ja2VkKSByZXR1cm47XG5cdFxuXHRcdFx0XHRcdFx0XHRzZWxmLmNsZWFyKCk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSkoKTtcblx0XHRcdH07XG5cdFxuXHRcdFx0dmFyIG11bHRpQ2xvc2UgPSBmdW5jdGlvbih0aGlzUmVmLCBvcHRpb25zKSB7XG5cdFxuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXNSZWY7XG5cdFx0XHRcdHZhciBodG1sID0gJzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBjbGFzcz1cIicgKyBvcHRpb25zLmNsYXNzTmFtZSArICdcIiB0YWJpbmRleD1cIi0xXCIgdGl0bGU9XCInICsgZXNjYXBlX2h0bWwob3B0aW9ucy50aXRsZSkgKyAnXCI+JyArIG9wdGlvbnMubGFiZWwgKyAnPC9hPic7XG5cdFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogQXBwZW5kcyBhbiBlbGVtZW50IGFzIGEgY2hpbGQgKHdpdGggcmF3IEhUTUwpLlxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbF9jb250YWluZXJcblx0XHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxfZWxlbWVudFxuXHRcdFx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR2YXIgYXBwZW5kID0gZnVuY3Rpb24oaHRtbF9jb250YWluZXIsIGh0bWxfZWxlbWVudCkge1xuXHRcdFx0XHRcdHZhciBwb3MgPSBodG1sX2NvbnRhaW5lci5zZWFyY2goLyg8XFwvW14+XSs+XFxzKikkLyk7XG5cdFx0XHRcdFx0cmV0dXJuIGh0bWxfY29udGFpbmVyLnN1YnN0cmluZygwLCBwb3MpICsgaHRtbF9lbGVtZW50ICsgaHRtbF9jb250YWluZXIuc3Vic3RyaW5nKHBvcyk7XG5cdFx0XHRcdH07XG5cdFxuXHRcdFx0XHR0aGlzUmVmLnNldHVwID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBvcmlnaW5hbCA9IHNlbGYuc2V0dXA7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0Ly8gb3ZlcnJpZGUgdGhlIGl0ZW0gcmVuZGVyaW5nIG1ldGhvZCB0byBhZGQgdGhlIGJ1dHRvbiB0byBlYWNoXG5cdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5hcHBlbmQpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHJlbmRlcl9pdGVtID0gc2VsZi5zZXR0aW5ncy5yZW5kZXIuaXRlbTtcblx0XHRcdFx0XHRcdFx0c2VsZi5zZXR0aW5ncy5yZW5kZXIuaXRlbSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gYXBwZW5kKHJlbmRlcl9pdGVtLmFwcGx5KHRoaXNSZWYsIGFyZ3VtZW50cyksIGh0bWwpO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdG9yaWdpbmFsLmFwcGx5KHRoaXNSZWYsIGFyZ3VtZW50cyk7XG5cdFxuXHRcdFx0XHRcdFx0Ly8gYWRkIGV2ZW50IGxpc3RlbmVyXG5cdFx0XHRcdFx0XHR0aGlzUmVmLiRjb250cm9sLm9uKCdjbGljaycsICcuJyArIG9wdGlvbnMuY2xhc3NOYW1lLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0aWYgKHNlbGYuaXNMb2NrZWQpIHJldHVybjtcblx0XG5cdFx0XHRcdFx0XHRcdHZhciAkaXRlbSA9ICQoZS5jdXJyZW50VGFyZ2V0KS5wYXJlbnQoKTtcblx0XHRcdFx0XHRcdFx0c2VsZi5zZXRBY3RpdmVJdGVtKCRpdGVtKTtcblx0XHRcdFx0XHRcdFx0aWYgKHNlbGYuZGVsZXRlU2VsZWN0aW9uKCkpIHtcblx0XHRcdFx0XHRcdFx0XHRzZWxmLnNldENhcmV0KHNlbGYuaXRlbXMubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0pKCk7XG5cdFx0XHR9O1xuXHRcblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLm1vZGUgPT09ICdzaW5nbGUnKSB7XG5cdFx0XHRcdHNpbmdsZUNsb3NlKHRoaXMsIG9wdGlvbnMpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtdWx0aUNsb3NlKHRoaXMsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHR9KTtcblx0XG5cdFxuXHRTZWxlY3RpemUuZGVmaW5lKCdyZXN0b3JlX29uX2JhY2tzcGFjZScsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFxuXHRcdG9wdGlvbnMudGV4dCA9IG9wdGlvbnMudGV4dCB8fCBmdW5jdGlvbihvcHRpb24pIHtcblx0XHRcdHJldHVybiBvcHRpb25bdGhpcy5zZXR0aW5ncy5sYWJlbEZpZWxkXTtcblx0XHR9O1xuXHRcblx0XHR0aGlzLm9uS2V5RG93biA9IChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvcmlnaW5hbCA9IHNlbGYub25LZXlEb3duO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0dmFyIGluZGV4LCBvcHRpb247XG5cdFx0XHRcdGlmIChlLmtleUNvZGUgPT09IEtFWV9CQUNLU1BBQ0UgJiYgdGhpcy4kY29udHJvbF9pbnB1dC52YWwoKSA9PT0gJycgJiYgIXRoaXMuJGFjdGl2ZUl0ZW1zLmxlbmd0aCkge1xuXHRcdFx0XHRcdGluZGV4ID0gdGhpcy5jYXJldFBvcyAtIDE7XG5cdFx0XHRcdFx0aWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLml0ZW1zLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uID0gdGhpcy5vcHRpb25zW3RoaXMuaXRlbXNbaW5kZXhdXTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLmRlbGV0ZVNlbGVjdGlvbihlKSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFRleHRib3hWYWx1ZShvcHRpb25zLnRleHQuYXBwbHkodGhpcywgW29wdGlvbl0pKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5yZWZyZXNoT3B0aW9ucyh0cnVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXHRcdH0pKCk7XG5cdH0pO1xuXHRcblxuXHRyZXR1cm4gU2VsZWN0aXplO1xufSkpOyIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuMy4xKTogdXRpbC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogUHJpdmF0ZSBUcmFuc2l0aW9uRW5kIEhlbHBlcnNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IFRSQU5TSVRJT05fRU5EID0gJ3RyYW5zaXRpb25lbmQnXG5jb25zdCBNQVhfVUlEID0gMTAwMDAwMFxuY29uc3QgTUlMTElTRUNPTkRTX01VTFRJUExJRVIgPSAxMDAwXG5cbi8vIFNob3V0b3V0IEFuZ3VzQ3JvbGwgKGh0dHBzOi8vZ29vLmdsL3B4d1FHcClcbmZ1bmN0aW9uIHRvVHlwZShvYmopIHtcbiAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqKS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBnZXRTcGVjaWFsVHJhbnNpdGlvbkVuZEV2ZW50KCkge1xuICByZXR1cm4ge1xuICAgIGJpbmRUeXBlOiBUUkFOU0lUSU9OX0VORCxcbiAgICBkZWxlZ2F0ZVR5cGU6IFRSQU5TSVRJT05fRU5ELFxuICAgIGhhbmRsZShldmVudCkge1xuICAgICAgaWYgKCQoZXZlbnQudGFyZ2V0KS5pcyh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZXZlbnQuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmaW5lZFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uRW5kRW11bGF0b3IoZHVyYXRpb24pIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlXG5cbiAgJCh0aGlzKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgKCkgPT4ge1xuICAgIGNhbGxlZCA9IHRydWVcbiAgfSlcblxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgVXRpbC50cmlnZ2VyVHJhbnNpdGlvbkVuZCh0aGlzKVxuICAgIH1cbiAgfSwgZHVyYXRpb24pXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkVuZFN1cHBvcnQoKSB7XG4gICQuZm4uZW11bGF0ZVRyYW5zaXRpb25FbmQgPSB0cmFuc2l0aW9uRW5kRW11bGF0b3JcbiAgJC5ldmVudC5zcGVjaWFsW1V0aWwuVFJBTlNJVElPTl9FTkRdID0gZ2V0U3BlY2lhbFRyYW5zaXRpb25FbmRFdmVudCgpXG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFB1YmxpYyBVdGlsIEFwaVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBVdGlsID0ge1xuXG4gIFRSQU5TSVRJT05fRU5EOiAnYnNUcmFuc2l0aW9uRW5kJyxcblxuICBnZXRVSUQocHJlZml4KSB7XG4gICAgZG8ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgIHByZWZpeCArPSB+fihNYXRoLnJhbmRvbSgpICogTUFYX1VJRCkgLy8gXCJ+flwiIGFjdHMgbGlrZSBhIGZhc3RlciBNYXRoLmZsb29yKCkgaGVyZVxuICAgIH0gd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHByZWZpeCkpXG4gICAgcmV0dXJuIHByZWZpeFxuICB9LFxuXG4gIGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgIGxldCBzZWxlY3RvciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcpXG5cbiAgICBpZiAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSAnIycpIHtcbiAgICAgIGNvbnN0IGhyZWZBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKVxuICAgICAgc2VsZWN0b3IgPSBocmVmQXR0ciAmJiBocmVmQXR0ciAhPT0gJyMnID8gaHJlZkF0dHIudHJpbSgpIDogJydcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpID8gc2VsZWN0b3IgOiBudWxsXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfSxcblxuICBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIC8vIEdldCB0cmFuc2l0aW9uLWR1cmF0aW9uIG9mIHRoZSBlbGVtZW50XG4gICAgbGV0IHRyYW5zaXRpb25EdXJhdGlvbiA9ICQoZWxlbWVudCkuY3NzKCd0cmFuc2l0aW9uLWR1cmF0aW9uJylcbiAgICBsZXQgdHJhbnNpdGlvbkRlbGF5ID0gJChlbGVtZW50KS5jc3MoJ3RyYW5zaXRpb24tZGVsYXknKVxuXG4gICAgY29uc3QgZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gPSBwYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICBjb25zdCBmbG9hdFRyYW5zaXRpb25EZWxheSA9IHBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KVxuXG4gICAgLy8gUmV0dXJuIDAgaWYgZWxlbWVudCBvciB0cmFuc2l0aW9uIGR1cmF0aW9uIGlzIG5vdCBmb3VuZFxuICAgIGlmICghZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gJiYgIWZsb2F0VHJhbnNpdGlvbkRlbGF5KSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIC8vIElmIG11bHRpcGxlIGR1cmF0aW9ucyBhcmUgZGVmaW5lZCwgdGFrZSB0aGUgZmlyc3RcbiAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb24uc3BsaXQoJywnKVswXVxuICAgIHRyYW5zaXRpb25EZWxheSA9IHRyYW5zaXRpb25EZWxheS5zcGxpdCgnLCcpWzBdXG5cbiAgICByZXR1cm4gKHBhcnNlRmxvYXQodHJhbnNpdGlvbkR1cmF0aW9uKSArIHBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KSkgKiBNSUxMSVNFQ09ORFNfTVVMVElQTElFUlxuICB9LFxuXG4gIHJlZmxvdyhlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0SGVpZ2h0XG4gIH0sXG5cbiAgdHJpZ2dlclRyYW5zaXRpb25FbmQoZWxlbWVudCkge1xuICAgICQoZWxlbWVudCkudHJpZ2dlcihUUkFOU0lUSU9OX0VORClcbiAgfSxcblxuICAvLyBUT0RPOiBSZW1vdmUgaW4gdjVcbiAgc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkge1xuICAgIHJldHVybiBCb29sZWFuKFRSQU5TSVRJT05fRU5EKVxuICB9LFxuXG4gIGlzRWxlbWVudChvYmopIHtcbiAgICByZXR1cm4gKG9ialswXSB8fCBvYmopLm5vZGVUeXBlXG4gIH0sXG5cbiAgdHlwZUNoZWNrQ29uZmlnKGNvbXBvbmVudE5hbWUsIGNvbmZpZywgY29uZmlnVHlwZXMpIHtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIGNvbmZpZ1R5cGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZ1R5cGVzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IGNvbmZpZ1R5cGVzW3Byb3BlcnR5XVxuICAgICAgICBjb25zdCB2YWx1ZSAgICAgICAgID0gY29uZmlnW3Byb3BlcnR5XVxuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgICAgID0gdmFsdWUgJiYgVXRpbC5pc0VsZW1lbnQodmFsdWUpXG4gICAgICAgICAgPyAnZWxlbWVudCcgOiB0b1R5cGUodmFsdWUpXG5cbiAgICAgICAgaWYgKCFuZXcgUmVnRXhwKGV4cGVjdGVkVHlwZXMpLnRlc3QodmFsdWVUeXBlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGAke2NvbXBvbmVudE5hbWUudG9VcHBlckNhc2UoKX06IGAgK1xuICAgICAgICAgICAgYE9wdGlvbiBcIiR7cHJvcGVydHl9XCIgcHJvdmlkZWQgdHlwZSBcIiR7dmFsdWVUeXBlfVwiIGAgK1xuICAgICAgICAgICAgYGJ1dCBleHBlY3RlZCB0eXBlIFwiJHtleHBlY3RlZFR5cGVzfVwiLmApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZmluZFNoYWRvd1Jvb3QoZWxlbWVudCkge1xuICAgIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dGFjaFNoYWRvdykge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyBDYW4gZmluZCB0aGUgc2hhZG93IHJvb3Qgb3RoZXJ3aXNlIGl0J2xsIHJldHVybiB0aGUgZG9jdW1lbnRcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQuZ2V0Um9vdE5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IHJvb3QgPSBlbGVtZW50LmdldFJvb3ROb2RlKClcbiAgICAgIHJldHVybiByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHJvb3QgOiBudWxsXG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICByZXR1cm4gZWxlbWVudFxuICAgIH1cblxuICAgIC8vIHdoZW4gd2UgZG9uJ3QgZmluZCBhIHNoYWRvdyByb290XG4gICAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIFV0aWwuZmluZFNoYWRvd1Jvb3QoZWxlbWVudC5wYXJlbnROb2RlKVxuICB9XG59XG5cbnNldFRyYW5zaXRpb25FbmRTdXBwb3J0KClcblxuZXhwb3J0IGRlZmF1bHQgVXRpbFxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4zLjEpOiBhbGVydC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0IFV0aWwgZnJvbSAnLi91dGlsJ1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FICAgICAgICAgICAgICAgID0gJ2FsZXJ0J1xuY29uc3QgVkVSU0lPTiAgICAgICAgICAgICA9ICc0LjMuMSdcbmNvbnN0IERBVEFfS0VZICAgICAgICAgICAgPSAnYnMuYWxlcnQnXG5jb25zdCBFVkVOVF9LRVkgICAgICAgICAgID0gYC4ke0RBVEFfS0VZfWBcbmNvbnN0IERBVEFfQVBJX0tFWSAgICAgICAgPSAnLmRhdGEtYXBpJ1xuY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUICA9ICQuZm5bTkFNRV1cblxuY29uc3QgU2VsZWN0b3IgPSB7XG4gIERJU01JU1MgOiAnW2RhdGEtZGlzbWlzcz1cImFsZXJ0XCJdJ1xufVxuXG5jb25zdCBFdmVudCA9IHtcbiAgQ0xPU0UgICAgICAgICAgOiBgY2xvc2Uke0VWRU5UX0tFWX1gLFxuICBDTE9TRUQgICAgICAgICA6IGBjbG9zZWQke0VWRU5UX0tFWX1gLFxuICBDTElDS19EQVRBX0FQSSA6IGBjbGljayR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcbn1cblxuY29uc3QgQ2xhc3NOYW1lID0ge1xuICBBTEVSVCA6ICdhbGVydCcsXG4gIEZBREUgIDogJ2ZhZGUnLFxuICBTSE9XICA6ICdzaG93J1xufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgQWxlcnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnRcbiAgfVxuXG4gIC8vIEdldHRlcnNcblxuICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgcmV0dXJuIFZFUlNJT05cbiAgfVxuXG4gIC8vIFB1YmxpY1xuXG4gIGNsb3NlKGVsZW1lbnQpIHtcbiAgICBsZXQgcm9vdEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHJvb3RFbGVtZW50ID0gdGhpcy5fZ2V0Um9vdEVsZW1lbnQoZWxlbWVudClcbiAgICB9XG5cbiAgICBjb25zdCBjdXN0b21FdmVudCA9IHRoaXMuX3RyaWdnZXJDbG9zZUV2ZW50KHJvb3RFbGVtZW50KVxuXG4gICAgaWYgKGN1c3RvbUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9yZW1vdmVFbGVtZW50KHJvb3RFbGVtZW50KVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGxcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBfZ2V0Um9vdEVsZW1lbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpXG4gICAgbGV0IHBhcmVudCAgICAgPSBmYWxzZVxuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBwYXJlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKVxuICAgIH1cblxuICAgIGlmICghcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSAkKGVsZW1lbnQpLmNsb3Nlc3QoYC4ke0NsYXNzTmFtZS5BTEVSVH1gKVswXVxuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnRcbiAgfVxuXG4gIF90cmlnZ2VyQ2xvc2VFdmVudChlbGVtZW50KSB7XG4gICAgY29uc3QgY2xvc2VFdmVudCA9ICQuRXZlbnQoRXZlbnQuQ0xPU0UpXG5cbiAgICAkKGVsZW1lbnQpLnRyaWdnZXIoY2xvc2VFdmVudClcbiAgICByZXR1cm4gY2xvc2VFdmVudFxuICB9XG5cbiAgX3JlbW92ZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICQoZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG5cbiAgICBpZiAoISQoZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpKSB7XG4gICAgICB0aGlzLl9kZXN0cm95RWxlbWVudChlbGVtZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudChlbGVtZW50KVxuXG4gICAgJChlbGVtZW50KVxuICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCAoZXZlbnQpID0+IHRoaXMuX2Rlc3Ryb3lFbGVtZW50KGVsZW1lbnQsIGV2ZW50KSlcbiAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gIH1cblxuICBfZGVzdHJveUVsZW1lbnQoZWxlbWVudCkge1xuICAgICQoZWxlbWVudClcbiAgICAgIC5kZXRhY2goKVxuICAgICAgLnRyaWdnZXIoRXZlbnQuQ0xPU0VEKVxuICAgICAgLnJlbW92ZSgpXG4gIH1cblxuICAvLyBTdGF0aWNcblxuICBzdGF0aWMgX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0ICRlbGVtZW50ID0gJCh0aGlzKVxuICAgICAgbGV0IGRhdGEgICAgICAgPSAkZWxlbWVudC5kYXRhKERBVEFfS0VZKVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBBbGVydCh0aGlzKVxuICAgICAgICAkZWxlbWVudC5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnID09PSAnY2xvc2UnKSB7XG4gICAgICAgIGRhdGFbY29uZmlnXSh0aGlzKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBzdGF0aWMgX2hhbmRsZURpc21pc3MoYWxlcnRJbnN0YW5jZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICB9XG5cbiAgICAgIGFsZXJ0SW5zdGFuY2UuY2xvc2UodGhpcylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kKGRvY3VtZW50KS5vbihcbiAgRXZlbnQuQ0xJQ0tfREFUQV9BUEksXG4gIFNlbGVjdG9yLkRJU01JU1MsXG4gIEFsZXJ0Ll9oYW5kbGVEaXNtaXNzKG5ldyBBbGVydCgpKVxuKVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kLmZuW05BTUVdICAgICAgICAgICAgID0gQWxlcnQuX2pRdWVyeUludGVyZmFjZVxuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IEFsZXJ0XG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBBbGVydC5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IEFsZXJ0XG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjMuMSk6IGJ1dHRvbi5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FICAgICAgICAgICAgICAgID0gJ2J1dHRvbidcbmNvbnN0IFZFUlNJT04gICAgICAgICAgICAgPSAnNC4zLjEnXG5jb25zdCBEQVRBX0tFWSAgICAgICAgICAgID0gJ2JzLmJ1dHRvbidcbmNvbnN0IEVWRU5UX0tFWSAgICAgICAgICAgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgREFUQV9BUElfS0VZICAgICAgICA9ICcuZGF0YS1hcGknXG5jb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgID0gJC5mbltOQU1FXVxuXG5jb25zdCBDbGFzc05hbWUgPSB7XG4gIEFDVElWRSA6ICdhY3RpdmUnLFxuICBCVVRUT04gOiAnYnRuJyxcbiAgRk9DVVMgIDogJ2ZvY3VzJ1xufVxuXG5jb25zdCBTZWxlY3RvciA9IHtcbiAgREFUQV9UT0dHTEVfQ0FSUk9UIDogJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLFxuICBEQVRBX1RPR0dMRSAgICAgICAgOiAnW2RhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiXScsXG4gIElOUFVUICAgICAgICAgICAgICA6ICdpbnB1dDpub3QoW3R5cGU9XCJoaWRkZW5cIl0pJyxcbiAgQUNUSVZFICAgICAgICAgICAgIDogJy5hY3RpdmUnLFxuICBCVVRUT04gICAgICAgICAgICAgOiAnLmJ0bidcbn1cblxuY29uc3QgRXZlbnQgPSB7XG4gIENMSUNLX0RBVEFfQVBJICAgICAgOiBgY2xpY2ske0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gLFxuICBGT0NVU19CTFVSX0RBVEFfQVBJIDogYGZvY3VzJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBgYmx1ciR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNsYXNzIEJ1dHRvbiB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFxuICB9XG5cbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgdG9nZ2xlKCkge1xuICAgIGxldCB0cmlnZ2VyQ2hhbmdlRXZlbnQgPSB0cnVlXG4gICAgbGV0IGFkZEFyaWFQcmVzc2VkID0gdHJ1ZVxuICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gJCh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KFxuICAgICAgU2VsZWN0b3IuREFUQV9UT0dHTEVcbiAgICApWzBdXG5cbiAgICBpZiAocm9vdEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yLklOUFVUKVxuXG4gICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LnR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCAmJlxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ2xhc3NOYW1lLkFDVElWRSkpIHtcbiAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2VFdmVudCA9IGZhbHNlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSByb290RWxlbWVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yLkFDVElWRSlcblxuICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgJChhY3RpdmVFbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQUNUSVZFKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpIHx8XG4gICAgICAgICAgICByb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHxcbiAgICAgICAgICAgIGlucHV0LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSB8fFxuICAgICAgICAgICAgcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXQuY2hlY2tlZCA9ICF0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDbGFzc05hbWUuQUNUSVZFKVxuICAgICAgICAgICQoaW5wdXQpLnRyaWdnZXIoJ2NoYW5nZScpXG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dC5mb2N1cygpXG4gICAgICAgIGFkZEFyaWFQcmVzc2VkID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWRkQXJpYVByZXNzZWQpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXByZXNzZWQnLFxuICAgICAgICAhdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ2xhc3NOYW1lLkFDVElWRSkpXG4gICAgfVxuXG4gICAgaWYgKHRyaWdnZXJDaGFuZ2VFdmVudCkge1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS50b2dnbGVDbGFzcyhDbGFzc05hbWUuQUNUSVZFKVxuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKVxuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsXG4gIH1cblxuICAvLyBTdGF0aWNcblxuICBzdGF0aWMgX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBkYXRhID0gJCh0aGlzKS5kYXRhKERBVEFfS0VZKVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBCdXR0b24odGhpcylcbiAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnID09PSAndG9nZ2xlJykge1xuICAgICAgICBkYXRhW2NvbmZpZ10oKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kKGRvY3VtZW50KVxuICAub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkRBVEFfVE9HR0xFX0NBUlJPVCwgKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXG4gICAgbGV0IGJ1dHRvbiA9IGV2ZW50LnRhcmdldFxuXG4gICAgaWYgKCEkKGJ1dHRvbikuaGFzQ2xhc3MoQ2xhc3NOYW1lLkJVVFRPTikpIHtcbiAgICAgIGJ1dHRvbiA9ICQoYnV0dG9uKS5jbG9zZXN0KFNlbGVjdG9yLkJVVFRPTilcbiAgICB9XG5cbiAgICBCdXR0b24uX2pRdWVyeUludGVyZmFjZS5jYWxsKCQoYnV0dG9uKSwgJ3RvZ2dsZScpXG4gIH0pXG4gIC5vbihFdmVudC5GT0NVU19CTFVSX0RBVEFfQVBJLCBTZWxlY3Rvci5EQVRBX1RPR0dMRV9DQVJST1QsIChldmVudCkgPT4ge1xuICAgIGNvbnN0IGJ1dHRvbiA9ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFNlbGVjdG9yLkJVVFRPTilbMF1cbiAgICAkKGJ1dHRvbikudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lLkZPQ1VTLCAvXmZvY3VzKGluKT8kLy50ZXN0KGV2ZW50LnR5cGUpKVxuICB9KVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kLmZuW05BTUVdID0gQnV0dG9uLl9qUXVlcnlJbnRlcmZhY2VcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBCdXR0b25cbiQuZm5bTkFNRV0ubm9Db25mbGljdCA9ICgpID0+IHtcbiAgJC5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVFxuICByZXR1cm4gQnV0dG9uLl9qUXVlcnlJbnRlcmZhY2Vcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjMuMSk6IGNhcm91c2VsLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknXG5pbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUgICAgICAgICAgICAgICAgICAgPSAnY2Fyb3VzZWwnXG5jb25zdCBWRVJTSU9OICAgICAgICAgICAgICAgID0gJzQuMy4xJ1xuY29uc3QgREFUQV9LRVkgICAgICAgICAgICAgICA9ICdicy5jYXJvdXNlbCdcbmNvbnN0IEVWRU5UX0tFWSAgICAgICAgICAgICAgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgREFUQV9BUElfS0VZICAgICAgICAgICA9ICcuZGF0YS1hcGknXG5jb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgICAgID0gJC5mbltOQU1FXVxuY29uc3QgQVJST1dfTEVGVF9LRVlDT0RFICAgICA9IDM3IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIGxlZnQgYXJyb3cga2V5XG5jb25zdCBBUlJPV19SSUdIVF9LRVlDT0RFICAgID0gMzkgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgcmlnaHQgYXJyb3cga2V5XG5jb25zdCBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUID0gNTAwIC8vIFRpbWUgZm9yIG1vdXNlIGNvbXBhdCBldmVudHMgdG8gZmlyZSBhZnRlciB0b3VjaFxuY29uc3QgU1dJUEVfVEhSRVNIT0xEICAgICAgICA9IDQwXG5cbmNvbnN0IERlZmF1bHQgPSB7XG4gIGludGVydmFsIDogNTAwMCxcbiAga2V5Ym9hcmQgOiB0cnVlLFxuICBzbGlkZSAgICA6IGZhbHNlLFxuICBwYXVzZSAgICA6ICdob3ZlcicsXG4gIHdyYXAgICAgIDogdHJ1ZSxcbiAgdG91Y2ggICAgOiB0cnVlXG59XG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBpbnRlcnZhbCA6ICcobnVtYmVyfGJvb2xlYW4pJyxcbiAga2V5Ym9hcmQgOiAnYm9vbGVhbicsXG4gIHNsaWRlICAgIDogJyhib29sZWFufHN0cmluZyknLFxuICBwYXVzZSAgICA6ICcoc3RyaW5nfGJvb2xlYW4pJyxcbiAgd3JhcCAgICAgOiAnYm9vbGVhbicsXG4gIHRvdWNoICAgIDogJ2Jvb2xlYW4nXG59XG5cbmNvbnN0IERpcmVjdGlvbiA9IHtcbiAgTkVYVCAgICAgOiAnbmV4dCcsXG4gIFBSRVYgICAgIDogJ3ByZXYnLFxuICBMRUZUICAgICA6ICdsZWZ0JyxcbiAgUklHSFQgICAgOiAncmlnaHQnXG59XG5cbmNvbnN0IEV2ZW50ID0ge1xuICBTTElERSAgICAgICAgICA6IGBzbGlkZSR7RVZFTlRfS0VZfWAsXG4gIFNMSUQgICAgICAgICAgIDogYHNsaWQke0VWRU5UX0tFWX1gLFxuICBLRVlET1dOICAgICAgICA6IGBrZXlkb3duJHtFVkVOVF9LRVl9YCxcbiAgTU9VU0VFTlRFUiAgICAgOiBgbW91c2VlbnRlciR7RVZFTlRfS0VZfWAsXG4gIE1PVVNFTEVBVkUgICAgIDogYG1vdXNlbGVhdmUke0VWRU5UX0tFWX1gLFxuICBUT1VDSFNUQVJUICAgICA6IGB0b3VjaHN0YXJ0JHtFVkVOVF9LRVl9YCxcbiAgVE9VQ0hNT1ZFICAgICAgOiBgdG91Y2htb3ZlJHtFVkVOVF9LRVl9YCxcbiAgVE9VQ0hFTkQgICAgICAgOiBgdG91Y2hlbmQke0VWRU5UX0tFWX1gLFxuICBQT0lOVEVSRE9XTiAgICA6IGBwb2ludGVyZG93biR7RVZFTlRfS0VZfWAsXG4gIFBPSU5URVJVUCAgICAgIDogYHBvaW50ZXJ1cCR7RVZFTlRfS0VZfWAsXG4gIERSQUdfU1RBUlQgICAgIDogYGRyYWdzdGFydCR7RVZFTlRfS0VZfWAsXG4gIExPQURfREFUQV9BUEkgIDogYGxvYWQke0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gLFxuICBDTElDS19EQVRBX0FQSSA6IGBjbGljayR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcbn1cblxuY29uc3QgQ2xhc3NOYW1lID0ge1xuICBDQVJPVVNFTCAgICAgIDogJ2Nhcm91c2VsJyxcbiAgQUNUSVZFICAgICAgICA6ICdhY3RpdmUnLFxuICBTTElERSAgICAgICAgIDogJ3NsaWRlJyxcbiAgUklHSFQgICAgICAgICA6ICdjYXJvdXNlbC1pdGVtLXJpZ2h0JyxcbiAgTEVGVCAgICAgICAgICA6ICdjYXJvdXNlbC1pdGVtLWxlZnQnLFxuICBORVhUICAgICAgICAgIDogJ2Nhcm91c2VsLWl0ZW0tbmV4dCcsXG4gIFBSRVYgICAgICAgICAgOiAnY2Fyb3VzZWwtaXRlbS1wcmV2JyxcbiAgSVRFTSAgICAgICAgICA6ICdjYXJvdXNlbC1pdGVtJyxcbiAgUE9JTlRFUl9FVkVOVCA6ICdwb2ludGVyLWV2ZW50J1xufVxuXG5jb25zdCBTZWxlY3RvciA9IHtcbiAgQUNUSVZFICAgICAgOiAnLmFjdGl2ZScsXG4gIEFDVElWRV9JVEVNIDogJy5hY3RpdmUuY2Fyb3VzZWwtaXRlbScsXG4gIElURU0gICAgICAgIDogJy5jYXJvdXNlbC1pdGVtJyxcbiAgSVRFTV9JTUcgICAgOiAnLmNhcm91c2VsLWl0ZW0gaW1nJyxcbiAgTkVYVF9QUkVWICAgOiAnLmNhcm91c2VsLWl0ZW0tbmV4dCwgLmNhcm91c2VsLWl0ZW0tcHJldicsXG4gIElORElDQVRPUlMgIDogJy5jYXJvdXNlbC1pbmRpY2F0b3JzJyxcbiAgREFUQV9TTElERSAgOiAnW2RhdGEtc2xpZGVdLCBbZGF0YS1zbGlkZS10b10nLFxuICBEQVRBX1JJREUgICA6ICdbZGF0YS1yaWRlPVwiY2Fyb3VzZWxcIl0nXG59XG5cbmNvbnN0IFBvaW50ZXJUeXBlID0ge1xuICBUT1VDSCA6ICd0b3VjaCcsXG4gIFBFTiAgIDogJ3Blbidcbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5jbGFzcyBDYXJvdXNlbCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHRoaXMuX2l0ZW1zICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5faW50ZXJ2YWwgICAgICA9IG51bGxcbiAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbnVsbFxuICAgIHRoaXMuX2lzUGF1c2VkICAgICAgPSBmYWxzZVxuICAgIHRoaXMuX2lzU2xpZGluZyAgICAgPSBmYWxzZVxuICAgIHRoaXMudG91Y2hUaW1lb3V0ICAgPSBudWxsXG4gICAgdGhpcy50b3VjaFN0YXJ0WCAgICA9IDBcbiAgICB0aGlzLnRvdWNoRGVsdGFYICAgID0gMFxuXG4gICAgdGhpcy5fY29uZmlnICAgICAgICAgICAgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgIHRoaXMuX2VsZW1lbnQgICAgICAgICAgID0gZWxlbWVudFxuICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yLklORElDQVRPUlMpXG4gICAgdGhpcy5fdG91Y2hTdXBwb3J0ZWQgICAgPSAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMFxuICAgIHRoaXMuX3BvaW50ZXJFdmVudCAgICAgID0gQm9vbGVhbih3aW5kb3cuUG9pbnRlckV2ZW50IHx8IHdpbmRvdy5NU1BvaW50ZXJFdmVudClcblxuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKClcbiAgfVxuXG4gIC8vIEdldHRlcnNcblxuICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgcmV0dXJuIFZFUlNJT05cbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgbmV4dCgpIHtcbiAgICBpZiAoIXRoaXMuX2lzU2xpZGluZykge1xuICAgICAgdGhpcy5fc2xpZGUoRGlyZWN0aW9uLk5FWFQpXG4gICAgfVxuICB9XG5cbiAgbmV4dFdoZW5WaXNpYmxlKCkge1xuICAgIC8vIERvbid0IGNhbGwgbmV4dCB3aGVuIHRoZSBwYWdlIGlzbid0IHZpc2libGVcbiAgICAvLyBvciB0aGUgY2Fyb3VzZWwgb3IgaXRzIHBhcmVudCBpc24ndCB2aXNpYmxlXG4gICAgaWYgKCFkb2N1bWVudC5oaWRkZW4gJiZcbiAgICAgICgkKHRoaXMuX2VsZW1lbnQpLmlzKCc6dmlzaWJsZScpICYmICQodGhpcy5fZWxlbWVudCkuY3NzKCd2aXNpYmlsaXR5JykgIT09ICdoaWRkZW4nKSkge1xuICAgICAgdGhpcy5uZXh0KClcbiAgICB9XG4gIH1cblxuICBwcmV2KCkge1xuICAgIGlmICghdGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICB0aGlzLl9zbGlkZShEaXJlY3Rpb24uUFJFVilcbiAgICB9XG4gIH1cblxuICBwYXVzZShldmVudCkge1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3IuTkVYVF9QUkVWKSkge1xuICAgICAgVXRpbC50cmlnZ2VyVHJhbnNpdGlvbkVuZCh0aGlzLl9lbGVtZW50KVxuICAgICAgdGhpcy5jeWNsZSh0cnVlKVxuICAgIH1cblxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsXG4gIH1cblxuICBjeWNsZShldmVudCkge1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpXG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29uZmlnLmludGVydmFsICYmICF0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA/IHRoaXMubmV4dFdoZW5WaXNpYmxlIDogdGhpcy5uZXh0KS5iaW5kKHRoaXMpLFxuICAgICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICB0byhpbmRleCkge1xuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3IuQUNUSVZFX0lURU0pXG5cbiAgICBjb25zdCBhY3RpdmVJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9hY3RpdmVFbGVtZW50KVxuXG4gICAgaWYgKGluZGV4ID4gdGhpcy5faXRlbXMubGVuZ3RoIC0gMSB8fCBpbmRleCA8IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgICQodGhpcy5fZWxlbWVudCkub25lKEV2ZW50LlNMSUQsICgpID0+IHRoaXMudG8oaW5kZXgpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGFjdGl2ZUluZGV4ID09PSBpbmRleCkge1xuICAgICAgdGhpcy5wYXVzZSgpXG4gICAgICB0aGlzLmN5Y2xlKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGluZGV4ID4gYWN0aXZlSW5kZXhcbiAgICAgID8gRGlyZWN0aW9uLk5FWFRcbiAgICAgIDogRGlyZWN0aW9uLlBSRVZcblxuICAgIHRoaXMuX3NsaWRlKGRpcmVjdGlvbiwgdGhpcy5faXRlbXNbaW5kZXhdKVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihFVkVOVF9LRVkpXG4gICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKVxuXG4gICAgdGhpcy5faXRlbXMgICAgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5fY29uZmlnICAgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5fZWxlbWVudCAgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5faW50ZXJ2YWwgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5faXNQYXVzZWQgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5faXNTbGlkaW5nICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5fYWN0aXZlRWxlbWVudCAgICAgPSBudWxsXG4gICAgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQgPSBudWxsXG4gIH1cblxuICAvLyBQcml2YXRlXG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7XG4gICAgICAuLi5EZWZhdWx0LFxuICAgICAgLi4uY29uZmlnXG4gICAgfVxuICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgRGVmYXVsdFR5cGUpXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX2hhbmRsZVN3aXBlKCkge1xuICAgIGNvbnN0IGFic0RlbHRheCA9IE1hdGguYWJzKHRoaXMudG91Y2hEZWx0YVgpXG5cbiAgICBpZiAoYWJzRGVsdGF4IDw9IFNXSVBFX1RIUkVTSE9MRCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZGlyZWN0aW9uID0gYWJzRGVsdGF4IC8gdGhpcy50b3VjaERlbHRhWFxuXG4gICAgLy8gc3dpcGUgbGVmdFxuICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICB0aGlzLnByZXYoKVxuICAgIH1cblxuICAgIC8vIHN3aXBlIHJpZ2h0XG4gICAgaWYgKGRpcmVjdGlvbiA8IDApIHtcbiAgICAgIHRoaXMubmV4dCgpXG4gICAgfVxuICB9XG5cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcbiAgICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgICAgLm9uKEV2ZW50LktFWURPV04sIChldmVudCkgPT4gdGhpcy5fa2V5ZG93bihldmVudCkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gJ2hvdmVyJykge1xuICAgICAgJCh0aGlzLl9lbGVtZW50KVxuICAgICAgICAub24oRXZlbnQuTU9VU0VFTlRFUiwgKGV2ZW50KSA9PiB0aGlzLnBhdXNlKGV2ZW50KSlcbiAgICAgICAgLm9uKEV2ZW50Lk1PVVNFTEVBVkUsIChldmVudCkgPT4gdGhpcy5jeWNsZShldmVudCkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy50b3VjaCkge1xuICAgICAgdGhpcy5fYWRkVG91Y2hFdmVudExpc3RlbmVycygpXG4gICAgfVxuICB9XG5cbiAgX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKCF0aGlzLl90b3VjaFN1cHBvcnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmICh0aGlzLl9wb2ludGVyRXZlbnQgJiYgUG9pbnRlclR5cGVbZXZlbnQub3JpZ2luYWxFdmVudC5wb2ludGVyVHlwZS50b1VwcGVyQ2FzZSgpXSkge1xuICAgICAgICB0aGlzLnRvdWNoU3RhcnRYID0gZXZlbnQub3JpZ2luYWxFdmVudC5jbGllbnRYXG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9wb2ludGVyRXZlbnQpIHtcbiAgICAgICAgdGhpcy50b3VjaFN0YXJ0WCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXS5jbGllbnRYXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbW92ZSA9IChldmVudCkgPT4ge1xuICAgICAgLy8gZW5zdXJlIHN3aXBpbmcgd2l0aCBvbmUgdG91Y2ggYW5kIG5vdCBwaW5jaGluZ1xuICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcyAmJiBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnRvdWNoRGVsdGFYID0gMFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50b3VjaERlbHRhWCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXS5jbGllbnRYIC0gdGhpcy50b3VjaFN0YXJ0WFxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGVuZCA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudCAmJiBQb2ludGVyVHlwZVtldmVudC5vcmlnaW5hbEV2ZW50LnBvaW50ZXJUeXBlLnRvVXBwZXJDYXNlKCldKSB7XG4gICAgICAgIHRoaXMudG91Y2hEZWx0YVggPSBldmVudC5vcmlnaW5hbEV2ZW50LmNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnRYXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2hhbmRsZVN3aXBlKClcbiAgICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgPT09ICdob3ZlcicpIHtcbiAgICAgICAgLy8gSWYgaXQncyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlLCBtb3VzZWVudGVyL2xlYXZlIGFyZSBmaXJlZCBhc1xuICAgICAgICAvLyBwYXJ0IG9mIHRoZSBtb3VzZSBjb21wYXRpYmlsaXR5IGV2ZW50cyBvbiBmaXJzdCB0YXAgLSB0aGUgY2Fyb3VzZWxcbiAgICAgICAgLy8gd291bGQgc3RvcCBjeWNsaW5nIHVudGlsIHVzZXIgdGFwcGVkIG91dCBvZiBpdDtcbiAgICAgICAgLy8gaGVyZSwgd2UgbGlzdGVuIGZvciB0b3VjaGVuZCwgZXhwbGljaXRseSBwYXVzZSB0aGUgY2Fyb3VzZWxcbiAgICAgICAgLy8gKGFzIGlmIGl0J3MgdGhlIHNlY29uZCB0aW1lIHdlIHRhcCBvbiBpdCwgbW91c2VlbnRlciBjb21wYXQgZXZlbnRcbiAgICAgICAgLy8gaXMgTk9UIGZpcmVkKSBhbmQgYWZ0ZXIgYSB0aW1lb3V0ICh0byBhbGxvdyBmb3IgbW91c2UgY29tcGF0aWJpbGl0eVxuICAgICAgICAvLyBldmVudHMgdG8gZmlyZSkgd2UgZXhwbGljaXRseSByZXN0YXJ0IGN5Y2xpbmdcblxuICAgICAgICB0aGlzLnBhdXNlKClcbiAgICAgICAgaWYgKHRoaXMudG91Y2hUaW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudG91Y2hUaW1lb3V0KVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoZXZlbnQpID0+IHRoaXMuY3ljbGUoZXZlbnQpLCBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUICsgdGhpcy5fY29uZmlnLmludGVydmFsKVxuICAgICAgfVxuICAgIH1cblxuICAgICQodGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yLklURU1fSU1HKSkub24oRXZlbnQuRFJBR19TVEFSVCwgKGUpID0+IGUucHJldmVudERlZmF1bHQoKSlcbiAgICBpZiAodGhpcy5fcG9pbnRlckV2ZW50KSB7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKEV2ZW50LlBPSU5URVJET1dOLCAoZXZlbnQpID0+IHN0YXJ0KGV2ZW50KSlcbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oRXZlbnQuUE9JTlRFUlVQLCAoZXZlbnQpID0+IGVuZChldmVudCkpXG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDbGFzc05hbWUuUE9JTlRFUl9FVkVOVClcbiAgICB9IGVsc2Uge1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudC5UT1VDSFNUQVJULCAoZXZlbnQpID0+IHN0YXJ0KGV2ZW50KSlcbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oRXZlbnQuVE9VQ0hNT1ZFLCAoZXZlbnQpID0+IG1vdmUoZXZlbnQpKVxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudC5UT1VDSEVORCwgKGV2ZW50KSA9PiBlbmQoZXZlbnQpKVxuICAgIH1cbiAgfVxuXG4gIF9rZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XG4gICAgICBjYXNlIEFSUk9XX0xFRlRfS0VZQ09ERTpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB0aGlzLnByZXYoKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBBUlJPV19SSUdIVF9LRVlDT0RFOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHRoaXMubmV4dCgpXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIF9nZXRJdGVtSW5kZXgoZWxlbWVudCkge1xuICAgIHRoaXMuX2l0ZW1zID0gZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGVcbiAgICAgID8gW10uc2xpY2UuY2FsbChlbGVtZW50LnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChTZWxlY3Rvci5JVEVNKSlcbiAgICAgIDogW11cbiAgICByZXR1cm4gdGhpcy5faXRlbXMuaW5kZXhPZihlbGVtZW50KVxuICB9XG5cbiAgX2dldEl0ZW1CeURpcmVjdGlvbihkaXJlY3Rpb24sIGFjdGl2ZUVsZW1lbnQpIHtcbiAgICBjb25zdCBpc05leHREaXJlY3Rpb24gPSBkaXJlY3Rpb24gPT09IERpcmVjdGlvbi5ORVhUXG4gICAgY29uc3QgaXNQcmV2RGlyZWN0aW9uID0gZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uUFJFVlxuICAgIGNvbnN0IGFjdGl2ZUluZGV4ICAgICA9IHRoaXMuX2dldEl0ZW1JbmRleChhY3RpdmVFbGVtZW50KVxuICAgIGNvbnN0IGxhc3RJdGVtSW5kZXggICA9IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDFcbiAgICBjb25zdCBpc0dvaW5nVG9XcmFwICAgPSBpc1ByZXZEaXJlY3Rpb24gJiYgYWN0aXZlSW5kZXggPT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc05leHREaXJlY3Rpb24gJiYgYWN0aXZlSW5kZXggPT09IGxhc3RJdGVtSW5kZXhcblxuICAgIGlmIChpc0dvaW5nVG9XcmFwICYmICF0aGlzLl9jb25maWcud3JhcCkge1xuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRcbiAgICB9XG5cbiAgICBjb25zdCBkZWx0YSAgICAgPSBkaXJlY3Rpb24gPT09IERpcmVjdGlvbi5QUkVWID8gLTEgOiAxXG4gICAgY29uc3QgaXRlbUluZGV4ID0gKGFjdGl2ZUluZGV4ICsgZGVsdGEpICUgdGhpcy5faXRlbXMubGVuZ3RoXG5cbiAgICByZXR1cm4gaXRlbUluZGV4ID09PSAtMVxuICAgICAgPyB0aGlzLl9pdGVtc1t0aGlzLl9pdGVtcy5sZW5ndGggLSAxXSA6IHRoaXMuX2l0ZW1zW2l0ZW1JbmRleF1cbiAgfVxuXG4gIF90cmlnZ2VyU2xpZGVFdmVudChyZWxhdGVkVGFyZ2V0LCBldmVudERpcmVjdGlvbk5hbWUpIHtcbiAgICBjb25zdCB0YXJnZXRJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChyZWxhdGVkVGFyZ2V0KVxuICAgIGNvbnN0IGZyb21JbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3IuQUNUSVZFX0lURU0pKVxuICAgIGNvbnN0IHNsaWRlRXZlbnQgPSAkLkV2ZW50KEV2ZW50LlNMSURFLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0LFxuICAgICAgZGlyZWN0aW9uOiBldmVudERpcmVjdGlvbk5hbWUsXG4gICAgICBmcm9tOiBmcm9tSW5kZXgsXG4gICAgICB0bzogdGFyZ2V0SW5kZXhcbiAgICB9KVxuXG4gICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNsaWRlRXZlbnQpXG5cbiAgICByZXR1cm4gc2xpZGVFdmVudFxuICB9XG5cbiAgX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCkge1xuICAgICAgY29uc3QgaW5kaWNhdG9ycyA9IFtdLnNsaWNlLmNhbGwodGhpcy5faW5kaWNhdG9yc0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3Rvci5BQ1RJVkUpKVxuICAgICAgJChpbmRpY2F0b3JzKVxuICAgICAgICAucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSlcblxuICAgICAgY29uc3QgbmV4dEluZGljYXRvciA9IHRoaXMuX2luZGljYXRvcnNFbGVtZW50LmNoaWxkcmVuW1xuICAgICAgICB0aGlzLl9nZXRJdGVtSW5kZXgoZWxlbWVudClcbiAgICAgIF1cblxuICAgICAgaWYgKG5leHRJbmRpY2F0b3IpIHtcbiAgICAgICAgJChuZXh0SW5kaWNhdG9yKS5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9zbGlkZShkaXJlY3Rpb24sIGVsZW1lbnQpIHtcbiAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yLkFDVElWRV9JVEVNKVxuICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnRJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChhY3RpdmVFbGVtZW50KVxuICAgIGNvbnN0IG5leHRFbGVtZW50ICAgPSBlbGVtZW50IHx8IGFjdGl2ZUVsZW1lbnQgJiZcbiAgICAgIHRoaXMuX2dldEl0ZW1CeURpcmVjdGlvbihkaXJlY3Rpb24sIGFjdGl2ZUVsZW1lbnQpXG4gICAgY29uc3QgbmV4dEVsZW1lbnRJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChuZXh0RWxlbWVudClcbiAgICBjb25zdCBpc0N5Y2xpbmcgPSBCb29sZWFuKHRoaXMuX2ludGVydmFsKVxuXG4gICAgbGV0IGRpcmVjdGlvbmFsQ2xhc3NOYW1lXG4gICAgbGV0IG9yZGVyQ2xhc3NOYW1lXG4gICAgbGV0IGV2ZW50RGlyZWN0aW9uTmFtZVxuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLk5FWFQpIHtcbiAgICAgIGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gQ2xhc3NOYW1lLkxFRlRcbiAgICAgIG9yZGVyQ2xhc3NOYW1lID0gQ2xhc3NOYW1lLk5FWFRcbiAgICAgIGV2ZW50RGlyZWN0aW9uTmFtZSA9IERpcmVjdGlvbi5MRUZUXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gQ2xhc3NOYW1lLlJJR0hUXG4gICAgICBvcmRlckNsYXNzTmFtZSA9IENsYXNzTmFtZS5QUkVWXG4gICAgICBldmVudERpcmVjdGlvbk5hbWUgPSBEaXJlY3Rpb24uUklHSFRcbiAgICB9XG5cbiAgICBpZiAobmV4dEVsZW1lbnQgJiYgJChuZXh0RWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSkpIHtcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzbGlkZUV2ZW50ID0gdGhpcy5fdHJpZ2dlclNsaWRlRXZlbnQobmV4dEVsZW1lbnQsIGV2ZW50RGlyZWN0aW9uTmFtZSlcbiAgICBpZiAoc2xpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFhY3RpdmVFbGVtZW50IHx8ICFuZXh0RWxlbWVudCkge1xuICAgICAgLy8gU29tZSB3ZWlyZG5lc3MgaXMgaGFwcGVuaW5nLCBzbyB3ZSBiYWlsXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pc1NsaWRpbmcgPSB0cnVlXG5cbiAgICBpZiAoaXNDeWNsaW5nKSB7XG4gICAgICB0aGlzLnBhdXNlKClcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50KVxuXG4gICAgY29uc3Qgc2xpZEV2ZW50ID0gJC5FdmVudChFdmVudC5TTElELCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiBuZXh0RWxlbWVudCxcbiAgICAgIGRpcmVjdGlvbjogZXZlbnREaXJlY3Rpb25OYW1lLFxuICAgICAgZnJvbTogYWN0aXZlRWxlbWVudEluZGV4LFxuICAgICAgdG86IG5leHRFbGVtZW50SW5kZXhcbiAgICB9KVxuXG4gICAgaWYgKCQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNMSURFKSkge1xuICAgICAgJChuZXh0RWxlbWVudCkuYWRkQ2xhc3Mob3JkZXJDbGFzc05hbWUpXG5cbiAgICAgIFV0aWwucmVmbG93KG5leHRFbGVtZW50KVxuXG4gICAgICAkKGFjdGl2ZUVsZW1lbnQpLmFkZENsYXNzKGRpcmVjdGlvbmFsQ2xhc3NOYW1lKVxuICAgICAgJChuZXh0RWxlbWVudCkuYWRkQ2xhc3MoZGlyZWN0aW9uYWxDbGFzc05hbWUpXG5cbiAgICAgIGNvbnN0IG5leHRFbGVtZW50SW50ZXJ2YWwgPSBwYXJzZUludChuZXh0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW50ZXJ2YWwnKSwgMTApXG4gICAgICBpZiAobmV4dEVsZW1lbnRJbnRlcnZhbCkge1xuICAgICAgICB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWxcbiAgICAgICAgdGhpcy5fY29uZmlnLmludGVydmFsID0gbmV4dEVsZW1lbnRJbnRlcnZhbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29uZmlnLmludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudChhY3RpdmVFbGVtZW50KVxuXG4gICAgICAkKGFjdGl2ZUVsZW1lbnQpXG4gICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgKCkgPT4ge1xuICAgICAgICAgICQobmV4dEVsZW1lbnQpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoYCR7ZGlyZWN0aW9uYWxDbGFzc05hbWV9ICR7b3JkZXJDbGFzc05hbWV9YClcbiAgICAgICAgICAgIC5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKVxuXG4gICAgICAgICAgJChhY3RpdmVFbGVtZW50KS5yZW1vdmVDbGFzcyhgJHtDbGFzc05hbWUuQUNUSVZFfSAke29yZGVyQ2xhc3NOYW1lfSAke2RpcmVjdGlvbmFsQ2xhc3NOYW1lfWApXG5cbiAgICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZVxuXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2xpZEV2ZW50KSwgMClcbiAgICAgICAgfSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgJChhY3RpdmVFbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQUNUSVZFKVxuICAgICAgJChuZXh0RWxlbWVudCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSlcblxuICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2VcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzbGlkRXZlbnQpXG4gICAgfVxuXG4gICAgaWYgKGlzQ3ljbGluZykge1xuICAgICAgdGhpcy5jeWNsZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gU3RhdGljXG5cbiAgc3RhdGljIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSlcbiAgICAgIGxldCBfY29uZmlnID0ge1xuICAgICAgICAuLi5EZWZhdWx0LFxuICAgICAgICAuLi4kKHRoaXMpLmRhdGEoKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgX2NvbmZpZyA9IHtcbiAgICAgICAgICAuLi5fY29uZmlnLFxuICAgICAgICAgIC4uLmNvbmZpZ1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFjdGlvbiA9IHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnID8gY29uZmlnIDogX2NvbmZpZy5zbGlkZVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBDYXJvdXNlbCh0aGlzLCBfY29uZmlnKVxuICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnbnVtYmVyJykge1xuICAgICAgICBkYXRhLnRvKGNvbmZpZylcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2FjdGlvbl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHthY3Rpb259XCJgKVxuICAgICAgICB9XG4gICAgICAgIGRhdGFbYWN0aW9uXSgpXG4gICAgICB9IGVsc2UgaWYgKF9jb25maWcuaW50ZXJ2YWwgJiYgX2NvbmZpZy5yaWRlKSB7XG4gICAgICAgIGRhdGEucGF1c2UoKVxuICAgICAgICBkYXRhLmN5Y2xlKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIF9kYXRhQXBpQ2xpY2tIYW5kbGVyKGV2ZW50KSB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcylcblxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9ICQoc2VsZWN0b3IpWzBdXG5cbiAgICBpZiAoIXRhcmdldCB8fCAhJCh0YXJnZXQpLmhhc0NsYXNzKENsYXNzTmFtZS5DQVJPVVNFTCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIC4uLiQodGFyZ2V0KS5kYXRhKCksXG4gICAgICAuLi4kKHRoaXMpLmRhdGEoKVxuICAgIH1cbiAgICBjb25zdCBzbGlkZUluZGV4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xpZGUtdG8nKVxuXG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgIGNvbmZpZy5pbnRlcnZhbCA9IGZhbHNlXG4gICAgfVxuXG4gICAgQ2Fyb3VzZWwuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGFyZ2V0KSwgY29uZmlnKVxuXG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgICQodGFyZ2V0KS5kYXRhKERBVEFfS0VZKS50byhzbGlkZUluZGV4KVxuICAgIH1cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQoZG9jdW1lbnQpXG4gIC5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9TTElERSwgQ2Fyb3VzZWwuX2RhdGFBcGlDbGlja0hhbmRsZXIpXG5cbiQod2luZG93KS5vbihFdmVudC5MT0FEX0RBVEFfQVBJLCAoKSA9PiB7XG4gIGNvbnN0IGNhcm91c2VscyA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3Rvci5EQVRBX1JJREUpKVxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2Fyb3VzZWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgJGNhcm91c2VsID0gJChjYXJvdXNlbHNbaV0pXG4gICAgQ2Fyb3VzZWwuX2pRdWVyeUludGVyZmFjZS5jYWxsKCRjYXJvdXNlbCwgJGNhcm91c2VsLmRhdGEoKSlcbiAgfVxufSlcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuJC5mbltOQU1FXSA9IENhcm91c2VsLl9qUXVlcnlJbnRlcmZhY2VcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBDYXJvdXNlbFxuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IENhcm91c2VsXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjMuMSk6IGNvbGxhcHNlLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknXG5pbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUgICAgICAgICAgICAgICAgPSAnY29sbGFwc2UnXG5jb25zdCBWRVJTSU9OICAgICAgICAgICAgID0gJzQuMy4xJ1xuY29uc3QgREFUQV9LRVkgICAgICAgICAgICA9ICdicy5jb2xsYXBzZSdcbmNvbnN0IEVWRU5UX0tFWSAgICAgICAgICAgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgREFUQV9BUElfS0VZICAgICAgICA9ICcuZGF0YS1hcGknXG5jb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgID0gJC5mbltOQU1FXVxuXG5jb25zdCBEZWZhdWx0ID0ge1xuICB0b2dnbGUgOiB0cnVlLFxuICBwYXJlbnQgOiAnJ1xufVxuXG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgdG9nZ2xlIDogJ2Jvb2xlYW4nLFxuICBwYXJlbnQgOiAnKHN0cmluZ3xlbGVtZW50KSdcbn1cblxuY29uc3QgRXZlbnQgPSB7XG4gIFNIT1cgICAgICAgICAgIDogYHNob3cke0VWRU5UX0tFWX1gLFxuICBTSE9XTiAgICAgICAgICA6IGBzaG93biR7RVZFTlRfS0VZfWAsXG4gIEhJREUgICAgICAgICAgIDogYGhpZGUke0VWRU5UX0tFWX1gLFxuICBISURERU4gICAgICAgICA6IGBoaWRkZW4ke0VWRU5UX0tFWX1gLFxuICBDTElDS19EQVRBX0FQSSA6IGBjbGljayR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcbn1cblxuY29uc3QgQ2xhc3NOYW1lID0ge1xuICBTSE9XICAgICAgIDogJ3Nob3cnLFxuICBDT0xMQVBTRSAgIDogJ2NvbGxhcHNlJyxcbiAgQ09MTEFQU0lORyA6ICdjb2xsYXBzaW5nJyxcbiAgQ09MTEFQU0VEICA6ICdjb2xsYXBzZWQnXG59XG5cbmNvbnN0IERpbWVuc2lvbiA9IHtcbiAgV0lEVEggIDogJ3dpZHRoJyxcbiAgSEVJR0hUIDogJ2hlaWdodCdcbn1cblxuY29uc3QgU2VsZWN0b3IgPSB7XG4gIEFDVElWRVMgICAgIDogJy5zaG93LCAuY29sbGFwc2luZycsXG4gIERBVEFfVE9HR0xFIDogJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdJ1xufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgQ29sbGFwc2Uge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZVxuICAgIHRoaXMuX2VsZW1lbnQgICAgICAgICA9IGVsZW1lbnRcbiAgICB0aGlzLl9jb25maWcgICAgICAgICAgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgIHRoaXMuX3RyaWdnZXJBcnJheSAgICA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgIGBbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtocmVmPVwiIyR7ZWxlbWVudC5pZH1cIl0sYCArXG4gICAgICBgW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS10YXJnZXQ9XCIjJHtlbGVtZW50LmlkfVwiXWBcbiAgICApKVxuXG4gICAgY29uc3QgdG9nZ2xlTGlzdCA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3Rvci5EQVRBX1RPR0dMRSkpXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRvZ2dsZUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW0gPSB0b2dnbGVMaXN0W2ldXG4gICAgICBjb25zdCBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtKVxuICAgICAgY29uc3QgZmlsdGVyRWxlbWVudCA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpXG4gICAgICAgIC5maWx0ZXIoKGZvdW5kRWxlbSkgPT4gZm91bmRFbGVtID09PSBlbGVtZW50KVxuXG4gICAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwgJiYgZmlsdGVyRWxlbWVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3JcbiAgICAgICAgdGhpcy5fdHJpZ2dlckFycmF5LnB1c2goZWxlbSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50ID8gdGhpcy5fZ2V0UGFyZW50KCkgOiBudWxsXG5cbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl90cmlnZ2VyQXJyYXkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy50b2dnbGUpIHtcbiAgICAgIHRoaXMudG9nZ2xlKClcbiAgICB9XG4gIH1cblxuICAvLyBHZXR0ZXJzXG5cbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIC8vIFB1YmxpY1xuXG4gIHRvZ2dsZSgpIHtcbiAgICBpZiAoJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVykpIHtcbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvdygpXG4gICAgfVxuICB9XG5cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGFjdGl2ZXNcbiAgICBsZXQgYWN0aXZlc0RhdGFcblxuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgIGFjdGl2ZXMgPSBbXS5zbGljZS5jYWxsKHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yLkFDVElWRVMpKVxuICAgICAgICAuZmlsdGVyKChlbGVtKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcucGFyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCdkYXRhLXBhcmVudCcpID09PSB0aGlzLl9jb25maWcucGFyZW50XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKENsYXNzTmFtZS5DT0xMQVBTRSlcbiAgICAgICAgfSlcblxuICAgICAgaWYgKGFjdGl2ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGFjdGl2ZXMgPSBudWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2ZXMpIHtcbiAgICAgIGFjdGl2ZXNEYXRhID0gJChhY3RpdmVzKS5ub3QodGhpcy5fc2VsZWN0b3IpLmRhdGEoREFUQV9LRVkpXG4gICAgICBpZiAoYWN0aXZlc0RhdGEgJiYgYWN0aXZlc0RhdGEuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdGFydEV2ZW50ID0gJC5FdmVudChFdmVudC5TSE9XKVxuICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzdGFydEV2ZW50KVxuICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoYWN0aXZlcykge1xuICAgICAgQ29sbGFwc2UuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQoYWN0aXZlcykubm90KHRoaXMuX3NlbGVjdG9yKSwgJ2hpZGUnKVxuICAgICAgaWYgKCFhY3RpdmVzRGF0YSkge1xuICAgICAgICAkKGFjdGl2ZXMpLmRhdGEoREFUQV9LRVksIG51bGwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKClcblxuICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgIC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0UpXG4gICAgICAuYWRkQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNJTkcpXG5cbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAwXG5cbiAgICBpZiAodGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aCkge1xuICAgICAgJCh0aGlzLl90cmlnZ2VyQXJyYXkpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0VEKVxuICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG4gICAgfVxuXG4gICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKHRydWUpXG5cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgICAgLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5DT0xMQVBTSU5HKVxuICAgICAgICAuYWRkQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNFKVxuICAgICAgICAuYWRkQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnXG5cbiAgICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyhmYWxzZSlcblxuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKEV2ZW50LlNIT1dOKVxuICAgIH1cblxuICAgIGNvbnN0IGNhcGl0YWxpemVkRGltZW5zaW9uID0gZGltZW5zaW9uWzBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoMSlcbiAgICBjb25zdCBzY3JvbGxTaXplID0gYHNjcm9sbCR7Y2FwaXRhbGl6ZWREaW1lbnNpb259YFxuICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudClcblxuICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpXG4gICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKVxuXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudFtzY3JvbGxTaXplXX1weGBcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fFxuICAgICAgISQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzdGFydEV2ZW50ID0gJC5FdmVudChFdmVudC5ISURFKVxuICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzdGFydEV2ZW50KVxuICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKVxuXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkaW1lbnNpb25dfXB4YFxuXG4gICAgVXRpbC5yZWZsb3codGhpcy5fZWxlbWVudClcblxuICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgIC5hZGRDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0lORylcbiAgICAgIC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0UpXG4gICAgICAucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG5cbiAgICBjb25zdCB0cmlnZ2VyQXJyYXlMZW5ndGggPSB0aGlzLl90cmlnZ2VyQXJyYXkubGVuZ3RoXG4gICAgaWYgKHRyaWdnZXJBcnJheUxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpZ2dlckFycmF5TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHJpZ2dlciA9IHRoaXMuX3RyaWdnZXJBcnJheVtpXVxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0cmlnZ2VyKVxuXG4gICAgICAgIGlmIChzZWxlY3RvciAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0ICRlbGVtID0gJChbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKSlcbiAgICAgICAgICBpZiAoISRlbGVtLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgICAgICAgJCh0cmlnZ2VyKS5hZGRDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0VEKVxuICAgICAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyh0cnVlKVxuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLnNldFRyYW5zaXRpb25pbmcoZmFsc2UpXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0lORylcbiAgICAgICAgLmFkZENsYXNzKENsYXNzTmFtZS5DT0xMQVBTRSlcbiAgICAgICAgLnRyaWdnZXIoRXZlbnQuSElEREVOKVxuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnXG4gICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KVxuXG4gICAgJCh0aGlzLl9lbGVtZW50KVxuICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSlcbiAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gIH1cblxuICBzZXRUcmFuc2l0aW9uaW5nKGlzVHJhbnNpdGlvbmluZykge1xuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGlzVHJhbnNpdGlvbmluZ1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG5cbiAgICB0aGlzLl9jb25maWcgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5fcGFyZW50ICAgICAgICAgID0gbnVsbFxuICAgIHRoaXMuX2VsZW1lbnQgICAgICAgICA9IG51bGxcbiAgICB0aGlzLl90cmlnZ2VyQXJyYXkgICAgPSBudWxsXG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gbnVsbFxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0ge1xuICAgICAgLi4uRGVmYXVsdCxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH1cbiAgICBjb25maWcudG9nZ2xlID0gQm9vbGVhbihjb25maWcudG9nZ2xlKSAvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlc1xuICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgRGVmYXVsdFR5cGUpXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX2dldERpbWVuc2lvbigpIHtcbiAgICBjb25zdCBoYXNXaWR0aCA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoRGltZW5zaW9uLldJRFRIKVxuICAgIHJldHVybiBoYXNXaWR0aCA/IERpbWVuc2lvbi5XSURUSCA6IERpbWVuc2lvbi5IRUlHSFRcbiAgfVxuXG4gIF9nZXRQYXJlbnQoKSB7XG4gICAgbGV0IHBhcmVudFxuXG4gICAgaWYgKFV0aWwuaXNFbGVtZW50KHRoaXMuX2NvbmZpZy5wYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50XG5cbiAgICAgIC8vIEl0J3MgYSBqUXVlcnkgb2JqZWN0XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5wYXJlbnQuanF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50WzBdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5fY29uZmlnLnBhcmVudClcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3RvciA9XG4gICAgICBgW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS1wYXJlbnQ9XCIke3RoaXMuX2NvbmZpZy5wYXJlbnR9XCJdYFxuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXS5zbGljZS5jYWxsKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcbiAgICAkKGNoaWxkcmVuKS5lYWNoKChpLCBlbGVtZW50KSA9PiB7XG4gICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoXG4gICAgICAgIENvbGxhcHNlLl9nZXRUYXJnZXRGcm9tRWxlbWVudChlbGVtZW50KSxcbiAgICAgICAgW2VsZW1lbnRdXG4gICAgICApXG4gICAgfSlcblxuICAgIHJldHVybiBwYXJlbnRcbiAgfVxuXG4gIF9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoZWxlbWVudCwgdHJpZ2dlckFycmF5KSB7XG4gICAgY29uc3QgaXNPcGVuID0gJChlbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVylcblxuICAgIGlmICh0cmlnZ2VyQXJyYXkubGVuZ3RoKSB7XG4gICAgICAkKHRyaWdnZXJBcnJheSlcbiAgICAgICAgLnRvZ2dsZUNsYXNzKENsYXNzTmFtZS5DT0xMQVBTRUQsICFpc09wZW4pXG4gICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKVxuICAgIH1cbiAgfVxuXG4gIC8vIFN0YXRpY1xuXG4gIHN0YXRpYyBfZ2V0VGFyZ2V0RnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpXG4gICAgcmV0dXJuIHNlbGVjdG9yID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgOiBudWxsXG4gIH1cblxuICBzdGF0aWMgX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0ICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICBsZXQgZGF0YSAgICAgID0gJHRoaXMuZGF0YShEQVRBX0tFWSlcbiAgICAgIGNvbnN0IF9jb25maWcgPSB7XG4gICAgICAgIC4uLkRlZmF1bHQsXG4gICAgICAgIC4uLiR0aGlzLmRhdGEoKSxcbiAgICAgICAgLi4udHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge31cbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhICYmIF9jb25maWcudG9nZ2xlICYmIC9zaG93fGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgICBfY29uZmlnLnRvZ2dsZSA9IGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0gbmV3IENvbGxhcHNlKHRoaXMsIF9jb25maWcpXG4gICAgICAgICR0aGlzLmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApXG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtjb25maWddKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuJChkb2N1bWVudCkub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkRBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gcHJldmVudERlZmF1bHQgb25seSBmb3IgPGE+IGVsZW1lbnRzICh3aGljaCBjaGFuZ2UgdGhlIFVSTCkgbm90IGluc2lkZSB0aGUgY29sbGFwc2libGUgZWxlbWVudFxuICBpZiAoZXZlbnQuY3VycmVudFRhcmdldC50YWdOYW1lID09PSAnQScpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBjb25zdCAkdHJpZ2dlciA9ICQodGhpcylcbiAgY29uc3Qgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcylcbiAgY29uc3Qgc2VsZWN0b3JzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcblxuICAkKHNlbGVjdG9ycykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgJHRhcmdldCA9ICQodGhpcylcbiAgICBjb25zdCBkYXRhICAgID0gJHRhcmdldC5kYXRhKERBVEFfS0VZKVxuICAgIGNvbnN0IGNvbmZpZyAgPSBkYXRhID8gJ3RvZ2dsZScgOiAkdHJpZ2dlci5kYXRhKClcbiAgICBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJHRhcmdldCwgY29uZmlnKVxuICB9KVxufSlcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuJC5mbltOQU1FXSA9IENvbGxhcHNlLl9qUXVlcnlJbnRlcmZhY2VcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBDb2xsYXBzZVxuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbGxhcHNlXG4iLCIvKiohXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiAxLjE0LjdcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmVkZXJpY28gWml2b2xvIGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxudmFyIGxvbmdlclRpbWVvdXRCcm93c2VycyA9IFsnRWRnZScsICdUcmlkZW50JywgJ0ZpcmVmb3gnXTtcbnZhciB0aW1lb3V0RHVyYXRpb24gPSAwO1xuZm9yICh2YXIgaSA9IDA7IGkgPCBsb25nZXJUaW1lb3V0QnJvd3NlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgaWYgKGlzQnJvd3NlciAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YobG9uZ2VyVGltZW91dEJyb3dzZXJzW2ldKSA+PSAwKSB7XG4gICAgdGltZW91dER1cmF0aW9uID0gMTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBtaWNyb3Rhc2tEZWJvdW5jZShmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHdpbmRvdy5Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgZm4oKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0sIHRpbWVvdXREdXJhdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG52YXIgc3VwcG9ydHNNaWNyb1Rhc2tzID0gaXNCcm93c2VyICYmIHdpbmRvdy5Qcm9taXNlO1xuXG4vKipcbiogQ3JlYXRlIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgYSBtZXRob2QsIHRoYXQncyBhc3luY2hyb25vdXNseSBkZWZlcnJlZFxuKiBidXQgY2FsbGVkIGluIHRoZSBtaW5pbXVtIHRpbWUgcG9zc2libGUuXG4qXG4qIEBtZXRob2RcbiogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuKiBAYXJndW1lbnQge0Z1bmN0aW9ufSBmblxuKiBAcmV0dXJucyB7RnVuY3Rpb259XG4qL1xudmFyIGRlYm91bmNlID0gc3VwcG9ydHNNaWNyb1Rhc2tzID8gbWljcm90YXNrRGVib3VuY2UgOiB0YXNrRGVib3VuY2U7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QW55fSBmdW5jdGlvblRvQ2hlY2sgLSB2YXJpYWJsZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0bzogaXMgYSBmdW5jdGlvbj9cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgdmFyIGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgY3NzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gIHJldHVybiBwcm9wZXJ0eSA/IGNzc1twcm9wZXJ0eV0gOiBjc3M7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyZW50Tm9kZSBvciB0aGUgaG9zdCBvZiB0aGUgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2Nyb2xsaW5nIHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gc2Nyb2xsIHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBSZXR1cm4gYm9keSwgYGdldFNjcm9sbGAgd2lsbCB0YWtlIGNhcmUgdG8gZ2V0IHRoZSBjb3JyZWN0IGBzY3JvbGxUb3BgIGZyb20gaXRcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBzd2l0Y2ggKGVsZW1lbnQubm9kZU5hbWUpIHtcbiAgICBjYXNlICdIVE1MJzpcbiAgICBjYXNlICdCT0RZJzpcbiAgICAgIHJldHVybiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuYm9keTtcbiAgfVxuXG4gIC8vIEZpcmVmb3ggd2FudCB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuXG4gIHZhciBfZ2V0U3R5bGVDb21wdXRlZFByb3AgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dZO1xuXG4gIGlmICgvKGF1dG98c2Nyb2xsfG92ZXJsYXkpLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbn1cblxudmFyIGlzSUUxMSA9IGlzQnJvd3NlciAmJiAhISh3aW5kb3cuTVNJbnB1dE1ldGhvZENvbnRleHQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTtcbnZhciBpc0lFMTAgPSBpc0Jyb3dzZXIgJiYgL01TSUUgMTAvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3JlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtOdW1iZXJ9IHZlcnNpb24gdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpc0lFXG4gKi9cbmZ1bmN0aW9uIGlzSUUodmVyc2lvbikge1xuICBpZiAodmVyc2lvbiA9PT0gMTEpIHtcbiAgICByZXR1cm4gaXNJRTExO1xuICB9XG4gIGlmICh2ZXJzaW9uID09PSAxMCkge1xuICAgIHJldHVybiBpc0lFMTA7XG4gIH1cbiAgcmV0dXJuIGlzSUUxMSB8fCBpc0lFMTA7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb2Zmc2V0IHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgdmFyIG5vT2Zmc2V0UGFyZW50ID0gaXNJRSgxMCkgPyBkb2N1bWVudC5ib2R5IDogbnVsbDtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgfHwgbnVsbDtcbiAgLy8gU2tpcCBoaWRkZW4gZWxlbWVudHMgd2hpY2ggZG9uJ3QgaGF2ZSBhbiBvZmZzZXRQYXJlbnRcbiAgd2hpbGUgKG9mZnNldFBhcmVudCA9PT0gbm9PZmZzZXRQYXJlbnQgJiYgZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSAoZWxlbWVudCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKS5vZmZzZXRQYXJlbnQ7XG4gIH1cblxuICB2YXIgbm9kZU5hbWUgPSBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50Lm5vZGVOYW1lO1xuXG4gIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBUSCwgVEQgb3IgVEFCTEUgaW4gY2FzZVxuICAvLyBubyBvZmZzZXRQYXJlbnQgaXMgcHJlc2VudCwgSSBoYXRlIHRoaXMgam9iLi4uXG4gIGlmIChbJ1RIJywgJ1REJywgJ1RBQkxFJ10uaW5kZXhPZihvZmZzZXRQYXJlbnQubm9kZU5hbWUpICE9PSAtMSAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkob2Zmc2V0UGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50O1xufVxuXG5mdW5jdGlvbiBpc09mZnNldENvbnRhaW5lcihlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnSFRNTCcgfHwgZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBlbGVtZW50O1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSByb290IG5vZGUgKGRvY3VtZW50LCBzaGFkb3dET00gcm9vdCkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0VsZW1lbnR9IHJvb3Qgbm9kZVxuICovXG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRSb290KG5vZGUucGFyZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgb2Zmc2V0IHBhcmVudCBjb21tb24gdG8gdGhlIHR3byBwcm92aWRlZCBub2Rlc1xuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MVxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MlxuICogQHJldHVybnMge0VsZW1lbnR9IGNvbW1vbiBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGVsZW1lbnQyKSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQxIHx8ICFlbGVtZW50MS5ub2RlVHlwZSB8fCAhZWxlbWVudDIgfHwgIWVsZW1lbnQyLm5vZGVUeXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIEhlcmUgd2UgbWFrZSBzdXJlIHRvIGdpdmUgYXMgXCJzdGFydFwiIHRoZSBlbGVtZW50IHRoYXQgY29tZXMgZmlyc3QgaW4gdGhlIERPTVxuICB2YXIgb3JkZXIgPSBlbGVtZW50MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50MikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgdmFyIHN0YXJ0ID0gb3JkZXIgPyBlbGVtZW50MSA6IGVsZW1lbnQyO1xuICB2YXIgZW5kID0gb3JkZXIgPyBlbGVtZW50MiA6IGVsZW1lbnQxO1xuXG4gIC8vIEdldCBjb21tb24gYW5jZXN0b3IgY29udGFpbmVyXG4gIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIHJhbmdlLnNldFN0YXJ0KHN0YXJ0LCAwKTtcbiAgcmFuZ2Uuc2V0RW5kKGVuZCwgMCk7XG4gIHZhciBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gIC8vIEJvdGggbm9kZXMgYXJlIGluc2lkZSAjZG9jdW1lbnRcblxuICBpZiAoZWxlbWVudDEgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyICYmIGVsZW1lbnQyICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciB8fCBzdGFydC5jb250YWlucyhlbmQpKSB7XG4gICAgaWYgKGlzT2Zmc2V0Q29udGFpbmVyKGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgcmV0dXJuIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuICB9XG5cbiAgLy8gb25lIG9mIHRoZSBub2RlcyBpcyBpbnNpZGUgc2hhZG93RE9NLCBmaW5kIHdoaWNoIG9uZVxuICB2YXIgZWxlbWVudDFyb290ID0gZ2V0Um9vdChlbGVtZW50MSk7XG4gIGlmIChlbGVtZW50MXJvb3QuaG9zdCkge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxcm9vdC5ob3N0LCBlbGVtZW50Mik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGdldFJvb3QoZWxlbWVudDIpLmhvc3QpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50IGluIHRoZSBnaXZlbiBzaWRlICh0b3AgYW5kIGxlZnQpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzaWRlIGB0b3BgIG9yIGBsZWZ0YFxuICogQHJldHVybnMge251bWJlcn0gYW1vdW50IG9mIHNjcm9sbGVkIHBpeGVsc1xuICovXG5mdW5jdGlvbiBnZXRTY3JvbGwoZWxlbWVudCkge1xuICB2YXIgc2lkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3RvcCc7XG5cbiAgdmFyIHVwcGVyU2lkZSA9IHNpZGUgPT09ICd0b3AnID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCc7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGh0bWw7XG4gICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnRbdXBwZXJTaWRlXTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50W3VwcGVyU2lkZV07XG59XG5cbi8qXG4gKiBTdW0gb3Igc3VidHJhY3QgdGhlIGVsZW1lbnQgc2Nyb2xsIHZhbHVlcyAobGVmdCBhbmQgdG9wKSBmcm9tIGEgZ2l2ZW4gcmVjdCBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IC0gUmVjdCBvYmplY3QgeW91IHdhbnQgdG8gY2hhbmdlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgZnJvbSB0aGUgZnVuY3Rpb24gcmVhZHMgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VidHJhY3QgLSBzZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBzdWJ0cmFjdCB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHJldHVybiB7T2JqZWN0fSByZWN0IC0gVGhlIG1vZGlmaWVyIHJlY3Qgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVTY3JvbGwocmVjdCwgZWxlbWVudCkge1xuICB2YXIgc3VidHJhY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICB2YXIgbW9kaWZpZXIgPSBzdWJ0cmFjdCA/IC0xIDogMTtcbiAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbi8qXG4gKiBIZWxwZXIgdG8gZGV0ZWN0IGJvcmRlcnMgb2YgYSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xuICogUmVzdWx0IG9mIGBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHlgIG9uIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gYXhpcyAtIGB4YCBvciBgeWBcbiAqIEByZXR1cm4ge251bWJlcn0gYm9yZGVycyAtIFRoZSBib3JkZXJzIHNpemUgb2YgdGhlIGdpdmVuIGF4aXNcbiAqL1xuXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsIGF4aXMpIHtcbiAgdmFyIHNpZGVBID0gYXhpcyA9PT0gJ3gnID8gJ0xlZnQnIDogJ1RvcCc7XG4gIHZhciBzaWRlQiA9IHNpZGVBID09PSAnTGVmdCcgPyAnUmlnaHQnIDogJ0JvdHRvbSc7XG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUEgKyAnV2lkdGgnXSwgMTApICsgcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQiArICdXaWR0aCddLCAxMCk7XG59XG5cbmZ1bmN0aW9uIGdldFNpemUoYXhpcywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSkge1xuICByZXR1cm4gTWF0aC5tYXgoYm9keVsnb2Zmc2V0JyArIGF4aXNdLCBib2R5WydzY3JvbGwnICsgYXhpc10sIGh0bWxbJ2NsaWVudCcgKyBheGlzXSwgaHRtbFsnb2Zmc2V0JyArIGF4aXNdLCBodG1sWydzY3JvbGwnICsgYXhpc10sIGlzSUUoMTApID8gcGFyc2VJbnQoaHRtbFsnb2Zmc2V0JyArIGF4aXNdKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnVG9wJyA6ICdMZWZ0JyldKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCcpXSkgOiAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2l6ZXMoZG9jdW1lbnQpIHtcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICB2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBpc0lFKDEwKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKVxuICB9O1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG9mZnNldHMsIHtcbiAgICByaWdodDogb2Zmc2V0cy5sZWZ0ICsgb2Zmc2V0cy53aWR0aCxcbiAgICBib3R0b206IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHRcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gY2xpZW50IHJlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSB7fTtcblxuICAvLyBJRTEwIDEwIEZJWDogUGxlYXNlLCBkb24ndCBhc2ssIHRoZSBlbGVtZW50IGlzbid0XG4gIC8vIGNvbnNpZGVyZWQgaW4gRE9NIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4uLlxuICAvLyBUaGlzIGlzbid0IHJlcHJvZHVjaWJsZSBpbiBJRTEwIGNvbXBhdGliaWxpdHkgbW9kZSBvZiBJRTExXG4gIHRyeSB7XG4gICAgaWYgKGlzSUUoMTApKSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgICAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICB3aWR0aDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgfTtcblxuICAvLyBzdWJ0cmFjdCBzY3JvbGxiYXIgc2l6ZSBmcm9tIHNpemVzXG4gIHZhciBzaXplcyA9IGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJyA/IGdldFdpbmRvd1NpemVzKGVsZW1lbnQub3duZXJEb2N1bWVudCkgOiB7fTtcbiAgdmFyIHdpZHRoID0gc2l6ZXMud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCB8fCByZXN1bHQucmlnaHQgLSByZXN1bHQubGVmdDtcbiAgdmFyIGhlaWdodCA9IHNpemVzLmhlaWdodCB8fCBlbGVtZW50LmNsaWVudEhlaWdodCB8fCByZXN1bHQuYm90dG9tIC0gcmVzdWx0LnRvcDtcblxuICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gIHZhciB2ZXJ0U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgLy8gaWYgYW4gaHlwb3RoZXRpY2FsIHNjcm9sbGJhciBpcyBkZXRlY3RlZCwgd2UgbXVzdCBiZSBzdXJlIGl0J3Mgbm90IGEgYGJvcmRlcmBcbiAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICBob3JpelNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd4Jyk7XG4gICAgdmVydFNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd5Jyk7XG5cbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICB9XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3QocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBpc0lFMTAgPSBpc0lFKDEwKTtcbiAgdmFyIGlzSFRNTCA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChjaGlsZHJlbik7XG5cbiAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICB2YXIgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCwgMTApO1xuICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG5cbiAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIHBhcmVudCBpcyBmaXhlZCwgd2UgbXVzdCBpZ25vcmUgbmVnYXRpdmUgc2Nyb2xsIGluIG9mZnNldCBjYWxjXG4gIGlmIChmaXhlZFBvc2l0aW9uICYmIGlzSFRNTCkge1xuICAgIHBhcmVudFJlY3QudG9wID0gTWF0aC5tYXgocGFyZW50UmVjdC50b3AsIDApO1xuICAgIHBhcmVudFJlY3QubGVmdCA9IE1hdGgubWF4KHBhcmVudFJlY3QubGVmdCwgMCk7XG4gIH1cbiAgdmFyIG9mZnNldHMgPSBnZXRDbGllbnRSZWN0KHtcbiAgICB0b3A6IGNoaWxkcmVuUmVjdC50b3AgLSBwYXJlbnRSZWN0LnRvcCAtIGJvcmRlclRvcFdpZHRoLFxuICAgIGxlZnQ6IGNoaWxkcmVuUmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0IC0gYm9yZGVyTGVmdFdpZHRoLFxuICAgIHdpZHRoOiBjaGlsZHJlblJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBjaGlsZHJlblJlY3QuaGVpZ2h0XG4gIH0pO1xuICBvZmZzZXRzLm1hcmdpblRvcCA9IDA7XG4gIG9mZnNldHMubWFyZ2luTGVmdCA9IDA7XG5cbiAgLy8gU3VidHJhY3QgbWFyZ2lucyBvZiBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBpdCdzIGJlaW5nIHVzZWQgYXMgcGFyZW50XG4gIC8vIHdlIGRvIHRoaXMgb25seSBvbiBIVE1MIGJlY2F1c2UgaXQncyB0aGUgb25seSBlbGVtZW50IHRoYXQgYmVoYXZlc1xuICAvLyBkaWZmZXJlbnRseSB3aGVuIG1hcmdpbnMgYXJlIGFwcGxpZWQgdG8gaXQuIFRoZSBtYXJnaW5zIGFyZSBpbmNsdWRlZCBpblxuICAvLyB0aGUgYm94IG9mIHRoZSBkb2N1bWVudEVsZW1lbnQsIGluIHRoZSBvdGhlciBjYXNlcyBub3QuXG4gIGlmICghaXNJRTEwICYmIGlzSFRNTCkge1xuICAgIHZhciBtYXJnaW5Ub3AgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3AsIDEwKTtcbiAgICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQsIDEwKTtcblxuICAgIG9mZnNldHMudG9wIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMuYm90dG9tIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubGVmdCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuICAgIG9mZnNldHMucmlnaHQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcblxuICAgIC8vIEF0dGFjaCBtYXJnaW5Ub3AgYW5kIG1hcmdpbkxlZnQgYmVjYXVzZSBpbiBzb21lIGNpcmN1bXN0YW5jZXMgd2UgbWF5IG5lZWQgdGhlbVxuICAgIG9mZnNldHMubWFyZ2luVG9wID0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubWFyZ2luTGVmdCA9IG1hcmdpbkxlZnQ7XG4gIH1cblxuICBpZiAoaXNJRTEwICYmICFmaXhlZFBvc2l0aW9uID8gcGFyZW50LmNvbnRhaW5zKHNjcm9sbFBhcmVudCkgOiBwYXJlbnQgPT09IHNjcm9sbFBhcmVudCAmJiBzY3JvbGxQYXJlbnQubm9kZU5hbWUgIT09ICdCT0RZJykge1xuICAgIG9mZnNldHMgPSBpbmNsdWRlU2Nyb2xsKG9mZnNldHMsIHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKGVsZW1lbnQpIHtcbiAgdmFyIGV4Y2x1ZGVTY3JvbGwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGVsZW1lbnQsIGh0bWwpO1xuICB2YXIgd2lkdGggPSBNYXRoLm1heChodG1sLmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgdmFyIGhlaWdodCA9IE1hdGgubWF4KGh0bWwuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG5cbiAgdmFyIHNjcm9sbFRvcCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwpIDogMDtcbiAgdmFyIHNjcm9sbExlZnQgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sLCAnbGVmdCcpIDogMDtcblxuICB2YXIgb2Zmc2V0ID0ge1xuICAgIHRvcDogc2Nyb2xsVG9wIC0gcmVsYXRpdmVPZmZzZXQudG9wICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luVG9wLFxuICAgIGxlZnQ6IHNjcm9sbExlZnQgLSByZWxhdGl2ZU9mZnNldC5sZWZ0ICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luTGVmdCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChvZmZzZXQpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGZpeGVkIG9yIGlzIGluc2lkZSBhIGZpeGVkIHBhcmVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGN1c3RvbUNvbnRhaW5lclxuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0byBcImlzRml4ZWQ/XCJcbiAqL1xuZnVuY3Rpb24gaXNGaXhlZChlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkKHBhcmVudE5vZGUpO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBwYXJlbnQgb2YgYW4gZWxlbWVudCB0aGF0IGhhcyBhIHRyYW5zZm9ybWVkIHByb3BlcnR5IGRlZmluZWRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IGZpcnN0IHRyYW5zZm9ybWVkIHBhcmVudCBvciBkb2N1bWVudEVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5wYXJlbnRFbGVtZW50IHx8IGlzSUUoKSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cbiAgdmFyIGVsID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICB3aGlsZSAoZWwgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsLCAndHJhbnNmb3JtJykgPT09ICdub25lJykge1xuICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWwgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xufVxuXG4vKipcbiAqIENvbXB1dGVkIHRoZSBib3VuZGFyaWVzIGxpbWl0cyBhbmQgcmV0dXJuIHRoZW1cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZ1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQgLSBFbGVtZW50IHVzZWQgdG8gZGVmaW5lIHRoZSBib3VuZGFyaWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZpeGVkUG9zaXRpb24gLSBJcyBpbiBmaXhlZCBwb3NpdGlvbiBtb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgYm91bmRhcmllc1xuICovXG5mdW5jdGlvbiBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcblxuICB2YXIgYm91bmRhcmllcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIHJlZmVyZW5jZSk7XG5cbiAgLy8gSGFuZGxlIHZpZXdwb3J0IGNhc2VcbiAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgYm91bmRhcmllcyA9IGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIEhhbmRsZSBvdGhlciBjYXNlcyBiYXNlZCBvbiBET00gZWxlbWVudCB1c2VkIGFzIGJvdW5kYXJpZXNcbiAgICB2YXIgYm91bmRhcmllc05vZGUgPSB2b2lkIDA7XG4gICAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnc2Nyb2xsUGFyZW50Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShyZWZlcmVuY2UpKTtcbiAgICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd3aW5kb3cnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBib3VuZGFyaWVzRWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0cyA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShib3VuZGFyaWVzTm9kZSwgb2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcblxuICAgIC8vIEluIGNhc2Ugb2YgSFRNTCwgd2UgbmVlZCBhIGRpZmZlcmVudCBjb21wdXRhdGlvblxuICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnICYmICFpc0ZpeGVkKG9mZnNldFBhcmVudCkpIHtcbiAgICAgIHZhciBfZ2V0V2luZG93U2l6ZXMgPSBnZXRXaW5kb3dTaXplcyhwb3BwZXIub3duZXJEb2N1bWVudCksXG4gICAgICAgICAgaGVpZ2h0ID0gX2dldFdpbmRvd1NpemVzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRXaW5kb3dTaXplcy53aWR0aDtcblxuICAgICAgYm91bmRhcmllcy50b3AgKz0gb2Zmc2V0cy50b3AgLSBvZmZzZXRzLm1hcmdpblRvcDtcbiAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gaGVpZ2h0ICsgb2Zmc2V0cy50b3A7XG4gICAgICBib3VuZGFyaWVzLmxlZnQgKz0gb2Zmc2V0cy5sZWZ0IC0gb2Zmc2V0cy5tYXJnaW5MZWZ0O1xuICAgICAgYm91bmRhcmllcy5yaWdodCA9IHdpZHRoICsgb2Zmc2V0cy5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgYWxsIHRoZSBvdGhlciBET00gZWxlbWVudHMsIHRoaXMgb25lIGlzIGdvb2RcbiAgICAgIGJvdW5kYXJpZXMgPSBvZmZzZXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nc1xuICBwYWRkaW5nID0gcGFkZGluZyB8fCAwO1xuICB2YXIgaXNQYWRkaW5nTnVtYmVyID0gdHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInO1xuICBib3VuZGFyaWVzLmxlZnQgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcubGVmdCB8fCAwO1xuICBib3VuZGFyaWVzLnRvcCArPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy50b3AgfHwgMDtcbiAgYm91bmRhcmllcy5yaWdodCAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5yaWdodCB8fCAwO1xuICBib3VuZGFyaWVzLmJvdHRvbSAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5ib3R0b20gfHwgMDtcblxuICByZXR1cm4gYm91bmRhcmllcztcbn1cblxuZnVuY3Rpb24gZ2V0QXJlYShfcmVmKSB7XG4gIHZhciB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodDtcblxuICByZXR1cm4gd2lkdGggKiBoZWlnaHQ7XG59XG5cbi8qKlxuICogVXRpbGl0eSB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgYGF1dG9gIHBsYWNlbWVudCB0byB0aGUgcGxhY2VtZW50IHdpdGggbW9yZVxuICogYXZhaWxhYmxlIHNwYWNlLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQocGxhY2VtZW50LCByZWZSZWN0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDA7XG5cbiAgaWYgKHBsYWNlbWVudC5pbmRleE9mKCdhdXRvJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpO1xuXG4gIHZhciByZWN0cyA9IHtcbiAgICB0b3A6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWZSZWN0LnRvcCAtIGJvdW5kYXJpZXMudG9wXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMucmlnaHQgLSByZWZSZWN0LnJpZ2h0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5ib3R0b20gLSByZWZSZWN0LmJvdHRvbVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgd2lkdGg6IHJlZlJlY3QubGVmdCAtIGJvdW5kYXJpZXMubGVmdCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNvcnRlZEFyZWFzID0gT2JqZWN0LmtleXMocmVjdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleToga2V5XG4gICAgfSwgcmVjdHNba2V5XSwge1xuICAgICAgYXJlYTogZ2V0QXJlYShyZWN0c1trZXldKVxuICAgIH0pO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuYXJlYSAtIGEuYXJlYTtcbiAgfSk7XG5cbiAgdmFyIGZpbHRlcmVkQXJlYXMgPSBzb3J0ZWRBcmVhcy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodDtcbiAgICByZXR1cm4gd2lkdGggPj0gcG9wcGVyLmNsaWVudFdpZHRoICYmIGhlaWdodCA+PSBwb3BwZXIuY2xpZW50SGVpZ2h0O1xuICB9KTtcblxuICB2YXIgY29tcHV0ZWRQbGFjZW1lbnQgPSBmaWx0ZXJlZEFyZWFzLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZEFyZWFzWzBdLmtleSA6IHNvcnRlZEFyZWFzWzBdLmtleTtcblxuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgcmV0dXJuIGNvbXB1dGVkUGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7RWxlbWVudH0gZml4ZWRQb3NpdGlvbiAtIGlzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlKSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHZhciBjb21tb25PZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIHJlZmVyZW5jZSk7XG4gIHJldHVybiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUocmVmZXJlbmNlLCBjb21tb25PZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3V0ZXIgc2l6ZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnQgKG9mZnNldCBzaXplICsgbWFyZ2lucylcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVyU2l6ZXMoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHZhciB4ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wIHx8IDApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luQm90dG9tIHx8IDApO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5SaWdodCB8fCAwKTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCArIHksXG4gICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCArIHhcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudFxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgdmFyIGhhc2ggPSB7IGxlZnQ6ICdyaWdodCcsIHJpZ2h0OiAnbGVmdCcsIGJvdHRvbTogJ3RvcCcsIHRvcDogJ2JvdHRvbScgfTtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0gQ1NTIHBvc2l0aW9uIHRoZSBQb3BwZXIgd2lsbCBnZXQgYXBwbGllZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0cyAtIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhY2VtZW50IC0gb25lIG9mIHRoZSB2YWxpZCBwbGFjZW1lbnQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gcG9wcGVyT2Zmc2V0cyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFBvcHBlck9mZnNldHMocG9wcGVyLCByZWZlcmVuY2VPZmZzZXRzLCBwbGFjZW1lbnQpIHtcbiAgcGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgLy8gR2V0IHBvcHBlciBub2RlIHNpemVzXG4gIHZhciBwb3BwZXJSZWN0ID0gZ2V0T3V0ZXJTaXplcyhwb3BwZXIpO1xuXG4gIC8vIEFkZCBwb3NpdGlvbiwgd2lkdGggYW5kIGhlaWdodCB0byBvdXIgb2Zmc2V0cyBvYmplY3RcbiAgdmFyIHBvcHBlck9mZnNldHMgPSB7XG4gICAgd2lkdGg6IHBvcHBlclJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBwb3BwZXJSZWN0LmhlaWdodFxuICB9O1xuXG4gIC8vIGRlcGVuZGluZyBieSB0aGUgcG9wcGVyIHBsYWNlbWVudCB3ZSBoYXZlIHRvIGNvbXB1dGUgaXRzIG9mZnNldHMgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgdmFyIGlzSG9yaXogPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgbWFpblNpZGUgPSBpc0hvcml6ID8gJ3RvcCcgOiAnbGVmdCc7XG4gIHZhciBzZWNvbmRhcnlTaWRlID0gaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2Vjb25kYXJ5TWVhc3VyZW1lbnQgPSAhaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBwb3BwZXJPZmZzZXRzW21haW5TaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbbWFpblNpZGVdICsgcmVmZXJlbmNlT2Zmc2V0c1ttZWFzdXJlbWVudF0gLyAyIC0gcG9wcGVyUmVjdFttZWFzdXJlbWVudF0gLyAyO1xuICBpZiAocGxhY2VtZW50ID09PSBzZWNvbmRhcnlTaWRlKSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gLSBwb3BwZXJSZWN0W3NlY29uZGFyeU1lYXN1cmVtZW50XTtcbiAgfSBlbHNlIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tnZXRPcHBvc2l0ZVBsYWNlbWVudChzZWNvbmRhcnlTaWRlKV07XG4gIH1cblxuICByZXR1cm4gcG9wcGVyT2Zmc2V0cztcbn1cblxuLyoqXG4gKiBNaW1pY3MgdGhlIGBmaW5kYCBtZXRob2Qgb2YgQXJyYXlcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZChhcnIsIGNoZWNrKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgcmV0dXJuIGFyci5maW5kKGNoZWNrKTtcbiAgfVxuXG4gIC8vIHVzZSBgZmlsdGVyYCB0byBvYnRhaW4gdGhlIHNhbWUgYmVoYXZpb3Igb2YgYGZpbmRgXG4gIHJldHVybiBhcnIuZmlsdGVyKGNoZWNrKVswXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBtYXRjaGluZyBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFyciwgcHJvcCwgdmFsdWUpIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kSW5kZXggaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoZnVuY3Rpb24gKGN1cikge1xuICAgICAgcmV0dXJuIGN1cltwcm9wXSA9PT0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvLyB1c2UgYGZpbmRgICsgYGluZGV4T2ZgIGlmIGBmaW5kSW5kZXhgIGlzbid0IHN1cHBvcnRlZFxuICB2YXIgbWF0Y2ggPSBmaW5kKGFyciwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmpbcHJvcF0gPT09IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGFyci5pbmRleE9mKG1hdGNoKTtcbn1cblxuLyoqXG4gKiBMb29wIHRyb3VnaCB0aGUgbGlzdCBvZiBtb2RpZmllcnMgYW5kIHJ1biB0aGVtIGluIG9yZGVyLFxuICogZWFjaCBvZiB0aGVtIHdpbGwgdGhlbiBlZGl0IHRoZSBkYXRhIG9iamVjdC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5kcyAtIE9wdGlvbmFsIG1vZGlmaWVyIG5hbWUgdXNlZCBhcyBzdG9wcGVyXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH1cbiAqL1xuZnVuY3Rpb24gcnVuTW9kaWZpZXJzKG1vZGlmaWVycywgZGF0YSwgZW5kcykge1xuICB2YXIgbW9kaWZpZXJzVG9SdW4gPSBlbmRzID09PSB1bmRlZmluZWQgPyBtb2RpZmllcnMgOiBtb2RpZmllcnMuc2xpY2UoMCwgZmluZEluZGV4KG1vZGlmaWVycywgJ25hbWUnLCBlbmRzKSk7XG5cbiAgbW9kaWZpZXJzVG9SdW4uZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAobW9kaWZpZXJbJ2Z1bmN0aW9uJ10pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICBjb25zb2xlLndhcm4oJ2Btb2RpZmllci5mdW5jdGlvbmAgaXMgZGVwcmVjYXRlZCwgdXNlIGBtb2RpZmllci5mbmAhJyk7XG4gICAgfVxuICAgIHZhciBmbiA9IG1vZGlmaWVyWydmdW5jdGlvbiddIHx8IG1vZGlmaWVyLmZuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIGlmIChtb2RpZmllci5lbmFibGVkICYmIGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgICAvLyBBZGQgcHJvcGVydGllcyB0byBvZmZzZXRzIHRvIG1ha2UgdGhlbSBhIGNvbXBsZXRlIGNsaWVudFJlY3Qgb2JqZWN0XG4gICAgICAvLyB3ZSBkbyB0aGlzIGJlZm9yZSBlYWNoIG1vZGlmaWVyIHRvIG1ha2Ugc3VyZSB0aGUgcHJldmlvdXMgb25lIGRvZXNuJ3RcbiAgICAgIC8vIG1lc3Mgd2l0aCB0aGVzZSB2YWx1ZXNcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuICAgICAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSk7XG5cbiAgICAgIGRhdGEgPSBmbihkYXRhLCBtb2RpZmllcik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyLCBjb21wdXRpbmcgdGhlIG5ldyBvZmZzZXRzIGFuZCBhcHBseWluZ1xuICogdGhlIG5ldyBzdHlsZS48YnIgLz5cbiAqIFByZWZlciBgc2NoZWR1bGVVcGRhdGVgIG92ZXIgYHVwZGF0ZWAgYmVjYXVzZSBvZiBwZXJmb3JtYW5jZSByZWFzb25zLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiB1cGRhdGUoKSB7XG4gIC8vIGlmIHBvcHBlciBpcyBkZXN0cm95ZWQsIGRvbid0IHBlcmZvcm0gYW55IGZ1cnRoZXIgdXBkYXRlXG4gIGlmICh0aGlzLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRhdGEgPSB7XG4gICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgc3R5bGVzOiB7fSxcbiAgICBhcnJvd1N0eWxlczoge30sXG4gICAgYXR0cmlidXRlczoge30sXG4gICAgZmxpcHBlZDogZmFsc2UsXG4gICAgb2Zmc2V0czoge31cbiAgfTtcblxuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZU9mZnNldHModGhpcy5zdGF0ZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIGRhdGEucGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQodGhpcy5vcHRpb25zLnBsYWNlbWVudCwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICAvLyBzdG9yZSB0aGUgY29tcHV0ZWQgcGxhY2VtZW50IGluc2lkZSBgb3JpZ2luYWxQbGFjZW1lbnRgXG4gIGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcblxuICBkYXRhLnBvc2l0aW9uRml4ZWQgPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZDtcblxuICAvLyBjb21wdXRlIHRoZSBwb3BwZXIgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0UG9wcGVyT2Zmc2V0cyh0aGlzLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIucG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnO1xuXG4gIC8vIHJ1biB0aGUgbW9kaWZpZXJzXG4gIGRhdGEgPSBydW5Nb2RpZmllcnModGhpcy5tb2RpZmllcnMsIGRhdGEpO1xuXG4gIC8vIHRoZSBmaXJzdCBgdXBkYXRlYCB3aWxsIGNhbGwgYG9uQ3JlYXRlYCBjYWxsYmFja1xuICAvLyB0aGUgb3RoZXIgb25lcyB3aWxsIGNhbGwgYG9uVXBkYXRlYCBjYWxsYmFja1xuICBpZiAoIXRoaXMuc3RhdGUuaXNDcmVhdGVkKSB7XG4gICAgdGhpcy5zdGF0ZS5pc0NyZWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy5vbkNyZWF0ZShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUoZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBpcyBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJFbmFibGVkKG1vZGlmaWVycywgbW9kaWZpZXJOYW1lKSB7XG4gIHJldHVybiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICBlbmFibGVkID0gX3JlZi5lbmFibGVkO1xuICAgIHJldHVybiBlbmFibGVkICYmIG5hbWUgPT09IG1vZGlmaWVyTmFtZTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmVmaXhlZCBzdXBwb3J0ZWQgcHJvcGVydHkgbmFtZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5IChjYW1lbENhc2UpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBwcmVmaXhlZCBwcm9wZXJ0eSAoY2FtZWxDYXNlIG9yIFBhc2NhbENhc2UsIGRlcGVuZGluZyBvbiB0aGUgdmVuZG9yIHByZWZpeClcbiAqL1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKHByb3BlcnR5KSB7XG4gIHZhciBwcmVmaXhlcyA9IFtmYWxzZSwgJ21zJywgJ1dlYmtpdCcsICdNb3onLCAnTyddO1xuICB2YXIgdXBwZXJQcm9wID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgIHZhciB0b0NoZWNrID0gcHJlZml4ID8gJycgKyBwcmVmaXggKyB1cHBlclByb3AgOiBwcm9wZXJ0eTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGVbdG9DaGVja10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdG9DaGVjaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIHBvcHBlci5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXR5IGFza2VkIGZvciB0aGUgZGVsZXRpb24gb24gZGVzdHJveVxuICAvLyBkbyBub3QgdXNlIGByZW1vdmVgIGJlY2F1c2UgSUUxMSBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICB0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge1dpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KGVsZW1lbnQpIHtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvdztcbn1cblxuZnVuY3Rpb24gYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbFBhcmVudCwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKSB7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IHNjcm9sbFBhcmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogc2Nyb2xsUGFyZW50O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICBpZiAoIWlzQm9keSkge1xuICAgIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhnZXRTY3JvbGxQYXJlbnQodGFyZ2V0LnBhcmVudE5vZGUpLCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpO1xuICB9XG4gIHNjcm9sbFBhcmVudHMucHVzaCh0YXJnZXQpO1xufVxuXG4vKipcbiAqIFNldHVwIG5lZWRlZCBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIG9wdGlvbnMsIHN0YXRlLCB1cGRhdGVCb3VuZCkge1xuICAvLyBSZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gdXBkYXRlQm91bmQ7XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgLy8gU2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHZhciBzY3JvbGxFbGVtZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHJlZmVyZW5jZSk7XG4gIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxFbGVtZW50LCAnc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQsIHN0YXRlLnNjcm9sbFBhcmVudHMpO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgYWRkIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCBzdGFydCByZWNhbGN1bGF0aW5nXG4gKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAoIXRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcblxuICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHN0YXRlLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgc3RhdGVcbiAgc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gZmFsc2U7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gKiB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC4gSXQgYWxzbyB3b24ndCB0cmlnZ2VyIGBvblVwZGF0ZWAgY2FsbGJhY2sgYW55bW9yZSxcbiAqIHVubGVzcyB5b3UgY2FsbCBgdXBkYXRlYCBtZXRob2QgbWFudWFsbHkuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICAgIHRoaXMuc3RhdGUgPSByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5zdGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUZWxscyBpZiBhIGdpdmVuIGlucHV0IGlzIGEgbnVtYmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0geyp9IGlucHV0IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gbiAhPT0gJycgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgc3R5bGUgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgc3R5bGUgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldFN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHVuaXQgPSAnJztcbiAgICAvLyBhZGQgdW5pdCBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpYyBhbmQgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmdcbiAgICBpZiAoWyd3aWR0aCcsICdoZWlnaHQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uaW5kZXhPZihwcm9wKSAhPT0gLTEgJiYgaXNOdW1lcmljKHN0eWxlc1twcm9wXSkpIHtcbiAgICAgIHVuaXQgPSAncHgnO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdICsgdW5pdDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBhdHRyaWJ1dGVzIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZXMgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLnN0eWxlcyAtIExpc3Qgb2Ygc3R5bGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuYXR0cmlidXRlcyAtIExpc3Qgb2YgYXR0cmlidXRlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzYW1lIGRhdGEgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoZGF0YSkge1xuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5zdHlsZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyBpbiB0aGlzIHdheSB3ZSBjYW4gbWFrZSB0aGUgM3JkIHBhcnR5IG1vZGlmaWVycyBhZGQgY3VzdG9tIHN0eWxlcyB0byBpdFxuICAvLyBCZSBhd2FyZSwgbW9kaWZpZXJzIGNvdWxkIG92ZXJyaWRlIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhlIHByZXZpb3VzXG4gIC8vIGxpbmVzIG9mIHRoaXMgbW9kaWZpZXIhXG4gIHNldFN0eWxlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5zdHlsZXMpO1xuXG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLmF0dHJpYnV0ZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyB0aGV5IHdpbGwgYmUgc2V0IGFzIEhUTUwgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICBzZXRBdHRyaWJ1dGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBkZWZpbmVkIGFuZCBhcnJvd1N0eWxlcyBoYXMgc29tZSBwcm9wZXJ0aWVzXG4gIGlmIChkYXRhLmFycm93RWxlbWVudCAmJiBPYmplY3Qua2V5cyhkYXRhLmFycm93U3R5bGVzKS5sZW5ndGgpIHtcbiAgICBzZXRTdHlsZXMoZGF0YS5hcnJvd0VsZW1lbnQsIGRhdGEuYXJyb3dTdHlsZXMpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogU2V0IHRoZSB4LXBsYWNlbWVudCBhdHRyaWJ1dGUgYmVmb3JlIGV2ZXJ5dGhpbmcgZWxzZSBiZWNhdXNlIGl0IGNvdWxkIGJlIHVzZWRcbiAqIHRvIGFkZCBtYXJnaW5zIHRvIHRoZSBwb3BwZXIgbWFyZ2lucyBuZWVkcyB0byBiZSBjYWxjdWxhdGVkIHRvIGdldCB0aGVcbiAqIGNvcnJlY3QgcG9wcGVyIG9mZnNldHMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLm1vZGlmaWVyc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgZWxlbWVudCB1c2VkIGFzIHBvcHBlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBQb3BwZXIuanMgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlT25Mb2FkKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIHN0YXRlKSB7XG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICB2YXIgcmVmZXJlbmNlT2Zmc2V0cyA9IGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICB2YXIgcGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQob3B0aW9ucy5wbGFjZW1lbnQsIHJlZmVyZW5jZU9mZnNldHMsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JywgcGxhY2VtZW50KTtcblxuICAvLyBBcHBseSBgcG9zaXRpb25gIHRvIHBvcHBlciBiZWZvcmUgYW55dGhpbmcgZWxzZSBiZWNhdXNlXG4gIC8vIHdpdGhvdXQgdGhlIHBvc2l0aW9uIGFwcGxpZWQgd2UgY2FuJ3QgZ3VhcmFudGVlIGNvcnJlY3QgY29tcHV0YXRpb25zXG4gIHNldFN0eWxlcyhwb3BwZXIsIHsgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnIH0pO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtCb29sZWFufSBzaG91bGRSb3VuZCAtIElmIHRoZSBvZmZzZXRzIHNob3VsZCBiZSByb3VuZGVkIGF0IGFsbFxuICogQHJldHVybnMge09iamVjdH0gVGhlIHBvcHBlcidzIHBvc2l0aW9uIG9mZnNldHMgcm91bmRlZFxuICpcbiAqIFRoZSB0YWxlIG9mIHBpeGVsLXBlcmZlY3QgcG9zaXRpb25pbmcuIEl0J3Mgc3RpbGwgbm90IDEwMCUgcGVyZmVjdCwgYnV0IGFzXG4gKiBnb29kIGFzIGl0IGNhbiBiZSB3aXRoaW4gcmVhc29uLlxuICogRGlzY3Vzc2lvbiBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9wdWxsLzcxNVxuICpcbiAqIExvdyBEUEkgc2NyZWVucyBjYXVzZSBhIHBvcHBlciB0byBiZSBibHVycnkgaWYgbm90IHVzaW5nIGZ1bGwgcGl4ZWxzIChTYWZhcmlcbiAqIGFzIHdlbGwgb24gSGlnaCBEUEkgc2NyZWVucykuXG4gKlxuICogRmlyZWZveCBwcmVmZXJzIG5vIHJvdW5kaW5nIGZvciBwb3NpdGlvbmluZyBhbmQgZG9lcyBub3QgaGF2ZSBibHVycmluZXNzIG9uXG4gKiBoaWdoIERQSSBzY3JlZW5zLlxuICpcbiAqIE9ubHkgaG9yaXpvbnRhbCBwbGFjZW1lbnQgYW5kIGxlZnQvcmlnaHQgdmFsdWVzIG5lZWQgdG8gYmUgY29uc2lkZXJlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0Um91bmRlZE9mZnNldHMoZGF0YSwgc2hvdWxkUm91bmQpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgICAgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4gIHZhciBub1JvdW5kID0gZnVuY3Rpb24gbm9Sb3VuZCh2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgdmFyIHJlZmVyZW5jZVdpZHRoID0gcm91bmQocmVmZXJlbmNlLndpZHRoKTtcbiAgdmFyIHBvcHBlcldpZHRoID0gcm91bmQocG9wcGVyLndpZHRoKTtcblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZGF0YS5wbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIGlzVmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuaW5kZXhPZignLScpICE9PSAtMTtcbiAgdmFyIHNhbWVXaWR0aFBhcml0eSA9IHJlZmVyZW5jZVdpZHRoICUgMiA9PT0gcG9wcGVyV2lkdGggJSAyO1xuICB2YXIgYm90aE9kZFdpZHRoID0gcmVmZXJlbmNlV2lkdGggJSAyID09PSAxICYmIHBvcHBlcldpZHRoICUgMiA9PT0gMTtcblxuICB2YXIgaG9yaXpvbnRhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiBpc1ZlcnRpY2FsIHx8IGlzVmFyaWF0aW9uIHx8IHNhbWVXaWR0aFBhcml0eSA/IHJvdW5kIDogZmxvb3I7XG4gIHZhciB2ZXJ0aWNhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiByb3VuZDtcblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IGhvcml6b250YWxUb0ludGVnZXIoYm90aE9kZFdpZHRoICYmICFpc1ZhcmlhdGlvbiAmJiBzaG91bGRSb3VuZCA/IHBvcHBlci5sZWZ0IC0gMSA6IHBvcHBlci5sZWZ0KSxcbiAgICB0b3A6IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci50b3ApLFxuICAgIGJvdHRvbTogdmVydGljYWxUb0ludGVnZXIocG9wcGVyLmJvdHRvbSksXG4gICAgcmlnaHQ6IGhvcml6b250YWxUb0ludGVnZXIocG9wcGVyLnJpZ2h0KVxuICB9O1xufVxuXG52YXIgaXNGaXJlZm94ID0gaXNCcm93c2VyICYmIC9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVN0eWxlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIHggPSBvcHRpb25zLngsXG4gICAgICB5ID0gb3B0aW9ucy55O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICAvLyBSZW1vdmUgdGhpcyBsZWdhY3kgc3VwcG9ydCBpbiBQb3BwZXIuanMgdjJcblxuICB2YXIgbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdhcHBseVN0eWxlJztcbiAgfSkuZ3B1QWNjZWxlcmF0aW9uO1xuICBpZiAobGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBncHVBY2NlbGVyYXRpb25gIG9wdGlvbiBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllciBhbmQgd2lsbCBub3QgYmUgc3VwcG9ydGVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBQb3BwZXIuanMhJyk7XG4gIH1cbiAgdmFyIGdwdUFjY2VsZXJhdGlvbiA9IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkID8gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIDogb3B0aW9ucy5ncHVBY2NlbGVyYXRpb247XG5cbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBvZmZzZXRQYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG5cbiAgLy8gU3R5bGVzXG4gIHZhciBzdHlsZXMgPSB7XG4gICAgcG9zaXRpb246IHBvcHBlci5wb3NpdGlvblxuICB9O1xuXG4gIHZhciBvZmZzZXRzID0gZ2V0Um91bmRlZE9mZnNldHMoZGF0YSwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPCAyIHx8ICFpc0ZpcmVmb3gpO1xuXG4gIHZhciBzaWRlQSA9IHggPT09ICdib3R0b20nID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgdmFyIHNpZGVCID0geSA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cbiAgLy8gaWYgZ3B1QWNjZWxlcmF0aW9uIGlzIHNldCB0byBgdHJ1ZWAgYW5kIHRyYW5zZm9ybSBpcyBzdXBwb3J0ZWQsXG4gIC8vICB3ZSB1c2UgYHRyYW5zbGF0ZTNkYCB0byBhcHBseSB0aGUgcG9zaXRpb24gdG8gdGhlIHBvcHBlciB3ZVxuICAvLyBhdXRvbWF0aWNhbGx5IHVzZSB0aGUgc3VwcG9ydGVkIHByZWZpeGVkIHZlcnNpb24gaWYgbmVlZGVkXG4gIHZhciBwcmVmaXhlZFByb3BlcnR5ID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcblxuICAvLyBub3csIGxldCdzIG1ha2UgYSBzdGVwIGJhY2sgYW5kIGxvb2sgYXQgdGhpcyBjb2RlIGNsb3NlbHkgKHd0Zj8pXG4gIC8vIElmIHRoZSBjb250ZW50IG9mIHRoZSBwb3BwZXIgZ3Jvd3Mgb25jZSBpdCdzIGJlZW4gcG9zaXRpb25lZCwgaXRcbiAgLy8gbWF5IGhhcHBlbiB0aGF0IHRoZSBwb3BwZXIgZ2V0cyBtaXNwbGFjZWQgYmVjYXVzZSBvZiB0aGUgbmV3IGNvbnRlbnRcbiAgLy8gb3ZlcmZsb3dpbmcgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRvIGF2b2lkIHRoaXMgcHJvYmxlbSwgd2UgcHJvdmlkZSB0d28gb3B0aW9ucyAoeCBhbmQgeSksIHdoaWNoIGFsbG93XG4gIC8vIHRoZSBjb25zdW1lciB0byBkZWZpbmUgdGhlIG9mZnNldCBvcmlnaW4uXG4gIC8vIElmIHdlIHBvc2l0aW9uIGEgcG9wcGVyIG9uIHRvcCBvZiBhIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSBjYW4gc2V0XG4gIC8vIGB4YCB0byBgdG9wYCB0byBtYWtlIHRoZSBwb3BwZXIgZ3JvdyB0b3dhcmRzIGl0cyB0b3AgaW5zdGVhZCBvZlxuICAvLyBpdHMgYm90dG9tLlxuICB2YXIgbGVmdCA9IHZvaWQgMCxcbiAgICAgIHRvcCA9IHZvaWQgMDtcbiAgaWYgKHNpZGVBID09PSAnYm90dG9tJykge1xuICAgIC8vIHdoZW4gb2Zmc2V0UGFyZW50IGlzIDxodG1sPiB0aGUgcG9zaXRpb25pbmcgaXMgcmVsYXRpdmUgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuIChleGNsdWRpbmcgdGhlIHNjcm9sbGJhcilcbiAgICAvLyBhbmQgbm90IHRoZSBib3R0b20gb2YgdGhlIGh0bWwgZWxlbWVudFxuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudFJlY3QuaGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRvcCA9IG9mZnNldHMudG9wO1xuICB9XG4gIGlmIChzaWRlQiA9PT0gJ3JpZ2h0Jykge1xuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gLW9mZnNldFBhcmVudFJlY3Qud2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZWZ0ID0gb2Zmc2V0cy5sZWZ0O1xuICB9XG4gIGlmIChncHVBY2NlbGVyYXRpb24gJiYgcHJlZml4ZWRQcm9wZXJ0eSkge1xuICAgIHN0eWxlc1twcmVmaXhlZFByb3BlcnR5XSA9ICd0cmFuc2xhdGUzZCgnICsgbGVmdCArICdweCwgJyArIHRvcCArICdweCwgMCknO1xuICAgIHN0eWxlc1tzaWRlQV0gPSAwO1xuICAgIHN0eWxlc1tzaWRlQl0gPSAwO1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3Rod2VyaXNlLCB3ZSB1c2UgdGhlIHN0YW5kYXJkIGB0b3BgLCBgbGVmdGAsIGBib3R0b21gIGFuZCBgcmlnaHRgIHByb3BlcnRpZXNcbiAgICB2YXIgaW52ZXJ0VG9wID0gc2lkZUEgPT09ICdib3R0b20nID8gLTEgOiAxO1xuICAgIHZhciBpbnZlcnRMZWZ0ID0gc2lkZUIgPT09ICdyaWdodCcgPyAtMSA6IDE7XG4gICAgc3R5bGVzW3NpZGVBXSA9IHRvcCAqIGludmVydFRvcDtcbiAgICBzdHlsZXNbc2lkZUJdID0gbGVmdCAqIGludmVydExlZnQ7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSBzaWRlQSArICcsICcgKyBzaWRlQjtcbiAgfVxuXG4gIC8vIEF0dHJpYnV0ZXNcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ3gtcGxhY2VtZW50JzogZGF0YS5wbGFjZW1lbnRcbiAgfTtcblxuICAvLyBVcGRhdGUgYGRhdGFgIGF0dHJpYnV0ZXMsIHN0eWxlcyBhbmQgYXJyb3dTdHlsZXNcbiAgZGF0YS5hdHRyaWJ1dGVzID0gX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIGRhdGEuYXR0cmlidXRlcyk7XG4gIGRhdGEuc3R5bGVzID0gX2V4dGVuZHMoe30sIHN0eWxlcywgZGF0YS5zdHlsZXMpO1xuICBkYXRhLmFycm93U3R5bGVzID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5hcnJvdywgZGF0YS5hcnJvd1N0eWxlcyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgZGVwZW5kcyBmcm9tIGFub3RoZXIgb25lLjxiciAvPlxuICogSXQgY2hlY2tzIGlmIHRoZSBuZWVkZWQgbW9kaWZpZXIgaXMgbGlzdGVkIGFuZCBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzIC0gbGlzdCBvZiBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0aW5nTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGluZyBtb2RpZmllclxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RlZE5hbWUgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJSZXF1aXJlZChtb2RpZmllcnMsIHJlcXVlc3RpbmdOYW1lLCByZXF1ZXN0ZWROYW1lKSB7XG4gIHZhciByZXF1ZXN0aW5nID0gZmluZChtb2RpZmllcnMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgPT09IHJlcXVlc3RpbmdOYW1lO1xuICB9KTtcblxuICB2YXIgaXNSZXF1aXJlZCA9ICEhcmVxdWVzdGluZyAmJiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gcmVxdWVzdGVkTmFtZSAmJiBtb2RpZmllci5lbmFibGVkICYmIG1vZGlmaWVyLm9yZGVyIDwgcmVxdWVzdGluZy5vcmRlcjtcbiAgfSk7XG5cbiAgaWYgKCFpc1JlcXVpcmVkKSB7XG4gICAgdmFyIF9yZXF1ZXN0aW5nID0gJ2AnICsgcmVxdWVzdGluZ05hbWUgKyAnYCc7XG4gICAgdmFyIHJlcXVlc3RlZCA9ICdgJyArIHJlcXVlc3RlZE5hbWUgKyAnYCc7XG4gICAgY29uc29sZS53YXJuKHJlcXVlc3RlZCArICcgbW9kaWZpZXIgaXMgcmVxdWlyZWQgYnkgJyArIF9yZXF1ZXN0aW5nICsgJyBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlICcgKyBfcmVxdWVzdGluZyArICchJyk7XG4gIH1cbiAgcmV0dXJuIGlzUmVxdWlyZWQ7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBhcnJvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzJGFycm93O1xuXG4gIC8vIGFycm93IGRlcGVuZHMgb24ga2VlcFRvZ2V0aGVyIGluIG9yZGVyIHRvIHdvcmtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdhcnJvdycsICdrZWVwVG9nZXRoZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGFycm93RWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgYSBzdHJpbmcsIHN1cHBvc2UgaXQncyBhIENTUyBzZWxlY3RvclxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgbm90IGZvdW5kLCBkb24ndCBydW4gdGhlIG1vZGlmaWVyXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgYXJyb3dFbGVtZW50IGlzbid0IGEgcXVlcnkgc2VsZWN0b3Igd2UgbXVzdCBjaGVjayB0aGF0IHRoZVxuICAgIC8vIHByb3ZpZGVkIERPTSBub2RlIGlzIGNoaWxkIG9mIGl0cyBwb3BwZXIgbm9kZVxuICAgIGlmICghZGF0YS5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgYXJyb3cuZWxlbWVudGAgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyIGVsZW1lbnQhJyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNpZGVDYXBpdGFsaXplZCA9IGlzVmVydGljYWwgPyAnVG9wJyA6ICdMZWZ0JztcbiAgdmFyIHNpZGUgPSBzaWRlQ2FwaXRhbGl6ZWQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGFsdFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICB2YXIgYXJyb3dFbGVtZW50U2l6ZSA9IGdldE91dGVyU2l6ZXMoYXJyb3dFbGVtZW50KVtsZW5dO1xuXG4gIC8vXG4gIC8vIGV4dGVuZHMga2VlcFRvZ2V0aGVyIGJlaGF2aW9yIG1ha2luZyBzdXJlIHRoZSBwb3BwZXIgYW5kIGl0c1xuICAvLyByZWZlcmVuY2UgaGF2ZSBlbm91Z2ggcGl4ZWxzIGluIGNvbmp1bmN0aW9uXG4gIC8vXG5cbiAgLy8gdG9wL2xlZnQgc2lkZVxuICBpZiAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplIDwgcG9wcGVyW3NpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtPSBwb3BwZXJbc2lkZV0gLSAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplKTtcbiAgfVxuICAvLyBib3R0b20vcmlnaHQgc2lkZVxuICBpZiAocmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSA+IHBvcHBlcltvcFNpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSArPSByZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplIC0gcG9wcGVyW29wU2lkZV07XG4gIH1cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG5cbiAgLy8gY29tcHV0ZSBjZW50ZXIgb2YgdGhlIHBvcHBlclxuICB2YXIgY2VudGVyID0gcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW2xlbl0gLyAyIC0gYXJyb3dFbGVtZW50U2l6ZSAvIDI7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgc2lkZVZhbHVlIHVzaW5nIHRoZSB1cGRhdGVkIHBvcHBlciBvZmZzZXRzXG4gIC8vIHRha2UgcG9wcGVyIG1hcmdpbiBpbiBhY2NvdW50IGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0aGlzIGluZm8gYXZhaWxhYmxlXG4gIHZhciBjc3MgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgcG9wcGVyTWFyZ2luU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydtYXJnaW4nICsgc2lkZUNhcGl0YWxpemVkXSwgMTApO1xuICB2YXIgcG9wcGVyQm9yZGVyU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydib3JkZXInICsgc2lkZUNhcGl0YWxpemVkICsgJ1dpZHRoJ10sIDEwKTtcbiAgdmFyIHNpZGVWYWx1ZSA9IGNlbnRlciAtIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLSBwb3BwZXJNYXJnaW5TaWRlIC0gcG9wcGVyQm9yZGVyU2lkZTtcblxuICAvLyBwcmV2ZW50IGFycm93RWxlbWVudCBmcm9tIGJlaW5nIHBsYWNlZCBub3QgY29udGlndW91c2x5IHRvIGl0cyBwb3BwZXJcbiAgc2lkZVZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4ocG9wcGVyW2xlbl0gLSBhcnJvd0VsZW1lbnRTaXplLCBzaWRlVmFsdWUpLCAwKTtcblxuICBkYXRhLmFycm93RWxlbWVudCA9IGFycm93RWxlbWVudDtcbiAgZGF0YS5vZmZzZXRzLmFycm93ID0gKF9kYXRhJG9mZnNldHMkYXJyb3cgPSB7fSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgc2lkZSwgTWF0aC5yb3VuZChzaWRlVmFsdWUpKSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgYWx0U2lkZSwgJycpLCBfZGF0YSRvZmZzZXRzJGFycm93KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCB2YXJpYXRpb24gb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCB2YXJpYXRpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50IHZhcmlhdGlvblxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pIHtcbiAgaWYgKHZhcmlhdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICByZXR1cm4gJ3N0YXJ0JztcbiAgfSBlbHNlIGlmICh2YXJpYXRpb24gPT09ICdzdGFydCcpIHtcbiAgICByZXR1cm4gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHZhcmlhdGlvbjtcbn1cblxuLyoqXG4gKiBMaXN0IG9mIGFjY2VwdGVkIHBsYWNlbWVudHMgdG8gdXNlIGFzIHZhbHVlcyBvZiB0aGUgYHBsYWNlbWVudGAgb3B0aW9uLjxiciAvPlxuICogVmFsaWQgcGxhY2VtZW50cyBhcmU6XG4gKiAtIGBhdXRvYFxuICogLSBgdG9wYFxuICogLSBgcmlnaHRgXG4gKiAtIGBib3R0b21gXG4gKiAtIGBsZWZ0YFxuICpcbiAqIEVhY2ggcGxhY2VtZW50IGNhbiBoYXZlIGEgdmFyaWF0aW9uIGZyb20gdGhpcyBsaXN0OlxuICogLSBgLXN0YXJ0YFxuICogLSBgLWVuZGBcbiAqXG4gKiBWYXJpYXRpb25zIGFyZSBpbnRlcnByZXRlZCBlYXNpbHkgaWYgeW91IHRoaW5rIG9mIHRoZW0gYXMgdGhlIGxlZnQgdG8gcmlnaHRcbiAqIHdyaXR0ZW4gbGFuZ3VhZ2VzLiBIb3Jpem9udGFsbHkgKGB0b3BgIGFuZCBgYm90dG9tYCksIGBzdGFydGAgaXMgbGVmdCBhbmQgYGVuZGBcbiAqIGlzIHJpZ2h0LjxiciAvPlxuICogVmVydGljYWxseSAoYGxlZnRgIGFuZCBgcmlnaHRgKSwgYHN0YXJ0YCBpcyB0b3AgYW5kIGBlbmRgIGlzIGJvdHRvbS5cbiAqXG4gKiBTb21lIHZhbGlkIGV4YW1wbGVzIGFyZTpcbiAqIC0gYHRvcC1lbmRgIChvbiB0b3Agb2YgcmVmZXJlbmNlLCByaWdodCBhbGlnbmVkKVxuICogLSBgcmlnaHQtc3RhcnRgIChvbiByaWdodCBvZiByZWZlcmVuY2UsIHRvcCBhbGlnbmVkKVxuICogLSBgYm90dG9tYCAob24gYm90dG9tLCBjZW50ZXJlZClcbiAqIC0gYGF1dG8tZW5kYCAob24gdGhlIHNpZGUgd2l0aCBtb3JlIHNwYWNlIGF2YWlsYWJsZSwgYWxpZ25tZW50IGRlcGVuZHMgYnkgcGxhY2VtZW50KVxuICpcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBlbnVtIHtTdHJpbmd9XG4gKiBAcmVhZG9ubHlcbiAqIEBtZXRob2QgcGxhY2VtZW50c1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgcGxhY2VtZW50cyA9IFsnYXV0by1zdGFydCcsICdhdXRvJywgJ2F1dG8tZW5kJywgJ3RvcC1zdGFydCcsICd0b3AnLCAndG9wLWVuZCcsICdyaWdodC1zdGFydCcsICdyaWdodCcsICdyaWdodC1lbmQnLCAnYm90dG9tLWVuZCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2xlZnQtZW5kJywgJ2xlZnQnLCAnbGVmdC1zdGFydCddO1xuXG4vLyBHZXQgcmlkIG9mIGBhdXRvYCBgYXV0by1zdGFydGAgYW5kIGBhdXRvLWVuZGBcbnZhciB2YWxpZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLnNsaWNlKDMpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGluaXRpYWwgcGxhY2VtZW50LCByZXR1cm5zIGFsbCB0aGUgc3Vic2VxdWVudCBwbGFjZW1lbnRzXG4gKiBjbG9ja3dpc2UgKG9yIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IC0gQSB2YWxpZCBwbGFjZW1lbnQgKGl0IGFjY2VwdHMgdmFyaWF0aW9ucylcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gY291bnRlciAtIFNldCB0byB0cnVlIHRvIHdhbGsgdGhlIHBsYWNlbWVudHMgY291bnRlcmNsb2Nrd2lzZVxuICogQHJldHVybnMge0FycmF5fSBwbGFjZW1lbnRzIGluY2x1ZGluZyB0aGVpciB2YXJpYXRpb25zXG4gKi9cbmZ1bmN0aW9uIGNsb2Nrd2lzZShwbGFjZW1lbnQpIHtcbiAgdmFyIGNvdW50ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBpbmRleCA9IHZhbGlkUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCk7XG4gIHZhciBhcnIgPSB2YWxpZFBsYWNlbWVudHMuc2xpY2UoaW5kZXggKyAxKS5jb25jYXQodmFsaWRQbGFjZW1lbnRzLnNsaWNlKDAsIGluZGV4KSk7XG4gIHJldHVybiBjb3VudGVyID8gYXJyLnJldmVyc2UoKSA6IGFycjtcbn1cblxudmFyIEJFSEFWSU9SUyA9IHtcbiAgRkxJUDogJ2ZsaXAnLFxuICBDTE9DS1dJU0U6ICdjbG9ja3dpc2UnLFxuICBDT1VOVEVSQ0xPQ0tXSVNFOiAnY291bnRlcmNsb2Nrd2lzZSdcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBmbGlwKGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gaWYgYGlubmVyYCBtb2RpZmllciBpcyBlbmFibGVkLCB3ZSBjYW4ndCB1c2UgdGhlIGBmbGlwYCBtb2RpZmllclxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdpbm5lcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBpZiAoZGF0YS5mbGlwcGVkICYmIGRhdGEucGxhY2VtZW50ID09PSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50KSB7XG4gICAgLy8gc2VlbXMgbGlrZSBmbGlwIGlzIHRyeWluZyB0byBsb29wLCBwcm9iYWJseSB0aGVyZSdzIG5vdCBlbm91Z2ggc3BhY2Ugb24gYW55IG9mIHRoZSBmbGlwcGFibGUgc2lkZXNcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsIG9wdGlvbnMucGFkZGluZywgb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMV0gfHwgJyc7XG5cbiAgdmFyIGZsaXBPcmRlciA9IFtdO1xuXG4gIHN3aXRjaCAob3B0aW9ucy5iZWhhdmlvcikge1xuICAgIGNhc2UgQkVIQVZJT1JTLkZMSVA6XG4gICAgICBmbGlwT3JkZXIgPSBbcGxhY2VtZW50LCBwbGFjZW1lbnRPcHBvc2l0ZV07XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNPVU5URVJDTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50LCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmbGlwT3JkZXIgPSBvcHRpb25zLmJlaGF2aW9yO1xuICB9XG5cbiAgZmxpcE9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHN0ZXAsIGluZGV4KSB7XG4gICAgaWYgKHBsYWNlbWVudCAhPT0gc3RlcCB8fCBmbGlwT3JkZXIubGVuZ3RoID09PSBpbmRleCArIDEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuICAgIHZhciByZWZPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcblxuICAgIC8vIHVzaW5nIGZsb29yIGJlY2F1c2UgdGhlIHJlZmVyZW5jZSBvZmZzZXRzIG1heSBjb250YWluIGRlY2ltYWxzIHdlIGFyZSBub3QgZ29pbmcgdG8gY29uc2lkZXIgaGVyZVxuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgdmFyIG92ZXJsYXBzUmVmID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihyZWZPZmZzZXRzLmxlZnQpIHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IocmVmT2Zmc2V0cy5yaWdodCkgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihyZWZPZmZzZXRzLnRvcCkgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihyZWZPZmZzZXRzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzTGVmdCA9IGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihib3VuZGFyaWVzLmxlZnQpO1xuICAgIHZhciBvdmVyZmxvd3NSaWdodCA9IGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IoYm91bmRhcmllcy5yaWdodCk7XG4gICAgdmFyIG92ZXJmbG93c1RvcCA9IGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKGJvdW5kYXJpZXMudG9wKTtcbiAgICB2YXIgb3ZlcmZsb3dzQm90dG9tID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IoYm91bmRhcmllcy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0JvdW5kYXJpZXMgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIG92ZXJmbG93c1RvcCB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIG92ZXJmbG93c0JvdHRvbTtcblxuICAgIC8vIGZsaXAgdGhlIHZhcmlhdGlvbiBpZiByZXF1aXJlZFxuICAgIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbiA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1RvcCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0JvdHRvbSk7XG5cbiAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcyB8fCBmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAvLyB0aGlzIGJvb2xlYW4gdG8gZGV0ZWN0IGFueSBmbGlwIGxvb3BcbiAgICAgIGRhdGEuZmxpcHBlZCA9IHRydWU7XG5cbiAgICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IGZsaXBPcmRlcltpbmRleCArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgICB2YXJpYXRpb24gPSBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnBsYWNlbWVudCA9IHBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG5cbiAgICAgIC8vIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGBwb3NpdGlvbmAsIHdlIHdhbnQgdG8gcHJlc2VydmUgaXQgYWxvbmcgd2l0aFxuICAgICAgLy8gYW55IGFkZGl0aW9uYWwgcHJvcGVydHkgd2UgbWF5IGFkZCBpbiB0aGUgZnV0dXJlXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5wb3BwZXIsIGdldFBvcHBlck9mZnNldHMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KSk7XG5cbiAgICAgIGRhdGEgPSBydW5Nb2RpZmllcnMoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGRhdGEsICdmbGlwJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBrZWVwVG9nZXRoZXIoZGF0YSkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gIGlmIChwb3BwZXJbc2lkZV0gPCBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkgLSBwb3BwZXJbbWVhc3VyZW1lbnRdO1xuICB9XG4gIGlmIChwb3BwZXJbb3BTaWRlXSA+IGZsb29yKHJlZmVyZW5jZVtzaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgY29udGFpbmluZyB2YWx1ZSArIHVuaXQgaW50byBhIHB4IHZhbHVlIG51bWJlclxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHN0ciAtIFZhbHVlICsgdW5pdCBzdHJpbmdcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBtZWFzdXJlbWVudCAtIGBoZWlnaHRgIG9yIGB3aWR0aGBcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQHJldHVybnMge051bWJlcnxTdHJpbmd9XG4gKiBWYWx1ZSBpbiBwaXhlbHMsIG9yIG9yaWdpbmFsIHN0cmluZyBpZiBubyB2YWx1ZXMgd2VyZSBleHRyYWN0ZWRcbiAqL1xuZnVuY3Rpb24gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKSB7XG4gIC8vIHNlcGFyYXRlIHZhbHVlIGZyb20gdW5pdFxuICB2YXIgc3BsaXQgPSBzdHIubWF0Y2goLygoPzpcXC18XFwrKT9cXGQqXFwuP1xcZCopKC4qKS8pO1xuICB2YXIgdmFsdWUgPSArc3BsaXRbMV07XG4gIHZhciB1bml0ID0gc3BsaXRbMl07XG5cbiAgLy8gSWYgaXQncyBub3QgYSBudW1iZXIgaXQncyBhbiBvcGVyYXRvciwgSSBndWVzc1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmICh1bml0LmluZGV4T2YoJyUnKSA9PT0gMCkge1xuICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgY2FzZSAnJXAnOlxuICAgICAgICBlbGVtZW50ID0gcG9wcGVyT2Zmc2V0cztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICclJzpcbiAgICAgIGNhc2UgJyVyJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVsZW1lbnQgPSByZWZlcmVuY2VPZmZzZXRzO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdChlbGVtZW50KTtcbiAgICByZXR1cm4gcmVjdFttZWFzdXJlbWVudF0gLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIGlmICh1bml0ID09PSAndmgnIHx8IHVuaXQgPT09ICd2dycpIHtcbiAgICAvLyBpZiBpcyBhIHZoIG9yIHZ3LCB3ZSBjYWxjdWxhdGUgdGhlIHNpemUgYmFzZWQgb24gdGhlIHZpZXdwb3J0XG4gICAgdmFyIHNpemUgPSB2b2lkIDA7XG4gICAgaWYgKHVuaXQgPT09ICd2aCcpIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIGlzIGFuIGV4cGxpY2l0IHBpeGVsIHVuaXQsIHdlIGdldCByaWQgb2YgdGhlIHVuaXQgYW5kIGtlZXAgdGhlIHZhbHVlXG4gICAgLy8gaWYgaXMgYW4gaW1wbGljaXQgdW5pdCwgaXQncyBweCwgYW5kIHdlIHJldHVybiBqdXN0IHRoZSB2YWx1ZVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGBvZmZzZXRgIHN0cmluZyB0byBleHRyYXBvbGF0ZSBgeGAgYW5kIGB5YCBudW1lcmljIG9mZnNldHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gb2Zmc2V0XG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBiYXNlUGxhY2VtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl9IGEgdHdvIGNlbGxzIGFycmF5IHdpdGggeCBhbmQgeSBvZmZzZXRzIGluIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzLCBiYXNlUGxhY2VtZW50KSB7XG4gIHZhciBvZmZzZXRzID0gWzAsIDBdO1xuXG4gIC8vIFVzZSBoZWlnaHQgaWYgcGxhY2VtZW50IGlzIGxlZnQgb3IgcmlnaHQgYW5kIGluZGV4IGlzIDAgb3RoZXJ3aXNlIHVzZSB3aWR0aFxuICAvLyBpbiB0aGlzIHdheSB0aGUgZmlyc3Qgb2Zmc2V0IHdpbGwgdXNlIGFuIGF4aXMgYW5kIHRoZSBzZWNvbmQgb25lXG4gIC8vIHdpbGwgdXNlIHRoZSBvdGhlciBvbmVcbiAgdmFyIHVzZUhlaWdodCA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIC8vIFNwbGl0IHRoZSBvZmZzZXQgc3RyaW5nIHRvIG9idGFpbiBhIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kc1xuICAvLyBUaGUgcmVnZXggYWRkcmVzc2VzIHZhbHVlcyB3aXRoIHRoZSBwbHVzIG9yIG1pbnVzIHNpZ24gaW4gZnJvbnQgKCsxMCwgLTIwLCBldGMpXG4gIHZhciBmcmFnbWVudHMgPSBvZmZzZXQuc3BsaXQoLyhcXCt8XFwtKS8pLm1hcChmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnRyaW0oKTtcbiAgfSk7XG5cbiAgLy8gRGV0ZWN0IGlmIHRoZSBvZmZzZXQgc3RyaW5nIGNvbnRhaW5zIGEgcGFpciBvZiB2YWx1ZXMgb3IgYSBzaW5nbGUgb25lXG4gIC8vIHRoZXkgY291bGQgYmUgc2VwYXJhdGVkIGJ5IGNvbW1hIG9yIHNwYWNlXG4gIHZhciBkaXZpZGVyID0gZnJhZ21lbnRzLmluZGV4T2YoZmluZChmcmFnbWVudHMsIGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcuc2VhcmNoKC8sfFxccy8pICE9PSAtMTtcbiAgfSkpO1xuXG4gIGlmIChmcmFnbWVudHNbZGl2aWRlcl0gJiYgZnJhZ21lbnRzW2RpdmlkZXJdLmluZGV4T2YoJywnKSA9PT0gLTEpIHtcbiAgICBjb25zb2xlLndhcm4oJ09mZnNldHMgc2VwYXJhdGVkIGJ5IHdoaXRlIHNwYWNlKHMpIGFyZSBkZXByZWNhdGVkLCB1c2UgYSBjb21tYSAoLCkgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIC8vIElmIGRpdmlkZXIgaXMgZm91bmQsIHdlIGRpdmlkZSB0aGUgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzIHRvIGRpdmlkZVxuICAvLyB0aGVtIGJ5IG9mc2V0IFggYW5kIFkuXG4gIHZhciBzcGxpdFJlZ2V4ID0gL1xccyosXFxzKnxcXHMrLztcbiAgdmFyIG9wcyA9IGRpdmlkZXIgIT09IC0xID8gW2ZyYWdtZW50cy5zbGljZSgwLCBkaXZpZGVyKS5jb25jYXQoW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVswXV0pLCBbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzFdXS5jb25jYXQoZnJhZ21lbnRzLnNsaWNlKGRpdmlkZXIgKyAxKSldIDogW2ZyYWdtZW50c107XG5cbiAgLy8gQ29udmVydCB0aGUgdmFsdWVzIHdpdGggdW5pdHMgdG8gYWJzb2x1dGUgcGl4ZWxzIHRvIGFsbG93IG91ciBjb21wdXRhdGlvbnNcbiAgb3BzID0gb3BzLm1hcChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgLy8gTW9zdCBvZiB0aGUgdW5pdHMgcmVseSBvbiB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHBvcHBlclxuICAgIHZhciBtZWFzdXJlbWVudCA9IChpbmRleCA9PT0gMSA/ICF1c2VIZWlnaHQgOiB1c2VIZWlnaHQpID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgIHJldHVybiBvcFxuICAgIC8vIFRoaXMgYWdncmVnYXRlcyBhbnkgYCtgIG9yIGAtYCBzaWduIHRoYXQgYXJlbid0IGNvbnNpZGVyZWQgb3BlcmF0b3JzXG4gICAgLy8gZS5nLjogMTAgKyArNSA9PiBbMTAsICssICs1XVxuICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhW2EubGVuZ3RoIC0gMV0gPT09ICcnICYmIFsnKycsICctJ10uaW5kZXhPZihiKSAhPT0gLTEpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdID0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSBpZiAobWVyZ2VXaXRoUHJldmlvdXMpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdICs9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfVxuICAgIH0sIFtdKVxuICAgIC8vIEhlcmUgd2UgY29udmVydCB0aGUgc3RyaW5nIHZhbHVlcyBpbnRvIG51bWJlciB2YWx1ZXMgKGluIHB4KVxuICAgIC5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIExvb3AgdHJvdWdoIHRoZSBvZmZzZXRzIGFycmF5cyBhbmQgZXhlY3V0ZSB0aGUgb3BlcmF0aW9uc1xuICBvcHMuZm9yRWFjaChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgb3AuZm9yRWFjaChmdW5jdGlvbiAoZnJhZywgaW5kZXgyKSB7XG4gICAgICBpZiAoaXNOdW1lcmljKGZyYWcpKSB7XG4gICAgICAgIG9mZnNldHNbaW5kZXhdICs9IGZyYWcgKiAob3BbaW5kZXgyIC0gMV0gPT09ICctJyA/IC0xIDogMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAYXJndW1lbnQge051bWJlcnxTdHJpbmd9IG9wdGlvbnMub2Zmc2V0PTBcbiAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBvZmZzZXQoZGF0YSwgX3JlZikge1xuICB2YXIgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudCxcbiAgICAgIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgdmFyIG9mZnNldHMgPSB2b2lkIDA7XG4gIGlmIChpc051bWVyaWMoK29mZnNldCkpIHtcbiAgICBvZmZzZXRzID0gWytvZmZzZXQsIDBdO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldHMgPSBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlciwgcmVmZXJlbmNlLCBiYXNlUGxhY2VtZW50KTtcbiAgfVxuXG4gIGlmIChiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzFdO1xuICB9XG5cbiAgZGF0YS5wb3BwZXIgPSBwb3BwZXI7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgYm91bmRhcmllc0VsZW1lbnQgPSBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50IHx8IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG5cbiAgLy8gSWYgb2Zmc2V0UGFyZW50IGlzIHRoZSByZWZlcmVuY2UgZWxlbWVudCwgd2UgcmVhbGx5IHdhbnQgdG9cbiAgLy8gZ28gb25lIHN0ZXAgdXAgYW5kIHVzZSB0aGUgbmV4dCBvZmZzZXRQYXJlbnQgYXMgcmVmZXJlbmNlIHRvXG4gIC8vIGF2b2lkIHRvIG1ha2UgdGhpcyBtb2RpZmllciBjb21wbGV0ZWx5IHVzZWxlc3MgYW5kIGxvb2sgbGlrZSBicm9rZW5cbiAgaWYgKGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlID09PSBib3VuZGFyaWVzRWxlbWVudCkge1xuICAgIGJvdW5kYXJpZXNFbGVtZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGJvdW5kYXJpZXNFbGVtZW50KTtcbiAgfVxuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXNldHMgdGhlIHBvcHBlcidzIHBvc2l0aW9uIHNvIHRoYXQgdGhlIGRvY3VtZW50IHNpemUgY2FuIGJlIGNhbGN1bGF0ZWQgZXhjbHVkaW5nXG4gIC8vIHRoZSBzaXplIG9mIHRoZSBwb3BwZXIgZWxlbWVudCBpdHNlbGZcbiAgdmFyIHRyYW5zZm9ybVByb3AgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuICB2YXIgcG9wcGVyU3R5bGVzID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIuc3R5bGU7IC8vIGFzc2lnbm1lbnQgdG8gaGVscCBtaW5pZmljYXRpb25cbiAgdmFyIHRvcCA9IHBvcHBlclN0eWxlcy50b3AsXG4gICAgICBsZWZ0ID0gcG9wcGVyU3R5bGVzLmxlZnQsXG4gICAgICB0cmFuc2Zvcm0gPSBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF07XG5cbiAgcG9wcGVyU3R5bGVzLnRvcCA9ICcnO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9ICcnO1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSAnJztcblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXN0b3JlcyB0aGUgb3JpZ2luYWwgc3R5bGUgcHJvcGVydGllcyBhZnRlciB0aGUgb2Zmc2V0cyBoYXZlIGJlZW4gY29tcHV0ZWRcbiAgcG9wcGVyU3R5bGVzLnRvcCA9IHRvcDtcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSBsZWZ0O1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm07XG5cbiAgb3B0aW9ucy5ib3VuZGFyaWVzID0gYm91bmRhcmllcztcblxuICB2YXIgb3JkZXIgPSBvcHRpb25zLnByaW9yaXR5O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICB2YXIgY2hlY2sgPSB7XG4gICAgcHJpbWFyeTogZnVuY3Rpb24gcHJpbWFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlcltwbGFjZW1lbnRdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdIDwgYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1heChwb3BwZXJbcGxhY2VtZW50XSwgYm91bmRhcmllc1twbGFjZW1lbnRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgcGxhY2VtZW50LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZWNvbmRhcnk6IGZ1bmN0aW9uIHNlY29uZGFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciBtYWluU2lkZSA9IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW21haW5TaWRlXTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA+IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5taW4ocG9wcGVyW21haW5TaWRlXSwgYm91bmRhcmllc1twbGFjZW1lbnRdIC0gKHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/IHBvcHBlci53aWR0aCA6IHBvcHBlci5oZWlnaHQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgbWFpblNpZGUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgb3JkZXIuZm9yRWFjaChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgdmFyIHNpZGUgPSBbJ2xlZnQnLCAndG9wJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMSA/ICdwcmltYXJ5JyA6ICdzZWNvbmRhcnknO1xuICAgIHBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIGNoZWNrW3NpZGVdKHBsYWNlbWVudCkpO1xuICB9KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gcG9wcGVyO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBzaGlmdChkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHNoaWZ0dmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgLy8gaWYgc2hpZnQgc2hpZnR2YXJpYXRpb24gaXMgc3BlY2lmaWVkLCBydW4gdGhlIG1vZGlmaWVyXG4gIGlmIChzaGlmdHZhcmlhdGlvbikge1xuICAgIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXI7XG5cbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsnYm90dG9tJywgJ3RvcCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuICAgIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgICB2YXIgc2hpZnRPZmZzZXRzID0ge1xuICAgICAgc3RhcnQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0pLFxuICAgICAgZW5kOiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW21lYXN1cmVtZW50XSAtIHBvcHBlclttZWFzdXJlbWVudF0pXG4gICAgfTtcblxuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBzaGlmdE9mZnNldHNbc2hpZnR2YXJpYXRpb25dKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaGlkZShkYXRhKSB7XG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaGlkZScsICdwcmV2ZW50T3ZlcmZsb3cnKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHJlZlJlY3QgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgYm91bmQgPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ3ByZXZlbnRPdmVyZmxvdyc7XG4gIH0pLmJvdW5kYXJpZXM7XG5cbiAgaWYgKHJlZlJlY3QuYm90dG9tIDwgYm91bmQudG9wIHx8IHJlZlJlY3QubGVmdCA+IGJvdW5kLnJpZ2h0IHx8IHJlZlJlY3QudG9wID4gYm91bmQuYm90dG9tIHx8IHJlZlJlY3QucmlnaHQgPCBib3VuZC5sZWZ0KSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gdHJ1ZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSBmYWxzZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGlubmVyKGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzSG9yaXogPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgc3VidHJhY3RMZW5ndGggPSBbJ3RvcCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA9PT0gLTE7XG5cbiAgcG9wcGVyW2lzSG9yaXogPyAnbGVmdCcgOiAndG9wJ10gPSByZWZlcmVuY2VbYmFzZVBsYWNlbWVudF0gLSAoc3VidHJhY3RMZW5ndGggPyBwb3BwZXJbaXNIb3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gOiAwKTtcblxuICBkYXRhLnBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KHBvcHBlcik7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogTW9kaWZpZXIgZnVuY3Rpb24sIGVhY2ggbW9kaWZpZXIgY2FuIGhhdmUgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgYXNzaWduZWRcbiAqIHRvIGl0cyBgZm5gIHByb3BlcnR5LjxiciAvPlxuICogVGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLCB0aGlzIG1lYW5zIHRoYXQgeW91IG11c3RcbiAqIG1ha2Ugc3VyZSB0aGV5IGFyZSBwZXJmb3JtYW50IGVub3VnaCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrcy5cbiAqXG4gKiBAZnVuY3Rpb24gTW9kaWZpZXJGblxuICogQGFyZ3VtZW50IHtkYXRhT2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cblxuLyoqXG4gKiBNb2RpZmllcnMgYXJlIHBsdWdpbnMgdXNlZCB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgeW91ciBwb3BwZXJzLjxiciAvPlxuICogUG9wcGVyLmpzIHVzZXMgYSBzZXQgb2YgOSBtb2RpZmllcnMgdG8gcHJvdmlkZSBhbGwgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllc1xuICogbmVlZGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICpcbiAqIFVzdWFsbHkgeW91IGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGBvcmRlcmAsIGBmbmAgYW5kIGBvbkxvYWRgIHByb3BzLlxuICogQWxsIHRoZSBvdGhlciBwcm9wZXJ0aWVzIGFyZSBjb25maWd1cmF0aW9ucyB0aGF0IGNvdWxkIGJlIHR3ZWFrZWQuXG4gKiBAbmFtZXNwYWNlIG1vZGlmaWVyc1xuICovXG52YXIgbW9kaWZpZXJzID0ge1xuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzdGFydCBvciBlbmQgb2YgaXRzIHJlZmVyZW5jZVxuICAgKiBlbGVtZW50LjxiciAvPlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIHZhcmlhdGlvbiBvZiB0aGUgYHBsYWNlbWVudGAgcHJvcGVydHkuPGJyIC8+XG4gICAqIEl0IGNhbiBiZSBvbmUgZWl0aGVyIGAtZW5kYCBvciBgLXN0YXJ0YC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHNoaWZ0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTEwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogc2hpZnRcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGBvZmZzZXRgIG1vZGlmaWVyIGNhbiBzaGlmdCB5b3VyIHBvcHBlciBvbiBib3RoIGl0cyBheGlzLlxuICAgKlxuICAgKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgdW5pdHM6XG4gICAqIC0gYHB4YCBvciB1bml0LWxlc3MsIGludGVycHJldGVkIGFzIHBpeGVsc1xuICAgKiAtIGAlYCBvciBgJXJgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiAtIGB2d2AsIENTUyB2aWV3cG9ydCB3aWR0aCB1bml0XG4gICAqIC0gYHZoYCwgQ1NTIHZpZXdwb3J0IGhlaWdodCB1bml0XG4gICAqXG4gICAqIEZvciBsZW5ndGggaXMgaW50ZW5kZWQgdGhlIG1haW4gYXhpcyByZWxhdGl2ZSB0byB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuPGJyIC8+XG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgcGxhY2VtZW50IGlzIGB0b3BgIG9yIGBib3R0b21gLCB0aGUgbGVuZ3RoIHdpbGwgYmUgdGhlXG4gICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGBoZWlnaHRgLlxuICAgKlxuICAgKiBZb3UgY2FuIHByb3ZpZGUgYSBzaW5nbGUgdmFsdWUgKGFzIGBOdW1iZXJgIG9yIGBTdHJpbmdgKSwgb3IgYSBwYWlyIG9mIHZhbHVlc1xuICAgKiBhcyBgU3RyaW5nYCBkaXZpZGVkIGJ5IGEgY29tbWEgb3Igb25lIChvciBtb3JlKSB3aGl0ZSBzcGFjZXMuPGJyIC8+XG4gICAqIFRoZSBsYXR0ZXIgaXMgYSBkZXByZWNhdGVkIG1ldGhvZCBiZWNhdXNlIGl0IGxlYWRzIHRvIGNvbmZ1c2lvbiBhbmQgd2lsbCBiZVxuICAgKiByZW1vdmVkIGluIHYyLjxiciAvPlxuICAgKiBBZGRpdGlvbmFsbHksIGl0IGFjY2VwdHMgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMgYmV0d2VlbiBkaWZmZXJlbnQgdW5pdHMuXG4gICAqIE5vdGUgdGhhdCBtdWx0aXBsaWNhdGlvbnMgYW5kIGRpdmlzaW9ucyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBWYWxpZCBleGFtcGxlcyBhcmU6XG4gICAqIGBgYFxuICAgKiAxMFxuICAgKiAnMTAlJ1xuICAgKiAnMTAsIDEwJ1xuICAgKiAnMTAlLCAxMCdcbiAgICogJzEwICsgMTAlJ1xuICAgKiAnMTAgLSA1dmggKyAzJSdcbiAgICogJy0xMHB4ICsgNXZoLCA1cHggLSA2JSdcbiAgICogYGBgXG4gICAqID4gKipOQioqOiBJZiB5b3UgZGVzaXJlIHRvIGFwcGx5IG9mZnNldHMgdG8geW91ciBwb3BwZXJzIGluIGEgd2F5IHRoYXQgbWF5IG1ha2UgdGhlbSBvdmVybGFwXG4gICAqID4gd2l0aCB0aGVpciByZWZlcmVuY2UgZWxlbWVudCwgdW5mb3J0dW5hdGVseSwgeW91IHdpbGwgaGF2ZSB0byBkaXNhYmxlIHRoZSBgZmxpcGAgbW9kaWZpZXIuXG4gICAqID4gWW91IGNhbiByZWFkIG1vcmUgb24gdGhpcyBhdCB0aGlzIFtpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvaXNzdWVzLzM3MykuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBvZmZzZXQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAyMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBvZmZzZXQsXG4gICAgLyoqIEBwcm9wIHtOdW1iZXJ8U3RyaW5nfSBvZmZzZXQ9MFxuICAgICAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIG9mZnNldDogMFxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHByZXZlbnQgdGhlIHBvcHBlciBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgb3V0c2lkZSB0aGUgYm91bmRhcnkuXG4gICAqXG4gICAqIEEgc2NlbmFyaW8gZXhpc3RzIHdoZXJlIHRoZSByZWZlcmVuY2UgaXRzZWxmIGlzIG5vdCB3aXRoaW4gdGhlIGJvdW5kYXJpZXMuPGJyIC8+XG4gICAqIFdlIGNhbiBzYXkgaXQgaGFzIFwiZXNjYXBlZCB0aGUgYm91bmRhcmllc1wiIOKAlCBvciBqdXN0IFwiZXNjYXBlZFwiLjxiciAvPlxuICAgKiBJbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBkZWNpZGUgd2hldGhlciB0aGUgcG9wcGVyIHNob3VsZCBlaXRoZXI6XG4gICAqXG4gICAqIC0gZGV0YWNoIGZyb20gdGhlIHJlZmVyZW5jZSBhbmQgcmVtYWluIFwidHJhcHBlZFwiIGluIHRoZSBib3VuZGFyaWVzLCBvclxuICAgKiAtIGlmIGl0IHNob3VsZCBpZ25vcmUgdGhlIGJvdW5kYXJ5IGFuZCBcImVzY2FwZSB3aXRoIGl0cyByZWZlcmVuY2VcIlxuICAgKlxuICAgKiBXaGVuIGBlc2NhcGVXaXRoUmVmZXJlbmNlYCBpcyBzZXQgdG9gdHJ1ZWAgYW5kIHJlZmVyZW5jZSBpcyBjb21wbGV0ZWx5XG4gICAqIG91dHNpZGUgaXRzIGJvdW5kYXJpZXMsIHRoZSBwb3BwZXIgd2lsbCBvdmVyZmxvdyAob3IgY29tcGxldGVseSBsZWF2ZSlcbiAgICogdGhlIGJvdW5kYXJpZXMgaW4gb3JkZXIgdG8gcmVtYWluIGF0dGFjaGVkIHRvIHRoZSBlZGdlIG9mIHRoZSByZWZlcmVuY2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAzMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gICAgLyoqXG4gICAgICogQHByb3Age0FycmF5fSBbcHJpb3JpdHk9WydsZWZ0JywncmlnaHQnLCd0b3AnLCdib3R0b20nXV1cbiAgICAgKiBQb3BwZXIgd2lsbCB0cnkgdG8gcHJldmVudCBvdmVyZmxvdyBmb2xsb3dpbmcgdGhlc2UgcHJpb3JpdGllcyBieSBkZWZhdWx0LFxuICAgICAqIHRoZW4sIGl0IGNvdWxkIG92ZXJmbG93IG9uIHRoZSBsZWZ0IGFuZCBvbiB0b3Agb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwcmlvcml0eTogWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBBbW91bnQgb2YgcGl4ZWwgdXNlZCB0byBkZWZpbmUgYSBtaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvdW5kYXJpZXNcbiAgICAgKiBhbmQgdGhlIHBvcHBlci4gVGhpcyBtYWtlcyBzdXJlIHRoZSBwb3BwZXIgYWx3YXlzIGhhcyBhIGxpdHRsZSBwYWRkaW5nXG4gICAgICogYmV0d2VlbiB0aGUgZWRnZXMgb2YgaXRzIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3Njcm9sbFBhcmVudCdcbiAgICAgKiBCb3VuZGFyaWVzIHVzZWQgYnkgdGhlIG1vZGlmaWVyLiBDYW4gYmUgYHNjcm9sbFBhcmVudGAsIGB3aW5kb3dgLFxuICAgICAqIGB2aWV3cG9ydGAgb3IgYW55IERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgcmVmZXJlbmNlIGFuZCBpdHMgcG9wcGVyIHN0YXkgbmVhciBlYWNoIG90aGVyXG4gICAqIHdpdGhvdXQgbGVhdmluZyBhbnkgZ2FwIGJldHdlZW4gdGhlIHR3by4gRXNwZWNpYWxseSB1c2VmdWwgd2hlbiB0aGUgYXJyb3cgaXNcbiAgICogZW5hYmxlZCBhbmQgeW91IHdhbnQgdG8gZW5zdXJlIHRoYXQgaXQgcG9pbnRzIHRvIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogSXQgY2FyZXMgb25seSBhYm91dCB0aGUgZmlyc3QgYXhpcy4gWW91IGNhbiBzdGlsbCBoYXZlIHBvcHBlcnMgd2l0aCBtYXJnaW5cbiAgICogYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBrZWVwVG9nZXRoZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NDAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA0MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBrZWVwVG9nZXRoZXJcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtb2RpZmllciBpcyB1c2VkIHRvIG1vdmUgdGhlIGBhcnJvd0VsZW1lbnRgIG9mIHRoZSBwb3BwZXIgdG8gbWFrZVxuICAgKiBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYW5kIGl0cyBwb3BwZXIgZWxlbWVudC5cbiAgICogSXQgd2lsbCByZWFkIHRoZSBvdXRlciBzaXplIG9mIHRoZSBgYXJyb3dFbGVtZW50YCBub2RlIHRvIGRldGVjdCBob3cgbWFueVxuICAgKiBwaXhlbHMgb2YgY29uanVuY3Rpb24gYXJlIG5lZWRlZC5cbiAgICpcbiAgICogSXQgaGFzIG5vIGVmZmVjdCBpZiBubyBgYXJyb3dFbGVtZW50YCBpcyBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFycm93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXJyb3csXG4gICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICBlbGVtZW50OiAnW3gtYXJyb3ddJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGZsaXAgdGhlIHBvcHBlcidzIHBsYWNlbWVudCB3aGVuIGl0IHN0YXJ0cyB0byBvdmVybGFwIGl0c1xuICAgKiByZWZlcmVuY2UgZWxlbWVudC5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKlxuICAgKiAqKk5PVEU6KiogdGhpcyBtb2RpZmllciB3aWxsIGludGVycnVwdCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUgYW5kIHdpbGxcbiAgICogcmVzdGFydCBpdCBpZiBpdCBkZXRlY3RzIHRoZSBuZWVkIHRvIGZsaXAgdGhlIHBsYWNlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGZsaXA6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA2MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBmbGlwLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8QXJyYXl9IGJlaGF2aW9yPSdmbGlwJ1xuICAgICAqIFRoZSBiZWhhdmlvciB1c2VkIHRvIGNoYW5nZSB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50LiBJdCBjYW4gYmUgb25lIG9mXG4gICAgICogYGZsaXBgLCBgY2xvY2t3aXNlYCwgYGNvdW50ZXJjbG9ja3dpc2VgIG9yIGFuIGFycmF5IHdpdGggYSBsaXN0IG9mIHZhbGlkXG4gICAgICogcGxhY2VtZW50cyAod2l0aCBvcHRpb25hbCB2YXJpYXRpb25zKVxuICAgICAqL1xuICAgIGJlaGF2aW9yOiAnZmxpcCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogVGhlIHBvcHBlciB3aWxsIGZsaXAgaWYgaXQgaGl0cyB0aGUgZWRnZXMgb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSd2aWV3cG9ydCdcbiAgICAgKiBUaGUgZWxlbWVudCB3aGljaCB3aWxsIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcG9wcGVyIHBvc2l0aW9uLlxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgZGVmaW5lZCBib3VuZGFyaWVzXG4gICAgICogKGV4Y2VwdCBpZiBga2VlcFRvZ2V0aGVyYCBpcyBlbmFibGVkKVxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAndmlld3BvcnQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSB0aGUgcG9wcGVyIGZsb3cgdG93YXJkIHRoZSBpbm5lciBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEJ5IGRlZmF1bHQsIHdoZW4gdGhpcyBtb2RpZmllciBpcyBkaXNhYmxlZCwgdGhlIHBvcHBlciB3aWxsIGJlIHBsYWNlZCBvdXRzaWRlXG4gICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGlubmVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTcwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD1mYWxzZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBpbm5lclxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGhpZGUgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXRzaWRlIG9mIHRoZVxuICAgKiBwb3BwZXIgYm91bmRhcmllcy4gSXQgd2lsbCBzZXQgYSBgeC1vdXQtb2YtYm91bmRhcmllc2AgYXR0cmlidXRlIHdoaWNoIGNhblxuICAgKiBiZSB1c2VkIHRvIGhpZGUgd2l0aCBhIENTUyBzZWxlY3RvciB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBpc1xuICAgKiBvdXQgb2YgYm91bmRhcmllcy5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaGlkZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDgwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGhpZGVcbiAgfSxcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHN0eWxlIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgZWxlbWVudCB0byBnZXRzXG4gICAqIHByb3Blcmx5IHBvc2l0aW9uZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1vZGlmaWVyIHdpbGwgbm90IHRvdWNoIHRoZSBET00sIGl0IGp1c3QgcHJlcGFyZXMgdGhlIHN0eWxlc1xuICAgKiBzbyB0aGF0IGBhcHBseVN0eWxlYCBtb2RpZmllciBjYW4gYXBwbHkgaXQuIFRoaXMgc2VwYXJhdGlvbiBpcyB1c2VmdWxcbiAgICogaW4gY2FzZSB5b3UgbmVlZCB0byByZXBsYWNlIGBhcHBseVN0eWxlYCB3aXRoIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBUaGlzIG1vZGlmaWVyIGhhcyBgODUwYCBhcyBgb3JkZXJgIHZhbHVlIHRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICogd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBQb3BwZXIuanMuIEV4cGVjdCB0aGUgbW9kaWZpZXJzIG9yZGVyaW5nIG1ldGhvZFxuICAgKiB0byBjaGFuZ2UgaW4gZnV0dXJlIG1ham9yIHZlcnNpb25zIG9mIHRoZSBsaWJyYXJ5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgY29tcHV0ZVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTg1MCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODUwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogY29tcHV0ZVN0eWxlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nYm90dG9tJ11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFggYXhpcyAoYGJvdHRvbWAgb3IgYHRvcGApLiBBS0EgWCBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGBib3R0b21gXG4gICAgICovXG4gICAgeDogJ2JvdHRvbScsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2xlZnQnXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWSBheGlzIChgbGVmdGAgb3IgYHJpZ2h0YCkuIEFLQSBZIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYHJpZ2h0YFxuICAgICAqL1xuICAgIHk6ICdyaWdodCdcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudC5cbiAgICpcbiAgICogQWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyBhcmUgbGltaXRlZCB0byB0aGlzIG1vZGlmaWVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlXG4gICAqIHlvdSB3YW50IHRvIGludGVncmF0ZSBQb3BwZXIuanMgaW5zaWRlIGEgZnJhbWV3b3JrIG9yIHZpZXcgbGlicmFyeSBhbmQgeW91XG4gICAqIHdhbnQgdG8gZGVsZWdhdGUgYWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyB0byBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkaXNhYmxlIHRoaXMgbW9kaWZpZXIsIHlvdSBtdXN0IG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogaGFzIGl0cyBwb3NpdGlvbiBzZXQgdG8gYGFic29sdXRlYCBiZWZvcmUgUG9wcGVyLmpzIGNhbiBkbyBpdHMgd29yayFcbiAgICpcbiAgICogSnVzdCBkaXNhYmxlIHRoaXMgbW9kaWZpZXIgYW5kIGRlZmluZSB5b3VyIG93biB0byBhY2hpZXZlIHRoZSBkZXNpcmVkIGVmZmVjdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFwcGx5U3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9OTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA5MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcHBseVN0eWxlLFxuICAgIC8qKiBAcHJvcCB7RnVuY3Rpb259ICovXG4gICAgb25Mb2FkOiBhcHBseVN0eWxlT25Mb2FkLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xMC4wLCB0aGUgcHJvcGVydHkgbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXJcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHVuZGVmaW5lZFxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBgZGF0YU9iamVjdGAgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBpbmZvcm1hdGlvbiB1c2VkIGJ5IFBvcHBlci5qcy5cbiAqIFRoaXMgb2JqZWN0IGlzIHBhc3NlZCB0byBtb2RpZmllcnMgYW5kIHRvIHRoZSBgb25DcmVhdGVgIGFuZCBgb25VcGRhdGVgIGNhbGxiYWNrcy5cbiAqIEBuYW1lIGRhdGFPYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmluc3RhbmNlIFRoZSBQb3BwZXIuanMgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLnBsYWNlbWVudCBQbGFjZW1lbnQgYXBwbGllZCB0byBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50IFBsYWNlbWVudCBvcmlnaW5hbGx5IGRlZmluZWQgb24gaW5pdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmZsaXBwZWQgVHJ1ZSBpZiBwb3BwZXIgaGFzIGJlZW4gZmxpcHBlZCBieSBmbGlwIG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuaGlkZSBUcnVlIGlmIHRoZSByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXQgb2YgYm91bmRhcmllcywgdXNlZnVsIHRvIGtub3cgd2hlbiB0byBoaWRlIHRoZSBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGRhdGEuYXJyb3dFbGVtZW50IE5vZGUgdXNlZCBhcyBhcnJvdyBieSBhcnJvdyBtb2RpZmllclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuc3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYXJyb3dTdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgYXJyb3cuIEl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5ib3VuZGFyaWVzIE9mZnNldHMgb2YgdGhlIHBvcHBlciBib3VuZGFyaWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzIFRoZSBtZWFzdXJlbWVudHMgb2YgcG9wcGVyLCByZWZlcmVuY2UgYW5kIGFycm93IGVsZW1lbnRzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnBvcHBlciBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucmVmZXJlbmNlIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5hcnJvd10gYHRvcGAgYW5kIGBsZWZ0YCBvZmZzZXRzLCBvbmx5IG9uZSBvZiB0aGVtIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gMFxuICovXG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIHByb3ZpZGVkIHRvIFBvcHBlci5qcyBjb25zdHJ1Y3Rvci48YnIgLz5cbiAqIFRoZXNlIGNhbiBiZSBvdmVycmlkZGVuIHVzaW5nIHRoZSBgb3B0aW9uc2AgYXJndW1lbnQgb2YgUG9wcGVyLmpzLjxiciAvPlxuICogVG8gb3ZlcnJpZGUgYW4gb3B0aW9uLCBzaW1wbHkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZVxuICogc3RydWN0dXJlIG9mIHRoZSBgb3B0aW9uc2Agb2JqZWN0LCBhcyB0aGUgM3JkIGFyZ3VtZW50LiBGb3IgZXhhbXBsZTpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWYsIHBvcCwge1xuICogICBtb2RpZmllcnM6IHtcbiAqICAgICBwcmV2ZW50T3ZlcmZsb3c6IHsgZW5hYmxlZDogZmFsc2UgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgRGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBQb3BwZXIncyBwbGFjZW1lbnQuXG4gICAqIEBwcm9wIHtQb3BwZXIucGxhY2VtZW50c30gcGxhY2VtZW50PSdib3R0b20nXG4gICAqL1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuXG4gIC8qKlxuICAgKiBTZXQgdGhpcyB0byB0cnVlIGlmIHlvdSB3YW50IHBvcHBlciB0byBwb3NpdGlvbiBpdCBzZWxmIGluICdmaXhlZCcgbW9kZVxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcG9zaXRpb25GaXhlZD1mYWxzZVxuICAgKi9cbiAgcG9zaXRpb25GaXhlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZXZlbnRzIChyZXNpemUsIHNjcm9sbCkgYXJlIGluaXRpYWxseSBlbmFibGVkLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gZXZlbnRzRW5hYmxlZD10cnVlXG4gICAqL1xuICBldmVudHNFbmFibGVkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgcG9wcGVyIHdoZW5cbiAgICogeW91IGNhbGwgdGhlIGBkZXN0cm95YCBtZXRob2QuXG4gICAqIEBwcm9wIHtCb29sZWFufSByZW1vdmVPbkRlc3Ryb3k9ZmFsc2VcbiAgICovXG4gIHJlbW92ZU9uRGVzdHJveTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgY3JlYXRlZC48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25DcmVhdGV9XG4gICAqL1xuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICogb24gdGhlIGluaXRpYWxpemF0aW9uL2NyZWF0aW9uIG9mIHRoZSBwb3BwZXIsIGJ1dCBvbmx5IG9uIHN1YnNlcXVlbnRcbiAgICogdXBkYXRlcy48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25VcGRhdGV9XG4gICAqL1xuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoKSB7fSxcblxuICAvKipcbiAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICogVGhleSBwcm92aWRlIG1vc3Qgb2YgdGhlIGZ1bmN0aW9uYWxpdGllcyBvZiBQb3BwZXIuanMuXG4gICAqIEBwcm9wIHttb2RpZmllcnN9XG4gICAqL1xuICBtb2RpZmllcnM6IG1vZGlmaWVyc1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgb25DcmVhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9uVXBkYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vLyBVdGlsc1xuLy8gTWV0aG9kc1xudmFyIFBvcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUG9wcGVyLmpzIGluc3RhbmNlLlxuICAgKiBAY2xhc3MgUG9wcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8cmVmZXJlbmNlT2JqZWN0fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gWW91ciBjdXN0b20gb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgb25lcyBkZWZpbmVkIGluIFtEZWZhdWx0c10oI2RlZmF1bHRzKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluc3RhbmNlIC0gVGhlIGdlbmVyYXRlZCBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHBlcihyZWZlcmVuY2UsIHBvcHBlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wcGVyKTtcblxuICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLnVwZGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIG1ha2UgdXBkYXRlKCkgZGVib3VuY2VkLCBzbyB0aGF0IGl0IG9ubHkgcnVucyBhdCBtb3N0IG9uY2UtcGVyLXRpY2tcbiAgICB0aGlzLnVwZGF0ZSA9IGRlYm91bmNlKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gd2l0aCB7fSB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG9wdGlvbnMgaW5zaWRlIGl0XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAvLyBpbml0IHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAgIGlzQ3JlYXRlZDogZmFsc2UsXG4gICAgICBzY3JvbGxQYXJlbnRzOiBbXVxuICAgIH07XG5cbiAgICAvLyBnZXQgcmVmZXJlbmNlIGFuZCBwb3BwZXIgZWxlbWVudHMgKGFsbG93IGpRdWVyeSB3cmFwcGVycylcbiAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuanF1ZXJ5ID8gcmVmZXJlbmNlWzBdIDogcmVmZXJlbmNlO1xuICAgIHRoaXMucG9wcGVyID0gcG9wcGVyICYmIHBvcHBlci5qcXVlcnkgPyBwb3BwZXJbMF0gOiBwb3BwZXI7XG5cbiAgICAvLyBEZWVwIG1lcmdlIG1vZGlmaWVycyBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zLm1vZGlmaWVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzLCBvcHRpb25zLm1vZGlmaWVycykpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnNbbmFtZV0gfHwge30sIG9wdGlvbnMubW9kaWZpZXJzID8gb3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gOiB7fSk7XG4gICAgfSk7XG5cbiAgICAvLyBSZWZhY3RvcmluZyBtb2RpZmllcnMnIGxpc3QgKE9iamVjdCA9PiBBcnJheSlcbiAgICB0aGlzLm1vZGlmaWVycyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2RpZmllcnMpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0pO1xuICAgIH0pXG4gICAgLy8gc29ydCB0aGUgbW9kaWZpZXJzIGJ5IG9yZGVyXG4gICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICB9KTtcblxuICAgIC8vIG1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgd2hlbiBQb3BwZXIuanMgZ2V0IGluaXRlZFxuICAgIC8vIHN1Y2ggY29kZSBpcyBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBvZiBpdHMgbW9kaWZpZXJcbiAgICAvLyB0aGV5IGNvdWxkIGFkZCBuZXcgcHJvcGVydGllcyB0byB0aGVpciBvcHRpb25zIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBCRSBBV0FSRTogZG9uJ3QgYWRkIG9wdGlvbnMgdG8gYG9wdGlvbnMubW9kaWZpZXJzLm5hbWVgIGJ1dCB0byBgbW9kaWZpZXJPcHRpb25zYCFcbiAgICB0aGlzLm1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck9wdGlvbnMpIHtcbiAgICAgIGlmIChtb2RpZmllck9wdGlvbnMuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQpKSB7XG4gICAgICAgIG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQoX3RoaXMucmVmZXJlbmNlLCBfdGhpcy5wb3BwZXIsIF90aGlzLm9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgX3RoaXMuc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmlyZSB0aGUgZmlyc3QgdXBkYXRlIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIHZhciBldmVudHNFbmFibGVkID0gdGhpcy5vcHRpb25zLmV2ZW50c0VuYWJsZWQ7XG4gICAgaWYgKGV2ZW50c0VuYWJsZWQpIHtcbiAgICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVycywgdGhleSB3aWxsIHRha2UgY2FyZSBvZiB1cGRhdGUgdGhlIHBvc2l0aW9uIGluIHNwZWNpZmljIHNpdHVhdGlvbnNcbiAgICAgIHRoaXMuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQgPSBldmVudHNFbmFibGVkO1xuICB9XG5cbiAgLy8gV2UgY2FuJ3QgdXNlIGNsYXNzIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGRvbid0IGdldCBsaXN0ZWQgaW4gdGhlXG4gIC8vIGNsYXNzIHByb3RvdHlwZSBhbmQgYnJlYWsgc3R1ZmYgbGlrZSBTaW5vbiBzdHVic1xuXG5cbiAgY3JlYXRlQ2xhc3MoUG9wcGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSQkMSgpIHtcbiAgICAgIHJldHVybiB1cGRhdGUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSQkMSgpIHtcbiAgICAgIHJldHVybiBkZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBlbmFibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYW4gdXBkYXRlLiBJdCB3aWxsIHJ1biBvbiB0aGUgbmV4dCBVSSB1cGRhdGUgYXZhaWxhYmxlLlxuICAgICAqIEBtZXRob2Qgc2NoZWR1bGVVcGRhdGVcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIENvbGxlY3Rpb24gb2YgdXRpbGl0aWVzIHVzZWZ1bCB3aGVuIHdyaXRpbmcgY3VzdG9tIG1vZGlmaWVycy5cbiAgICAgKiBTdGFydGluZyBmcm9tIHZlcnNpb24gMS43LCB0aGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgb25seSBpZiB5b3VcbiAgICAgKiBpbmNsdWRlIGBwb3BwZXItdXRpbHMuanNgIGJlZm9yZSBgcG9wcGVyLmpzYC5cbiAgICAgKlxuICAgICAqICoqREVQUkVDQVRJT04qKjogVGhpcyB3YXkgdG8gYWNjZXNzIFBvcHBlclV0aWxzIGlzIGRlcHJlY2F0ZWRcbiAgICAgKiBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHYyISBVc2UgdGhlIFBvcHBlclV0aWxzIG1vZHVsZSBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAqIER1ZSB0byB0aGUgaGlnaCBpbnN0YWJpbGl0eSBvZiB0aGUgbWV0aG9kcyBjb250YWluZWQgaW4gVXRpbHMsIHdlIGNhbid0XG4gICAgICogZ3VhcmFudGVlIHRoZW0gdG8gZm9sbG93IHNlbXZlci4gVXNlIHRoZW0gYXQgeW91ciBvd24gcmlzayFcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS44XG4gICAgICogQG1lbWJlciBVdGlsc1xuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKi9cblxuICB9XSk7XG4gIHJldHVybiBQb3BwZXI7XG59KCk7XG5cbi8qKlxuICogVGhlIGByZWZlcmVuY2VPYmplY3RgIGlzIGFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIGFuIGludGVyZmFjZSBjb21wYXRpYmxlIHdpdGggUG9wcGVyLmpzXG4gKiBhbmQgbGV0cyB5b3UgdXNlIGl0IGFzIHJlcGxhY2VtZW50IG9mIGEgcmVhbCBET00gbm9kZS48YnIgLz5cbiAqIFlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kIHRvIHBvc2l0aW9uIGEgcG9wcGVyIHJlbGF0aXZlbHkgdG8gYSBzZXQgb2YgY29vcmRpbmF0ZXNcbiAqIGluIGNhc2UgeW91IGRvbid0IGhhdmUgYSBET00gbm9kZSB0byB1c2UgYXMgcmVmZXJlbmNlLlxuICpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWZlcmVuY2VPYmplY3QsIHBvcHBlck5vZGUpO1xuICogYGBgXG4gKlxuICogTkI6IFRoaXMgZmVhdHVyZSBpc24ndCBzdXBwb3J0ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAuXG4gKiBAbmFtZSByZWZlcmVuY2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBjb29yZGluYXRlcyBjb21wYXRpYmxlIHdpdGggdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBtZXRob2QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRXaWR0aFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudEhlaWdodFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cblxuXG5Qb3BwZXIuVXRpbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpLlBvcHBlclV0aWxzO1xuUG9wcGVyLnBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuUG9wcGVyLkRlZmF1bHRzID0gRGVmYXVsdHM7XG5cbmV4cG9ydCBkZWZhdWx0IFBvcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci5qcy5tYXBcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuMy4xKTogZHJvcGRvd24uanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSdcbmltcG9ydCBQb3BwZXIgZnJvbSAncG9wcGVyLmpzJ1xuaW1wb3J0IFV0aWwgZnJvbSAnLi91dGlsJ1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FICAgICAgICAgICAgICAgICAgICAgPSAnZHJvcGRvd24nXG5jb25zdCBWRVJTSU9OICAgICAgICAgICAgICAgICAgPSAnNC4zLjEnXG5jb25zdCBEQVRBX0tFWSAgICAgICAgICAgICAgICAgPSAnYnMuZHJvcGRvd24nXG5jb25zdCBFVkVOVF9LRVkgICAgICAgICAgICAgICAgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgREFUQV9BUElfS0VZICAgICAgICAgICAgID0gJy5kYXRhLWFwaSdcbmNvbnN0IEpRVUVSWV9OT19DT05GTElDVCAgICAgICA9ICQuZm5bTkFNRV1cbmNvbnN0IEVTQ0FQRV9LRVlDT0RFICAgICAgICAgICA9IDI3IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIEVzY2FwZSAoRXNjKSBrZXlcbmNvbnN0IFNQQUNFX0tFWUNPREUgICAgICAgICAgICA9IDMyIC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIHNwYWNlIGtleVxuY29uc3QgVEFCX0tFWUNPREUgICAgICAgICAgICAgID0gOSAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciB0YWIga2V5XG5jb25zdCBBUlJPV19VUF9LRVlDT0RFICAgICAgICAgPSAzOCAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciB1cCBhcnJvdyBrZXlcbmNvbnN0IEFSUk9XX0RPV05fS0VZQ09ERSAgICAgICA9IDQwIC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIGRvd24gYXJyb3cga2V5XG5jb25zdCBSSUdIVF9NT1VTRV9CVVRUT05fV0hJQ0ggPSAzIC8vIE1vdXNlRXZlbnQud2hpY2ggdmFsdWUgZm9yIHRoZSByaWdodCBidXR0b24gKGFzc3VtaW5nIGEgcmlnaHQtaGFuZGVkIG1vdXNlKVxuY29uc3QgUkVHRVhQX0tFWURPV04gICAgICAgICAgID0gbmV3IFJlZ0V4cChgJHtBUlJPV19VUF9LRVlDT0RFfXwke0FSUk9XX0RPV05fS0VZQ09ERX18JHtFU0NBUEVfS0VZQ09ERX1gKVxuXG5jb25zdCBFdmVudCA9IHtcbiAgSElERSAgICAgICAgICAgICA6IGBoaWRlJHtFVkVOVF9LRVl9YCxcbiAgSElEREVOICAgICAgICAgICA6IGBoaWRkZW4ke0VWRU5UX0tFWX1gLFxuICBTSE9XICAgICAgICAgICAgIDogYHNob3cke0VWRU5UX0tFWX1gLFxuICBTSE9XTiAgICAgICAgICAgIDogYHNob3duJHtFVkVOVF9LRVl9YCxcbiAgQ0xJQ0sgICAgICAgICAgICA6IGBjbGljayR7RVZFTlRfS0VZfWAsXG4gIENMSUNLX0RBVEFfQVBJICAgOiBgY2xpY2ske0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gLFxuICBLRVlET1dOX0RBVEFfQVBJIDogYGtleWRvd24ke0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gLFxuICBLRVlVUF9EQVRBX0FQSSAgIDogYGtleXVwJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxufVxuXG5jb25zdCBDbGFzc05hbWUgPSB7XG4gIERJU0FCTEVEICAgICAgICA6ICdkaXNhYmxlZCcsXG4gIFNIT1cgICAgICAgICAgICA6ICdzaG93JyxcbiAgRFJPUFVQICAgICAgICAgIDogJ2Ryb3B1cCcsXG4gIERST1BSSUdIVCAgICAgICA6ICdkcm9wcmlnaHQnLFxuICBEUk9QTEVGVCAgICAgICAgOiAnZHJvcGxlZnQnLFxuICBNRU5VUklHSFQgICAgICAgOiAnZHJvcGRvd24tbWVudS1yaWdodCcsXG4gIE1FTlVMRUZUICAgICAgICA6ICdkcm9wZG93bi1tZW51LWxlZnQnLFxuICBQT1NJVElPTl9TVEFUSUMgOiAncG9zaXRpb24tc3RhdGljJ1xufVxuXG5jb25zdCBTZWxlY3RvciA9IHtcbiAgREFUQV9UT0dHTEUgICA6ICdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXScsXG4gIEZPUk1fQ0hJTEQgICAgOiAnLmRyb3Bkb3duIGZvcm0nLFxuICBNRU5VICAgICAgICAgIDogJy5kcm9wZG93bi1tZW51JyxcbiAgTkFWQkFSX05BViAgICA6ICcubmF2YmFyLW5hdicsXG4gIFZJU0lCTEVfSVRFTVMgOiAnLmRyb3Bkb3duLW1lbnUgLmRyb3Bkb3duLWl0ZW06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZCknXG59XG5cbmNvbnN0IEF0dGFjaG1lbnRNYXAgPSB7XG4gIFRPUCAgICAgICA6ICd0b3Atc3RhcnQnLFxuICBUT1BFTkQgICAgOiAndG9wLWVuZCcsXG4gIEJPVFRPTSAgICA6ICdib3R0b20tc3RhcnQnLFxuICBCT1RUT01FTkQgOiAnYm90dG9tLWVuZCcsXG4gIFJJR0hUICAgICA6ICdyaWdodC1zdGFydCcsXG4gIFJJR0hURU5EICA6ICdyaWdodC1lbmQnLFxuICBMRUZUICAgICAgOiAnbGVmdC1zdGFydCcsXG4gIExFRlRFTkQgICA6ICdsZWZ0LWVuZCdcbn1cblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgb2Zmc2V0ICAgIDogMCxcbiAgZmxpcCAgICAgIDogdHJ1ZSxcbiAgYm91bmRhcnkgIDogJ3Njcm9sbFBhcmVudCcsXG4gIHJlZmVyZW5jZSA6ICd0b2dnbGUnLFxuICBkaXNwbGF5ICAgOiAnZHluYW1pYydcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIG9mZnNldCAgICA6ICcobnVtYmVyfHN0cmluZ3xmdW5jdGlvbiknLFxuICBmbGlwICAgICAgOiAnYm9vbGVhbicsXG4gIGJvdW5kYXJ5ICA6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgcmVmZXJlbmNlIDogJyhzdHJpbmd8ZWxlbWVudCknLFxuICBkaXNwbGF5ICAgOiAnc3RyaW5nJ1xufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgRHJvcGRvd24ge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICB0aGlzLl9lbGVtZW50ICA9IGVsZW1lbnRcbiAgICB0aGlzLl9wb3BwZXIgICA9IG51bGxcbiAgICB0aGlzLl9jb25maWcgICA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpXG4gICAgdGhpcy5fbWVudSAgICAgPSB0aGlzLl9nZXRNZW51RWxlbWVudCgpXG4gICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKVxuXG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZVxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50LmRpc2FibGVkIHx8ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkRJU0FCTEVEKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50ICAgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudClcbiAgICBjb25zdCBpc0FjdGl2ZSA9ICQodGhpcy5fbWVudSkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG5cbiAgICBEcm9wZG93bi5fY2xlYXJNZW51cygpXG5cbiAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfVxuICAgIGNvbnN0IHNob3dFdmVudCA9ICQuRXZlbnQoRXZlbnQuU0hPVywgcmVsYXRlZFRhcmdldClcblxuICAgICQocGFyZW50KS50cmlnZ2VyKHNob3dFdmVudClcblxuICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIERpc2FibGUgdG90YWxseSBQb3BwZXIuanMgZm9yIERyb3Bkb3duIGluIE5hdmJhclxuICAgIGlmICghdGhpcy5faW5OYXZiYXIpIHtcbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2sgZm9yIFBvcHBlciBkZXBlbmRlbmN5XG4gICAgICAgKiBQb3BwZXIgLSBodHRwczovL3BvcHBlci5qcy5vcmdcbiAgICAgICAqL1xuICAgICAgaWYgKHR5cGVvZiBQb3BwZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgZHJvcGRvd25zIHJlcXVpcmUgUG9wcGVyLmpzIChodHRwczovL3BvcHBlci5qcy5vcmcvKScpXG4gICAgICB9XG5cbiAgICAgIGxldCByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fZWxlbWVudFxuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PT0gJ3BhcmVudCcpIHtcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHBhcmVudFxuICAgICAgfSBlbHNlIGlmIChVdGlsLmlzRWxlbWVudCh0aGlzLl9jb25maWcucmVmZXJlbmNlKSkge1xuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fY29uZmlnLnJlZmVyZW5jZVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGl0J3MgalF1ZXJ5IGVsZW1lbnRcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcucmVmZXJlbmNlLmpxdWVyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fY29uZmlnLnJlZmVyZW5jZVswXVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGJvdW5kYXJ5IGlzIG5vdCBgc2Nyb2xsUGFyZW50YCwgdGhlbiBzZXQgcG9zaXRpb24gdG8gYHN0YXRpY2BcbiAgICAgIC8vIHRvIGFsbG93IHRoZSBtZW51IHRvIFwiZXNjYXBlXCIgdGhlIHNjcm9sbCBwYXJlbnQncyBib3VuZGFyaWVzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvaXNzdWVzLzI0MjUxXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmJvdW5kYXJ5ICE9PSAnc2Nyb2xsUGFyZW50Jykge1xuICAgICAgICAkKHBhcmVudCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLlBPU0lUSU9OX1NUQVRJQylcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BvcHBlciA9IG5ldyBQb3BwZXIocmVmZXJlbmNlRWxlbWVudCwgdGhpcy5fbWVudSwgdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKCkpXG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxuICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgdG8gdGhlIGJvZHkncyBpbW1lZGlhdGUgY2hpbGRyZW47XG4gICAgLy8gb25seSBuZWVkZWQgYmVjYXVzZSBvZiBicm9rZW4gZXZlbnQgZGVsZWdhdGlvbiBvbiBpT1NcbiAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmXG4gICAgICAgICQocGFyZW50KS5jbG9zZXN0KFNlbGVjdG9yLk5BVkJBUl9OQVYpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgJChkb2N1bWVudC5ib2R5KS5jaGlsZHJlbigpLm9uKCdtb3VzZW92ZXInLCBudWxsLCAkLm5vb3ApXG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudC5mb2N1cygpXG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKVxuXG4gICAgJCh0aGlzLl9tZW51KS50b2dnbGVDbGFzcyhDbGFzc05hbWUuU0hPVylcbiAgICAkKHBhcmVudClcbiAgICAgIC50b2dnbGVDbGFzcyhDbGFzc05hbWUuU0hPVylcbiAgICAgIC50cmlnZ2VyKCQuRXZlbnQoRXZlbnQuU0hPV04sIHJlbGF0ZWRUYXJnZXQpKVxuICB9XG5cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5kaXNhYmxlZCB8fCAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5ESVNBQkxFRCkgfHwgJCh0aGlzLl9tZW51KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfVxuICAgIGNvbnN0IHNob3dFdmVudCA9ICQuRXZlbnQoRXZlbnQuU0hPVywgcmVsYXRlZFRhcmdldClcbiAgICBjb25zdCBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudClcblxuICAgICQocGFyZW50KS50cmlnZ2VyKHNob3dFdmVudClcblxuICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgICQodGhpcy5fbWVudSkudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG4gICAgJChwYXJlbnQpXG4gICAgICAudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG4gICAgICAudHJpZ2dlcigkLkV2ZW50KEV2ZW50LlNIT1dOLCByZWxhdGVkVGFyZ2V0KSlcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuZGlzYWJsZWQgfHwgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRElTQUJMRUQpIHx8ICEkKHRoaXMuX21lbnUpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9XG4gICAgY29uc3QgaGlkZUV2ZW50ID0gJC5FdmVudChFdmVudC5ISURFLCByZWxhdGVkVGFyZ2V0KVxuICAgIGNvbnN0IHBhcmVudCA9IERyb3Bkb3duLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KVxuXG4gICAgJChwYXJlbnQpLnRyaWdnZXIoaGlkZUV2ZW50KVxuXG4gICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgJCh0aGlzLl9tZW51KS50b2dnbGVDbGFzcyhDbGFzc05hbWUuU0hPVylcbiAgICAkKHBhcmVudClcbiAgICAgIC50b2dnbGVDbGFzcyhDbGFzc05hbWUuU0hPVylcbiAgICAgIC50cmlnZ2VyKCQuRXZlbnQoRXZlbnQuSElEREVOLCByZWxhdGVkVGFyZ2V0KSlcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKVxuICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEVWRU5UX0tFWSlcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbFxuICAgIHRoaXMuX21lbnUgPSBudWxsXG4gICAgaWYgKHRoaXMuX3BvcHBlciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKVxuICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpXG4gICAgaWYgKHRoaXMuX3BvcHBlciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fcG9wcGVyLnNjaGVkdWxlVXBkYXRlKClcbiAgICB9XG4gIH1cblxuICAvLyBQcml2YXRlXG5cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICQodGhpcy5fZWxlbWVudCkub24oRXZlbnQuQ0xJQ0ssIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIHRoaXMudG9nZ2xlKClcbiAgICB9KVxuICB9XG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7XG4gICAgICAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAuLi4kKHRoaXMuX2VsZW1lbnQpLmRhdGEoKSxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH1cblxuICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKFxuICAgICAgTkFNRSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGVcbiAgICApXG5cbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICBfZ2V0TWVudUVsZW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9tZW51KSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudClcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICB0aGlzLl9tZW51ID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3IuTUVOVSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX21lbnVcbiAgfVxuXG4gIF9nZXRQbGFjZW1lbnQoKSB7XG4gICAgY29uc3QgJHBhcmVudERyb3Bkb3duID0gJCh0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUpXG4gICAgbGV0IHBsYWNlbWVudCA9IEF0dGFjaG1lbnRNYXAuQk9UVE9NXG5cbiAgICAvLyBIYW5kbGUgZHJvcHVwXG4gICAgaWYgKCRwYXJlbnREcm9wZG93bi5oYXNDbGFzcyhDbGFzc05hbWUuRFJPUFVQKSkge1xuICAgICAgcGxhY2VtZW50ID0gQXR0YWNobWVudE1hcC5UT1BcbiAgICAgIGlmICgkKHRoaXMuX21lbnUpLmhhc0NsYXNzKENsYXNzTmFtZS5NRU5VUklHSFQpKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IEF0dGFjaG1lbnRNYXAuVE9QRU5EXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgkcGFyZW50RHJvcGRvd24uaGFzQ2xhc3MoQ2xhc3NOYW1lLkRST1BSSUdIVCkpIHtcbiAgICAgIHBsYWNlbWVudCA9IEF0dGFjaG1lbnRNYXAuUklHSFRcbiAgICB9IGVsc2UgaWYgKCRwYXJlbnREcm9wZG93bi5oYXNDbGFzcyhDbGFzc05hbWUuRFJPUExFRlQpKSB7XG4gICAgICBwbGFjZW1lbnQgPSBBdHRhY2htZW50TWFwLkxFRlRcbiAgICB9IGVsc2UgaWYgKCQodGhpcy5fbWVudSkuaGFzQ2xhc3MoQ2xhc3NOYW1lLk1FTlVSSUdIVCkpIHtcbiAgICAgIHBsYWNlbWVudCA9IEF0dGFjaG1lbnRNYXAuQk9UVE9NRU5EXG4gICAgfVxuICAgIHJldHVybiBwbGFjZW1lbnRcbiAgfVxuXG4gIF9kZXRlY3ROYXZiYXIoKSB7XG4gICAgcmV0dXJuICQodGhpcy5fZWxlbWVudCkuY2xvc2VzdCgnLm5hdmJhcicpLmxlbmd0aCA+IDBcbiAgfVxuXG4gIF9nZXRPZmZzZXQoKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0ge31cblxuICAgIGlmICh0eXBlb2YgdGhpcy5fY29uZmlnLm9mZnNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb2Zmc2V0LmZuID0gKGRhdGEpID0+IHtcbiAgICAgICAgZGF0YS5vZmZzZXRzID0ge1xuICAgICAgICAgIC4uLmRhdGEub2Zmc2V0cyxcbiAgICAgICAgICAuLi50aGlzLl9jb25maWcub2Zmc2V0KGRhdGEub2Zmc2V0cywgdGhpcy5fZWxlbWVudCkgfHwge31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldC5vZmZzZXQgPSB0aGlzLl9jb25maWcub2Zmc2V0XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldFxuICB9XG5cbiAgX2dldFBvcHBlckNvbmZpZygpIHtcbiAgICBjb25zdCBwb3BwZXJDb25maWcgPSB7XG4gICAgICBwbGFjZW1lbnQ6IHRoaXMuX2dldFBsYWNlbWVudCgpLFxuICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KCksXG4gICAgICAgIGZsaXA6IHtcbiAgICAgICAgICBlbmFibGVkOiB0aGlzLl9jb25maWcuZmxpcFxuICAgICAgICB9LFxuICAgICAgICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAgICAgICBib3VuZGFyaWVzRWxlbWVudDogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXNhYmxlIFBvcHBlci5qcyBpZiB3ZSBoYXZlIGEgc3RhdGljIGRpc3BsYXlcbiAgICBpZiAodGhpcy5fY29uZmlnLmRpc3BsYXkgPT09ICdzdGF0aWMnKSB7XG4gICAgICBwb3BwZXJDb25maWcubW9kaWZpZXJzLmFwcGx5U3R5bGUgPSB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcHBlckNvbmZpZ1xuICB9XG5cbiAgLy8gU3RhdGljXG5cbiAgc3RhdGljIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSlcbiAgICAgIGNvbnN0IF9jb25maWcgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IG51bGxcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgRHJvcGRvd24odGhpcywgX2NvbmZpZylcbiAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHN0YXRpYyBfY2xlYXJNZW51cyhldmVudCkge1xuICAgIGlmIChldmVudCAmJiAoZXZlbnQud2hpY2ggPT09IFJJR0hUX01PVVNFX0JVVFRPTl9XSElDSCB8fFxuICAgICAgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC53aGljaCAhPT0gVEFCX0tFWUNPREUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB0b2dnbGVzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yLkRBVEFfVE9HR0xFKSlcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0b2dnbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodG9nZ2xlc1tpXSlcbiAgICAgIGNvbnN0IGNvbnRleHQgPSAkKHRvZ2dsZXNbaV0pLmRhdGEoREFUQV9LRVkpXG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0b2dnbGVzW2ldXG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudCAmJiBldmVudC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQuY2xpY2tFdmVudCA9IGV2ZW50XG4gICAgICB9XG5cbiAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkcm9wZG93bk1lbnUgPSBjb250ZXh0Ll9tZW51XG4gICAgICBpZiAoISQocGFyZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVykpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50ICYmIChldmVudC50eXBlID09PSAnY2xpY2snICYmXG4gICAgICAgICAgL2lucHV0fHRleHRhcmVhL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSkgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC53aGljaCA9PT0gVEFCX0tFWUNPREUpICYmXG4gICAgICAgICAgJC5jb250YWlucyhwYXJlbnQsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gJC5FdmVudChFdmVudC5ISURFLCByZWxhdGVkVGFyZ2V0KVxuICAgICAgJChwYXJlbnQpLnRyaWdnZXIoaGlkZUV2ZW50KVxuICAgICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgJChkb2N1bWVudC5ib2R5KS5jaGlsZHJlbigpLm9mZignbW91c2VvdmVyJywgbnVsbCwgJC5ub29wKVxuICAgICAgfVxuXG4gICAgICB0b2dnbGVzW2ldLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpXG5cbiAgICAgICQoZHJvcGRvd25NZW51KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVylcbiAgICAgICQocGFyZW50KVxuICAgICAgICAucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG4gICAgICAgIC50cmlnZ2VyKCQuRXZlbnQoRXZlbnQuSElEREVOLCByZWxhdGVkVGFyZ2V0KSlcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgX2dldFBhcmVudEZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICBsZXQgcGFyZW50XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudClcblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgcGFyZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcilcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50IHx8IGVsZW1lbnQucGFyZW50Tm9kZVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgc3RhdGljIF9kYXRhQXBpS2V5ZG93bkhhbmRsZXIoZXZlbnQpIHtcbiAgICAvLyBJZiBub3QgaW5wdXQvdGV4dGFyZWE6XG4gICAgLy8gIC0gQW5kIG5vdCBhIGtleSBpbiBSRUdFWFBfS0VZRE9XTiA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgLy8gSWYgaW5wdXQvdGV4dGFyZWE6XG4gICAgLy8gIC0gSWYgc3BhY2Uga2V5ID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcbiAgICAvLyAgLSBJZiBrZXkgaXMgb3RoZXIgdGhhbiBlc2NhcGVcbiAgICAvLyAgICAtIElmIGtleSBpcyBub3QgdXAgb3IgZG93biA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgLy8gICAgLSBJZiB0cmlnZ2VyIGluc2lkZSB0aGUgbWVudSA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpXG4gICAgICA/IGV2ZW50LndoaWNoID09PSBTUEFDRV9LRVlDT0RFIHx8IGV2ZW50LndoaWNoICE9PSBFU0NBUEVfS0VZQ09ERSAmJlxuICAgICAgKGV2ZW50LndoaWNoICE9PSBBUlJPV19ET1dOX0tFWUNPREUgJiYgZXZlbnQud2hpY2ggIT09IEFSUk9XX1VQX0tFWUNPREUgfHxcbiAgICAgICAgJChldmVudC50YXJnZXQpLmNsb3Nlc3QoU2VsZWN0b3IuTUVOVSkubGVuZ3RoKSA6ICFSRUdFWFBfS0VZRE9XTi50ZXN0KGV2ZW50LndoaWNoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAkKHRoaXMpLmhhc0NsYXNzKENsYXNzTmFtZS5ESVNBQkxFRCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudCAgID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMpXG4gICAgY29uc3QgaXNBY3RpdmUgPSAkKHBhcmVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG5cbiAgICBpZiAoIWlzQWN0aXZlIHx8IGlzQWN0aXZlICYmIChldmVudC53aGljaCA9PT0gRVNDQVBFX0tFWUNPREUgfHwgZXZlbnQud2hpY2ggPT09IFNQQUNFX0tFWUNPREUpKSB7XG4gICAgICBpZiAoZXZlbnQud2hpY2ggPT09IEVTQ0FQRV9LRVlDT0RFKSB7XG4gICAgICAgIGNvbnN0IHRvZ2dsZSA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yLkRBVEFfVE9HR0xFKVxuICAgICAgICAkKHRvZ2dsZSkudHJpZ2dlcignZm9jdXMnKVxuICAgICAgfVxuXG4gICAgICAkKHRoaXMpLnRyaWdnZXIoJ2NsaWNrJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1zID0gW10uc2xpY2UuY2FsbChwYXJlbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3Rvci5WSVNJQkxFX0lURU1TKSlcblxuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBpbmRleCA9IGl0ZW1zLmluZGV4T2YoZXZlbnQudGFyZ2V0KVxuXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSBBUlJPV19VUF9LRVlDT0RFICYmIGluZGV4ID4gMCkgeyAvLyBVcFxuICAgICAgaW5kZXgtLVxuICAgIH1cblxuICAgIGlmIChldmVudC53aGljaCA9PT0gQVJST1dfRE9XTl9LRVlDT0RFICYmIGluZGV4IDwgaXRlbXMubGVuZ3RoIC0gMSkgeyAvLyBEb3duXG4gICAgICBpbmRleCsrXG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgaW5kZXggPSAwXG4gICAgfVxuXG4gICAgaXRlbXNbaW5kZXhdLmZvY3VzKClcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQoZG9jdW1lbnQpXG4gIC5vbihFdmVudC5LRVlET1dOX0RBVEFfQVBJLCBTZWxlY3Rvci5EQVRBX1RPR0dMRSwgRHJvcGRvd24uX2RhdGFBcGlLZXlkb3duSGFuZGxlcilcbiAgLm9uKEV2ZW50LktFWURPV05fREFUQV9BUEksIFNlbGVjdG9yLk1FTlUsIERyb3Bkb3duLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIpXG4gIC5vbihgJHtFdmVudC5DTElDS19EQVRBX0FQSX0gJHtFdmVudC5LRVlVUF9EQVRBX0FQSX1gLCBEcm9wZG93bi5fY2xlYXJNZW51cylcbiAgLm9uKEV2ZW50LkNMSUNLX0RBVEFfQVBJLCBTZWxlY3Rvci5EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGhpcyksICd0b2dnbGUnKVxuICB9KVxuICAub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkZPUk1fQ0hJTEQsIChlKSA9PiB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICB9KVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kLmZuW05BTUVdID0gRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZVxuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IERyb3Bkb3duXG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgcmV0dXJuIERyb3Bkb3duLl9qUXVlcnlJbnRlcmZhY2Vcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBEcm9wZG93blxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4zLjEpOiBtb2RhbC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0IFV0aWwgZnJvbSAnLi91dGlsJ1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FICAgICAgICAgICAgICAgPSAnbW9kYWwnXG5jb25zdCBWRVJTSU9OICAgICAgICAgICAgPSAnNC4zLjEnXG5jb25zdCBEQVRBX0tFWSAgICAgICAgICAgPSAnYnMubW9kYWwnXG5jb25zdCBFVkVOVF9LRVkgICAgICAgICAgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgREFUQV9BUElfS0VZICAgICAgID0gJy5kYXRhLWFwaSdcbmNvbnN0IEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV1cbmNvbnN0IEVTQ0FQRV9LRVlDT0RFICAgICA9IDI3IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIEVzY2FwZSAoRXNjKSBrZXlcblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgYmFja2Ryb3AgOiB0cnVlLFxuICBrZXlib2FyZCA6IHRydWUsXG4gIGZvY3VzICAgIDogdHJ1ZSxcbiAgc2hvdyAgICAgOiB0cnVlXG59XG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBiYWNrZHJvcCA6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAga2V5Ym9hcmQgOiAnYm9vbGVhbicsXG4gIGZvY3VzICAgIDogJ2Jvb2xlYW4nLFxuICBzaG93ICAgICA6ICdib29sZWFuJ1xufVxuXG5jb25zdCBFdmVudCA9IHtcbiAgSElERSAgICAgICAgICAgICAgOiBgaGlkZSR7RVZFTlRfS0VZfWAsXG4gIEhJRERFTiAgICAgICAgICAgIDogYGhpZGRlbiR7RVZFTlRfS0VZfWAsXG4gIFNIT1cgICAgICAgICAgICAgIDogYHNob3cke0VWRU5UX0tFWX1gLFxuICBTSE9XTiAgICAgICAgICAgICA6IGBzaG93biR7RVZFTlRfS0VZfWAsXG4gIEZPQ1VTSU4gICAgICAgICAgIDogYGZvY3VzaW4ke0VWRU5UX0tFWX1gLFxuICBSRVNJWkUgICAgICAgICAgICA6IGByZXNpemUke0VWRU5UX0tFWX1gLFxuICBDTElDS19ESVNNSVNTICAgICA6IGBjbGljay5kaXNtaXNzJHtFVkVOVF9LRVl9YCxcbiAgS0VZRE9XTl9ESVNNSVNTICAgOiBga2V5ZG93bi5kaXNtaXNzJHtFVkVOVF9LRVl9YCxcbiAgTU9VU0VVUF9ESVNNSVNTICAgOiBgbW91c2V1cC5kaXNtaXNzJHtFVkVOVF9LRVl9YCxcbiAgTU9VU0VET1dOX0RJU01JU1MgOiBgbW91c2Vkb3duLmRpc21pc3Mke0VWRU5UX0tFWX1gLFxuICBDTElDS19EQVRBX0FQSSAgICA6IGBjbGljayR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcbn1cblxuY29uc3QgQ2xhc3NOYW1lID0ge1xuICBTQ1JPTExBQkxFICAgICAgICAgOiAnbW9kYWwtZGlhbG9nLXNjcm9sbGFibGUnLFxuICBTQ1JPTExCQVJfTUVBU1VSRVIgOiAnbW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUnLFxuICBCQUNLRFJPUCAgICAgICAgICAgOiAnbW9kYWwtYmFja2Ryb3AnLFxuICBPUEVOICAgICAgICAgICAgICAgOiAnbW9kYWwtb3BlbicsXG4gIEZBREUgICAgICAgICAgICAgICA6ICdmYWRlJyxcbiAgU0hPVyAgICAgICAgICAgICAgIDogJ3Nob3cnXG59XG5cbmNvbnN0IFNlbGVjdG9yID0ge1xuICBESUFMT0cgICAgICAgICA6ICcubW9kYWwtZGlhbG9nJyxcbiAgTU9EQUxfQk9EWSAgICAgOiAnLm1vZGFsLWJvZHknLFxuICBEQVRBX1RPR0dMRSAgICA6ICdbZGF0YS10b2dnbGU9XCJtb2RhbFwiXScsXG4gIERBVEFfRElTTUlTUyAgIDogJ1tkYXRhLWRpc21pc3M9XCJtb2RhbFwiXScsXG4gIEZJWEVEX0NPTlRFTlQgIDogJy5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3AnLFxuICBTVElDS1lfQ09OVEVOVCA6ICcuc3RpY2t5LXRvcCdcbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNsYXNzIE1vZGFsIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnICAgICAgICAgICAgICA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpXG4gICAgdGhpcy5fZWxlbWVudCAgICAgICAgICAgICA9IGVsZW1lbnRcbiAgICB0aGlzLl9kaWFsb2cgICAgICAgICAgICAgID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yLkRJQUxPRylcbiAgICB0aGlzLl9iYWNrZHJvcCAgICAgICAgICAgID0gbnVsbFxuICAgIHRoaXMuX2lzU2hvd24gICAgICAgICAgICAgPSBmYWxzZVxuICAgIHRoaXMuX2lzQm9keU92ZXJmbG93aW5nICAgPSBmYWxzZVxuICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSBmYWxzZVxuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyAgICAgPSBmYWxzZVxuICAgIHRoaXMuX3Njcm9sbGJhcldpZHRoICAgICAgPSAwXG4gIH1cblxuICAvLyBHZXR0ZXJzXG5cbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIC8vIFB1YmxpY1xuXG4gIHRvZ2dsZShyZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KVxuICB9XG5cbiAgc2hvdyhyZWxhdGVkVGFyZ2V0KSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSkpIHtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBzaG93RXZlbnQgPSAkLkV2ZW50KEV2ZW50LlNIT1csIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICB9KVxuXG4gICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNob3dFdmVudClcblxuICAgIGlmICh0aGlzLl9pc1Nob3duIHx8IHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5faXNTaG93biA9IHRydWVcblxuICAgIHRoaXMuX2NoZWNrU2Nyb2xsYmFyKClcbiAgICB0aGlzLl9zZXRTY3JvbGxiYXIoKVxuXG4gICAgdGhpcy5fYWRqdXN0RGlhbG9nKClcblxuICAgIHRoaXMuX3NldEVzY2FwZUV2ZW50KClcbiAgICB0aGlzLl9zZXRSZXNpemVFdmVudCgpXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKFxuICAgICAgRXZlbnQuQ0xJQ0tfRElTTUlTUyxcbiAgICAgIFNlbGVjdG9yLkRBVEFfRElTTUlTUyxcbiAgICAgIChldmVudCkgPT4gdGhpcy5oaWRlKGV2ZW50KVxuICAgIClcblxuICAgICQodGhpcy5fZGlhbG9nKS5vbihFdmVudC5NT1VTRURPV05fRElTTUlTUywgKCkgPT4ge1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbmUoRXZlbnQuTU9VU0VVUF9ESVNNSVNTLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCQoZXZlbnQudGFyZ2V0KS5pcyh0aGlzLl9lbGVtZW50KSkge1xuICAgICAgICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMuX3Nob3dCYWNrZHJvcCgoKSA9PiB0aGlzLl9zaG93RWxlbWVudChyZWxhdGVkVGFyZ2V0KSlcbiAgfVxuXG4gIGhpZGUoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBoaWRlRXZlbnQgPSAkLkV2ZW50KEV2ZW50LkhJREUpXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50KVxuXG4gICAgaWYgKCF0aGlzLl9pc1Nob3duIHx8IGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5faXNTaG93biA9IGZhbHNlXG4gICAgY29uc3QgdHJhbnNpdGlvbiA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpXG5cbiAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZVxuICAgIH1cblxuICAgIHRoaXMuX3NldEVzY2FwZUV2ZW50KClcbiAgICB0aGlzLl9zZXRSZXNpemVFdmVudCgpXG5cbiAgICAkKGRvY3VtZW50KS5vZmYoRXZlbnQuRk9DVVNJTilcblxuICAgICQodGhpcy5fZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihFdmVudC5DTElDS19ESVNNSVNTKVxuICAgICQodGhpcy5fZGlhbG9nKS5vZmYoRXZlbnQuTU9VU0VET1dOX0RJU01JU1MpXG5cblxuICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KVxuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpXG4gICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgKGV2ZW50KSA9PiB0aGlzLl9oaWRlTW9kYWwoZXZlbnQpKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oaWRlTW9kYWwoKVxuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgW3dpbmRvdywgdGhpcy5fZWxlbWVudCwgdGhpcy5fZGlhbG9nXVxuICAgICAgLmZvckVhY2goKGh0bWxFbGVtZW50KSA9PiAkKGh0bWxFbGVtZW50KS5vZmYoRVZFTlRfS0VZKSlcblxuICAgIC8qKlxuICAgICAqIGBkb2N1bWVudGAgaGFzIDIgZXZlbnRzIGBFdmVudC5GT0NVU0lOYCBhbmQgYEV2ZW50LkNMSUNLX0RBVEFfQVBJYFxuICAgICAqIERvIG5vdCBtb3ZlIGBkb2N1bWVudGAgaW4gYGh0bWxFbGVtZW50c2AgYXJyYXlcbiAgICAgKiBJdCB3aWxsIHJlbW92ZSBgRXZlbnQuQ0xJQ0tfREFUQV9BUElgIGV2ZW50IHRoYXQgc2hvdWxkIHJlbWFpblxuICAgICAqL1xuICAgICQoZG9jdW1lbnQpLm9mZihFdmVudC5GT0NVU0lOKVxuXG4gICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKVxuXG4gICAgdGhpcy5fY29uZmlnICAgICAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLl9lbGVtZW50ICAgICAgICAgICAgID0gbnVsbFxuICAgIHRoaXMuX2RpYWxvZyAgICAgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5fYmFja2Ryb3AgICAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLl9pc1Nob3duICAgICAgICAgICAgID0gbnVsbFxuICAgIHRoaXMuX2lzQm9keU92ZXJmbG93aW5nICAgPSBudWxsXG4gICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IG51bGxcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgICAgID0gbnVsbFxuICAgIHRoaXMuX3Njcm9sbGJhcldpZHRoICAgICAgPSBudWxsXG4gIH1cblxuICBoYW5kbGVVcGRhdGUoKSB7XG4gICAgdGhpcy5fYWRqdXN0RGlhbG9nKClcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IHtcbiAgICAgIC4uLkRlZmF1bHQsXG4gICAgICAuLi5jb25maWdcbiAgICB9XG4gICAgVXRpbC50eXBlQ2hlY2tDb25maWcoTkFNRSwgY29uZmlnLCBEZWZhdWx0VHlwZSlcbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICBfc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCkge1xuICAgIGNvbnN0IHRyYW5zaXRpb24gPSAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5GQURFKVxuXG4gICAgaWYgKCF0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgfHxcbiAgICAgICAgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgLy8gRG9uJ3QgbW92ZSBtb2RhbCdzIERPTSBwb3NpdGlvblxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50KVxuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKVxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSlcblxuICAgIGlmICgkKHRoaXMuX2RpYWxvZykuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNDUk9MTEFCTEUpKSB7XG4gICAgICB0aGlzLl9kaWFsb2cucXVlcnlTZWxlY3RvcihTZWxlY3Rvci5NT0RBTF9CT0RZKS5zY3JvbGxUb3AgPSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMFxuICAgIH1cblxuICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICBVdGlsLnJlZmxvdyh0aGlzLl9lbGVtZW50KVxuICAgIH1cblxuICAgICQodGhpcy5fZWxlbWVudCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG5cbiAgICBpZiAodGhpcy5fY29uZmlnLmZvY3VzKSB7XG4gICAgICB0aGlzLl9lbmZvcmNlRm9jdXMoKVxuICAgIH1cblxuICAgIGNvbnN0IHNob3duRXZlbnQgPSAkLkV2ZW50KEV2ZW50LlNIT1dOLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0XG4gICAgfSlcblxuICAgIGNvbnN0IHRyYW5zaXRpb25Db21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jb25maWcuZm9jdXMpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpXG4gICAgICB9XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZVxuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNob3duRXZlbnQpXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiAgPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2RpYWxvZylcblxuICAgICAgJCh0aGlzLl9kaWFsb2cpXG4gICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgdHJhbnNpdGlvbkNvbXBsZXRlKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2l0aW9uQ29tcGxldGUoKVxuICAgIH1cbiAgfVxuXG4gIF9lbmZvcmNlRm9jdXMoKSB7XG4gICAgJChkb2N1bWVudClcbiAgICAgIC5vZmYoRXZlbnQuRk9DVVNJTikgLy8gR3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXG4gICAgICAub24oRXZlbnQuRk9DVVNJTiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChkb2N1bWVudCAhPT0gZXZlbnQudGFyZ2V0ICYmXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50ICE9PSBldmVudC50YXJnZXQgJiZcbiAgICAgICAgICAgICQodGhpcy5fZWxlbWVudCkuaGFzKGV2ZW50LnRhcmdldCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICBfc2V0RXNjYXBlRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24gJiYgdGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKEV2ZW50LktFWURPV05fRElTTUlTUywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC53aGljaCA9PT0gRVNDQVBFX0tFWUNPREUpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgdGhpcy5oaWRlKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1Nob3duKSB7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihFdmVudC5LRVlET1dOX0RJU01JU1MpXG4gICAgfVxuICB9XG5cbiAgX3NldFJlc2l6ZUV2ZW50KCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XG4gICAgICAkKHdpbmRvdykub24oRXZlbnQuUkVTSVpFLCAoZXZlbnQpID0+IHRoaXMuaGFuZGxlVXBkYXRlKGV2ZW50KSlcbiAgICB9IGVsc2Uge1xuICAgICAgJCh3aW5kb3cpLm9mZihFdmVudC5SRVNJWkUpXG4gICAgfVxuICB9XG5cbiAgX2hpZGVNb2RhbCgpIHtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKVxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJylcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZVxuICAgIHRoaXMuX3Nob3dCYWNrZHJvcCgoKSA9PiB7XG4gICAgICAkKGRvY3VtZW50LmJvZHkpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5PUEVOKVxuICAgICAgdGhpcy5fcmVzZXRBZGp1c3RtZW50cygpXG4gICAgICB0aGlzLl9yZXNldFNjcm9sbGJhcigpXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoRXZlbnQuSElEREVOKVxuICAgIH0pXG4gIH1cblxuICBfcmVtb3ZlQmFja2Ryb3AoKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tkcm9wKSB7XG4gICAgICAkKHRoaXMuX2JhY2tkcm9wKS5yZW1vdmUoKVxuICAgICAgdGhpcy5fYmFja2Ryb3AgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgX3Nob3dCYWNrZHJvcChjYWxsYmFjaykge1xuICAgIGNvbnN0IGFuaW1hdGUgPSAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5GQURFKVxuICAgICAgPyBDbGFzc05hbWUuRkFERSA6ICcnXG5cbiAgICBpZiAodGhpcy5faXNTaG93biAmJiB0aGlzLl9jb25maWcuYmFja2Ryb3ApIHtcbiAgICAgIHRoaXMuX2JhY2tkcm9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmNsYXNzTmFtZSA9IENsYXNzTmFtZS5CQUNLRFJPUFxuXG4gICAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgICB0aGlzLl9iYWNrZHJvcC5jbGFzc0xpc3QuYWRkKGFuaW1hdGUpXG4gICAgICB9XG5cbiAgICAgICQodGhpcy5fYmFja2Ryb3ApLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpXG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oRXZlbnQuQ0xJQ0tfRElTTUlTUywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gZXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5oaWRlKClcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgVXRpbC5yZWZsb3codGhpcy5fYmFja2Ryb3ApXG4gICAgICB9XG5cbiAgICAgICQodGhpcy5fYmFja2Ryb3ApLmFkZENsYXNzKENsYXNzTmFtZS5TSE9XKVxuXG4gICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoIWFuaW1hdGUpIHtcbiAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2JhY2tkcm9wKVxuXG4gICAgICAkKHRoaXMuX2JhY2tkcm9wKVxuICAgICAgICAub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNhbGxiYWNrKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24pXG4gICAgfSBlbHNlIGlmICghdGhpcy5faXNTaG93biAmJiB0aGlzLl9iYWNrZHJvcCkge1xuICAgICAgJCh0aGlzLl9iYWNrZHJvcCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG5cbiAgICAgIGNvbnN0IGNhbGxiYWNrUmVtb3ZlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9yZW1vdmVCYWNrZHJvcCgpXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSkpIHtcbiAgICAgICAgY29uc3QgYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2JhY2tkcm9wKVxuXG4gICAgICAgICQodGhpcy5fYmFja2Ryb3ApXG4gICAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjYWxsYmFja1JlbW92ZSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFja1JlbW92ZSgpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gdGhlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcbiAgLy8gdG9kbyAoZmF0KTogdGhlc2Ugc2hvdWxkIHByb2JhYmx5IGJlIHJlZmFjdG9yZWQgb3V0IG9mIG1vZGFsLmpzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBfYWRqdXN0RGlhbG9nKCkge1xuICAgIGNvbnN0IGlzTW9kYWxPdmVyZmxvd2luZyA9XG4gICAgICB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcblxuICAgIGlmICghdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgJiYgaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gYCR7dGhpcy5fc2Nyb2xsYmFyV2lkdGh9cHhgXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gYCR7dGhpcy5fc2Nyb2xsYmFyV2lkdGh9cHhgXG4gICAgfVxuICB9XG5cbiAgX3Jlc2V0QWRqdXN0bWVudHMoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9ICcnXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJ1xuICB9XG5cbiAgX2NoZWNrU2Nyb2xsYmFyKCkge1xuICAgIGNvbnN0IHJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgPSByZWN0LmxlZnQgKyByZWN0LnJpZ2h0IDwgd2luZG93LmlubmVyV2lkdGhcbiAgICB0aGlzLl9zY3JvbGxiYXJXaWR0aCA9IHRoaXMuX2dldFNjcm9sbGJhcldpZHRoKClcbiAgfVxuXG4gIF9zZXRTY3JvbGxiYXIoKSB7XG4gICAgaWYgKHRoaXMuX2lzQm9keU92ZXJmbG93aW5nKSB7XG4gICAgICAvLyBOb3RlOiBET01Ob2RlLnN0eWxlLnBhZGRpbmdSaWdodCByZXR1cm5zIHRoZSBhY3R1YWwgdmFsdWUgb3IgJycgaWYgbm90IHNldFxuICAgICAgLy8gICB3aGlsZSAkKERPTU5vZGUpLmNzcygncGFkZGluZy1yaWdodCcpIHJldHVybnMgdGhlIGNhbGN1bGF0ZWQgdmFsdWUgb3IgMCBpZiBub3Qgc2V0XG4gICAgICBjb25zdCBmaXhlZENvbnRlbnQgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU2VsZWN0b3IuRklYRURfQ09OVEVOVCkpXG4gICAgICBjb25zdCBzdGlja3lDb250ZW50ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yLlNUSUNLWV9DT05URU5UKSlcblxuICAgICAgLy8gQWRqdXN0IGZpeGVkIGNvbnRlbnQgcGFkZGluZ1xuICAgICAgJChmaXhlZENvbnRlbnQpLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGFjdHVhbFBhZGRpbmcgPSBlbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodFxuICAgICAgICBjb25zdCBjYWxjdWxhdGVkUGFkZGluZyA9ICQoZWxlbWVudCkuY3NzKCdwYWRkaW5nLXJpZ2h0JylcbiAgICAgICAgJChlbGVtZW50KVxuICAgICAgICAgIC5kYXRhKCdwYWRkaW5nLXJpZ2h0JywgYWN0dWFsUGFkZGluZylcbiAgICAgICAgICAuY3NzKCdwYWRkaW5nLXJpZ2h0JywgYCR7cGFyc2VGbG9hdChjYWxjdWxhdGVkUGFkZGluZykgKyB0aGlzLl9zY3JvbGxiYXJXaWR0aH1weGApXG4gICAgICB9KVxuXG4gICAgICAvLyBBZGp1c3Qgc3RpY2t5IGNvbnRlbnQgbWFyZ2luXG4gICAgICAkKHN0aWNreUNvbnRlbnQpLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGFjdHVhbE1hcmdpbiA9IGVsZW1lbnQuc3R5bGUubWFyZ2luUmlnaHRcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZE1hcmdpbiA9ICQoZWxlbWVudCkuY3NzKCdtYXJnaW4tcmlnaHQnKVxuICAgICAgICAkKGVsZW1lbnQpXG4gICAgICAgICAgLmRhdGEoJ21hcmdpbi1yaWdodCcsIGFjdHVhbE1hcmdpbilcbiAgICAgICAgICAuY3NzKCdtYXJnaW4tcmlnaHQnLCBgJHtwYXJzZUZsb2F0KGNhbGN1bGF0ZWRNYXJnaW4pIC0gdGhpcy5fc2Nyb2xsYmFyV2lkdGh9cHhgKVxuICAgICAgfSlcblxuICAgICAgLy8gQWRqdXN0IGJvZHkgcGFkZGluZ1xuICAgICAgY29uc3QgYWN0dWFsUGFkZGluZyA9IGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0XG4gICAgICBjb25zdCBjYWxjdWxhdGVkUGFkZGluZyA9ICQoZG9jdW1lbnQuYm9keSkuY3NzKCdwYWRkaW5nLXJpZ2h0JylcbiAgICAgICQoZG9jdW1lbnQuYm9keSlcbiAgICAgICAgLmRhdGEoJ3BhZGRpbmctcmlnaHQnLCBhY3R1YWxQYWRkaW5nKVxuICAgICAgICAuY3NzKCdwYWRkaW5nLXJpZ2h0JywgYCR7cGFyc2VGbG9hdChjYWxjdWxhdGVkUGFkZGluZykgKyB0aGlzLl9zY3JvbGxiYXJXaWR0aH1weGApXG4gICAgfVxuXG4gICAgJChkb2N1bWVudC5ib2R5KS5hZGRDbGFzcyhDbGFzc05hbWUuT1BFTilcbiAgfVxuXG4gIF9yZXNldFNjcm9sbGJhcigpIHtcbiAgICAvLyBSZXN0b3JlIGZpeGVkIGNvbnRlbnQgcGFkZGluZ1xuICAgIGNvbnN0IGZpeGVkQ29udGVudCA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3Rvci5GSVhFRF9DT05URU5UKSlcbiAgICAkKGZpeGVkQ29udGVudCkuZWFjaCgoaW5kZXgsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IHBhZGRpbmcgPSAkKGVsZW1lbnQpLmRhdGEoJ3BhZGRpbmctcmlnaHQnKVxuICAgICAgJChlbGVtZW50KS5yZW1vdmVEYXRhKCdwYWRkaW5nLXJpZ2h0JylcbiAgICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gcGFkZGluZyA/IHBhZGRpbmcgOiAnJ1xuICAgIH0pXG5cbiAgICAvLyBSZXN0b3JlIHN0aWNreSBjb250ZW50XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYCR7U2VsZWN0b3IuU1RJQ0tZX0NPTlRFTlR9YCkpXG4gICAgJChlbGVtZW50cykuZWFjaCgoaW5kZXgsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IG1hcmdpbiA9ICQoZWxlbWVudCkuZGF0YSgnbWFyZ2luLXJpZ2h0JylcbiAgICAgIGlmICh0eXBlb2YgbWFyZ2luICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAkKGVsZW1lbnQpLmNzcygnbWFyZ2luLXJpZ2h0JywgbWFyZ2luKS5yZW1vdmVEYXRhKCdtYXJnaW4tcmlnaHQnKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBSZXN0b3JlIGJvZHkgcGFkZGluZ1xuICAgIGNvbnN0IHBhZGRpbmcgPSAkKGRvY3VtZW50LmJvZHkpLmRhdGEoJ3BhZGRpbmctcmlnaHQnKVxuICAgICQoZG9jdW1lbnQuYm9keSkucmVtb3ZlRGF0YSgncGFkZGluZy1yaWdodCcpXG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBwYWRkaW5nID8gcGFkZGluZyA6ICcnXG4gIH1cblxuICBfZ2V0U2Nyb2xsYmFyV2lkdGgoKSB7IC8vIHRoeCBkLndhbHNoXG4gICAgY29uc3Qgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gQ2xhc3NOYW1lLlNDUk9MTEJBUl9NRUFTVVJFUlxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2Nyb2xsRGl2KVxuICAgIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gc2Nyb2xsRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gc2Nyb2xsRGl2LmNsaWVudFdpZHRoXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpXG4gICAgcmV0dXJuIHNjcm9sbGJhcldpZHRoXG4gIH1cblxuICAvLyBTdGF0aWNcblxuICBzdGF0aWMgX2pRdWVyeUludGVyZmFjZShjb25maWcsIHJlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBkYXRhID0gJCh0aGlzKS5kYXRhKERBVEFfS0VZKVxuICAgICAgY29uc3QgX2NvbmZpZyA9IHtcbiAgICAgICAgLi4uRGVmYXVsdCxcbiAgICAgICAgLi4uJCh0aGlzKS5kYXRhKCksXG4gICAgICAgIC4uLnR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9XG4gICAgICB9XG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0gbmV3IE1vZGFsKHRoaXMsIF9jb25maWcpXG4gICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSlcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgICAgfVxuICAgICAgICBkYXRhW2NvbmZpZ10ocmVsYXRlZFRhcmdldClcbiAgICAgIH0gZWxzZSBpZiAoX2NvbmZpZy5zaG93KSB7XG4gICAgICAgIGRhdGEuc2hvdyhyZWxhdGVkVGFyZ2V0KVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kKGRvY3VtZW50KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICBsZXQgdGFyZ2V0XG4gIGNvbnN0IHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMpXG5cbiAgaWYgKHNlbGVjdG9yKSB7XG4gICAgdGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcilcbiAgfVxuXG4gIGNvbnN0IGNvbmZpZyA9ICQodGFyZ2V0KS5kYXRhKERBVEFfS0VZKVxuICAgID8gJ3RvZ2dsZScgOiB7XG4gICAgICAuLi4kKHRhcmdldCkuZGF0YSgpLFxuICAgICAgLi4uJCh0aGlzKS5kYXRhKClcbiAgICB9XG5cbiAgaWYgKHRoaXMudGFnTmFtZSA9PT0gJ0EnIHx8IHRoaXMudGFnTmFtZSA9PT0gJ0FSRUEnKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICB9XG5cbiAgY29uc3QgJHRhcmdldCA9ICQodGFyZ2V0KS5vbmUoRXZlbnQuU0hPVywgKHNob3dFdmVudCkgPT4ge1xuICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIC8vIE9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgICR0YXJnZXQub25lKEV2ZW50LkhJRERFTiwgKCkgPT4ge1xuICAgICAgaWYgKCQodGhpcykuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgdGhpcy5mb2N1cygpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcblxuICBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJCh0YXJnZXQpLCBjb25maWcsIHRoaXMpXG59KVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kLmZuW05BTUVdID0gTW9kYWwuX2pRdWVyeUludGVyZmFjZVxuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IE1vZGFsXG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgcmV0dXJuIE1vZGFsLl9qUXVlcnlJbnRlcmZhY2Vcbn1cblxuZXhwb3J0IGRlZmF1bHQgTW9kYWxcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuMy4xKTogdG9vbHMvc2FuaXRpemVyLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCB1cmlBdHRycyA9IFtcbiAgJ2JhY2tncm91bmQnLFxuICAnY2l0ZScsXG4gICdocmVmJyxcbiAgJ2l0ZW10eXBlJyxcbiAgJ2xvbmdkZXNjJyxcbiAgJ3Bvc3RlcicsXG4gICdzcmMnLFxuICAneGxpbms6aHJlZidcbl1cblxuY29uc3QgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTiA9IC9eYXJpYS1bXFx3LV0qJC9pXG5cbmV4cG9ydCBjb25zdCBEZWZhdWx0V2hpdGVsaXN0ID0ge1xuICAvLyBHbG9iYWwgYXR0cmlidXRlcyBhbGxvd2VkIG9uIGFueSBzdXBwbGllZCBlbGVtZW50IGJlbG93LlxuICAnKic6IFsnY2xhc3MnLCAnZGlyJywgJ2lkJywgJ2xhbmcnLCAncm9sZScsIEFSSUFfQVRUUklCVVRFX1BBVFRFUk5dLFxuICBhOiBbJ3RhcmdldCcsICdocmVmJywgJ3RpdGxlJywgJ3JlbCddLFxuICBhcmVhOiBbXSxcbiAgYjogW10sXG4gIGJyOiBbXSxcbiAgY29sOiBbXSxcbiAgY29kZTogW10sXG4gIGRpdjogW10sXG4gIGVtOiBbXSxcbiAgaHI6IFtdLFxuICBoMTogW10sXG4gIGgyOiBbXSxcbiAgaDM6IFtdLFxuICBoNDogW10sXG4gIGg1OiBbXSxcbiAgaDY6IFtdLFxuICBpOiBbXSxcbiAgaW1nOiBbJ3NyYycsICdhbHQnLCAndGl0bGUnLCAnd2lkdGgnLCAnaGVpZ2h0J10sXG4gIGxpOiBbXSxcbiAgb2w6IFtdLFxuICBwOiBbXSxcbiAgcHJlOiBbXSxcbiAgczogW10sXG4gIHNtYWxsOiBbXSxcbiAgc3BhbjogW10sXG4gIHN1YjogW10sXG4gIHN1cDogW10sXG4gIHN0cm9uZzogW10sXG4gIHU6IFtdLFxuICB1bDogW11cbn1cblxuLyoqXG4gKiBBIHBhdHRlcm4gdGhhdCByZWNvZ25pemVzIGEgY29tbW9ubHkgdXNlZnVsIHN1YnNldCBvZiBVUkxzIHRoYXQgYXJlIHNhZmUuXG4gKlxuICogU2hvdXRvdXQgdG8gQW5ndWxhciA3IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi83LjIuNC9wYWNrYWdlcy9jb3JlL3NyYy9zYW5pdGl6YXRpb24vdXJsX3Nhbml0aXplci50c1xuICovXG5jb25zdCBTQUZFX1VSTF9QQVRURVJOID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZSk6fFteJjovPyNdKig/OlsvPyNdfCQpKS9naVxuXG4vKipcbiAqIEEgcGF0dGVybiB0aGF0IG1hdGNoZXMgc2FmZSBkYXRhIFVSTHMuIE9ubHkgbWF0Y2hlcyBpbWFnZSwgdmlkZW8gYW5kIGF1ZGlvIHR5cGVzLlxuICpcbiAqIFNob3V0b3V0IHRvIEFuZ3VsYXIgNyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvNy4yLjQvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHNcbiAqL1xuY29uc3QgREFUQV9VUkxfUEFUVEVSTiA9IC9eZGF0YTooPzppbWFnZVxcLyg/OmJtcHxnaWZ8anBlZ3xqcGd8cG5nfHRpZmZ8d2VicCl8dmlkZW9cXC8oPzptcGVnfG1wNHxvZ2d8d2VibSl8YXVkaW9cXC8oPzptcDN8b2dhfG9nZ3xvcHVzKSk7YmFzZTY0LFthLXowLTkrL10rPSokL2lcblxuZnVuY3Rpb24gYWxsb3dlZEF0dHJpYnV0ZShhdHRyLCBhbGxvd2VkQXR0cmlidXRlTGlzdCkge1xuICBjb25zdCBhdHRyTmFtZSA9IGF0dHIubm9kZU5hbWUudG9Mb3dlckNhc2UoKVxuXG4gIGlmIChhbGxvd2VkQXR0cmlidXRlTGlzdC5pbmRleE9mKGF0dHJOYW1lKSAhPT0gLTEpIHtcbiAgICBpZiAodXJpQXR0cnMuaW5kZXhPZihhdHRyTmFtZSkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihhdHRyLm5vZGVWYWx1ZS5tYXRjaChTQUZFX1VSTF9QQVRURVJOKSB8fCBhdHRyLm5vZGVWYWx1ZS5tYXRjaChEQVRBX1VSTF9QQVRURVJOKSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3QgcmVnRXhwID0gYWxsb3dlZEF0dHJpYnV0ZUxpc3QuZmlsdGVyKChhdHRyUmVnZXgpID0+IGF0dHJSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cClcblxuICAvLyBDaGVjayBpZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB2YWxpZGF0ZXMgdGhlIGF0dHJpYnV0ZS5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSByZWdFeHAubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGF0dHJOYW1lLm1hdGNoKHJlZ0V4cFtpXSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZUh0bWwodW5zYWZlSHRtbCwgd2hpdGVMaXN0LCBzYW5pdGl6ZUZuKSB7XG4gIGlmICh1bnNhZmVIdG1sLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1bnNhZmVIdG1sXG4gIH1cblxuICBpZiAoc2FuaXRpemVGbiAmJiB0eXBlb2Ygc2FuaXRpemVGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzYW5pdGl6ZUZuKHVuc2FmZUh0bWwpXG4gIH1cblxuICBjb25zdCBkb21QYXJzZXIgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpXG4gIGNvbnN0IGNyZWF0ZWREb2N1bWVudCA9IGRvbVBhcnNlci5wYXJzZUZyb21TdHJpbmcodW5zYWZlSHRtbCwgJ3RleHQvaHRtbCcpXG4gIGNvbnN0IHdoaXRlbGlzdEtleXMgPSBPYmplY3Qua2V5cyh3aGl0ZUxpc3QpXG4gIGNvbnN0IGVsZW1lbnRzID0gW10uc2xpY2UuY2FsbChjcmVhdGVkRG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yQWxsKCcqJykpXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgZWwgPSBlbGVtZW50c1tpXVxuICAgIGNvbnN0IGVsTmFtZSA9IGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKClcblxuICAgIGlmICh3aGl0ZWxpc3RLZXlzLmluZGV4T2YoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKVxuXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IGF0dHJpYnV0ZUxpc3QgPSBbXS5zbGljZS5jYWxsKGVsLmF0dHJpYnV0ZXMpXG4gICAgY29uc3Qgd2hpdGVsaXN0ZWRBdHRyaWJ1dGVzID0gW10uY29uY2F0KHdoaXRlTGlzdFsnKiddIHx8IFtdLCB3aGl0ZUxpc3RbZWxOYW1lXSB8fCBbXSlcblxuICAgIGF0dHJpYnV0ZUxpc3QuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgaWYgKCFhbGxvd2VkQXR0cmlidXRlKGF0dHIsIHdoaXRlbGlzdGVkQXR0cmlidXRlcykpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIubm9kZU5hbWUpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVkRG9jdW1lbnQuYm9keS5pbm5lckhUTUxcbn1cbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuMy4xKTogdG9vbHRpcC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IHtcbiAgRGVmYXVsdFdoaXRlbGlzdCxcbiAgc2FuaXRpemVIdG1sXG59IGZyb20gJy4vdG9vbHMvc2FuaXRpemVyJ1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0IFBvcHBlciBmcm9tICdwb3BwZXIuanMnXG5pbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUgICAgICAgICAgICAgICAgICA9ICd0b29sdGlwJ1xuY29uc3QgVkVSU0lPTiAgICAgICAgICAgICAgID0gJzQuMy4xJ1xuY29uc3QgREFUQV9LRVkgICAgICAgICAgICAgID0gJ2JzLnRvb2x0aXAnXG5jb25zdCBFVkVOVF9LRVkgICAgICAgICAgICAgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUICAgID0gJC5mbltOQU1FXVxuY29uc3QgQ0xBU1NfUFJFRklYICAgICAgICAgID0gJ2JzLXRvb2x0aXAnXG5jb25zdCBCU0NMU19QUkVGSVhfUkVHRVggICAgPSBuZXcgUmVnRXhwKGAoXnxcXFxccykke0NMQVNTX1BSRUZJWH1cXFxcUytgLCAnZycpXG5jb25zdCBESVNBTExPV0VEX0FUVFJJQlVURVMgPSBbJ3Nhbml0aXplJywgJ3doaXRlTGlzdCcsICdzYW5pdGl6ZUZuJ11cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIGFuaW1hdGlvbiAgICAgICAgIDogJ2Jvb2xlYW4nLFxuICB0ZW1wbGF0ZSAgICAgICAgICA6ICdzdHJpbmcnLFxuICB0aXRsZSAgICAgICAgICAgICA6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJyxcbiAgdHJpZ2dlciAgICAgICAgICAgOiAnc3RyaW5nJyxcbiAgZGVsYXkgICAgICAgICAgICAgOiAnKG51bWJlcnxvYmplY3QpJyxcbiAgaHRtbCAgICAgICAgICAgICAgOiAnYm9vbGVhbicsXG4gIHNlbGVjdG9yICAgICAgICAgIDogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICBwbGFjZW1lbnQgICAgICAgICA6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXG4gIG9mZnNldCAgICAgICAgICAgIDogJyhudW1iZXJ8c3RyaW5nfGZ1bmN0aW9uKScsXG4gIGNvbnRhaW5lciAgICAgICAgIDogJyhzdHJpbmd8ZWxlbWVudHxib29sZWFuKScsXG4gIGZhbGxiYWNrUGxhY2VtZW50IDogJyhzdHJpbmd8YXJyYXkpJyxcbiAgYm91bmRhcnkgICAgICAgICAgOiAnKHN0cmluZ3xlbGVtZW50KScsXG4gIHNhbml0aXplICAgICAgICAgIDogJ2Jvb2xlYW4nLFxuICBzYW5pdGl6ZUZuICAgICAgICA6ICcobnVsbHxmdW5jdGlvbiknLFxuICB3aGl0ZUxpc3QgICAgICAgICA6ICdvYmplY3QnXG59XG5cbmNvbnN0IEF0dGFjaG1lbnRNYXAgPSB7XG4gIEFVVE8gICA6ICdhdXRvJyxcbiAgVE9QICAgIDogJ3RvcCcsXG4gIFJJR0hUICA6ICdyaWdodCcsXG4gIEJPVFRPTSA6ICdib3R0b20nLFxuICBMRUZUICAgOiAnbGVmdCdcbn1cblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgYW5pbWF0aW9uICAgICAgICAgOiB0cnVlLFxuICB0ZW1wbGF0ZSAgICAgICAgICA6ICc8ZGl2IGNsYXNzPVwidG9vbHRpcFwiIHJvbGU9XCJ0b29sdGlwXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYXJyb3dcIj48L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0b29sdGlwLWlubmVyXCI+PC9kaXY+PC9kaXY+JyxcbiAgdHJpZ2dlciAgICAgICAgICAgOiAnaG92ZXIgZm9jdXMnLFxuICB0aXRsZSAgICAgICAgICAgICA6ICcnLFxuICBkZWxheSAgICAgICAgICAgICA6IDAsXG4gIGh0bWwgICAgICAgICAgICAgIDogZmFsc2UsXG4gIHNlbGVjdG9yICAgICAgICAgIDogZmFsc2UsXG4gIHBsYWNlbWVudCAgICAgICAgIDogJ3RvcCcsXG4gIG9mZnNldCAgICAgICAgICAgIDogMCxcbiAgY29udGFpbmVyICAgICAgICAgOiBmYWxzZSxcbiAgZmFsbGJhY2tQbGFjZW1lbnQgOiAnZmxpcCcsXG4gIGJvdW5kYXJ5ICAgICAgICAgIDogJ3Njcm9sbFBhcmVudCcsXG4gIHNhbml0aXplICAgICAgICAgIDogdHJ1ZSxcbiAgc2FuaXRpemVGbiAgICAgICAgOiBudWxsLFxuICB3aGl0ZUxpc3QgICAgICAgICA6IERlZmF1bHRXaGl0ZWxpc3Rcbn1cblxuY29uc3QgSG92ZXJTdGF0ZSA9IHtcbiAgU0hPVyA6ICdzaG93JyxcbiAgT1VUICA6ICdvdXQnXG59XG5cbmNvbnN0IEV2ZW50ID0ge1xuICBISURFICAgICAgIDogYGhpZGUke0VWRU5UX0tFWX1gLFxuICBISURERU4gICAgIDogYGhpZGRlbiR7RVZFTlRfS0VZfWAsXG4gIFNIT1cgICAgICAgOiBgc2hvdyR7RVZFTlRfS0VZfWAsXG4gIFNIT1dOICAgICAgOiBgc2hvd24ke0VWRU5UX0tFWX1gLFxuICBJTlNFUlRFRCAgIDogYGluc2VydGVkJHtFVkVOVF9LRVl9YCxcbiAgQ0xJQ0sgICAgICA6IGBjbGljayR7RVZFTlRfS0VZfWAsXG4gIEZPQ1VTSU4gICAgOiBgZm9jdXNpbiR7RVZFTlRfS0VZfWAsXG4gIEZPQ1VTT1VUICAgOiBgZm9jdXNvdXQke0VWRU5UX0tFWX1gLFxuICBNT1VTRUVOVEVSIDogYG1vdXNlZW50ZXIke0VWRU5UX0tFWX1gLFxuICBNT1VTRUxFQVZFIDogYG1vdXNlbGVhdmUke0VWRU5UX0tFWX1gXG59XG5cbmNvbnN0IENsYXNzTmFtZSA9IHtcbiAgRkFERSA6ICdmYWRlJyxcbiAgU0hPVyA6ICdzaG93J1xufVxuXG5jb25zdCBTZWxlY3RvciA9IHtcbiAgVE9PTFRJUCAgICAgICA6ICcudG9vbHRpcCcsXG4gIFRPT0xUSVBfSU5ORVIgOiAnLnRvb2x0aXAtaW5uZXInLFxuICBBUlJPVyAgICAgICAgIDogJy5hcnJvdydcbn1cblxuY29uc3QgVHJpZ2dlciA9IHtcbiAgSE9WRVIgIDogJ2hvdmVyJyxcbiAgRk9DVVMgIDogJ2ZvY3VzJyxcbiAgQ0xJQ0sgIDogJ2NsaWNrJyxcbiAgTUFOVUFMIDogJ21hbnVhbCdcbn1cblxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgVG9vbHRpcCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIC8qKlxuICAgICAqIENoZWNrIGZvciBQb3BwZXIgZGVwZW5kZW5jeVxuICAgICAqIFBvcHBlciAtIGh0dHBzOi8vcG9wcGVyLmpzLm9yZ1xuICAgICAqL1xuICAgIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyB0b29sdGlwcyByZXF1aXJlIFBvcHBlci5qcyAoaHR0cHM6Ly9wb3BwZXIuanMub3JnLyknKVxuICAgIH1cblxuICAgIC8vIHByaXZhdGVcbiAgICB0aGlzLl9pc0VuYWJsZWQgICAgID0gdHJ1ZVxuICAgIHRoaXMuX3RpbWVvdXQgICAgICAgPSAwXG4gICAgdGhpcy5faG92ZXJTdGF0ZSAgICA9ICcnXG4gICAgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IHt9XG4gICAgdGhpcy5fcG9wcGVyICAgICAgICA9IG51bGxcblxuICAgIC8vIFByb3RlY3RlZFxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnRcbiAgICB0aGlzLmNvbmZpZyAgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgIHRoaXMudGlwICAgICA9IG51bGxcblxuICAgIHRoaXMuX3NldExpc3RlbmVycygpXG4gIH1cblxuICAvLyBHZXR0ZXJzXG5cbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRVxuICB9XG5cbiAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICByZXR1cm4gREFUQV9LRVlcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRXZlbnQoKSB7XG4gICAgcmV0dXJuIEV2ZW50XG4gIH1cblxuICBzdGF0aWMgZ2V0IEVWRU5UX0tFWSgpIHtcbiAgICByZXR1cm4gRVZFTlRfS0VZXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZVxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgZW5hYmxlKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWVcbiAgfVxuXG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2VcbiAgfVxuXG4gIHRvZ2dsZUVuYWJsZWQoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZFxuICB9XG5cbiAgdG9nZ2xlKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChldmVudCkge1xuICAgICAgY29uc3QgZGF0YUtleSA9IHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVlcbiAgICAgIGxldCBjb250ZXh0ID0gJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXkpXG5cbiAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoXG4gICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgICAgICB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpXG4gICAgICAgIClcbiAgICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXksIGNvbnRleHQpXG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXIuY2xpY2sgPSAhY29udGV4dC5fYWN0aXZlVHJpZ2dlci5jbGlja1xuXG4gICAgICBpZiAoY29udGV4dC5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICAgIGNvbnRleHQuX2VudGVyKG51bGwsIGNvbnRleHQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0Ll9sZWF2ZShudWxsLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJCh0aGlzLmdldFRpcEVsZW1lbnQoKSkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpKSB7XG4gICAgICAgIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbnRlcihudWxsLCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpXG5cbiAgICAkLnJlbW92ZURhdGEodGhpcy5lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKVxuXG4gICAgJCh0aGlzLmVsZW1lbnQpLm9mZih0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSlcbiAgICAkKHRoaXMuZWxlbWVudCkuY2xvc2VzdCgnLm1vZGFsJykub2ZmKCdoaWRlLmJzLm1vZGFsJylcblxuICAgIGlmICh0aGlzLnRpcCkge1xuICAgICAgJCh0aGlzLnRpcCkucmVtb3ZlKClcbiAgICB9XG5cbiAgICB0aGlzLl9pc0VuYWJsZWQgICAgID0gbnVsbFxuICAgIHRoaXMuX3RpbWVvdXQgICAgICAgPSBudWxsXG4gICAgdGhpcy5faG92ZXJTdGF0ZSAgICA9IG51bGxcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyID0gbnVsbFxuICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KClcbiAgICB9XG5cbiAgICB0aGlzLl9wb3BwZXIgPSBudWxsXG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbFxuICAgIHRoaXMuY29uZmlnICA9IG51bGxcbiAgICB0aGlzLnRpcCAgICAgPSBudWxsXG4gIH1cblxuICBzaG93KCkge1xuICAgIGlmICgkKHRoaXMuZWxlbWVudCkuY3NzKCdkaXNwbGF5JykgPT09ICdub25lJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgdXNlIHNob3cgb24gdmlzaWJsZSBlbGVtZW50cycpXG4gICAgfVxuXG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gJC5FdmVudCh0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1cpXG4gICAgaWYgKHRoaXMuaXNXaXRoQ29udGVudCgpICYmIHRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgJCh0aGlzLmVsZW1lbnQpLnRyaWdnZXIoc2hvd0V2ZW50KVxuXG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gVXRpbC5maW5kU2hhZG93Um9vdCh0aGlzLmVsZW1lbnQpXG4gICAgICBjb25zdCBpc0luVGhlRG9tID0gJC5jb250YWlucyhcbiAgICAgICAgc2hhZG93Um9vdCAhPT0gbnVsbCA/IHNoYWRvd1Jvb3QgOiB0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgIHRoaXMuZWxlbWVudFxuICAgICAgKVxuXG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8ICFpc0luVGhlRG9tKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB0aXAgICA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpXG4gICAgICBjb25zdCB0aXBJZCA9IFV0aWwuZ2V0VUlEKHRoaXMuY29uc3RydWN0b3IuTkFNRSlcblxuICAgICAgdGlwLnNldEF0dHJpYnV0ZSgnaWQnLCB0aXBJZClcbiAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aXBJZClcblxuICAgICAgdGhpcy5zZXRDb250ZW50KClcblxuICAgICAgaWYgKHRoaXMuY29uZmlnLmFuaW1hdGlvbikge1xuICAgICAgICAkKHRpcCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLkZBREUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBsYWNlbWVudCAgPSB0eXBlb2YgdGhpcy5jb25maWcucGxhY2VtZW50ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdGhpcy5jb25maWcucGxhY2VtZW50LmNhbGwodGhpcywgdGlwLCB0aGlzLmVsZW1lbnQpXG4gICAgICAgIDogdGhpcy5jb25maWcucGxhY2VtZW50XG5cbiAgICAgIGNvbnN0IGF0dGFjaG1lbnQgPSB0aGlzLl9nZXRBdHRhY2htZW50KHBsYWNlbWVudClcbiAgICAgIHRoaXMuYWRkQXR0YWNobWVudENsYXNzKGF0dGFjaG1lbnQpXG5cbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX2dldENvbnRhaW5lcigpXG4gICAgICAkKHRpcCkuZGF0YSh0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLCB0aGlzKVxuXG4gICAgICBpZiAoISQuY29udGFpbnModGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLnRpcCkpIHtcbiAgICAgICAgJCh0aXApLmFwcGVuZFRvKGNvbnRhaW5lcilcbiAgICAgIH1cblxuICAgICAgJCh0aGlzLmVsZW1lbnQpLnRyaWdnZXIodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5JTlNFUlRFRClcblxuICAgICAgdGhpcy5fcG9wcGVyID0gbmV3IFBvcHBlcih0aGlzLmVsZW1lbnQsIHRpcCwge1xuICAgICAgICBwbGFjZW1lbnQ6IGF0dGFjaG1lbnQsXG4gICAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KCksXG4gICAgICAgICAgZmxpcDoge1xuICAgICAgICAgICAgYmVoYXZpb3I6IHRoaXMuY29uZmlnLmZhbGxiYWNrUGxhY2VtZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhcnJvdzoge1xuICAgICAgICAgICAgZWxlbWVudDogU2VsZWN0b3IuQVJST1dcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByZXZlbnRPdmVyZmxvdzoge1xuICAgICAgICAgICAgYm91bmRhcmllc0VsZW1lbnQ6IHRoaXMuY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkNyZWF0ZTogKGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAoZGF0YS5vcmlnaW5hbFBsYWNlbWVudCAhPT0gZGF0YS5wbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShkYXRhKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25VcGRhdGU6IChkYXRhKSA9PiB0aGlzLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UoZGF0YSlcbiAgICAgIH0pXG5cbiAgICAgICQodGlwKS5hZGRDbGFzcyhDbGFzc05hbWUuU0hPVylcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB0byB0aGUgYm9keSdzIGltbWVkaWF0ZSBjaGlsZHJlbjtcbiAgICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXG4gICAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgJChkb2N1bWVudC5ib2R5KS5jaGlsZHJlbigpLm9uKCdtb3VzZW92ZXInLCBudWxsLCAkLm5vb3ApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5fZml4VHJhbnNpdGlvbigpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldkhvdmVyU3RhdGUgPSB0aGlzLl9ob3ZlclN0YXRlXG4gICAgICAgIHRoaXMuX2hvdmVyU3RhdGUgICAgID0gbnVsbFxuXG4gICAgICAgICQodGhpcy5lbGVtZW50KS50cmlnZ2VyKHRoaXMuY29uc3RydWN0b3IuRXZlbnQuU0hPV04pXG5cbiAgICAgICAgaWYgKHByZXZIb3ZlclN0YXRlID09PSBIb3ZlclN0YXRlLk9VVCkge1xuICAgICAgICAgIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCQodGhpcy50aXApLmhhc0NsYXNzKENsYXNzTmFtZS5GQURFKSkge1xuICAgICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMudGlwKVxuXG4gICAgICAgICQodGhpcy50aXApXG4gICAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGxldGUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhpZGUoY2FsbGJhY2spIHtcbiAgICBjb25zdCB0aXAgICAgICAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKVxuICAgIGNvbnN0IGhpZGVFdmVudCA9ICQuRXZlbnQodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURFKVxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2hvdmVyU3RhdGUgIT09IEhvdmVyU3RhdGUuU0hPVyAmJiB0aXAucGFyZW50Tm9kZSkge1xuICAgICAgICB0aXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aXApXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKVxuICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpXG4gICAgICAkKHRoaXMuZWxlbWVudCkudHJpZ2dlcih0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJRERFTilcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKVxuICAgICAgfVxuICAgIH1cblxuICAgICQodGhpcy5lbGVtZW50KS50cmlnZ2VyKGhpZGVFdmVudClcblxuICAgIGlmIChoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgICQodGlwKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVylcblxuICAgIC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXG4gICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAkKGRvY3VtZW50LmJvZHkpLmNoaWxkcmVuKCkub2ZmKCdtb3VzZW92ZXInLCBudWxsLCAkLm5vb3ApXG4gICAgfVxuXG4gICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUcmlnZ2VyLkNMSUNLXSA9IGZhbHNlXG4gICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUcmlnZ2VyLkZPQ1VTXSA9IGZhbHNlXG4gICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUcmlnZ2VyLkhPVkVSXSA9IGZhbHNlXG5cbiAgICBpZiAoJCh0aGlzLnRpcCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRpcClcblxuICAgICAgJCh0aXApXG4gICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlKClcbiAgICB9XG5cbiAgICB0aGlzLl9ob3ZlclN0YXRlID0gJydcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fcG9wcGVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9wb3BwZXIuc2NoZWR1bGVVcGRhdGUoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFByb3RlY3RlZFxuXG4gIGlzV2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5nZXRUaXRsZSgpKVxuICB9XG5cbiAgYWRkQXR0YWNobWVudENsYXNzKGF0dGFjaG1lbnQpIHtcbiAgICAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKS5hZGRDbGFzcyhgJHtDTEFTU19QUkVGSVh9LSR7YXR0YWNobWVudH1gKVxuICB9XG5cbiAgZ2V0VGlwRWxlbWVudCgpIHtcbiAgICB0aGlzLnRpcCA9IHRoaXMudGlwIHx8ICQodGhpcy5jb25maWcudGVtcGxhdGUpWzBdXG4gICAgcmV0dXJuIHRoaXMudGlwXG4gIH1cblxuICBzZXRDb250ZW50KCkge1xuICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpXG4gICAgdGhpcy5zZXRFbGVtZW50Q29udGVudCgkKHRpcC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yLlRPT0xUSVBfSU5ORVIpKSwgdGhpcy5nZXRUaXRsZSgpKVxuICAgICQodGlwKS5yZW1vdmVDbGFzcyhgJHtDbGFzc05hbWUuRkFERX0gJHtDbGFzc05hbWUuU0hPV31gKVxuICB9XG5cbiAgc2V0RWxlbWVudENvbnRlbnQoJGVsZW1lbnQsIGNvbnRlbnQpIHtcbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdvYmplY3QnICYmIChjb250ZW50Lm5vZGVUeXBlIHx8IGNvbnRlbnQuanF1ZXJ5KSkge1xuICAgICAgLy8gQ29udGVudCBpcyBhIERPTSBub2RlIG9yIGEgalF1ZXJ5XG4gICAgICBpZiAodGhpcy5jb25maWcuaHRtbCkge1xuICAgICAgICBpZiAoISQoY29udGVudCkucGFyZW50KCkuaXMoJGVsZW1lbnQpKSB7XG4gICAgICAgICAgJGVsZW1lbnQuZW1wdHkoKS5hcHBlbmQoY29udGVudClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGVsZW1lbnQudGV4dCgkKGNvbnRlbnQpLnRleHQoKSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29uZmlnLmh0bWwpIHtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5zYW5pdGl6ZSkge1xuICAgICAgICBjb250ZW50ID0gc2FuaXRpemVIdG1sKGNvbnRlbnQsIHRoaXMuY29uZmlnLndoaXRlTGlzdCwgdGhpcy5jb25maWcuc2FuaXRpemVGbilcbiAgICAgIH1cblxuICAgICAgJGVsZW1lbnQuaHRtbChjb250ZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICAkZWxlbWVudC50ZXh0KGNvbnRlbnQpXG4gICAgfVxuICB9XG5cbiAgZ2V0VGl0bGUoKSB7XG4gICAgbGV0IHRpdGxlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpXG5cbiAgICBpZiAoIXRpdGxlKSB7XG4gICAgICB0aXRsZSA9IHR5cGVvZiB0aGlzLmNvbmZpZy50aXRsZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHRoaXMuY29uZmlnLnRpdGxlLmNhbGwodGhpcy5lbGVtZW50KVxuICAgICAgICA6IHRoaXMuY29uZmlnLnRpdGxlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRpdGxlXG4gIH1cblxuICAvLyBQcml2YXRlXG5cbiAgX2dldE9mZnNldCgpIHtcbiAgICBjb25zdCBvZmZzZXQgPSB7fVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZy5vZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9mZnNldC5mbiA9IChkYXRhKSA9PiB7XG4gICAgICAgIGRhdGEub2Zmc2V0cyA9IHtcbiAgICAgICAgICAuLi5kYXRhLm9mZnNldHMsXG4gICAgICAgICAgLi4udGhpcy5jb25maWcub2Zmc2V0KGRhdGEub2Zmc2V0cywgdGhpcy5lbGVtZW50KSB8fCB7fVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0Lm9mZnNldCA9IHRoaXMuY29uZmlnLm9mZnNldFxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXRcbiAgfVxuXG4gIF9nZXRDb250YWluZXIoKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmNvbnRhaW5lciA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5XG4gICAgfVxuXG4gICAgaWYgKFV0aWwuaXNFbGVtZW50KHRoaXMuY29uZmlnLmNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybiAkKHRoaXMuY29uZmlnLmNvbnRhaW5lcilcbiAgICB9XG5cbiAgICByZXR1cm4gJChkb2N1bWVudCkuZmluZCh0aGlzLmNvbmZpZy5jb250YWluZXIpXG4gIH1cblxuICBfZ2V0QXR0YWNobWVudChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gQXR0YWNobWVudE1hcFtwbGFjZW1lbnQudG9VcHBlckNhc2UoKV1cbiAgfVxuXG4gIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgdHJpZ2dlcnMgPSB0aGlzLmNvbmZpZy50cmlnZ2VyLnNwbGl0KCcgJylcblxuICAgIHRyaWdnZXJzLmZvckVhY2goKHRyaWdnZXIpID0+IHtcbiAgICAgIGlmICh0cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgICQodGhpcy5lbGVtZW50KS5vbihcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkNMSUNLLFxuICAgICAgICAgIHRoaXMuY29uZmlnLnNlbGVjdG9yLFxuICAgICAgICAgIChldmVudCkgPT4gdGhpcy50b2dnbGUoZXZlbnQpXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAodHJpZ2dlciAhPT0gVHJpZ2dlci5NQU5VQUwpIHtcbiAgICAgICAgY29uc3QgZXZlbnRJbiA9IHRyaWdnZXIgPT09IFRyaWdnZXIuSE9WRVJcbiAgICAgICAgICA/IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VFTlRFUlxuICAgICAgICAgIDogdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU0lOXG4gICAgICAgIGNvbnN0IGV2ZW50T3V0ID0gdHJpZ2dlciA9PT0gVHJpZ2dlci5IT1ZFUlxuICAgICAgICAgID8gdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUxFQVZFXG4gICAgICAgICAgOiB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTT1VUXG5cbiAgICAgICAgJCh0aGlzLmVsZW1lbnQpXG4gICAgICAgICAgLm9uKFxuICAgICAgICAgICAgZXZlbnRJbixcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNlbGVjdG9yLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB0aGlzLl9lbnRlcihldmVudClcbiAgICAgICAgICApXG4gICAgICAgICAgLm9uKFxuICAgICAgICAgICAgZXZlbnRPdXQsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZWxlY3RvcixcbiAgICAgICAgICAgIChldmVudCkgPT4gdGhpcy5fbGVhdmUoZXZlbnQpXG4gICAgICAgICAgKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAkKHRoaXMuZWxlbWVudCkuY2xvc2VzdCgnLm1vZGFsJykub24oXG4gICAgICAnaGlkZS5icy5tb2RhbCcsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLmhpZGUoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuXG4gICAgaWYgKHRoaXMuY29uZmlnLnNlbGVjdG9yKSB7XG4gICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICBzZWxlY3RvcjogJydcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZml4VGl0bGUoKVxuICAgIH1cbiAgfVxuXG4gIF9maXhUaXRsZSgpIHtcbiAgICBjb25zdCB0aXRsZVR5cGUgPSB0eXBlb2YgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpXG5cbiAgICBpZiAodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgndGl0bGUnKSB8fCB0aXRsZVR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFxuICAgICAgICAnZGF0YS1vcmlnaW5hbC10aXRsZScsXG4gICAgICAgIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykgfHwgJydcbiAgICAgIClcblxuICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnJylcbiAgICB9XG4gIH1cblxuICBfZW50ZXIoZXZlbnQsIGNvbnRleHQpIHtcbiAgICBjb25zdCBkYXRhS2V5ID0gdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWVxuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5KVxuXG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICBjb250ZXh0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoXG4gICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKClcbiAgICAgIClcbiAgICAgICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5LCBjb250ZXh0KVxuICAgIH1cblxuICAgIGlmIChldmVudCkge1xuICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltcbiAgICAgICAgZXZlbnQudHlwZSA9PT0gJ2ZvY3VzaW4nID8gVHJpZ2dlci5GT0NVUyA6IFRyaWdnZXIuSE9WRVJcbiAgICAgIF0gPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKCQoY29udGV4dC5nZXRUaXBFbGVtZW50KCkpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSB8fCBjb250ZXh0Ll9ob3ZlclN0YXRlID09PSBIb3ZlclN0YXRlLlNIT1cpIHtcbiAgICAgIGNvbnRleHQuX2hvdmVyU3RhdGUgPSBIb3ZlclN0YXRlLlNIT1dcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNsZWFyVGltZW91dChjb250ZXh0Ll90aW1lb3V0KVxuXG4gICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhvdmVyU3RhdGUuU0hPV1xuXG4gICAgaWYgKCFjb250ZXh0LmNvbmZpZy5kZWxheSB8fCAhY29udGV4dC5jb25maWcuZGVsYXkuc2hvdykge1xuICAgICAgY29udGV4dC5zaG93KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnRleHQuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChjb250ZXh0Ll9ob3ZlclN0YXRlID09PSBIb3ZlclN0YXRlLlNIT1cpIHtcbiAgICAgICAgY29udGV4dC5zaG93KClcbiAgICAgIH1cbiAgICB9LCBjb250ZXh0LmNvbmZpZy5kZWxheS5zaG93KVxuICB9XG5cbiAgX2xlYXZlKGV2ZW50LCBjb250ZXh0KSB7XG4gICAgY29uc3QgZGF0YUtleSA9IHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVlcbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSlcblxuICAgIGlmICghY29udGV4dCkge1xuICAgICAgY29udGV4dCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKFxuICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpXG4gICAgICApXG4gICAgICAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSwgY29udGV4dClcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbXG4gICAgICAgIGV2ZW50LnR5cGUgPT09ICdmb2N1c291dCcgPyBUcmlnZ2VyLkZPQ1VTIDogVHJpZ2dlci5IT1ZFUlxuICAgICAgXSA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuX3RpbWVvdXQpXG5cbiAgICBjb250ZXh0Ll9ob3ZlclN0YXRlID0gSG92ZXJTdGF0ZS5PVVRcblxuICAgIGlmICghY29udGV4dC5jb25maWcuZGVsYXkgfHwgIWNvbnRleHQuY29uZmlnLmRlbGF5LmhpZGUpIHtcbiAgICAgIGNvbnRleHQuaGlkZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb250ZXh0Ll90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSG92ZXJTdGF0ZS5PVVQpIHtcbiAgICAgICAgY29udGV4dC5oaWRlKClcbiAgICAgIH1cbiAgICB9LCBjb250ZXh0LmNvbmZpZy5kZWxheS5oaWRlKVxuICB9XG5cbiAgX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XG4gICAgZm9yIChjb25zdCB0cmlnZ2VyIGluIHRoaXMuX2FjdGl2ZVRyaWdnZXIpIHtcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUcmlnZ2VyW3RyaWdnZXJdKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbnN0IGRhdGFBdHRyaWJ1dGVzID0gJCh0aGlzLmVsZW1lbnQpLmRhdGEoKVxuXG4gICAgT2JqZWN0LmtleXMoZGF0YUF0dHJpYnV0ZXMpXG4gICAgICAuZm9yRWFjaCgoZGF0YUF0dHIpID0+IHtcbiAgICAgICAgaWYgKERJU0FMTE9XRURfQVRUUklCVVRFUy5pbmRleE9mKGRhdGFBdHRyKSAhPT0gLTEpIHtcbiAgICAgICAgICBkZWxldGUgZGF0YUF0dHJpYnV0ZXNbZGF0YUF0dHJdXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICBjb25maWcgPSB7XG4gICAgICAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAuLi5kYXRhQXR0cmlidXRlcyxcbiAgICAgIC4uLnR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25maWcuZGVsYXkgPSB7XG4gICAgICAgIHNob3c6IGNvbmZpZy5kZWxheSxcbiAgICAgICAgaGlkZTogY29uZmlnLmRlbGF5XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcudGl0bGUgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25maWcudGl0bGUgPSBjb25maWcudGl0bGUudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnLmNvbnRlbnQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25maWcuY29udGVudCA9IGNvbmZpZy5jb250ZW50LnRvU3RyaW5nKClcbiAgICB9XG5cbiAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhcbiAgICAgIE5BTUUsXG4gICAgICBjb25maWcsXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlXG4gICAgKVxuXG4gICAgaWYgKGNvbmZpZy5zYW5pdGl6ZSkge1xuICAgICAgY29uZmlnLnRlbXBsYXRlID0gc2FuaXRpemVIdG1sKGNvbmZpZy50ZW1wbGF0ZSwgY29uZmlnLndoaXRlTGlzdCwgY29uZmlnLnNhbml0aXplRm4pXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX2dldERlbGVnYXRlQ29uZmlnKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHt9XG5cbiAgICBpZiAodGhpcy5jb25maWcpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuY29uZmlnKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRba2V5XSAhPT0gdGhpcy5jb25maWdba2V5XSkge1xuICAgICAgICAgIGNvbmZpZ1trZXldID0gdGhpcy5jb25maWdba2V5XVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX2NsZWFuVGlwQ2xhc3MoKSB7XG4gICAgY29uc3QgJHRpcCA9ICQodGhpcy5nZXRUaXBFbGVtZW50KCkpXG4gICAgY29uc3QgdGFiQ2xhc3MgPSAkdGlwLmF0dHIoJ2NsYXNzJykubWF0Y2goQlNDTFNfUFJFRklYX1JFR0VYKVxuICAgIGlmICh0YWJDbGFzcyAhPT0gbnVsbCAmJiB0YWJDbGFzcy5sZW5ndGgpIHtcbiAgICAgICR0aXAucmVtb3ZlQ2xhc3ModGFiQ2xhc3Muam9pbignJykpXG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShwb3BwZXJEYXRhKSB7XG4gICAgY29uc3QgcG9wcGVySW5zdGFuY2UgPSBwb3BwZXJEYXRhLmluc3RhbmNlXG4gICAgdGhpcy50aXAgPSBwb3BwZXJJbnN0YW5jZS5wb3BwZXJcbiAgICB0aGlzLl9jbGVhblRpcENsYXNzKClcbiAgICB0aGlzLmFkZEF0dGFjaG1lbnRDbGFzcyh0aGlzLl9nZXRBdHRhY2htZW50KHBvcHBlckRhdGEucGxhY2VtZW50KSlcbiAgfVxuXG4gIF9maXhUcmFuc2l0aW9uKCkge1xuICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpXG4gICAgY29uc3QgaW5pdENvbmZpZ0FuaW1hdGlvbiA9IHRoaXMuY29uZmlnLmFuaW1hdGlvblxuXG4gICAgaWYgKHRpcC5nZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JykgIT09IG51bGwpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgICQodGlwKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuRkFERSlcbiAgICB0aGlzLmNvbmZpZy5hbmltYXRpb24gPSBmYWxzZVxuICAgIHRoaXMuaGlkZSgpXG4gICAgdGhpcy5zaG93KClcbiAgICB0aGlzLmNvbmZpZy5hbmltYXRpb24gPSBpbml0Q29uZmlnQW5pbWF0aW9uXG4gIH1cblxuICAvLyBTdGF0aWNcblxuICBzdGF0aWMgX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBkYXRhID0gJCh0aGlzKS5kYXRhKERBVEFfS0VZKVxuICAgICAgY29uc3QgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZ1xuXG4gICAgICBpZiAoIWRhdGEgJiYgL2Rpc3Bvc2V8aGlkZS8udGVzdChjb25maWcpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBUb29sdGlwKHRoaXMsIF9jb25maWcpXG4gICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSlcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgICAgfVxuICAgICAgICBkYXRhW2NvbmZpZ10oKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuJC5mbltOQU1FXSA9IFRvb2x0aXAuX2pRdWVyeUludGVyZmFjZVxuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IFRvb2x0aXBcbiQuZm5bTkFNRV0ubm9Db25mbGljdCA9ICgpID0+IHtcbiAgJC5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVFxuICByZXR1cm4gVG9vbHRpcC5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRvb2x0aXBcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuMy4xKTogcG9wb3Zlci5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0IFRvb2x0aXAgZnJvbSAnLi90b29sdGlwJ1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FICAgICAgICAgICAgICAgID0gJ3BvcG92ZXInXG5jb25zdCBWRVJTSU9OICAgICAgICAgICAgID0gJzQuMy4xJ1xuY29uc3QgREFUQV9LRVkgICAgICAgICAgICA9ICdicy5wb3BvdmVyJ1xuY29uc3QgRVZFTlRfS0VZICAgICAgICAgICA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgID0gJC5mbltOQU1FXVxuY29uc3QgQ0xBU1NfUFJFRklYICAgICAgICA9ICdicy1wb3BvdmVyJ1xuY29uc3QgQlNDTFNfUFJFRklYX1JFR0VYICA9IG5ldyBSZWdFeHAoYChefFxcXFxzKSR7Q0xBU1NfUFJFRklYfVxcXFxTK2AsICdnJylcblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgLi4uVG9vbHRpcC5EZWZhdWx0LFxuICBwbGFjZW1lbnQgOiAncmlnaHQnLFxuICB0cmlnZ2VyICAgOiAnY2xpY2snLFxuICBjb250ZW50ICAgOiAnJyxcbiAgdGVtcGxhdGUgIDogJzxkaXYgY2xhc3M9XCJwb3BvdmVyXCIgcm9sZT1cInRvb2x0aXBcIj4nICtcbiAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PicgK1xuICAgICAgICAgICAgICAnPGgzIGNsYXNzPVwicG9wb3Zlci1oZWFkZXJcIj48L2gzPicgK1xuICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInBvcG92ZXItYm9keVwiPjwvZGl2PjwvZGl2Pidcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIC4uLlRvb2x0aXAuRGVmYXVsdFR5cGUsXG4gIGNvbnRlbnQgOiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKSdcbn1cblxuY29uc3QgQ2xhc3NOYW1lID0ge1xuICBGQURFIDogJ2ZhZGUnLFxuICBTSE9XIDogJ3Nob3cnXG59XG5cbmNvbnN0IFNlbGVjdG9yID0ge1xuICBUSVRMRSAgIDogJy5wb3BvdmVyLWhlYWRlcicsXG4gIENPTlRFTlQgOiAnLnBvcG92ZXItYm9keSdcbn1cblxuY29uc3QgRXZlbnQgPSB7XG4gIEhJREUgICAgICAgOiBgaGlkZSR7RVZFTlRfS0VZfWAsXG4gIEhJRERFTiAgICAgOiBgaGlkZGVuJHtFVkVOVF9LRVl9YCxcbiAgU0hPVyAgICAgICA6IGBzaG93JHtFVkVOVF9LRVl9YCxcbiAgU0hPV04gICAgICA6IGBzaG93biR7RVZFTlRfS0VZfWAsXG4gIElOU0VSVEVEICAgOiBgaW5zZXJ0ZWQke0VWRU5UX0tFWX1gLFxuICBDTElDSyAgICAgIDogYGNsaWNrJHtFVkVOVF9LRVl9YCxcbiAgRk9DVVNJTiAgICA6IGBmb2N1c2luJHtFVkVOVF9LRVl9YCxcbiAgRk9DVVNPVVQgICA6IGBmb2N1c291dCR7RVZFTlRfS0VZfWAsXG4gIE1PVVNFRU5URVIgOiBgbW91c2VlbnRlciR7RVZFTlRfS0VZfWAsXG4gIE1PVVNFTEVBVkUgOiBgbW91c2VsZWF2ZSR7RVZFTlRfS0VZfWBcbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNsYXNzIFBvcG92ZXIgZXh0ZW5kcyBUb29sdGlwIHtcbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUVcbiAgfVxuXG4gIHN0YXRpYyBnZXQgREFUQV9LRVkoKSB7XG4gICAgcmV0dXJuIERBVEFfS0VZXG4gIH1cblxuICBzdGF0aWMgZ2V0IEV2ZW50KCkge1xuICAgIHJldHVybiBFdmVudFxuICB9XG5cbiAgc3RhdGljIGdldCBFVkVOVF9LRVkoKSB7XG4gICAgcmV0dXJuIEVWRU5UX0tFWVxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGVcbiAgfVxuXG4gIC8vIE92ZXJyaWRlc1xuXG4gIGlzV2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KClcbiAgfVxuXG4gIGFkZEF0dGFjaG1lbnRDbGFzcyhhdHRhY2htZW50KSB7XG4gICAgJCh0aGlzLmdldFRpcEVsZW1lbnQoKSkuYWRkQ2xhc3MoYCR7Q0xBU1NfUFJFRklYfS0ke2F0dGFjaG1lbnR9YClcbiAgfVxuXG4gIGdldFRpcEVsZW1lbnQoKSB7XG4gICAgdGhpcy50aXAgPSB0aGlzLnRpcCB8fCAkKHRoaXMuY29uZmlnLnRlbXBsYXRlKVswXVxuICAgIHJldHVybiB0aGlzLnRpcFxuICB9XG5cbiAgc2V0Q29udGVudCgpIHtcbiAgICBjb25zdCAkdGlwID0gJCh0aGlzLmdldFRpcEVsZW1lbnQoKSlcblxuICAgIC8vIFdlIHVzZSBhcHBlbmQgZm9yIGh0bWwgb2JqZWN0cyB0byBtYWludGFpbiBqcyBldmVudHNcbiAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KCR0aXAuZmluZChTZWxlY3Rvci5USVRMRSksIHRoaXMuZ2V0VGl0bGUoKSlcbiAgICBsZXQgY29udGVudCA9IHRoaXMuX2dldENvbnRlbnQoKVxuICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29udGVudCA9IGNvbnRlbnQuY2FsbCh0aGlzLmVsZW1lbnQpXG4gICAgfVxuICAgIHRoaXMuc2V0RWxlbWVudENvbnRlbnQoJHRpcC5maW5kKFNlbGVjdG9yLkNPTlRFTlQpLCBjb250ZW50KVxuXG4gICAgJHRpcC5yZW1vdmVDbGFzcyhgJHtDbGFzc05hbWUuRkFERX0gJHtDbGFzc05hbWUuU0hPV31gKVxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIF9nZXRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbnRlbnQnKSB8fFxuICAgICAgdGhpcy5jb25maWcuY29udGVudFxuICB9XG5cbiAgX2NsZWFuVGlwQ2xhc3MoKSB7XG4gICAgY29uc3QgJHRpcCA9ICQodGhpcy5nZXRUaXBFbGVtZW50KCkpXG4gICAgY29uc3QgdGFiQ2xhc3MgPSAkdGlwLmF0dHIoJ2NsYXNzJykubWF0Y2goQlNDTFNfUFJFRklYX1JFR0VYKVxuICAgIGlmICh0YWJDbGFzcyAhPT0gbnVsbCAmJiB0YWJDbGFzcy5sZW5ndGggPiAwKSB7XG4gICAgICAkdGlwLnJlbW92ZUNsYXNzKHRhYkNsYXNzLmpvaW4oJycpKVxuICAgIH1cbiAgfVxuXG4gIC8vIFN0YXRpY1xuXG4gIHN0YXRpYyBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpXG4gICAgICBjb25zdCBfY29uZmlnID0gdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiBudWxsXG5cbiAgICAgIGlmICghZGF0YSAmJiAvZGlzcG9zZXxoaWRlLy50ZXN0KGNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0gbmV3IFBvcG92ZXIodGhpcywgX2NvbmZpZylcbiAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kLmZuW05BTUVdID0gUG9wb3Zlci5falF1ZXJ5SW50ZXJmYWNlXG4kLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gUG9wb3ZlclxuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBQb3BvdmVyLl9qUXVlcnlJbnRlcmZhY2Vcbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9wb3ZlclxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC4zLjEpOiBzY3JvbGxzcHkuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSdcbmltcG9ydCBVdGlsIGZyb20gJy4vdXRpbCdcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSAgICAgICAgICAgICAgID0gJ3Njcm9sbHNweSdcbmNvbnN0IFZFUlNJT04gICAgICAgICAgICA9ICc0LjMuMSdcbmNvbnN0IERBVEFfS0VZICAgICAgICAgICA9ICdicy5zY3JvbGxzcHknXG5jb25zdCBFVkVOVF9LRVkgICAgICAgICAgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgREFUQV9BUElfS0VZICAgICAgID0gJy5kYXRhLWFwaSdcbmNvbnN0IEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV1cblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgb2Zmc2V0IDogMTAsXG4gIG1ldGhvZCA6ICdhdXRvJyxcbiAgdGFyZ2V0IDogJydcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIG9mZnNldCA6ICdudW1iZXInLFxuICBtZXRob2QgOiAnc3RyaW5nJyxcbiAgdGFyZ2V0IDogJyhzdHJpbmd8ZWxlbWVudCknXG59XG5cbmNvbnN0IEV2ZW50ID0ge1xuICBBQ1RJVkFURSAgICAgIDogYGFjdGl2YXRlJHtFVkVOVF9LRVl9YCxcbiAgU0NST0xMICAgICAgICA6IGBzY3JvbGwke0VWRU5UX0tFWX1gLFxuICBMT0FEX0RBVEFfQVBJIDogYGxvYWQke0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG59XG5cbmNvbnN0IENsYXNzTmFtZSA9IHtcbiAgRFJPUERPV05fSVRFTSA6ICdkcm9wZG93bi1pdGVtJyxcbiAgRFJPUERPV05fTUVOVSA6ICdkcm9wZG93bi1tZW51JyxcbiAgQUNUSVZFICAgICAgICA6ICdhY3RpdmUnXG59XG5cbmNvbnN0IFNlbGVjdG9yID0ge1xuICBEQVRBX1NQWSAgICAgICAgOiAnW2RhdGEtc3B5PVwic2Nyb2xsXCJdJyxcbiAgQUNUSVZFICAgICAgICAgIDogJy5hY3RpdmUnLFxuICBOQVZfTElTVF9HUk9VUCAgOiAnLm5hdiwgLmxpc3QtZ3JvdXAnLFxuICBOQVZfTElOS1MgICAgICAgOiAnLm5hdi1saW5rJyxcbiAgTkFWX0lURU1TICAgICAgIDogJy5uYXYtaXRlbScsXG4gIExJU1RfSVRFTVMgICAgICA6ICcubGlzdC1ncm91cC1pdGVtJyxcbiAgRFJPUERPV04gICAgICAgIDogJy5kcm9wZG93bicsXG4gIERST1BET1dOX0lURU1TICA6ICcuZHJvcGRvd24taXRlbScsXG4gIERST1BET1dOX1RPR0dMRSA6ICcuZHJvcGRvd24tdG9nZ2xlJ1xufVxuXG5jb25zdCBPZmZzZXRNZXRob2QgPSB7XG4gIE9GRlNFVCAgIDogJ29mZnNldCcsXG4gIFBPU0lUSU9OIDogJ3Bvc2l0aW9uJ1xufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgU2Nyb2xsU3B5IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgdGhpcy5fZWxlbWVudCAgICAgICA9IGVsZW1lbnRcbiAgICB0aGlzLl9zY3JvbGxFbGVtZW50ID0gZWxlbWVudC50YWdOYW1lID09PSAnQk9EWScgPyB3aW5kb3cgOiBlbGVtZW50XG4gICAgdGhpcy5fY29uZmlnICAgICAgICA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpXG4gICAgdGhpcy5fc2VsZWN0b3IgICAgICA9IGAke3RoaXMuX2NvbmZpZy50YXJnZXR9ICR7U2VsZWN0b3IuTkFWX0xJTktTfSxgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5fY29uZmlnLnRhcmdldH0gJHtTZWxlY3Rvci5MSVNUX0lURU1TfSxgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5fY29uZmlnLnRhcmdldH0gJHtTZWxlY3Rvci5EUk9QRE9XTl9JVEVNU31gXG4gICAgdGhpcy5fb2Zmc2V0cyAgICAgICA9IFtdXG4gICAgdGhpcy5fdGFyZ2V0cyAgICAgICA9IFtdXG4gICAgdGhpcy5fYWN0aXZlVGFyZ2V0ICA9IG51bGxcbiAgICB0aGlzLl9zY3JvbGxIZWlnaHQgID0gMFxuXG4gICAgJCh0aGlzLl9zY3JvbGxFbGVtZW50KS5vbihFdmVudC5TQ1JPTEwsIChldmVudCkgPT4gdGhpcy5fcHJvY2VzcyhldmVudCkpXG5cbiAgICB0aGlzLnJlZnJlc2goKVxuICAgIHRoaXMuX3Byb2Nlc3MoKVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICAvLyBQdWJsaWNcblxuICByZWZyZXNoKCkge1xuICAgIGNvbnN0IGF1dG9NZXRob2QgPSB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB0aGlzLl9zY3JvbGxFbGVtZW50LndpbmRvd1xuICAgICAgPyBPZmZzZXRNZXRob2QuT0ZGU0VUIDogT2Zmc2V0TWV0aG9kLlBPU0lUSU9OXG5cbiAgICBjb25zdCBvZmZzZXRNZXRob2QgPSB0aGlzLl9jb25maWcubWV0aG9kID09PSAnYXV0bydcbiAgICAgID8gYXV0b01ldGhvZCA6IHRoaXMuX2NvbmZpZy5tZXRob2RcblxuICAgIGNvbnN0IG9mZnNldEJhc2UgPSBvZmZzZXRNZXRob2QgPT09IE9mZnNldE1ldGhvZC5QT1NJVElPTlxuICAgICAgPyB0aGlzLl9nZXRTY3JvbGxUb3AoKSA6IDBcblxuICAgIHRoaXMuX29mZnNldHMgPSBbXVxuICAgIHRoaXMuX3RhcmdldHMgPSBbXVxuXG4gICAgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gdGhpcy5fZ2V0U2Nyb2xsSGVpZ2h0KClcblxuICAgIGNvbnN0IHRhcmdldHMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5fc2VsZWN0b3IpKVxuXG4gICAgdGFyZ2V0c1xuICAgICAgLm1hcCgoZWxlbWVudCkgPT4ge1xuICAgICAgICBsZXQgdGFyZ2V0XG4gICAgICAgIGNvbnN0IHRhcmdldFNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpXG5cbiAgICAgICAgaWYgKHRhcmdldFNlbGVjdG9yKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXRTZWxlY3RvcilcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRCQ1IgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgICBpZiAodGFyZ2V0QkNSLndpZHRoIHx8IHRhcmdldEJDUi5oZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gKGZhdCk6IHJlbW92ZSBza2V0Y2ggcmVsaWFuY2Ugb24galF1ZXJ5IHBvc2l0aW9uL29mZnNldFxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgJCh0YXJnZXQpW29mZnNldE1ldGhvZF0oKS50b3AgKyBvZmZzZXRCYXNlLFxuICAgICAgICAgICAgICB0YXJnZXRTZWxlY3RvclxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0pXG4gICAgICAuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0pXG4gICAgICAuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICB0aGlzLl9vZmZzZXRzLnB1c2goaXRlbVswXSlcbiAgICAgICAgdGhpcy5fdGFyZ2V0cy5wdXNoKGl0ZW1bMV0pXG4gICAgICB9KVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG4gICAgJCh0aGlzLl9zY3JvbGxFbGVtZW50KS5vZmYoRVZFTlRfS0VZKVxuXG4gICAgdGhpcy5fZWxlbWVudCAgICAgICA9IG51bGxcbiAgICB0aGlzLl9zY3JvbGxFbGVtZW50ID0gbnVsbFxuICAgIHRoaXMuX2NvbmZpZyAgICAgICAgPSBudWxsXG4gICAgdGhpcy5fc2VsZWN0b3IgICAgICA9IG51bGxcbiAgICB0aGlzLl9vZmZzZXRzICAgICAgID0gbnVsbFxuICAgIHRoaXMuX3RhcmdldHMgICAgICAgPSBudWxsXG4gICAgdGhpcy5fYWN0aXZlVGFyZ2V0ICA9IG51bGxcbiAgICB0aGlzLl9zY3JvbGxIZWlnaHQgID0gbnVsbFxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0ge1xuICAgICAgLi4uRGVmYXVsdCxcbiAgICAgIC4uLnR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcudGFyZ2V0ICE9PSAnc3RyaW5nJykge1xuICAgICAgbGV0IGlkID0gJChjb25maWcudGFyZ2V0KS5hdHRyKCdpZCcpXG4gICAgICBpZiAoIWlkKSB7XG4gICAgICAgIGlkID0gVXRpbC5nZXRVSUQoTkFNRSlcbiAgICAgICAgJChjb25maWcudGFyZ2V0KS5hdHRyKCdpZCcsIGlkKVxuICAgICAgfVxuICAgICAgY29uZmlnLnRhcmdldCA9IGAjJHtpZH1gXG4gICAgfVxuXG4gICAgVXRpbC50eXBlQ2hlY2tDb25maWcoTkFNRSwgY29uZmlnLCBEZWZhdWx0VHlwZSlcblxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF9nZXRTY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHdpbmRvd1xuICAgICAgPyB0aGlzLl9zY3JvbGxFbGVtZW50LnBhZ2VZT2Zmc2V0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3BcbiAgfVxuXG4gIF9nZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IHx8IE1hdGgubWF4KFxuICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0XG4gICAgKVxuICB9XG5cbiAgX2dldE9mZnNldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93XG4gICAgICA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHRoaXMuX3Njcm9sbEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gIH1cblxuICBfcHJvY2VzcygpIHtcbiAgICBjb25zdCBzY3JvbGxUb3AgICAgPSB0aGlzLl9nZXRTY3JvbGxUb3AoKSArIHRoaXMuX2NvbmZpZy5vZmZzZXRcbiAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSB0aGlzLl9nZXRTY3JvbGxIZWlnaHQoKVxuICAgIGNvbnN0IG1heFNjcm9sbCAgICA9IHRoaXMuX2NvbmZpZy5vZmZzZXQgK1xuICAgICAgc2Nyb2xsSGVpZ2h0IC1cbiAgICAgIHRoaXMuX2dldE9mZnNldEhlaWdodCgpXG5cbiAgICBpZiAodGhpcy5fc2Nyb2xsSGVpZ2h0ICE9PSBzY3JvbGxIZWlnaHQpIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpXG4gICAgfVxuXG4gICAgaWYgKHNjcm9sbFRvcCA+PSBtYXhTY3JvbGwpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX3RhcmdldHNbdGhpcy5fdGFyZ2V0cy5sZW5ndGggLSAxXVxuXG4gICAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGUodGFyZ2V0KVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2FjdGl2ZVRhcmdldCAmJiBzY3JvbGxUb3AgPCB0aGlzLl9vZmZzZXRzWzBdICYmIHRoaXMuX29mZnNldHNbMF0gPiAwKSB7XG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsXG4gICAgICB0aGlzLl9jbGVhcigpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBvZmZzZXRMZW5ndGggPSB0aGlzLl9vZmZzZXRzLmxlbmd0aFxuICAgIGZvciAobGV0IGkgPSBvZmZzZXRMZW5ndGg7IGktLTspIHtcbiAgICAgIGNvbnN0IGlzQWN0aXZlVGFyZ2V0ID0gdGhpcy5fYWN0aXZlVGFyZ2V0ICE9PSB0aGlzLl90YXJnZXRzW2ldICYmXG4gICAgICAgICAgc2Nyb2xsVG9wID49IHRoaXMuX29mZnNldHNbaV0gJiZcbiAgICAgICAgICAodHlwZW9mIHRoaXMuX29mZnNldHNbaSArIDFdID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICBzY3JvbGxUb3AgPCB0aGlzLl9vZmZzZXRzW2kgKyAxXSlcblxuICAgICAgaWYgKGlzQWN0aXZlVGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX2FjdGl2YXRlKHRoaXMuX3RhcmdldHNbaV0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2FjdGl2YXRlKHRhcmdldCkge1xuICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHRhcmdldFxuXG4gICAgdGhpcy5fY2xlYXIoKVxuXG4gICAgY29uc3QgcXVlcmllcyA9IHRoaXMuX3NlbGVjdG9yXG4gICAgICAuc3BsaXQoJywnKVxuICAgICAgLm1hcCgoc2VsZWN0b3IpID0+IGAke3NlbGVjdG9yfVtkYXRhLXRhcmdldD1cIiR7dGFyZ2V0fVwiXSwke3NlbGVjdG9yfVtocmVmPVwiJHt0YXJnZXR9XCJdYClcblxuICAgIGNvbnN0ICRsaW5rID0gJChbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcmllcy5qb2luKCcsJykpKSlcblxuICAgIGlmICgkbGluay5oYXNDbGFzcyhDbGFzc05hbWUuRFJPUERPV05fSVRFTSkpIHtcbiAgICAgICRsaW5rLmNsb3Nlc3QoU2VsZWN0b3IuRFJPUERPV04pLmZpbmQoU2VsZWN0b3IuRFJPUERPV05fVE9HR0xFKS5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKVxuICAgICAgJGxpbmsuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0IHRyaWdnZXJlZCBsaW5rIGFzIGFjdGl2ZVxuICAgICAgJGxpbmsuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSlcbiAgICAgIC8vIFNldCB0cmlnZ2VyZWQgbGlua3MgcGFyZW50cyBhcyBhY3RpdmVcbiAgICAgIC8vIFdpdGggYm90aCA8dWw+IGFuZCA8bmF2PiBtYXJrdXAgYSBwYXJlbnQgaXMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgYW55IG5hdiBhbmNlc3RvclxuICAgICAgJGxpbmsucGFyZW50cyhTZWxlY3Rvci5OQVZfTElTVF9HUk9VUCkucHJldihgJHtTZWxlY3Rvci5OQVZfTElOS1N9LCAke1NlbGVjdG9yLkxJU1RfSVRFTVN9YCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSlcbiAgICAgIC8vIEhhbmRsZSBzcGVjaWFsIGNhc2Ugd2hlbiAubmF2LWxpbmsgaXMgaW5zaWRlIC5uYXYtaXRlbVxuICAgICAgJGxpbmsucGFyZW50cyhTZWxlY3Rvci5OQVZfTElTVF9HUk9VUCkucHJldihTZWxlY3Rvci5OQVZfSVRFTVMpLmNoaWxkcmVuKFNlbGVjdG9yLk5BVl9MSU5LUykuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSlcbiAgICB9XG5cbiAgICAkKHRoaXMuX3Njcm9sbEVsZW1lbnQpLnRyaWdnZXIoRXZlbnQuQUNUSVZBVEUsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRhcmdldFxuICAgIH0pXG4gIH1cblxuICBfY2xlYXIoKSB7XG4gICAgW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuX3NlbGVjdG9yKSlcbiAgICAgIC5maWx0ZXIoKG5vZGUpID0+IG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKENsYXNzTmFtZS5BQ1RJVkUpKVxuICAgICAgLmZvckVhY2goKG5vZGUpID0+IG5vZGUuY2xhc3NMaXN0LnJlbW92ZShDbGFzc05hbWUuQUNUSVZFKSlcbiAgfVxuXG4gIC8vIFN0YXRpY1xuXG4gIHN0YXRpYyBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpXG4gICAgICBjb25zdCBfY29uZmlnID0gdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnXG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0gbmV3IFNjcm9sbFNweSh0aGlzLCBfY29uZmlnKVxuICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApXG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtjb25maWddKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuJCh3aW5kb3cpLm9uKEV2ZW50LkxPQURfREFUQV9BUEksICgpID0+IHtcbiAgY29uc3Qgc2Nyb2xsU3B5cyA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3Rvci5EQVRBX1NQWSkpXG4gIGNvbnN0IHNjcm9sbFNweXNMZW5ndGggPSBzY3JvbGxTcHlzLmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSBzY3JvbGxTcHlzTGVuZ3RoOyBpLS07KSB7XG4gICAgY29uc3QgJHNweSA9ICQoc2Nyb2xsU3B5c1tpXSlcbiAgICBTY3JvbGxTcHkuX2pRdWVyeUludGVyZmFjZS5jYWxsKCRzcHksICRzcHkuZGF0YSgpKVxuICB9XG59KVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kLmZuW05BTUVdID0gU2Nyb2xsU3B5Ll9qUXVlcnlJbnRlcmZhY2VcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBTY3JvbGxTcHlcbiQuZm5bTkFNRV0ubm9Db25mbGljdCA9ICgpID0+IHtcbiAgJC5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVFxuICByZXR1cm4gU2Nyb2xsU3B5Ll9qUXVlcnlJbnRlcmZhY2Vcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2Nyb2xsU3B5XG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjMuMSk6IHRhYi5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0IFV0aWwgZnJvbSAnLi91dGlsJ1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FICAgICAgICAgICAgICAgPSAndGFiJ1xuY29uc3QgVkVSU0lPTiAgICAgICAgICAgID0gJzQuMy4xJ1xuY29uc3QgREFUQV9LRVkgICAgICAgICAgID0gJ2JzLnRhYidcbmNvbnN0IEVWRU5UX0tFWSAgICAgICAgICA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgICAgICAgPSAnLmRhdGEtYXBpJ1xuY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXVxuXG5jb25zdCBFdmVudCA9IHtcbiAgSElERSAgICAgICAgICAgOiBgaGlkZSR7RVZFTlRfS0VZfWAsXG4gIEhJRERFTiAgICAgICAgIDogYGhpZGRlbiR7RVZFTlRfS0VZfWAsXG4gIFNIT1cgICAgICAgICAgIDogYHNob3cke0VWRU5UX0tFWX1gLFxuICBTSE9XTiAgICAgICAgICA6IGBzaG93biR7RVZFTlRfS0VZfWAsXG4gIENMSUNLX0RBVEFfQVBJIDogYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxufVxuXG5jb25zdCBDbGFzc05hbWUgPSB7XG4gIERST1BET1dOX01FTlUgOiAnZHJvcGRvd24tbWVudScsXG4gIEFDVElWRSAgICAgICAgOiAnYWN0aXZlJyxcbiAgRElTQUJMRUQgICAgICA6ICdkaXNhYmxlZCcsXG4gIEZBREUgICAgICAgICAgOiAnZmFkZScsXG4gIFNIT1cgICAgICAgICAgOiAnc2hvdydcbn1cblxuY29uc3QgU2VsZWN0b3IgPSB7XG4gIERST1BET1dOICAgICAgICAgICAgICA6ICcuZHJvcGRvd24nLFxuICBOQVZfTElTVF9HUk9VUCAgICAgICAgOiAnLm5hdiwgLmxpc3QtZ3JvdXAnLFxuICBBQ1RJVkUgICAgICAgICAgICAgICAgOiAnLmFjdGl2ZScsXG4gIEFDVElWRV9VTCAgICAgICAgICAgICA6ICc+IGxpID4gLmFjdGl2ZScsXG4gIERBVEFfVE9HR0xFICAgICAgICAgICA6ICdbZGF0YS10b2dnbGU9XCJ0YWJcIl0sIFtkYXRhLXRvZ2dsZT1cInBpbGxcIl0sIFtkYXRhLXRvZ2dsZT1cImxpc3RcIl0nLFxuICBEUk9QRE9XTl9UT0dHTEUgICAgICAgOiAnLmRyb3Bkb3duLXRvZ2dsZScsXG4gIERST1BET1dOX0FDVElWRV9DSElMRCA6ICc+IC5kcm9wZG93bi1tZW51IC5hY3RpdmUnXG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBUYWIge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnRcbiAgfVxuXG4gIC8vIEdldHRlcnNcblxuICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgcmV0dXJuIFZFUlNJT05cbiAgfVxuXG4gIC8vIFB1YmxpY1xuXG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSAmJlxuICAgICAgICB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmXG4gICAgICAgICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSkgfHxcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRElTQUJMRUQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgdGFyZ2V0XG4gICAgbGV0IHByZXZpb3VzXG4gICAgY29uc3QgbGlzdEVsZW1lbnQgPSAkKHRoaXMuX2VsZW1lbnQpLmNsb3Nlc3QoU2VsZWN0b3IuTkFWX0xJU1RfR1JPVVApWzBdXG4gICAgY29uc3Qgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudClcblxuICAgIGlmIChsaXN0RWxlbWVudCkge1xuICAgICAgY29uc3QgaXRlbVNlbGVjdG9yID0gbGlzdEVsZW1lbnQubm9kZU5hbWUgPT09ICdVTCcgfHwgbGlzdEVsZW1lbnQubm9kZU5hbWUgPT09ICdPTCcgPyBTZWxlY3Rvci5BQ1RJVkVfVUwgOiBTZWxlY3Rvci5BQ1RJVkVcbiAgICAgIHByZXZpb3VzID0gJC5tYWtlQXJyYXkoJChsaXN0RWxlbWVudCkuZmluZChpdGVtU2VsZWN0b3IpKVxuICAgICAgcHJldmlvdXMgPSBwcmV2aW91c1twcmV2aW91cy5sZW5ndGggLSAxXVxuICAgIH1cblxuICAgIGNvbnN0IGhpZGVFdmVudCA9ICQuRXZlbnQoRXZlbnQuSElERSwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgIH0pXG5cbiAgICBjb25zdCBzaG93RXZlbnQgPSAkLkV2ZW50KEV2ZW50LlNIT1csIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHByZXZpb3VzXG4gICAgfSlcblxuICAgIGlmIChwcmV2aW91cykge1xuICAgICAgJChwcmV2aW91cykudHJpZ2dlcihoaWRlRXZlbnQpXG4gICAgfVxuXG4gICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNob3dFdmVudClcblxuICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHxcbiAgICAgICAgaGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgfVxuXG4gICAgdGhpcy5fYWN0aXZhdGUoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgbGlzdEVsZW1lbnRcbiAgICApXG5cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGhpZGRlbkV2ZW50ID0gJC5FdmVudChFdmVudC5ISURERU4sIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgICAgfSlcblxuICAgICAgY29uc3Qgc2hvd25FdmVudCA9ICQuRXZlbnQoRXZlbnQuU0hPV04sIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcHJldmlvdXNcbiAgICAgIH0pXG5cbiAgICAgICQocHJldmlvdXMpLnRyaWdnZXIoaGlkZGVuRXZlbnQpXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2hvd25FdmVudClcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLl9hY3RpdmF0ZSh0YXJnZXQsIHRhcmdldC5wYXJlbnROb2RlLCBjb21wbGV0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGxldGUoKVxuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKVxuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsXG4gIH1cblxuICAvLyBQcml2YXRlXG5cbiAgX2FjdGl2YXRlKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBhY3RpdmVFbGVtZW50cyA9IGNvbnRhaW5lciAmJiAoY29udGFpbmVyLm5vZGVOYW1lID09PSAnVUwnIHx8IGNvbnRhaW5lci5ub2RlTmFtZSA9PT0gJ09MJylcbiAgICAgID8gJChjb250YWluZXIpLmZpbmQoU2VsZWN0b3IuQUNUSVZFX1VMKVxuICAgICAgOiAkKGNvbnRhaW5lcikuY2hpbGRyZW4oU2VsZWN0b3IuQUNUSVZFKVxuXG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHNbMF1cbiAgICBjb25zdCBpc1RyYW5zaXRpb25pbmcgPSBjYWxsYmFjayAmJiAoYWN0aXZlICYmICQoYWN0aXZlKS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSkpXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB0aGlzLl90cmFuc2l0aW9uQ29tcGxldGUoXG4gICAgICBlbGVtZW50LFxuICAgICAgYWN0aXZlLFxuICAgICAgY2FsbGJhY2tcbiAgICApXG5cbiAgICBpZiAoYWN0aXZlICYmIGlzVHJhbnNpdGlvbmluZykge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudChhY3RpdmUpXG5cbiAgICAgICQoYWN0aXZlKVxuICAgICAgICAucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG4gICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlKClcbiAgICB9XG4gIH1cblxuICBfdHJhbnNpdGlvbkNvbXBsZXRlKGVsZW1lbnQsIGFjdGl2ZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAkKGFjdGl2ZSkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSlcblxuICAgICAgY29uc3QgZHJvcGRvd25DaGlsZCA9ICQoYWN0aXZlLnBhcmVudE5vZGUpLmZpbmQoXG4gICAgICAgIFNlbGVjdG9yLkRST1BET1dOX0FDVElWRV9DSElMRFxuICAgICAgKVswXVxuXG4gICAgICBpZiAoZHJvcGRvd25DaGlsZCkge1xuICAgICAgICAkKGRyb3Bkb3duQ2hpbGQpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5BQ1RJVkUpXG4gICAgICB9XG5cbiAgICAgIGlmIChhY3RpdmUuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICd0YWInKSB7XG4gICAgICAgIGFjdGl2ZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAkKGVsZW1lbnQpLmFkZENsYXNzKENsYXNzTmFtZS5BQ1RJVkUpXG4gICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICd0YWInKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIHRydWUpXG4gICAgfVxuXG4gICAgVXRpbC5yZWZsb3coZWxlbWVudClcblxuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDbGFzc05hbWUuRkFERSkpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDbGFzc05hbWUuU0hPVylcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICYmICQoZWxlbWVudC5wYXJlbnROb2RlKS5oYXNDbGFzcyhDbGFzc05hbWUuRFJPUERPV05fTUVOVSkpIHtcbiAgICAgIGNvbnN0IGRyb3Bkb3duRWxlbWVudCA9ICQoZWxlbWVudCkuY2xvc2VzdChTZWxlY3Rvci5EUk9QRE9XTilbMF1cblxuICAgICAgaWYgKGRyb3Bkb3duRWxlbWVudCkge1xuICAgICAgICBjb25zdCBkcm9wZG93blRvZ2dsZUxpc3QgPSBbXS5zbGljZS5jYWxsKGRyb3Bkb3duRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yLkRST1BET1dOX1RPR0dMRSkpXG5cbiAgICAgICAgJChkcm9wZG93blRvZ2dsZUxpc3QpLmFkZENsYXNzKENsYXNzTmFtZS5BQ1RJVkUpXG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICAvLyBTdGF0aWNcblxuICBzdGF0aWMgX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0ICR0aGlzID0gJCh0aGlzKVxuICAgICAgbGV0IGRhdGEgPSAkdGhpcy5kYXRhKERBVEFfS0VZKVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBUYWIodGhpcylcbiAgICAgICAgJHRoaXMuZGF0YShEQVRBX0tFWSwgZGF0YSlcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgICAgfVxuICAgICAgICBkYXRhW2NvbmZpZ10oKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kKGRvY3VtZW50KVxuICAub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkRBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgVGFiLl9qUXVlcnlJbnRlcmZhY2UuY2FsbCgkKHRoaXMpLCAnc2hvdycpXG4gIH0pXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQuZm5bTkFNRV0gPSBUYWIuX2pRdWVyeUludGVyZmFjZVxuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IFRhYlxuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBUYWIuX2pRdWVyeUludGVyZmFjZVxufVxuXG5leHBvcnQgZGVmYXVsdCBUYWJcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuMy4xKTogdG9hc3QuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSdcbmltcG9ydCBVdGlsIGZyb20gJy4vdXRpbCdcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSAgICAgICAgICAgICAgID0gJ3RvYXN0J1xuY29uc3QgVkVSU0lPTiAgICAgICAgICAgID0gJzQuMy4xJ1xuY29uc3QgREFUQV9LRVkgICAgICAgICAgID0gJ2JzLnRvYXN0J1xuY29uc3QgRVZFTlRfS0VZICAgICAgICAgID0gYC4ke0RBVEFfS0VZfWBcbmNvbnN0IEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV1cblxuY29uc3QgRXZlbnQgPSB7XG4gIENMSUNLX0RJU01JU1MgOiBgY2xpY2suZGlzbWlzcyR7RVZFTlRfS0VZfWAsXG4gIEhJREUgICAgICAgICAgOiBgaGlkZSR7RVZFTlRfS0VZfWAsXG4gIEhJRERFTiAgICAgICAgOiBgaGlkZGVuJHtFVkVOVF9LRVl9YCxcbiAgU0hPVyAgICAgICAgICA6IGBzaG93JHtFVkVOVF9LRVl9YCxcbiAgU0hPV04gICAgICAgICA6IGBzaG93biR7RVZFTlRfS0VZfWBcbn1cblxuY29uc3QgQ2xhc3NOYW1lID0ge1xuICBGQURFICAgIDogJ2ZhZGUnLFxuICBISURFICAgIDogJ2hpZGUnLFxuICBTSE9XICAgIDogJ3Nob3cnLFxuICBTSE9XSU5HIDogJ3Nob3dpbmcnXG59XG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBhbmltYXRpb24gOiAnYm9vbGVhbicsXG4gIGF1dG9oaWRlICA6ICdib29sZWFuJyxcbiAgZGVsYXkgICAgIDogJ251bWJlcidcbn1cblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgYW5pbWF0aW9uIDogdHJ1ZSxcbiAgYXV0b2hpZGUgIDogdHJ1ZSxcbiAgZGVsYXkgICAgIDogNTAwXG59XG5cbmNvbnN0IFNlbGVjdG9yID0ge1xuICBEQVRBX0RJU01JU1MgOiAnW2RhdGEtZGlzbWlzcz1cInRvYXN0XCJdJ1xufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgVG9hc3Qge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFxuICAgIHRoaXMuX2NvbmZpZyAgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsXG4gICAgdGhpcy5fc2V0TGlzdGVuZXJzKClcbiAgfVxuXG4gIC8vIEdldHRlcnNcblxuICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgcmV0dXJuIFZFUlNJT05cbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIC8vIFB1YmxpY1xuXG4gIHNob3coKSB7XG4gICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKEV2ZW50LlNIT1cpXG5cbiAgICBpZiAodGhpcy5fY29uZmlnLmFuaW1hdGlvbikge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENsYXNzTmFtZS5GQURFKVxuICAgIH1cblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENsYXNzTmFtZS5TSE9XSU5HKVxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENsYXNzTmFtZS5TSE9XKVxuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoRXZlbnQuU0hPV04pXG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcuYXV0b2hpZGUpIHtcbiAgICAgICAgdGhpcy5oaWRlKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ2xhc3NOYW1lLkhJREUpXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENsYXNzTmFtZS5TSE9XSU5HKVxuICAgIGlmICh0aGlzLl9jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpXG5cbiAgICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGxldGUoKVxuICAgIH1cbiAgfVxuXG4gIGhpZGUod2l0aG91dFRpbWVvdXQpIHtcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKEV2ZW50LkhJREUpXG5cbiAgICBpZiAod2l0aG91dFRpbWVvdXQpIHtcbiAgICAgIHRoaXMuX2Nsb3NlKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9jbG9zZSgpXG4gICAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkpXG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dClcbiAgICB0aGlzLl90aW1lb3V0ID0gbnVsbFxuXG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENsYXNzTmFtZS5TSE9XKVxuICAgIH1cblxuICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEV2ZW50LkNMSUNLX0RJU01JU1MpXG5cbiAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGxcbiAgICB0aGlzLl9jb25maWcgID0gbnVsbFxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0ge1xuICAgICAgLi4uRGVmYXVsdCxcbiAgICAgIC4uLiQodGhpcy5fZWxlbWVudCkuZGF0YSgpLFxuICAgICAgLi4udHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge31cbiAgICB9XG5cbiAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhcbiAgICAgIE5BTUUsXG4gICAgICBjb25maWcsXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlXG4gICAgKVxuXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX3NldExpc3RlbmVycygpIHtcbiAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKFxuICAgICAgRXZlbnQuQ0xJQ0tfRElTTUlTUyxcbiAgICAgIFNlbGVjdG9yLkRBVEFfRElTTUlTUyxcbiAgICAgICgpID0+IHRoaXMuaGlkZSh0cnVlKVxuICAgIClcbiAgfVxuXG4gIF9jbG9zZSgpIHtcbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDbGFzc05hbWUuSElERSlcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihFdmVudC5ISURERU4pXG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENsYXNzTmFtZS5TSE9XKVxuICAgIGlmICh0aGlzLl9jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpXG5cbiAgICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGxldGUoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFN0YXRpY1xuXG4gIHN0YXRpYyBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgJGVsZW1lbnQgPSAkKHRoaXMpXG4gICAgICBsZXQgZGF0YSAgICAgICA9ICRlbGVtZW50LmRhdGEoREFUQV9LRVkpXG4gICAgICBjb25zdCBfY29uZmlnICA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZ1xuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBUb2FzdCh0aGlzLCBfY29uZmlnKVxuICAgICAgICAkZWxlbWVudC5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKHRoaXMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kLmZuW05BTUVdICAgICAgICAgICAgID0gVG9hc3QuX2pRdWVyeUludGVyZmFjZVxuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IFRvYXN0XG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBUb2FzdC5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRvYXN0XG4iLCJpbXBvcnQgJCBmcm9tICdqcXVlcnknXG5pbXBvcnQgQWxlcnQgZnJvbSAnLi9hbGVydCdcbmltcG9ydCBCdXR0b24gZnJvbSAnLi9idXR0b24nXG5pbXBvcnQgQ2Fyb3VzZWwgZnJvbSAnLi9jYXJvdXNlbCdcbmltcG9ydCBDb2xsYXBzZSBmcm9tICcuL2NvbGxhcHNlJ1xuaW1wb3J0IERyb3Bkb3duIGZyb20gJy4vZHJvcGRvd24nXG5pbXBvcnQgTW9kYWwgZnJvbSAnLi9tb2RhbCdcbmltcG9ydCBQb3BvdmVyIGZyb20gJy4vcG9wb3ZlcidcbmltcG9ydCBTY3JvbGxzcHkgZnJvbSAnLi9zY3JvbGxzcHknXG5pbXBvcnQgVGFiIGZyb20gJy4vdGFiJ1xuaW1wb3J0IFRvYXN0IGZyb20gJy4vdG9hc3QnXG5pbXBvcnQgVG9vbHRpcCBmcm9tICcuL3Rvb2x0aXAnXG5pbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuMy4xKTogaW5kZXguanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbigoKSA9PiB7XG4gIGlmICh0eXBlb2YgJCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgalF1ZXJ5LiBqUXVlcnkgbXVzdCBiZSBpbmNsdWRlZCBiZWZvcmUgQm9vdHN0cmFwXFwncyBKYXZhU2NyaXB0LicpXG4gIH1cblxuICBjb25zdCB2ZXJzaW9uID0gJC5mbi5qcXVlcnkuc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpXG4gIGNvbnN0IG1pbk1ham9yID0gMVxuICBjb25zdCBsdE1ham9yID0gMlxuICBjb25zdCBtaW5NaW5vciA9IDlcbiAgY29uc3QgbWluUGF0Y2ggPSAxXG4gIGNvbnN0IG1heE1ham9yID0gNFxuXG4gIGlmICh2ZXJzaW9uWzBdIDwgbHRNYWpvciAmJiB2ZXJzaW9uWzFdIDwgbWluTWlub3IgfHwgdmVyc2lvblswXSA9PT0gbWluTWFqb3IgJiYgdmVyc2lvblsxXSA9PT0gbWluTWlub3IgJiYgdmVyc2lvblsyXSA8IG1pblBhdGNoIHx8IHZlcnNpb25bMF0gPj0gbWF4TWFqb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgSmF2YVNjcmlwdCByZXF1aXJlcyBhdCBsZWFzdCBqUXVlcnkgdjEuOS4xIGJ1dCBsZXNzIHRoYW4gdjQuMC4wJylcbiAgfVxufSkoKVxuXG5leHBvcnQge1xuICBVdGlsLFxuICBBbGVydCxcbiAgQnV0dG9uLFxuICBDYXJvdXNlbCxcbiAgQ29sbGFwc2UsXG4gIERyb3Bkb3duLFxuICBNb2RhbCxcbiAgUG9wb3ZlcixcbiAgU2Nyb2xsc3B5LFxuICBUYWIsXG4gIFRvYXN0LFxuICBUb29sdGlwXG59XG4iLCIvKipcbiAqIFlpaSBKYXZhU2NyaXB0IG1vZHVsZS5cbiAqXG4gKiBAbGluayBodHRwOi8vd3d3LnlpaWZyYW1ld29yay5jb20vXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAwOCBZaWkgU29mdHdhcmUgTExDXG4gKiBAbGljZW5zZSBodHRwOi8vd3d3LnlpaWZyYW1ld29yay5jb20vbGljZW5zZS9cbiAqIEBhdXRob3IgUWlhbmcgWHVlIDxxaWFuZy54dWVAZ21haWwuY29tPlxuICogQHNpbmNlIDIuMFxuICovXG5cbi8qKlxuICogeWlpIGlzIHRoZSByb290IG1vZHVsZSBmb3IgYWxsIFlpaSBKYXZhU2NyaXB0IG1vZHVsZXMuXG4gKiBJdCBpbXBsZW1lbnRzIGEgbWVjaGFuaXNtIG9mIG9yZ2FuaXppbmcgSmF2YVNjcmlwdCBjb2RlIGluIG1vZHVsZXMgdGhyb3VnaCB0aGUgZnVuY3Rpb24gXCJ5aWkuaW5pdE1vZHVsZSgpXCIuXG4gKlxuICogRWFjaCBtb2R1bGUgc2hvdWxkIGJlIG5hbWVkIGFzIFwieC55LnpcIiwgd2hlcmUgXCJ4XCIgc3RhbmRzIGZvciB0aGUgcm9vdCBtb2R1bGUgKGZvciB0aGUgWWlpIGNvcmUgY29kZSwgdGhpcyBpcyBcInlpaVwiKS5cbiAqXG4gKiBBIG1vZHVsZSBtYXkgYmUgc3RydWN0dXJlZCBhcyBmb2xsb3dzOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHdpbmRvdy55aWkuc2FtcGxlID0gKGZ1bmN0aW9uKCQpIHtcbiAqICAgICB2YXIgcHViID0ge1xuICogICAgICAgICAvLyB3aGV0aGVyIHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBhY3RpdmUuIElmIGZhbHNlLCBpbml0KCkgd2lsbCBub3QgYmUgY2FsbGVkIGZvciB0aGlzIG1vZHVsZVxuICogICAgICAgICAvLyBpdCB3aWxsIGFsc28gbm90IGJlIGNhbGxlZCBmb3IgYWxsIGl0cyBjaGlsZCBtb2R1bGVzLiBJZiB0aGlzIHByb3BlcnR5IGlzIHVuZGVmaW5lZCwgaXQgbWVhbnMgdHJ1ZS5cbiAqICAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gKiAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgLy8gLi4uIG1vZHVsZSBpbml0aWFsaXphdGlvbiBjb2RlIGdvZXMgaGVyZSAuLi5cbiAqICAgICAgICAgfSxcbiAqXG4gKiAgICAgICAgIC8vIC4uLiBvdGhlciBwdWJsaWMgZnVuY3Rpb25zIGFuZCBwcm9wZXJ0aWVzIGdvIGhlcmUgLi4uXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgLy8gLi4uIHByaXZhdGUgZnVuY3Rpb25zIGFuZCBwcm9wZXJ0aWVzIGdvIGhlcmUgLi4uXG4gKlxuICogICAgIHJldHVybiBwdWI7XG4gKiB9KSh3aW5kb3cualF1ZXJ5KTtcbiAqIGBgYFxuICpcbiAqIFVzaW5nIHRoaXMgc3RydWN0dXJlLCB5b3UgY2FuIGRlZmluZSBwdWJsaWMgYW5kIHByaXZhdGUgZnVuY3Rpb25zL3Byb3BlcnRpZXMgZm9yIGEgbW9kdWxlLlxuICogUHJpdmF0ZSBmdW5jdGlvbnMvcHJvcGVydGllcyBhcmUgb25seSB2aXNpYmxlIHdpdGhpbiB0aGUgbW9kdWxlLCB3aGlsZSBwdWJsaWMgZnVuY3Rpb25zL3Byb3BlcnRpZXNcbiAqIG1heSBiZSBhY2Nlc3NlZCBvdXRzaWRlIG9mIHRoZSBtb2R1bGUuIEZvciBleGFtcGxlLCB5b3UgY2FuIGFjY2VzcyBcInlpaS5zYW1wbGUuaXNBY3RpdmVcIi5cbiAqXG4gKiBZb3UgbXVzdCBjYWxsIFwieWlpLmluaXRNb2R1bGUoKVwiIG9uY2UgZm9yIHRoZSByb290IG1vZHVsZSBvZiBhbGwgeW91ciBtb2R1bGVzLlxuICovXG53aW5kb3cueWlpID0gKGZ1bmN0aW9uICgkKSB7XG4gICAgdmFyIHB1YiA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgSlMgb3IgQ1NTIFVSTHMgdGhhdCBjYW4gYmUgbG9hZGVkIG11bHRpcGxlIHRpbWVzIHZpYSBBSkFYIHJlcXVlc3RzLlxuICAgICAgICAgKiBFYWNoIGl0ZW0gbWF5IGJlIHJlcHJlc2VudGVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBVUkwgb3IgYSByZWxhdGl2ZSBvbmUuXG4gICAgICAgICAqIEVhY2ggaXRlbSBtYXkgY29udGFpbiBhIHdpbGRjYXJkIG1hdGNoaW5nIGNoYXJhY3RlciBgKmAsIHRoYXQgbWVhbnMgb25lIG9yIG1vcmVcbiAgICAgICAgICogYW55IGNoYXJhY3RlcnMgb24gdGhlIHBvc2l0aW9uLiBGb3IgZXhhbXBsZTpcbiAgICAgICAgICogIC0gYC9jc3MvKi5jc3NgIHdpbGwgbWF0Y2ggYW55IGZpbGUgZW5kaW5nIHdpdGggYC5jc3NgIGluIHRoZSBgY3NzYCBkaXJlY3Rvcnkgb2YgdGhlIGN1cnJlbnQgd2ViIHNpdGVcbiAgICAgICAgICogIC0gYGh0dHAqOi8vY2RuLmV4YW1wbGUuY29tLypgIHdpbGwgbWF0Y2ggYW55IGZpbGVzIG9uIGRvbWFpbiBgY2RuLmV4YW1wbGUuY29tYCwgbG9hZGVkIHdpdGggSFRUUCBvciBIVFRQU1xuICAgICAgICAgKiAgLSBgL2pzL215Q3VzdG9tU2NyaXB0LmpzP3JlYWxtPSpgIHdpbGwgbWF0Y2ggZmlsZSBgL2pzL215Q3VzdG9tU2NyaXB0LmpzYCB3aXRoIGRlZmluZWQgYHJlYWxtYCBwYXJhbWV0ZXJcbiAgICAgICAgICovXG4gICAgICAgIHJlbG9hZGFibGVTY3JpcHRzOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZWxlY3RvciBmb3IgY2xpY2thYmxlIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBzdXBwb3J0IGNvbmZpcm1hdGlvbiBhbmQgZm9ybSBzdWJtaXNzaW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgY2xpY2thYmxlU2VsZWN0b3I6ICdhLCBidXR0b24sIGlucHV0W3R5cGU9XCJzdWJtaXRcIl0sIGlucHV0W3R5cGU9XCJidXR0b25cIl0sIGlucHV0W3R5cGU9XCJyZXNldFwiXSwgJyArXG4gICAgICAgICAgICAnaW5wdXRbdHlwZT1cImltYWdlXCJdJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZWxlY3RvciBmb3IgY2hhbmdlYWJsZSBlbGVtZW50cyB0aGF0IG5lZWQgdG8gc3VwcG9ydCBjb25maXJtYXRpb24gYW5kIGZvcm0gc3VibWlzc2lvbi5cbiAgICAgICAgICovXG4gICAgICAgIGNoYW5nZWFibGVTZWxlY3RvcjogJ3NlbGVjdCwgaW5wdXQsIHRleHRhcmVhJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBzdHJpbmd8dW5kZWZpbmVkIHRoZSBDU1JGIHBhcmFtZXRlciBuYW1lLiBVbmRlZmluZWQgaXMgcmV0dXJuZWQgaWYgQ1NSRiB2YWxpZGF0aW9uIGlzIG5vdCBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q3NyZlBhcmFtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCgnbWV0YVtuYW1lPWNzcmYtcGFyYW1dJykuYXR0cignY29udGVudCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHN0cmluZ3x1bmRlZmluZWQgdGhlIENTUkYgdG9rZW4uIFVuZGVmaW5lZCBpcyByZXR1cm5lZCBpZiBDU1JGIHZhbGlkYXRpb24gaXMgbm90IGVuYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDc3JmVG9rZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKCdtZXRhW25hbWU9Y3NyZi10b2tlbl0nKS5hdHRyKCdjb250ZW50Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIENTUkYgdG9rZW4gaW4gdGhlIG1ldGEgZWxlbWVudHMuXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIHNvIHRoYXQgeW91IGNhbiB1cGRhdGUgdGhlIENTUkYgdG9rZW4gd2l0aCB0aGUgbGF0ZXN0IG9uZSB5b3Ugb2J0YWluIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICogQHBhcmFtIG5hbWUgdGhlIENTUkYgdG9rZW4gbmFtZVxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgdGhlIENTUkYgdG9rZW4gdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIHNldENzcmZUb2tlbjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAkKCdtZXRhW25hbWU9Y3NyZi1wYXJhbV0nKS5hdHRyKCdjb250ZW50JywgbmFtZSk7XG4gICAgICAgICAgICAkKCdtZXRhW25hbWU9Y3NyZi10b2tlbl0nKS5hdHRyKCdjb250ZW50JywgdmFsdWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIGFsbCBmb3JtIENTUkYgaW5wdXQgZmllbGRzIHdpdGggdGhlIGxhdGVzdCBDU1JGIHRva2VuLlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyBwcm92aWRlZCB0byBhdm9pZCBjYWNoZWQgZm9ybXMgY29udGFpbmluZyBvdXRkYXRlZCBDU1JGIHRva2Vucy5cbiAgICAgICAgICovXG4gICAgICAgIHJlZnJlc2hDc3JmVG9rZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHB1Yi5nZXRDc3JmVG9rZW4oKTtcbiAgICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICAgICQoJ2Zvcm0gaW5wdXRbbmFtZT1cIicgKyBwdWIuZ2V0Q3NyZlBhcmFtKCkgKyAnXCJdJykudmFsKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheXMgYSBjb25maXJtYXRpb24gZGlhbG9nLlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzaW1wbHkgZGlzcGxheXMgYSBqcyBjb25maXJtYXRpb24gZGlhbG9nLlxuICAgICAgICAgKiBZb3UgbWF5IG92ZXJyaWRlIHRoaXMgYnkgc2V0dGluZyBgeWlpLmNvbmZpcm1gLlxuICAgICAgICAgKiBAcGFyYW0gbWVzc2FnZSB0aGUgY29uZmlybWF0aW9uIG1lc3NhZ2UuXG4gICAgICAgICAqIEBwYXJhbSBvayBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNvbmZpcm1zIHRoZSBtZXNzYWdlXG4gICAgICAgICAqIEBwYXJhbSBjYW5jZWwgYSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiB0aGUgdXNlciBjYW5jZWxzIHRoZSBjb25maXJtYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIGNvbmZpcm06IGZ1bmN0aW9uIChtZXNzYWdlLCBvaywgY2FuY2VsKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LmNvbmZpcm0obWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAhb2sgfHwgb2soKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIWNhbmNlbCB8fCBjYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyB0aGUgYWN0aW9uIHRyaWdnZXJlZCBieSB1c2VyLlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCByZWNvZ25pemVzIHRoZSBgZGF0YS1tZXRob2RgIGF0dHJpYnV0ZSBvZiB0aGUgZWxlbWVudC4gSWYgdGhlIGF0dHJpYnV0ZSBleGlzdHMsXG4gICAgICAgICAqIHRoZSBtZXRob2Qgd2lsbCBzdWJtaXQgdGhlIGZvcm0gY29udGFpbmluZyB0aGlzIGVsZW1lbnQuIElmIHRoZXJlIGlzIG5vIGNvbnRhaW5pbmcgZm9ybSwgYSBmb3JtXG4gICAgICAgICAqIHdpbGwgYmUgY3JlYXRlZCBhbmQgc3VibWl0dGVkIHVzaW5nIHRoZSBtZXRob2QgZ2l2ZW4gYnkgdGhpcyBhdHRyaWJ1dGUgdmFsdWUgKGUuZy4gXCJwb3N0XCIsIFwicHV0XCIpLlxuICAgICAgICAgKiBGb3IgaHlwZXJsaW5rcywgdGhlIGZvcm0gYWN0aW9uIHdpbGwgdGFrZSB0aGUgdmFsdWUgb2YgdGhlIFwiaHJlZlwiIGF0dHJpYnV0ZSBvZiB0aGUgbGluay5cbiAgICAgICAgICogRm9yIG90aGVyIGVsZW1lbnRzLCBlaXRoZXIgdGhlIGNvbnRhaW5pbmcgZm9ybSBhY3Rpb24gb3IgdGhlIGN1cnJlbnQgcGFnZSBVUkwgd2lsbCBiZSB1c2VkXG4gICAgICAgICAqIGFzIHRoZSBmb3JtIGFjdGlvbiBVUkwuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBgZGF0YS1tZXRob2RgIGF0dHJpYnV0ZSBpcyBub3QgZGVmaW5lZCwgdGhlIGBocmVmYCBhdHRyaWJ1dGUgKGlmIGFueSkgb2YgdGhlIGVsZW1lbnRcbiAgICAgICAgICogd2lsbCBiZSBhc3NpZ25lZCB0byBgd2luZG93LmxvY2F0aW9uYC5cbiAgICAgICAgICpcbiAgICAgICAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDIuMC4zLCB0aGUgYGRhdGEtcGFyYW1zYCBhdHRyaWJ1dGUgaXMgYWxzbyByZWNvZ25pemVkIHdoZW4geW91IHNwZWNpZnlcbiAgICAgICAgICogYGRhdGEtbWV0aG9kYC4gVGhlIHZhbHVlIG9mIGBkYXRhLXBhcmFtc2Agc2hvdWxkIGJlIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF0YSAobmFtZS12YWx1ZSBwYWlycylcbiAgICAgICAgICogdGhhdCBzaG91bGQgYmUgc3VibWl0dGVkIGFzIGhpZGRlbiBpbnB1dHMuIEZvciBleGFtcGxlLCB5b3UgbWF5IHVzZSB0aGUgZm9sbG93aW5nIGNvZGUgdG8gZ2VuZXJhdGVcbiAgICAgICAgICogc3VjaCBhIGxpbms6XG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHBocFxuICAgICAgICAgKiB1c2UgeWlpXFxoZWxwZXJzXFxIdG1sO1xuICAgICAgICAgKiB1c2UgeWlpXFxoZWxwZXJzXFxKc29uO1xuICAgICAgICAgKlxuICAgICAgICAgKiBlY2hvIEh0bWw6OmEoJ3N1Ym1pdCcsIFsnc2l0ZS9mb29iYXInXSwgW1xuICAgICAgICAgKiAgICAgJ2RhdGEnID0+IFtcbiAgICAgICAgICogICAgICAgICAnbWV0aG9kJyA9PiAncG9zdCcsXG4gICAgICAgICAqICAgICAgICAgJ3BhcmFtcycgPT4gW1xuICAgICAgICAgKiAgICAgICAgICAgICAnbmFtZTEnID0+ICd2YWx1ZTEnLFxuICAgICAgICAgKiAgICAgICAgICAgICAnbmFtZTInID0+ICd2YWx1ZTInLFxuICAgICAgICAgKiAgICAgICAgIF0sXG4gICAgICAgICAqICAgICBdLFxuICAgICAgICAgKiBdKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAkZSB0aGUgalF1ZXJ5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSBldmVudCBSZWxhdGVkIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGVBY3Rpb246IGZ1bmN0aW9uICgkZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciAkZm9ybSA9ICRlLmF0dHIoJ2RhdGEtZm9ybScpID8gJCgnIycgKyAkZS5hdHRyKCdkYXRhLWZvcm0nKSkgOiAkZS5jbG9zZXN0KCdmb3JtJyksXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gISRlLmRhdGEoJ21ldGhvZCcpICYmICRmb3JtID8gJGZvcm0uYXR0cignbWV0aG9kJykgOiAkZS5kYXRhKCdtZXRob2QnKSxcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSAkZS5hdHRyKCdocmVmJyksXG4gICAgICAgICAgICAgICAgaXNWYWxpZEFjdGlvbiA9IGFjdGlvbiAmJiBhY3Rpb24gIT09ICcjJyxcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSAkZS5kYXRhKCdwYXJhbXMnKSxcbiAgICAgICAgICAgICAgICBhcmVWYWxpZFBhcmFtcyA9IHBhcmFtcyAmJiAkLmlzUGxhaW5PYmplY3QocGFyYW1zKSxcbiAgICAgICAgICAgICAgICBwamF4ID0gJGUuZGF0YSgncGpheCcpLFxuICAgICAgICAgICAgICAgIHVzZVBqYXggPSBwamF4ICE9PSB1bmRlZmluZWQgJiYgcGpheCAhPT0gMCAmJiAkLnN1cHBvcnQucGpheCxcbiAgICAgICAgICAgICAgICBwamF4Q29udGFpbmVyLFxuICAgICAgICAgICAgICAgIHBqYXhPcHRpb25zID0ge30sXG4gICAgICAgICAgICAgICAgY29uZmxpY3RQYXJhbXMgPSBbJ3N1Ym1pdCcsICdyZXNldCcsICdlbGVtZW50cycsICdsZW5ndGgnLCAnbmFtZScsICdhY2NlcHRDaGFyc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FjdGlvbicsICdlbmN0eXBlJywgJ21ldGhvZCcsICd0YXJnZXQnXTtcblxuICAgICAgICAgICAgLy8gRm9ybXMgYW5kIHRoZWlyIGNoaWxkIGVsZW1lbnRzIHNob3VsZCBub3QgdXNlIGlucHV0IG5hbWVzIG9yIGlkcyB0aGF0IGNvbmZsaWN0IHdpdGggcHJvcGVydGllcyBvZiBhIGZvcm0sXG4gICAgICAgICAgICAvLyBzdWNoIGFzIHN1Ym1pdCwgbGVuZ3RoLCBvciBtZXRob2QuXG4gICAgICAgICAgICAkLmVhY2goY29uZmxpY3RQYXJhbXMsIGZ1bmN0aW9uIChpbmRleCwgcGFyYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJlVmFsaWRQYXJhbXMgJiYgcGFyYW1zLmhhc093blByb3BlcnR5KHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiUGFyYW1ldGVyIG5hbWUgJ1wiICsgcGFyYW0gKyBcIicgY29uZmxpY3RzIHdpdGggYSBzYW1lIG5hbWVkIGZvcm0gcHJvcGVydHkuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUGxlYXNlIHVzZSBhbm90aGVyIG5hbWUuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAodXNlUGpheCkge1xuICAgICAgICAgICAgICAgIHBqYXhDb250YWluZXIgPSAkZS5kYXRhKCdwamF4LWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgIGlmIChwamF4Q29udGFpbmVyID09PSB1bmRlZmluZWQgfHwgIXBqYXhDb250YWluZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBqYXhDb250YWluZXIgPSAkZS5jbG9zZXN0KCdbZGF0YS1wamF4LWNvbnRhaW5lcl0nKS5hdHRyKCdpZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICgnIycgKyAkZS5jbG9zZXN0KCdbZGF0YS1wamF4LWNvbnRhaW5lcl0nKS5hdHRyKCdpZCcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwamF4Q29udGFpbmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwamF4Q29udGFpbmVyID0gJ2JvZHknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwamF4T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBwamF4Q29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICBwdXNoOiAhISRlLmRhdGEoJ3BqYXgtcHVzaC1zdGF0ZScpLFxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlOiAhISRlLmRhdGEoJ3BqYXgtcmVwbGFjZS1zdGF0ZScpLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUbzogJGUuZGF0YSgncGpheC1zY3JvbGx0bycpLFxuICAgICAgICAgICAgICAgICAgICBwdXNoUmVkaXJlY3Q6ICRlLmRhdGEoJ3BqYXgtcHVzaC1yZWRpcmVjdCcpLFxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlUmVkaXJlY3Q6ICRlLmRhdGEoJ3BqYXgtcmVwbGFjZS1yZWRpcmVjdCcpLFxuICAgICAgICAgICAgICAgICAgICBza2lwT3V0ZXJDb250YWluZXJzOiAkZS5kYXRhKCdwamF4LXNraXAtb3V0ZXItY29udGFpbmVycycpLFxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiAkZS5kYXRhKCdwamF4LXRpbWVvdXQnKSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsVGFyZ2V0OiAkZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZVBqYXggPyAkLnBqYXguY2xpY2soZXZlbnQsIHBqYXhPcHRpb25zKSA6IHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCRlLmlzKCc6c3VibWl0JykgJiYgJGZvcm0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VQamF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZm9ybS5vbignc3VibWl0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLnBqYXguc3VibWl0KGUsIHBqYXhPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRmb3JtLnRyaWdnZXIoJ3N1Ym1pdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvbGRNZXRob2QsXG4gICAgICAgICAgICAgICAgb2xkQWN0aW9uLFxuICAgICAgICAgICAgICAgIG5ld0Zvcm0gPSAhJGZvcm0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCFuZXdGb3JtKSB7XG4gICAgICAgICAgICAgICAgb2xkTWV0aG9kID0gJGZvcm0uYXR0cignbWV0aG9kJyk7XG4gICAgICAgICAgICAgICAgJGZvcm0uYXR0cignbWV0aG9kJywgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZEFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBvbGRBY3Rpb24gPSAkZm9ybS5hdHRyKCdhY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgJGZvcm0uYXR0cignYWN0aW9uJywgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSBwdWIuZ2V0Q3VycmVudFVybCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkZm9ybSA9ICQoJzxmb3JtLz4nLCB7bWV0aG9kOiBtZXRob2QsIGFjdGlvbjogYWN0aW9ufSk7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9ICRlLmF0dHIoJ3RhcmdldCcpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgJGZvcm0uYXR0cigndGFyZ2V0JywgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEvKGdldHxwb3N0KS9pLnRlc3QobWV0aG9kKSkge1xuICAgICAgICAgICAgICAgICAgICAkZm9ybS5hcHBlbmQoJCgnPGlucHV0Lz4nLCB7bmFtZTogJ19tZXRob2QnLCB2YWx1ZTogbWV0aG9kLCB0eXBlOiAnaGlkZGVuJ30pKTtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gJ3Bvc3QnO1xuICAgICAgICAgICAgICAgICAgICAkZm9ybS5hdHRyKCdtZXRob2QnLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoL3Bvc3QvaS50ZXN0KG1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNzcmZQYXJhbSA9IHB1Yi5nZXRDc3JmUGFyYW0oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzcmZQYXJhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGZvcm0uYXBwZW5kKCQoJzxpbnB1dC8+Jywge25hbWU6IGNzcmZQYXJhbSwgdmFsdWU6IHB1Yi5nZXRDc3JmVG9rZW4oKSwgdHlwZTogJ2hpZGRlbid9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJGZvcm0uaGlkZSgpLmFwcGVuZFRvKCdib2R5Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhY3RpdmVGb3JtRGF0YSA9ICRmb3JtLmRhdGEoJ3lpaUFjdGl2ZUZvcm0nKTtcbiAgICAgICAgICAgIGlmIChhY3RpdmVGb3JtRGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBlbGVtZW50IHRyaWdnZXJlZCB0aGUgZm9ybSBzdWJtaXNzaW9uLiBUaGlzIGlzIHVzZWQgYnkgeWlpLmFjdGl2ZUZvcm0uanMuXG4gICAgICAgICAgICAgICAgYWN0aXZlRm9ybURhdGEuc3VibWl0T2JqZWN0ID0gJGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhcmVWYWxpZFBhcmFtcykge1xuICAgICAgICAgICAgICAgICQuZWFjaChwYXJhbXMsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAkZm9ybS5hcHBlbmQoJCgnPGlucHV0Lz4nKS5hdHRyKHtuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIHR5cGU6ICdoaWRkZW4nfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXNlUGpheCkge1xuICAgICAgICAgICAgICAgICRmb3JtLm9uKCdzdWJtaXQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAkLnBqYXguc3VibWl0KGUsIHBqYXhPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJGZvcm0udHJpZ2dlcignc3VibWl0Jyk7XG5cbiAgICAgICAgICAgICQud2hlbigkZm9ybS5kYXRhKCd5aWlTdWJtaXRGaW5hbGl6ZVByb21pc2UnKSkuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgJGZvcm0ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob2xkQWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgJGZvcm0uYXR0cignYWN0aW9uJywgb2xkQWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJGZvcm0uYXR0cignbWV0aG9kJywgb2xkTWV0aG9kKTtcblxuICAgICAgICAgICAgICAgIGlmIChhcmVWYWxpZFBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICAkLmVhY2gocGFyYW1zLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnaW5wdXRbbmFtZT1cIicgKyBuYW1lICsgJ1wiXScsICRmb3JtKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0UXVlcnlQYXJhbXM6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB1cmwuaW5kZXhPZignPycpO1xuICAgICAgICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYWlycyA9ICQuZ3JlcCh1cmwuc3Vic3RyaW5nKHBvcyArIDEpLnNwbGl0KCcjJylbMF0uc3BsaXQoJyYnKSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSAnJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFpcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBkZWNvZGVVUklDb21wb25lbnQocGFpclswXS5yZXBsYWNlKC9cXCsvZywgJyUyMCcpKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwYWlyLmxlbmd0aCA+IDEgPyBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXS5yZXBsYWNlKC9cXCsvZywgJyUyMCcpKSA6ICcnO1xuICAgICAgICAgICAgICAgIGlmICghbmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbbmFtZV0gPSB2YWx1ZSB8fCAnJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISQuaXNBcnJheShwYXJhbXNbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbbmFtZV0gPSBbcGFyYW1zW25hbWVdXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbbmFtZV0ucHVzaCh2YWx1ZSB8fCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRNb2R1bGU6IGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgICAgIGlmIChtb2R1bGUuaXNBY3RpdmUgIT09IHVuZGVmaW5lZCAmJiAhbW9kdWxlLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihtb2R1bGUuaW5pdCkpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaW5pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJC5lYWNoKG1vZHVsZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QodGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcHViLmluaXRNb2R1bGUodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW5pdENzcmZIYW5kbGVyKCk7XG4gICAgICAgICAgICBpbml0UmVkaXJlY3RIYW5kbGVyKCk7XG4gICAgICAgICAgICBpbml0QXNzZXRGaWx0ZXJzKCk7XG4gICAgICAgICAgICBpbml0RGF0YU1ldGhvZHMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgVVJMIG9mIHRoZSBjdXJyZW50IHBhZ2Ugd2l0aG91dCBwYXJhbXMgYW5kIHRyYWlsaW5nIHNsYXNoLiBTZXBhcmF0ZWQgYW5kIG1hZGUgcHVibGljIGZvciB0ZXN0aW5nLlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QmFzZUN1cnJlbnRVcmw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgd2luZG93LmxvY2F0aW9uLmhvc3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIFVSTCBvZiB0aGUgY3VycmVudCBwYWdlLiBVc2VkIGZvciB0ZXN0aW5nLCB5b3UgY2FuIGFsd2F5cyBjYWxsIGB3aW5kb3cubG9jYXRpb24uaHJlZmAgbWFudWFsbHlcbiAgICAgICAgICogaW5zdGVhZC5cbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldEN1cnJlbnRVcmw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbml0Q3NyZkhhbmRsZXIoKSB7XG4gICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgc2VuZCBDU1JGIHRva2VuIGZvciBhbGwgQUpBWCByZXF1ZXN0c1xuICAgICAgICAkLmFqYXhQcmVmaWx0ZXIoZnVuY3Rpb24gKG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywgeGhyKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgcHViLmdldENzcmZQYXJhbSgpKSB7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1gtQ1NSRi1Ub2tlbicsIHB1Yi5nZXRDc3JmVG9rZW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwdWIucmVmcmVzaENzcmZUb2tlbigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRSZWRpcmVjdEhhbmRsZXIoKSB7XG4gICAgICAgIC8vIGhhbmRsZSBBSkFYIHJlZGlyZWN0aW9uXG4gICAgICAgICQoZG9jdW1lbnQpLmFqYXhDb21wbGV0ZShmdW5jdGlvbiAoZXZlbnQsIHhocikge1xuICAgICAgICAgICAgdmFyIHVybCA9IHhociAmJiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtUmVkaXJlY3QnKTtcbiAgICAgICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRBc3NldEZpbHRlcnMoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIGZvciBzdG9yaW5nIGxvYWRlZCBzY3JpcHRzIGFuZCBpbmZvcm1hdGlvbiBhYm91dCBsb2FkaW5nIGVhY2ggc2NyaXB0IGlmIGl0J3MgaW4gdGhlIHByb2Nlc3Mgb2YgbG9hZGluZy5cbiAgICAgICAgICogQSBzaW5nbGUgc2NyaXB0IGNhbiBoYXZlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAgICAgICAgICpcbiAgICAgICAgICogLSBgdW5kZWZpbmVkYCAtIHNjcmlwdCB3YXMgbm90IGxvYWRlZCBhdCBhbGwgYmVmb3JlIG9yIHdhcyBsb2FkZWQgd2l0aCBlcnJvciBsYXN0IHRpbWUuXG4gICAgICAgICAqIC0gYHRydWVgIChib29sZWFuKSAtICBzY3JpcHQgd2FzIHN1Y2Nlc3NmdWxseSBsb2FkZWQuXG4gICAgICAgICAqIC0gb2JqZWN0IC0gc2NyaXB0IGlzIGN1cnJlbnRseSBsb2FkaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiBjYXNlIG9mIGEgdmFsdWUgYmVpbmcgYW4gb2JqZWN0IHRoZSBwcm9wZXJ0aWVzIGFyZTpcbiAgICAgICAgICogLSBgeGhyTGlzdGAgLSByZXByZXNlbnRzIGEgcXVldWUgb2YgWEhSIHJlcXVlc3RzIHNlbnQgdG8gdGhlIHNhbWUgVVJMIChyZWxhdGVkIHdpdGggdGhpcyBzY3JpcHQpIGluIHRoZSBzYW1lXG4gICAgICAgICAqIHNtYWxsIHBlcmlvZCBvZiB0aW1lLlxuICAgICAgICAgKiAtIGB4aHJEb25lYCAtIGJvb2xlYW4sIGFjdHMgbGlrZSBhIGxvY2tpbmcgbWVjaGFuaXNtLiBXaGVuIG9uZSBvZiB0aGUgWEhSIHJlcXVlc3RzIGluIHRoZSBxdWV1ZSBpc1xuICAgICAgICAgKiBzdWNjZXNzZnVsbHkgY29tcGxldGVkLCBpdCB3aWxsIGFib3J0IHRoZSByZXN0IG9mIGNvbmN1cnJlbnQgcmVxdWVzdHMgdG8gdGhlIHNhbWUgVVJMIHVudGlsIGNsZWFudXAgaXMgZG9uZVxuICAgICAgICAgKiB0byBwcmV2ZW50IHBvc3NpYmxlIGVycm9ycyBhbmQgcmFjZSBjb25kaXRpb25zLlxuICAgICAgICAgKiBAdHlwZSB7e319XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgbG9hZGVkU2NyaXB0cyA9IHt9O1xuXG4gICAgICAgICQoJ3NjcmlwdFtzcmNdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gZ2V0QWJzb2x1dGVVcmwodGhpcy5zcmMpO1xuICAgICAgICAgICAgbG9hZGVkU2NyaXB0c1t1cmxdID0gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJC5hamF4UHJlZmlsdGVyKCdzY3JpcHQnLCBmdW5jdGlvbiAob3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCB4aHIpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGFUeXBlID09ICdqc29ucCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB1cmwgPSBnZXRBYnNvbHV0ZVVybChvcHRpb25zLnVybCksXG4gICAgICAgICAgICAgICAgZm9yYmlkZGVuUmVwZWF0ZWRMb2FkID0gbG9hZGVkU2NyaXB0c1t1cmxdID09PSB0cnVlICYmICFpc1JlbG9hZGFibGVBc3NldCh1cmwpLFxuICAgICAgICAgICAgICAgIGNsZWFudXBSdW5uaW5nID0gbG9hZGVkU2NyaXB0c1t1cmxdICE9PSB1bmRlZmluZWQgJiYgbG9hZGVkU2NyaXB0c1t1cmxdWyd4aHJEb25lJ10gPT09IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChmb3JiaWRkZW5SZXBlYXRlZExvYWQgfHwgY2xlYW51cFJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsb2FkZWRTY3JpcHRzW3VybF0gPT09IHVuZGVmaW5lZCB8fCBsb2FkZWRTY3JpcHRzW3VybF0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBsb2FkZWRTY3JpcHRzW3VybF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHhockxpc3Q6IFtdLFxuICAgICAgICAgICAgICAgICAgICB4aHJEb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHhoci5kb25lKGZ1bmN0aW9uIChkYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUikge1xuICAgICAgICAgICAgICAgIC8vIElmIG11bHRpcGxlIHJlcXVlc3RzIHdlcmUgc3VjY2Vzc2Z1bGx5IGxvYWRlZCwgcGVyZm9ybSBjbGVhbnVwIG9ubHkgb25jZVxuICAgICAgICAgICAgICAgIGlmIChsb2FkZWRTY3JpcHRzW2pxWEhSLnlpaVVybF1bJ3hockRvbmUnXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbG9hZGVkU2NyaXB0c1tqcVhIUi55aWlVcmxdWyd4aHJEb25lJ10gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxvYWRlZFNjcmlwdHNbanFYSFIueWlpVXJsXVsneGhyTGlzdCddLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaW5nbGVYaHIgPSBsb2FkZWRTY3JpcHRzW2pxWEhSLnlpaVVybF1bJ3hockxpc3QnXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbmdsZVhociAmJiBzaW5nbGVYaHIucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2luZ2xlWGhyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsb2FkZWRTY3JpcHRzW2pxWEhSLnlpaVVybF0gPSB0cnVlO1xuICAgICAgICAgICAgfSkuZmFpbChmdW5jdGlvbiAoanFYSFIsIHRleHRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dFN0YXR1cyA9PT0gJ2Fib3J0Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsZXRlIGxvYWRlZFNjcmlwdHNbanFYSFIueWlpVXJsXVsneGhyTGlzdCddW2pxWEhSLnlpaUluZGV4XTtcblxuICAgICAgICAgICAgICAgIHZhciBhbGxGYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsb2FkZWRTY3JpcHRzW2pxWEhSLnlpaVVybF1bJ3hockxpc3QnXS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGVkU2NyaXB0c1tqcVhIUi55aWlVcmxdWyd4aHJMaXN0J11baV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZhaWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFsbEZhaWxlZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbG9hZGVkU2NyaXB0c1tqcVhIUi55aWlVcmxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVXNlIHByZWZpeCBmb3IgY3VzdG9tIFhIUiBwcm9wZXJ0aWVzIHRvIGF2b2lkIHBvc3NpYmxlIGNvbmZsaWN0cyB3aXRoIGV4aXN0aW5nIHByb3BlcnRpZXNcbiAgICAgICAgICAgIHhoci55aWlJbmRleCA9IGxvYWRlZFNjcmlwdHNbdXJsXVsneGhyTGlzdCddLmxlbmd0aDtcbiAgICAgICAgICAgIHhoci55aWlVcmwgPSB1cmw7XG5cbiAgICAgICAgICAgIGxvYWRlZFNjcmlwdHNbdXJsXVsneGhyTGlzdCddW3hoci55aWlJbmRleF0gPSB4aHI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQoZG9jdW1lbnQpLmFqYXhDb21wbGV0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVTaGVldHMgPSBbXTtcbiAgICAgICAgICAgICQoJ2xpbmtbcmVsPXN0eWxlc2hlZXRdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVybCA9IGdldEFic29sdXRlVXJsKHRoaXMuaHJlZik7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVsb2FkYWJsZUFzc2V0KHVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICQuaW5BcnJheSh1cmwsIHN0eWxlU2hlZXRzKSA9PT0gLTEgPyBzdHlsZVNoZWV0cy5wdXNoKHVybCkgOiAkKHRoaXMpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXREYXRhTWV0aG9kcygpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gJHRoaXMuZGF0YSgnbWV0aG9kJyksXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9ICR0aGlzLmRhdGEoJ2NvbmZpcm0nKSxcbiAgICAgICAgICAgICAgICBmb3JtID0gJHRoaXMuZGF0YSgnZm9ybScpO1xuXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQgJiYgbWVzc2FnZSA9PT0gdW5kZWZpbmVkICYmIGZvcm0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkICYmIG1lc3NhZ2UgIT09IGZhbHNlICYmIG1lc3NhZ2UgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgJC5wcm94eShwdWIuY29uZmlybSwgdGhpcykobWVzc2FnZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBwdWIuaGFuZGxlQWN0aW9uKCR0aGlzLCBldmVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHB1Yi5oYW5kbGVBY3Rpb24oJHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGhhbmRsZSBkYXRhLWNvbmZpcm0gYW5kIGRhdGEtbWV0aG9kIGZvciBjbGlja2FibGUgYW5kIGNoYW5nZWFibGUgZWxlbWVudHNcbiAgICAgICAgJChkb2N1bWVudCkub24oJ2NsaWNrLnlpaScsIHB1Yi5jbGlja2FibGVTZWxlY3RvciwgaGFuZGxlcilcbiAgICAgICAgICAgIC5vbignY2hhbmdlLnlpaScsIHB1Yi5jaGFuZ2VhYmxlU2VsZWN0b3IsIGhhbmRsZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUmVsb2FkYWJsZUFzc2V0KHVybCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB1Yi5yZWxvYWRhYmxlU2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJ1bGUgPSBnZXRBYnNvbHV0ZVVybChwdWIucmVsb2FkYWJsZVNjcmlwdHNbaV0pO1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gbmV3IFJlZ0V4cChcIl5cIiArIGVzY2FwZVJlZ0V4cChydWxlKS5zcGxpdCgnXFxcXConKS5qb2luKCcuKycpICsgXCIkXCIpLnRlc3QodXJsKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzQ0NjE3MC9lc2NhcGUtc3RyaW5nLWZvci11c2UtaW4tamF2YXNjcmlwdC1yZWdleFxuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFwtXFxbXFxdXFwvXFx7XFx9XFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcXlxcJFxcfF0vZywgXCJcXFxcJCZcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhYnNvbHV0ZSBVUkwgYmFzZWQgb24gdGhlIGdpdmVuIFVSTFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgSW5pdGlhbCBVUkxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFic29sdXRlVXJsKHVybCkge1xuICAgICAgICByZXR1cm4gdXJsLmNoYXJBdCgwKSA9PT0gJy8nID8gcHViLmdldEJhc2VDdXJyZW50VXJsKCkgKyB1cmwgOiB1cmw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHB1Yjtcbn0pKHdpbmRvdy5qUXVlcnkpO1xuXG53aW5kb3cualF1ZXJ5KGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cueWlpLmluaXRNb2R1bGUod2luZG93LnlpaSk7XG59KTtcbiIsIi8qKlxuICogWWlpIHZhbGlkYXRpb24gbW9kdWxlLlxuICpcbiAqIFRoaXMgSmF2YVNjcmlwdCBtb2R1bGUgcHJvdmlkZXMgdGhlIHZhbGlkYXRpb24gbWV0aG9kcyBmb3IgdGhlIGJ1aWx0LWluIHZhbGlkYXRvcnMuXG4gKlxuICogQGxpbmsgaHR0cDovL3d3dy55aWlmcmFtZXdvcmsuY29tL1xuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMDggWWlpIFNvZnR3YXJlIExMQ1xuICogQGxpY2Vuc2UgaHR0cDovL3d3dy55aWlmcmFtZXdvcmsuY29tL2xpY2Vuc2UvXG4gKiBAYXV0aG9yIFFpYW5nIFh1ZSA8cWlhbmcueHVlQGdtYWlsLmNvbT5cbiAqIEBzaW5jZSAyLjBcbiAqL1xuXG55aWkudmFsaWRhdGlvbiA9IChmdW5jdGlvbiAoJCkge1xuICAgIHZhciBwdWIgPSB7XG4gICAgICAgIGlzRW1wdHk6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgKCQuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB8fCB2YWx1ZSA9PT0gJyc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkTWVzc2FnZTogZnVuY3Rpb24gKG1lc3NhZ2VzLCBtZXNzYWdlLCB2YWx1ZSkge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChtZXNzYWdlLnJlcGxhY2UoL1xce3ZhbHVlXFx9L2csIHZhbHVlKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVxdWlyZWQ6IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVxdWlyZWRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0cmljdCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8ICFvcHRpb25zLnN0cmljdCAmJiAhcHViLmlzRW1wdHkoaXNTdHJpbmcgPyAkLnRyaW0odmFsdWUpIDogdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvcHRpb25zLnN0cmljdCAmJiB2YWx1ZSA9PSBvcHRpb25zLnJlcXVpcmVkVmFsdWUgfHwgb3B0aW9ucy5zdHJpY3QgJiYgdmFsdWUgPT09IG9wdGlvbnMucmVxdWlyZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgIHB1Yi5hZGRNZXNzYWdlKG1lc3NhZ2VzLCBvcHRpb25zLm1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBcImJvb2xlYW5cIiBpcyBhIHJlc2VydmVkIGtleXdvcmQgaW4gb2xkZXIgdmVyc2lvbnMgb2YgRVMgc28gaXQncyBxdW90ZWQgZm9yIElFIDwgOSBzdXBwb3J0XG4gICAgICAgICdib29sZWFuJzogZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlcywgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2tpcE9uRW1wdHkgJiYgcHViLmlzRW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbGlkID0gIW9wdGlvbnMuc3RyaWN0ICYmICh2YWx1ZSA9PSBvcHRpb25zLnRydWVWYWx1ZSB8fCB2YWx1ZSA9PSBvcHRpb25zLmZhbHNlVmFsdWUpXG4gICAgICAgICAgICAgICAgfHwgb3B0aW9ucy5zdHJpY3QgJiYgKHZhbHVlID09PSBvcHRpb25zLnRydWVWYWx1ZSB8fCB2YWx1ZSA9PT0gb3B0aW9ucy5mYWxzZVZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgIHB1Yi5hZGRNZXNzYWdlKG1lc3NhZ2VzLCBvcHRpb25zLm1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzdHJpbmc6IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNraXBPbkVtcHR5ICYmIHB1Yi5pc0VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwdWIuYWRkTWVzc2FnZShtZXNzYWdlcywgb3B0aW9ucy5tZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pcyAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCAhPSBvcHRpb25zLmlzKSB7XG4gICAgICAgICAgICAgICAgcHViLmFkZE1lc3NhZ2UobWVzc2FnZXMsIG9wdGlvbnMubm90RXF1YWwsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5taW4gIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGggPCBvcHRpb25zLm1pbikge1xuICAgICAgICAgICAgICAgIHB1Yi5hZGRNZXNzYWdlKG1lc3NhZ2VzLCBvcHRpb25zLnRvb1Nob3J0LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tYXggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGggPiBvcHRpb25zLm1heCkge1xuICAgICAgICAgICAgICAgIHB1Yi5hZGRNZXNzYWdlKG1lc3NhZ2VzLCBvcHRpb25zLnRvb0xvbmcsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmaWxlOiBmdW5jdGlvbiAoYXR0cmlidXRlLCBtZXNzYWdlcywgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGZpbGVzID0gZ2V0VXBsb2FkZWRGaWxlcyhhdHRyaWJ1dGUsIG1lc3NhZ2VzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICQuZWFjaChmaWxlcywgZnVuY3Rpb24gKGksIGZpbGUpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUZpbGUoZmlsZSwgbWVzc2FnZXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW1hZ2U6IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIG1lc3NhZ2VzLCBvcHRpb25zLCBkZWZlcnJlZExpc3QpIHtcbiAgICAgICAgICAgIHZhciBmaWxlcyA9IGdldFVwbG9hZGVkRmlsZXMoYXR0cmlidXRlLCBtZXNzYWdlcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAkLmVhY2goZmlsZXMsIGZ1bmN0aW9uIChpLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVGaWxlKGZpbGUsIG1lc3NhZ2VzLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIC8vIFNraXAgaW1hZ2UgdmFsaWRhdGlvbiBpZiBGaWxlUmVhZGVyIEFQSSBpcyBub3QgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBGaWxlUmVhZGVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XG4gICAgICAgICAgICAgICAgcHViLnZhbGlkYXRlSW1hZ2UoZmlsZSwgbWVzc2FnZXMsIG9wdGlvbnMsIGRlZmVycmVkLCBuZXcgRmlsZVJlYWRlcigpLCBuZXcgSW1hZ2UoKSk7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWRMaXN0LnB1c2goZGVmZXJyZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsaWRhdGVJbWFnZTogZnVuY3Rpb24gKGZpbGUsIG1lc3NhZ2VzLCBvcHRpb25zLCBkZWZlcnJlZCwgZmlsZVJlYWRlciwgaW1hZ2UpIHtcbiAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlSW1hZ2VTaXplKGZpbGUsIGltYWdlLCBtZXNzYWdlcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlcy5wdXNoKG9wdGlvbnMubm90SW1hZ2UucmVwbGFjZSgvXFx7ZmlsZVxcfS9nLCBmaWxlLm5hbWUpKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpbWFnZS5zcmMgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFJlc29sdmUgZGVmZXJyZWQgaWYgdGhlcmUgd2FzIGVycm9yIHdoaWxlIHJlYWRpbmcgZGF0YVxuICAgICAgICAgICAgZmlsZVJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBudW1iZXI6IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNraXBPbkVtcHR5ICYmIHB1Yi5pc0VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIW9wdGlvbnMucGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHB1Yi5hZGRNZXNzYWdlKG1lc3NhZ2VzLCBvcHRpb25zLm1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1pbiAhPT0gdW5kZWZpbmVkICYmIHZhbHVlIDwgb3B0aW9ucy5taW4pIHtcbiAgICAgICAgICAgICAgICBwdWIuYWRkTWVzc2FnZShtZXNzYWdlcywgb3B0aW9ucy50b29TbWFsbCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWF4ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPiBvcHRpb25zLm1heCkge1xuICAgICAgICAgICAgICAgIHB1Yi5hZGRNZXNzYWdlKG1lc3NhZ2VzLCBvcHRpb25zLnRvb0JpZywgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJhbmdlOiBmdW5jdGlvbiAodmFsdWUsIG1lc3NhZ2VzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5za2lwT25FbXB0eSAmJiBwdWIuaXNFbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hbGxvd0FycmF5ICYmICQuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBwdWIuYWRkTWVzc2FnZShtZXNzYWdlcywgb3B0aW9ucy5tZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5BcnJheSA9IHRydWU7XG5cbiAgICAgICAgICAgICQuZWFjaCgkLmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdLCBmdW5jdGlvbiAoaSwgdikge1xuICAgICAgICAgICAgICAgIGlmICgkLmluQXJyYXkodiwgb3B0aW9ucy5yYW5nZSkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5BcnJheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm5vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5ub3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubm90ID09PSBpbkFycmF5KSB7XG4gICAgICAgICAgICAgICAgcHViLmFkZE1lc3NhZ2UobWVzc2FnZXMsIG9wdGlvbnMubWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uOiBmdW5jdGlvbiAodmFsdWUsIG1lc3NhZ2VzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5za2lwT25FbXB0eSAmJiBwdWIuaXNFbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5ub3QgJiYgIW9wdGlvbnMucGF0dGVybi50ZXN0KHZhbHVlKSB8fCBvcHRpb25zLm5vdCAmJiBvcHRpb25zLnBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBwdWIuYWRkTWVzc2FnZShtZXNzYWdlcywgb3B0aW9ucy5tZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW1haWw6IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNraXBPbkVtcHR5ICYmIHB1Yi5pc0VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICByZWdleHAgPSAvXigoPzpcIj8oW15cIl0qKVwiP1xccyk/KSg/OlxccyspPyg/Oig8PykoKC4rKUAoW14+XSspKSg+PykpJC8sXG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA9IHJlZ2V4cC5leGVjKHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxQYXJ0ID0gbWF0Y2hlc1s1XSxcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluID0gbWF0Y2hlc1s2XTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVuYWJsZUlETikge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFBhcnQgPSBwdW55Y29kZS50b0FTQ0lJKGxvY2FsUGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbiA9IHB1bnljb2RlLnRvQVNDSUkoZG9tYWluKTtcblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1hdGNoZXNbMV0gKyBtYXRjaGVzWzNdICsgbG9jYWxQYXJ0ICsgJ0AnICsgZG9tYWluICsgbWF0Y2hlc1s3XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobG9jYWxQYXJ0Lmxlbmd0aCA+IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgobG9jYWxQYXJ0ICsgJ0AnICsgZG9tYWluKS5sZW5ndGggPiAyNTQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IG9wdGlvbnMucGF0dGVybi50ZXN0KHZhbHVlKSB8fCAob3B0aW9ucy5hbGxvd05hbWUgJiYgb3B0aW9ucy5mdWxsUGF0dGVybi50ZXN0KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcHViLmFkZE1lc3NhZ2UobWVzc2FnZXMsIG9wdGlvbnMubWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVybDogZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlcywgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2tpcE9uRW1wdHkgJiYgcHViLmlzRW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0U2NoZW1lICYmICEvOlxcL1xcLy8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG9wdGlvbnMuZGVmYXVsdFNjaGVtZSArICc6Ly8nICsgdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWxpZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVuYWJsZUlETikge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gL14oW146XSspOlxcL1xcLyhbXlxcL10rKSguKikkLy5leGVjKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWF0Y2hlc1sxXSArICc6Ly8nICsgcHVueWNvZGUudG9BU0NJSShtYXRjaGVzWzJdKSArIG1hdGNoZXNbM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXZhbGlkIHx8ICFvcHRpb25zLnBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBwdWIuYWRkTWVzc2FnZShtZXNzYWdlcywgb3B0aW9ucy5tZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJpbTogZnVuY3Rpb24gKCRmb3JtLCBhdHRyaWJ1dGUsIG9wdGlvbnMsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgJGlucHV0ID0gJGZvcm0uZmluZChhdHRyaWJ1dGUuaW5wdXQpO1xuICAgICAgICAgICAgaWYgKCRpbnB1dC5pcygnOmNoZWNrYm94LCA6cmFkaW8nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSAkaW5wdXQudmFsKCk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc2tpcE9uRW1wdHkgfHwgIXB1Yi5pc0VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJC50cmltKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAkaW5wdXQudmFsKHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNhcHRjaGE6IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNraXBPbkVtcHR5ICYmIHB1Yi5pc0VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ0FQVENIQSBtYXkgYmUgdXBkYXRlZCB2aWEgQUpBWCBhbmQgdGhlIHVwZGF0ZWQgaGFzaCBpcyBzdG9yZWQgaW4gYm9keSBkYXRhXG4gICAgICAgICAgICB2YXIgaGFzaCA9ICQoJ2JvZHknKS5kYXRhKG9wdGlvbnMuaGFzaEtleSk7XG4gICAgICAgICAgICBoYXNoID0gaGFzaCA9PSBudWxsID8gb3B0aW9ucy5oYXNoIDogaGFzaFtvcHRpb25zLmNhc2VTZW5zaXRpdmUgPyAwIDogMV07XG4gICAgICAgICAgICB2YXIgdiA9IG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSA/IHZhbHVlIDogdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB2Lmxlbmd0aCAtIDEsIGggPSAwOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIGggKz0gdi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGggIT0gaGFzaCkge1xuICAgICAgICAgICAgICAgIHB1Yi5hZGRNZXNzYWdlKG1lc3NhZ2VzLCBvcHRpb25zLm1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjb21wYXJlOiBmdW5jdGlvbiAodmFsdWUsIG1lc3NhZ2VzLCBvcHRpb25zLCAkZm9ybSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2tpcE9uRW1wdHkgJiYgcHViLmlzRW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29tcGFyZVZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbXBhcmVBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbXBhcmVWYWx1ZSA9IG9wdGlvbnMuY29tcGFyZVZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgJHRhcmdldCA9ICQoJyMnICsgb3B0aW9ucy5jb21wYXJlQXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoISR0YXJnZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICR0YXJnZXQgPSAkZm9ybS5maW5kKCdbbmFtZT1cIicgKyBvcHRpb25zLmNvbXBhcmVBdHRyaWJ1dGVOYW1lICsgJ1wiXScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wYXJlVmFsdWUgPSAkdGFyZ2V0LnZhbCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IDA7XG4gICAgICAgICAgICAgICAgY29tcGFyZVZhbHVlID0gY29tcGFyZVZhbHVlID8gcGFyc2VGbG9hdChjb21wYXJlVmFsdWUpIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAob3B0aW9ucy5vcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB2YWx1ZSA9PSBjb21wYXJlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkID0gdmFsdWUgPT09IGNvbXBhcmVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHZhbHVlICE9IGNvbXBhcmVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB2YWx1ZSAhPT0gY29tcGFyZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB2YWx1ZSA+IGNvbXBhcmVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHZhbHVlID49IGNvbXBhcmVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkID0gdmFsdWUgPCBjb21wYXJlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB2YWx1ZSA8PSBjb21wYXJlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcHViLmFkZE1lc3NhZ2UobWVzc2FnZXMsIG9wdGlvbnMubWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlwOiBmdW5jdGlvbiAodmFsdWUsIG1lc3NhZ2VzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5za2lwT25FbXB0eSAmJiBwdWIuaXNFbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZWdhdGlvbiA9IG51bGwsXG4gICAgICAgICAgICAgICAgY2lkciA9IG51bGwsXG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA9IG5ldyBSZWdFeHAob3B0aW9ucy5pcFBhcnNlUGF0dGVybikuZXhlYyh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIG5lZ2F0aW9uID0gbWF0Y2hlc1sxXSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICAgICAgICBjaWRyID0gbWF0Y2hlc1s0XSB8fCBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdWJuZXQgPT09IHRydWUgJiYgY2lkciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHB1Yi5hZGRNZXNzYWdlKG1lc3NhZ2VzLCBvcHRpb25zLm1lc3NhZ2VzLm5vU3VibmV0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3VibmV0ID09PSBmYWxzZSAmJiBjaWRyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHViLmFkZE1lc3NhZ2UobWVzc2FnZXMsIG9wdGlvbnMubWVzc2FnZXMuaGFzU3VibmV0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubmVnYXRpb24gPT09IGZhbHNlICYmIG5lZ2F0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHViLmFkZE1lc3NhZ2UobWVzc2FnZXMsIG9wdGlvbnMubWVzc2FnZXMubWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlwVmVyc2lvbiA9IHZhbHVlLmluZGV4T2YoJzonKSA9PT0gLTEgPyA0IDogNjtcbiAgICAgICAgICAgIGlmIChpcFZlcnNpb24gPT0gNikge1xuICAgICAgICAgICAgICAgIGlmICghKG5ldyBSZWdFeHAob3B0aW9ucy5pcHY2UGF0dGVybikpLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1Yi5hZGRNZXNzYWdlKG1lc3NhZ2VzLCBvcHRpb25zLm1lc3NhZ2VzLm1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmlwdjYpIHtcbiAgICAgICAgICAgICAgICAgICAgcHViLmFkZE1lc3NhZ2UobWVzc2FnZXMsIG9wdGlvbnMubWVzc2FnZXMuaXB2Nk5vdEFsbG93ZWQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghKG5ldyBSZWdFeHAob3B0aW9ucy5pcHY0UGF0dGVybikpLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1Yi5hZGRNZXNzYWdlKG1lc3NhZ2VzLCBvcHRpb25zLm1lc3NhZ2VzLm1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmlwdjQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHViLmFkZE1lc3NhZ2UobWVzc2FnZXMsIG9wdGlvbnMubWVzc2FnZXMuaXB2NE5vdEFsbG93ZWQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0VXBsb2FkZWRGaWxlcyhhdHRyaWJ1dGUsIG1lc3NhZ2VzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFNraXAgdmFsaWRhdGlvbiBpZiBGaWxlIEFQSSBpcyBub3QgYXZhaWxhYmxlXG4gICAgICAgIGlmICh0eXBlb2YgRmlsZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpbGVJbnB1dCA9ICQoYXR0cmlidXRlLmlucHV0LCBhdHRyaWJ1dGUuJGZvcm0pLmdldCgwKTtcblxuICAgICAgICAvLyBTa2lwIHZhbGlkYXRpb24gaWYgZmlsZSBpbnB1dCBkb2VzIG5vdCBleGlzdFxuICAgICAgICAvLyAoaW4gY2FzZSBmaWxlIGlucHV0cyBhcmUgYWRkZWQgZHluYW1pY2FsbHkgYW5kIG5vIGZpbGUgaW5wdXQgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGZvcm0pXG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlucHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsZXMgPSBmaWxlSW5wdXQuZmlsZXM7XG4gICAgICAgIGlmICghZmlsZXMpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2gob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5za2lwT25FbXB0eSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2gob3B0aW9ucy51cGxvYWRSZXF1aXJlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLm1heEZpbGVzICYmIG9wdGlvbnMubWF4RmlsZXMgPCBmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2gob3B0aW9ucy50b29NYW55KTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaWxlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZpbGUoZmlsZSwgbWVzc2FnZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXh0ZW5zaW9ucyAmJiBvcHRpb25zLmV4dGVuc2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZmlsZS5uYW1lLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICAgICAgICB2YXIgZXh0ID0gIX5pbmRleCA/ICcnIDogZmlsZS5uYW1lLnN1YnN0cihpbmRleCArIDEsIGZpbGUubmFtZS5sZW5ndGgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmICghfm9wdGlvbnMuZXh0ZW5zaW9ucy5pbmRleE9mKGV4dCkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlcy5wdXNoKG9wdGlvbnMud3JvbmdFeHRlbnNpb24ucmVwbGFjZSgvXFx7ZmlsZVxcfS9nLCBmaWxlLm5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLm1pbWVUeXBlcyAmJiBvcHRpb25zLm1pbWVUeXBlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlTWltZVR5cGUob3B0aW9ucy5taW1lVHlwZXMsIGZpbGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlcy5wdXNoKG9wdGlvbnMud3JvbmdNaW1lVHlwZS5yZXBsYWNlKC9cXHtmaWxlXFx9L2csIGZpbGUubmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubWF4U2l6ZSAmJiBvcHRpb25zLm1heFNpemUgPCBmaWxlLnNpemUpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2gob3B0aW9ucy50b29CaWcucmVwbGFjZSgvXFx7ZmlsZVxcfS9nLCBmaWxlLm5hbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLm1pblNpemUgJiYgb3B0aW9ucy5taW5TaXplID4gZmlsZS5zaXplKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKG9wdGlvbnMudG9vU21hbGwucmVwbGFjZSgvXFx7ZmlsZVxcfS9nLCBmaWxlLm5hbWUpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlTWltZVR5cGUobWltZVR5cGVzLCBmaWxlVHlwZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWltZVR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobmV3IFJlZ0V4cChtaW1lVHlwZXNbaV0pLnRlc3QoZmlsZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJbWFnZVNpemUoZmlsZSwgaW1hZ2UsIG1lc3NhZ2VzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm1pbldpZHRoICYmIGltYWdlLndpZHRoIDwgb3B0aW9ucy5taW5XaWR0aCkge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChvcHRpb25zLnVuZGVyV2lkdGgucmVwbGFjZSgvXFx7ZmlsZVxcfS9nLCBmaWxlLm5hbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLm1heFdpZHRoICYmIGltYWdlLndpZHRoID4gb3B0aW9ucy5tYXhXaWR0aCkge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChvcHRpb25zLm92ZXJXaWR0aC5yZXBsYWNlKC9cXHtmaWxlXFx9L2csIGZpbGUubmFtZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubWluSGVpZ2h0ICYmIGltYWdlLmhlaWdodCA8IG9wdGlvbnMubWluSGVpZ2h0KSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKG9wdGlvbnMudW5kZXJIZWlnaHQucmVwbGFjZSgvXFx7ZmlsZVxcfS9nLCBmaWxlLm5hbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLm1heEhlaWdodCAmJiBpbWFnZS5oZWlnaHQgPiBvcHRpb25zLm1heEhlaWdodCkge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChvcHRpb25zLm92ZXJIZWlnaHQucmVwbGFjZSgvXFx7ZmlsZVxcfS9nLCBmaWxlLm5hbWUpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwdWI7XG59KShqUXVlcnkpO1xuIiwiLyoqXG4gKiBZaWkgZm9ybSB3aWRnZXQuXG4gKlxuICogVGhpcyBpcyB0aGUgSmF2YVNjcmlwdCB3aWRnZXQgdXNlZCBieSB0aGUgeWlpXFx3aWRnZXRzXFxBY3RpdmVGb3JtIHdpZGdldC5cbiAqXG4gKiBAbGluayBodHRwOi8vd3d3LnlpaWZyYW1ld29yay5jb20vXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAwOCBZaWkgU29mdHdhcmUgTExDXG4gKiBAbGljZW5zZSBodHRwOi8vd3d3LnlpaWZyYW1ld29yay5jb20vbGljZW5zZS9cbiAqIEBhdXRob3IgUWlhbmcgWHVlIDxxaWFuZy54dWVAZ21haWwuY29tPlxuICogQHNpbmNlIDIuMFxuICovXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgICQuZm4ueWlpQWN0aXZlRm9ybSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgaWYgKG1ldGhvZHNbbWV0aG9kXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHNbbWV0aG9kXS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyB8fCAhbWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLmVycm9yKCdNZXRob2QgJyArIG1ldGhvZCArICcgZG9lcyBub3QgZXhpc3Qgb24galF1ZXJ5LnlpaUFjdGl2ZUZvcm0nKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZXZlbnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogYmVmb3JlVmFsaWRhdGUgZXZlbnQgaXMgdHJpZ2dlcmVkIGJlZm9yZSB2YWxpZGF0aW5nIHRoZSB3aG9sZSBmb3JtLlxuICAgICAgICAgKiBUaGUgc2lnbmF0dXJlIG9mIHRoZSBldmVudCBoYW5kbGVyIHNob3VsZCBiZTpcbiAgICAgICAgICogICAgIGZ1bmN0aW9uIChldmVudCwgbWVzc2FnZXMsIGRlZmVycmVkcylcbiAgICAgICAgICogd2hlcmVcbiAgICAgICAgICogIC0gZXZlbnQ6IGFuIEV2ZW50IG9iamVjdC5cbiAgICAgICAgICogIC0gbWVzc2FnZXM6IGFuIGFzc29jaWF0aXZlIGFycmF5IHdpdGgga2V5cyBiZWluZyBhdHRyaWJ1dGUgSURzIGFuZCB2YWx1ZXMgYmVpbmcgZXJyb3IgbWVzc2FnZSBhcnJheXNcbiAgICAgICAgICogICAgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZXMuXG4gICAgICAgICAqICAtIGRlZmVycmVkczogYW4gYXJyYXkgb2YgRGVmZXJyZWQgb2JqZWN0cy4gWW91IGNhbiB1c2UgZGVmZXJyZWRzLmFkZChjYWxsYmFjaykgdG8gYWRkIGEgbmV3IGRlZmVycmVkIHZhbGlkYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBoYW5kbGVyIHJldHVybnMgYSBib29sZWFuIGZhbHNlLCBpdCB3aWxsIHN0b3AgZnVydGhlciBmb3JtIHZhbGlkYXRpb24gYWZ0ZXIgdGhpcyBldmVudC4gQW5kIGFzXG4gICAgICAgICAqIGEgcmVzdWx0LCBhZnRlclZhbGlkYXRlIGV2ZW50IHdpbGwgbm90IGJlIHRyaWdnZXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIGJlZm9yZVZhbGlkYXRlOiAnYmVmb3JlVmFsaWRhdGUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogYWZ0ZXJWYWxpZGF0ZSBldmVudCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgdmFsaWRhdGluZyB0aGUgd2hvbGUgZm9ybS5cbiAgICAgICAgICogVGhlIHNpZ25hdHVyZSBvZiB0aGUgZXZlbnQgaGFuZGxlciBzaG91bGQgYmU6XG4gICAgICAgICAqICAgICBmdW5jdGlvbiAoZXZlbnQsIG1lc3NhZ2VzLCBlcnJvckF0dHJpYnV0ZXMpXG4gICAgICAgICAqIHdoZXJlXG4gICAgICAgICAqICAtIGV2ZW50OiBhbiBFdmVudCBvYmplY3QuXG4gICAgICAgICAqICAtIG1lc3NhZ2VzOiBhbiBhc3NvY2lhdGl2ZSBhcnJheSB3aXRoIGtleXMgYmVpbmcgYXR0cmlidXRlIElEcyBhbmQgdmFsdWVzIGJlaW5nIGVycm9yIG1lc3NhZ2UgYXJyYXlzXG4gICAgICAgICAqICAgIGZvciB0aGUgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGVzLlxuICAgICAgICAgKiAgLSBlcnJvckF0dHJpYnV0ZXM6IGFuIGFycmF5IG9mIGF0dHJpYnV0ZXMgdGhhdCBoYXZlIHZhbGlkYXRpb24gZXJyb3JzLiBQbGVhc2UgcmVmZXIgdG8gYXR0cmlidXRlRGVmYXVsdHMgZm9yIHRoZSBzdHJ1Y3R1cmUgb2YgdGhpcyBwYXJhbWV0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBhZnRlclZhbGlkYXRlOiAnYWZ0ZXJWYWxpZGF0ZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBiZWZvcmVWYWxpZGF0ZUF0dHJpYnV0ZSBldmVudCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHZhbGlkYXRpbmcgYW4gYXR0cmlidXRlLlxuICAgICAgICAgKiBUaGUgc2lnbmF0dXJlIG9mIHRoZSBldmVudCBoYW5kbGVyIHNob3VsZCBiZTpcbiAgICAgICAgICogICAgIGZ1bmN0aW9uIChldmVudCwgYXR0cmlidXRlLCBtZXNzYWdlcywgZGVmZXJyZWRzKVxuICAgICAgICAgKiB3aGVyZVxuICAgICAgICAgKiAgLSBldmVudDogYW4gRXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiAgLSBhdHRyaWJ1dGU6IHRoZSBhdHRyaWJ1dGUgdG8gYmUgdmFsaWRhdGVkLiBQbGVhc2UgcmVmZXIgdG8gYXR0cmlidXRlRGVmYXVsdHMgZm9yIHRoZSBzdHJ1Y3R1cmUgb2YgdGhpcyBwYXJhbWV0ZXIuXG4gICAgICAgICAqICAtIG1lc3NhZ2VzOiBhbiBhcnJheSB0byB3aGljaCB5b3UgY2FuIGFkZCB2YWxpZGF0aW9uIGVycm9yIG1lc3NhZ2VzIGZvciB0aGUgc3BlY2lmaWVkIGF0dHJpYnV0ZS5cbiAgICAgICAgICogIC0gZGVmZXJyZWRzOiBhbiBhcnJheSBvZiBEZWZlcnJlZCBvYmplY3RzLiBZb3UgY2FuIHVzZSBkZWZlcnJlZHMuYWRkKGNhbGxiYWNrKSB0byBhZGQgYSBuZXcgZGVmZXJyZWQgdmFsaWRhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGhhbmRsZXIgcmV0dXJucyBhIGJvb2xlYW4gZmFsc2UsIGl0IHdpbGwgc3RvcCBmdXJ0aGVyIHZhbGlkYXRpb24gb2YgdGhlIHNwZWNpZmllZCBhdHRyaWJ1dGUuXG4gICAgICAgICAqIEFuZCBhcyBhIHJlc3VsdCwgYWZ0ZXJWYWxpZGF0ZUF0dHJpYnV0ZSBldmVudCB3aWxsIG5vdCBiZSB0cmlnZ2VyZWQuXG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVWYWxpZGF0ZUF0dHJpYnV0ZTogJ2JlZm9yZVZhbGlkYXRlQXR0cmlidXRlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFmdGVyVmFsaWRhdGVBdHRyaWJ1dGUgZXZlbnQgaXMgdHJpZ2dlcmVkIGFmdGVyIHZhbGlkYXRpbmcgdGhlIHdob2xlIGZvcm0gYW5kIGVhY2ggYXR0cmlidXRlLlxuICAgICAgICAgKiBUaGUgc2lnbmF0dXJlIG9mIHRoZSBldmVudCBoYW5kbGVyIHNob3VsZCBiZTpcbiAgICAgICAgICogICAgIGZ1bmN0aW9uIChldmVudCwgYXR0cmlidXRlLCBtZXNzYWdlcylcbiAgICAgICAgICogd2hlcmVcbiAgICAgICAgICogIC0gZXZlbnQ6IGFuIEV2ZW50IG9iamVjdC5cbiAgICAgICAgICogIC0gYXR0cmlidXRlOiB0aGUgYXR0cmlidXRlIGJlaW5nIHZhbGlkYXRlZC4gUGxlYXNlIHJlZmVyIHRvIGF0dHJpYnV0ZURlZmF1bHRzIGZvciB0aGUgc3RydWN0dXJlIG9mIHRoaXMgcGFyYW1ldGVyLlxuICAgICAgICAgKiAgLSBtZXNzYWdlczogYW4gYXJyYXkgdG8gd2hpY2ggeW91IGNhbiBhZGQgYWRkaXRpb25hbCB2YWxpZGF0aW9uIGVycm9yIG1lc3NhZ2VzIGZvciB0aGUgc3BlY2lmaWVkIGF0dHJpYnV0ZS5cbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyVmFsaWRhdGVBdHRyaWJ1dGU6ICdhZnRlclZhbGlkYXRlQXR0cmlidXRlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJlZm9yZVN1Ym1pdCBldmVudCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHN1Ym1pdHRpbmcgdGhlIGZvcm0gYWZ0ZXIgYWxsIHZhbGlkYXRpb25zIGhhdmUgcGFzc2VkLlxuICAgICAgICAgKiBUaGUgc2lnbmF0dXJlIG9mIHRoZSBldmVudCBoYW5kbGVyIHNob3VsZCBiZTpcbiAgICAgICAgICogICAgIGZ1bmN0aW9uIChldmVudClcbiAgICAgICAgICogd2hlcmUgZXZlbnQgaXMgYW4gRXZlbnQgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgaGFuZGxlciByZXR1cm5zIGEgYm9vbGVhbiBmYWxzZSwgaXQgd2lsbCBzdG9wIGZvcm0gc3VibWlzc2lvbi5cbiAgICAgICAgICovXG4gICAgICAgIGJlZm9yZVN1Ym1pdDogJ2JlZm9yZVN1Ym1pdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhamF4QmVmb3JlU2VuZCBldmVudCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHNlbmRpbmcgYW4gQUpBWCByZXF1ZXN0IGZvciBBSkFYLWJhc2VkIHZhbGlkYXRpb24uXG4gICAgICAgICAqIFRoZSBzaWduYXR1cmUgb2YgdGhlIGV2ZW50IGhhbmRsZXIgc2hvdWxkIGJlOlxuICAgICAgICAgKiAgICAgZnVuY3Rpb24gKGV2ZW50LCBqcVhIUiwgc2V0dGluZ3MpXG4gICAgICAgICAqIHdoZXJlXG4gICAgICAgICAqICAtIGV2ZW50OiBhbiBFdmVudCBvYmplY3QuXG4gICAgICAgICAqICAtIGpxWEhSOiBhIGpxWEhSIG9iamVjdFxuICAgICAgICAgKiAgLSBzZXR0aW5nczogdGhlIHNldHRpbmdzIGZvciB0aGUgQUpBWCByZXF1ZXN0XG4gICAgICAgICAqL1xuICAgICAgICBhamF4QmVmb3JlU2VuZDogJ2FqYXhCZWZvcmVTZW5kJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFqYXhDb21wbGV0ZSBldmVudCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgY29tcGxldGluZyBhbiBBSkFYIHJlcXVlc3QgZm9yIEFKQVgtYmFzZWQgdmFsaWRhdGlvbi5cbiAgICAgICAgICogVGhlIHNpZ25hdHVyZSBvZiB0aGUgZXZlbnQgaGFuZGxlciBzaG91bGQgYmU6XG4gICAgICAgICAqICAgICBmdW5jdGlvbiAoZXZlbnQsIGpxWEhSLCB0ZXh0U3RhdHVzKVxuICAgICAgICAgKiB3aGVyZVxuICAgICAgICAgKiAgLSBldmVudDogYW4gRXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiAgLSBqcVhIUjogYSBqcVhIUiBvYmplY3RcbiAgICAgICAgICogIC0gdGV4dFN0YXR1czogdGhlIHN0YXR1cyBvZiB0aGUgcmVxdWVzdCAoXCJzdWNjZXNzXCIsIFwibm90bW9kaWZpZWRcIiwgXCJlcnJvclwiLCBcInRpbWVvdXRcIiwgXCJhYm9ydFwiLCBvciBcInBhcnNlcmVycm9yXCIpLlxuICAgICAgICAgKi9cbiAgICAgICAgYWpheENvbXBsZXRlOiAnYWpheENvbXBsZXRlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFmdGVySW5pdCBldmVudCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgeWlpIGFjdGl2ZUZvcm0gaW5pdC5cbiAgICAgICAgICogVGhlIHNpZ25hdHVyZSBvZiB0aGUgZXZlbnQgaGFuZGxlciBzaG91bGQgYmU6XG4gICAgICAgICAqICAgICBmdW5jdGlvbiAoZXZlbnQpXG4gICAgICAgICAqIHdoZXJlXG4gICAgICAgICAqICAtIGV2ZW50OiBhbiBFdmVudCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBhZnRlckluaXQ6ICdhZnRlckluaXQnXG4gICAgfTtcblxuICAgIC8vIE5PVEU6IElmIHlvdSBjaGFuZ2UgYW55IG9mIHRoZXNlIGRlZmF1bHRzLCBtYWtlIHN1cmUgeW91IHVwZGF0ZSB5aWlcXHdpZGdldHNcXEFjdGl2ZUZvcm06OmdldENsaWVudE9wdGlvbnMoKSBhcyB3ZWxsXG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAvLyB3aGV0aGVyIHRvIGVuY29kZSB0aGUgZXJyb3Igc3VtbWFyeVxuICAgICAgICBlbmNvZGVFcnJvclN1bW1hcnk6IHRydWUsXG4gICAgICAgIC8vIHRoZSBqUXVlcnkgc2VsZWN0b3IgZm9yIHRoZSBlcnJvciBzdW1tYXJ5XG4gICAgICAgIGVycm9yU3VtbWFyeTogJy5lcnJvci1zdW1tYXJ5JyxcbiAgICAgICAgLy8gd2hldGhlciB0byBwZXJmb3JtIHZhbGlkYXRpb24gYmVmb3JlIHN1Ym1pdHRpbmcgdGhlIGZvcm0uXG4gICAgICAgIHZhbGlkYXRlT25TdWJtaXQ6IHRydWUsXG4gICAgICAgIC8vIHRoZSBjb250YWluZXIgQ1NTIGNsYXNzIHJlcHJlc2VudGluZyB0aGUgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGUgaGFzIHZhbGlkYXRpb24gZXJyb3JcbiAgICAgICAgZXJyb3JDc3NDbGFzczogJ2hhcy1lcnJvcicsXG4gICAgICAgIC8vIHRoZSBjb250YWluZXIgQ1NTIGNsYXNzIHJlcHJlc2VudGluZyB0aGUgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGUgcGFzc2VzIHZhbGlkYXRpb25cbiAgICAgICAgc3VjY2Vzc0Nzc0NsYXNzOiAnaGFzLXN1Y2Nlc3MnLFxuICAgICAgICAvLyB0aGUgY29udGFpbmVyIENTUyBjbGFzcyByZXByZXNlbnRpbmcgdGhlIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlIGlzIGJlaW5nIHZhbGlkYXRlZFxuICAgICAgICB2YWxpZGF0aW5nQ3NzQ2xhc3M6ICd2YWxpZGF0aW5nJyxcbiAgICAgICAgLy8gdGhlIEdFVCBwYXJhbWV0ZXIgbmFtZSBpbmRpY2F0aW5nIGFuIEFKQVgtYmFzZWQgdmFsaWRhdGlvblxuICAgICAgICBhamF4UGFyYW06ICdhamF4JyxcbiAgICAgICAgLy8gdGhlIHR5cGUgb2YgZGF0YSB0aGF0IHlvdSdyZSBleHBlY3RpbmcgYmFjayBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgICAgYWpheERhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIC8vIHRoZSBVUkwgZm9yIHBlcmZvcm1pbmcgQUpBWC1iYXNlZCB2YWxpZGF0aW9uLiBJZiBub3Qgc2V0LCBpdCB3aWxsIHVzZSB0aGUgdGhlIGZvcm0ncyBhY3Rpb25cbiAgICAgICAgdmFsaWRhdGlvblVybDogdW5kZWZpbmVkLFxuICAgICAgICAvLyB3aGV0aGVyIHRvIHNjcm9sbCB0byBmaXJzdCB2aXNpYmxlIGVycm9yIGFmdGVyIHZhbGlkYXRpb24uXG4gICAgICAgIHNjcm9sbFRvRXJyb3I6IHRydWUsXG4gICAgICAgIC8vIG9mZnNldCBpbiBwaXhlbHMgdGhhdCBzaG91bGQgYmUgYWRkZWQgd2hlbiBzY3JvbGxpbmcgdG8gdGhlIGZpcnN0IGVycm9yLlxuICAgICAgICBzY3JvbGxUb0Vycm9yT2Zmc2V0OiAwLFxuICAgICAgICAvLyB3aGVyZSB0byBhZGQgdmFsaWRhdGlvbiBjbGFzczogY29udGFpbmVyIG9yIGlucHV0XG4gICAgICAgIHZhbGlkYXRpb25TdGF0ZU9uOiAnY29udGFpbmVyJ1xuICAgIH07XG5cbiAgICAvLyBOT1RFOiBJZiB5b3UgY2hhbmdlIGFueSBvZiB0aGVzZSBkZWZhdWx0cywgbWFrZSBzdXJlIHlvdSB1cGRhdGUgeWlpXFx3aWRnZXRzXFxBY3RpdmVGaWVsZDo6Z2V0Q2xpZW50T3B0aW9ucygpIGFzIHdlbGxcbiAgICB2YXIgYXR0cmlidXRlRGVmYXVsdHMgPSB7XG4gICAgICAgIC8vIGEgdW5pcXVlIElEIGlkZW50aWZ5aW5nIGFuIGF0dHJpYnV0ZSAoZS5nLiBcImxvZ2luZm9ybS11c2VybmFtZVwiKSBpbiBhIGZvcm1cbiAgICAgICAgaWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gYXR0cmlidXRlIG5hbWUgb3IgZXhwcmVzc2lvbiAoZS5nLiBcIlswXWNvbnRlbnRcIiBmb3IgdGFidWxhciBpbnB1dClcbiAgICAgICAgbmFtZTogdW5kZWZpbmVkLFxuICAgICAgICAvLyB0aGUgalF1ZXJ5IHNlbGVjdG9yIG9mIHRoZSBjb250YWluZXIgb2YgdGhlIGlucHV0IGZpZWxkXG4gICAgICAgIGNvbnRhaW5lcjogdW5kZWZpbmVkLFxuICAgICAgICAvLyB0aGUgalF1ZXJ5IHNlbGVjdG9yIG9mIHRoZSBpbnB1dCBmaWVsZCB1bmRlciB0aGUgY29udGV4dCBvZiB0aGUgZm9ybVxuICAgICAgICBpbnB1dDogdW5kZWZpbmVkLFxuICAgICAgICAvLyB0aGUgalF1ZXJ5IHNlbGVjdG9yIG9mIHRoZSBlcnJvciB0YWcgdW5kZXIgdGhlIGNvbnRleHQgb2YgdGhlIGNvbnRhaW5lclxuICAgICAgICBlcnJvcjogJy5oZWxwLWJsb2NrJyxcbiAgICAgICAgLy8gd2hldGhlciB0byBlbmNvZGUgdGhlIGVycm9yXG4gICAgICAgIGVuY29kZUVycm9yOiB0cnVlLFxuICAgICAgICAvLyB3aGV0aGVyIHRvIHBlcmZvcm0gdmFsaWRhdGlvbiB3aGVuIGEgY2hhbmdlIGlzIGRldGVjdGVkIG9uIHRoZSBpbnB1dFxuICAgICAgICB2YWxpZGF0ZU9uQ2hhbmdlOiB0cnVlLFxuICAgICAgICAvLyB3aGV0aGVyIHRvIHBlcmZvcm0gdmFsaWRhdGlvbiB3aGVuIHRoZSBpbnB1dCBsb3NlcyBmb2N1c1xuICAgICAgICB2YWxpZGF0ZU9uQmx1cjogdHJ1ZSxcbiAgICAgICAgLy8gd2hldGhlciB0byBwZXJmb3JtIHZhbGlkYXRpb24gd2hlbiB0aGUgdXNlciBpcyB0eXBpbmcuXG4gICAgICAgIHZhbGlkYXRlT25UeXBlOiBmYWxzZSxcbiAgICAgICAgLy8gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IHRoZSB2YWxpZGF0aW9uIHNob3VsZCBiZSBkZWxheWVkIHdoZW4gYSB1c2VyIGlzIHR5cGluZyBpbiB0aGUgaW5wdXQgZmllbGQuXG4gICAgICAgIHZhbGlkYXRpb25EZWxheTogNTAwLFxuICAgICAgICAvLyB3aGV0aGVyIHRvIGVuYWJsZSBBSkFYLWJhc2VkIHZhbGlkYXRpb24uXG4gICAgICAgIGVuYWJsZUFqYXhWYWxpZGF0aW9uOiBmYWxzZSxcbiAgICAgICAgLy8gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgdmFsdWUsIG1lc3NhZ2VzLCBkZWZlcnJlZCwgJGZvcm0pLCB0aGUgY2xpZW50LXNpZGUgdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAgICAgICAgdmFsaWRhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gc3RhdHVzIG9mIHRoZSBpbnB1dCBmaWVsZCwgMDogZW1wdHksIG5vdCBlbnRlcmVkIGJlZm9yZSwgMTogdmFsaWRhdGVkLCAyOiBwZW5kaW5nIHZhbGlkYXRpb24sIDM6IHZhbGlkYXRpbmdcbiAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICAvLyB3aGV0aGVyIHRoZSB2YWxpZGF0aW9uIGlzIGNhbmNlbGxlZCBieSBiZWZvcmVWYWxpZGF0ZUF0dHJpYnV0ZSBldmVudCBoYW5kbGVyXG4gICAgICAgIGNhbmNlbGxlZDogZmFsc2UsXG4gICAgICAgIC8vIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXRcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gd2hldGhlciB0byB1cGRhdGUgYXJpYS1pbnZhbGlkIGF0dHJpYnV0ZSBhZnRlciB2YWxpZGF0aW9uXG4gICAgICAgIHVwZGF0ZUFyaWFJbnZhbGlkOiB0cnVlXG4gICAgfTtcblxuXG4gICAgdmFyIHN1Ym1pdERlZmVyO1xuXG4gICAgdmFyIHNldFN1Ym1pdEZpbmFsaXplRGVmZXIgPSBmdW5jdGlvbigkZm9ybSkge1xuICAgICAgICBzdWJtaXREZWZlciA9ICQuRGVmZXJyZWQoKTtcbiAgICAgICAgJGZvcm0uZGF0YSgneWlpU3VibWl0RmluYWxpemVQcm9taXNlJywgc3VibWl0RGVmZXIucHJvbWlzZSgpKTtcbiAgICB9O1xuXG4gICAgLy8gZmluYWxpemUgeWlpLmpzICRmb3JtLnN1Ym1pdFxuICAgIHZhciBzdWJtaXRGaW5hbGl6ZSA9IGZ1bmN0aW9uKCRmb3JtKSB7XG4gICAgICAgIGlmKHN1Ym1pdERlZmVyKSB7XG4gICAgICAgICAgICBzdWJtaXREZWZlci5yZXNvbHZlKCk7XG4gICAgICAgICAgICBzdWJtaXREZWZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICRmb3JtLnJlbW92ZURhdGEoJ3lpaVN1Ym1pdEZpbmFsaXplUHJvbWlzZScpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgdmFyIG1ldGhvZHMgPSB7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgJGZvcm0gPSAkKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICgkZm9ybS5kYXRhKCd5aWlBY3RpdmVGb3JtJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnZhbGlkYXRpb25VcmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy52YWxpZGF0aW9uVXJsID0gJGZvcm0uYXR0cignYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJC5lYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbaV0gPSAkLmV4dGVuZCh7dmFsdWU6IGdldFZhbHVlKCRmb3JtLCB0aGlzKX0sIGF0dHJpYnV0ZURlZmF1bHRzLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hBdHRyaWJ1dGUoJGZvcm0sIGF0dHJpYnV0ZXNbaV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgJGZvcm0uZGF0YSgneWlpQWN0aXZlRm9ybScsIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6IHNldHRpbmdzLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICBzdWJtaXR0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogZ2V0Rm9ybU9wdGlvbnMoJGZvcm0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDbGVhbiB1cCBlcnJvciBzdGF0dXMgd2hlbiB0aGUgZm9ybSBpcyByZXNldC5cbiAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgJGZvcm0ub24oJ3Jlc2V0JywgLi4uKSBkb2VzIHdvcmsgYmVjYXVzZSB0aGUgXCJyZXNldFwiIGV2ZW50IGRvZXMgbm90IGJ1YmJsZSBvbiBJRS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAkZm9ybS5vbigncmVzZXQueWlpQWN0aXZlRm9ybScsIG1ldGhvZHMucmVzZXRGb3JtKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy52YWxpZGF0ZU9uU3VibWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICRmb3JtLm9uKCdtb3VzZXVwLnlpaUFjdGl2ZUZvcm0ga2V5dXAueWlpQWN0aXZlRm9ybScsICc6c3VibWl0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGZvcm0uZGF0YSgneWlpQWN0aXZlRm9ybScpLnN1Ym1pdE9iamVjdCA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAkZm9ybS5vbignc3VibWl0LnlpaUFjdGl2ZUZvcm0nLCBtZXRob2RzLnN1Ym1pdEZvcm0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSAkLkV2ZW50KGV2ZW50cy5hZnRlckluaXQpO1xuICAgICAgICAgICAgICAgICRmb3JtLnRyaWdnZXIoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gYWRkIGEgbmV3IGF0dHJpYnV0ZSB0byB0aGUgZm9ybSBkeW5hbWljYWxseS5cbiAgICAgICAgLy8gcGxlYXNlIHJlZmVyIHRvIGF0dHJpYnV0ZURlZmF1bHRzIGZvciB0aGUgc3RydWN0dXJlIG9mIGF0dHJpYnV0ZVxuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHZhciAkZm9ybSA9ICQodGhpcyk7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgPSAkLmV4dGVuZCh7dmFsdWU6IGdldFZhbHVlKCRmb3JtLCBhdHRyaWJ1dGUpfSwgYXR0cmlidXRlRGVmYXVsdHMsIGF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAkZm9ybS5kYXRhKCd5aWlBY3RpdmVGb3JtJykuYXR0cmlidXRlcy5wdXNoKGF0dHJpYnV0ZSk7XG4gICAgICAgICAgICB3YXRjaEF0dHJpYnV0ZSgkZm9ybSwgYXR0cmlidXRlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyByZW1vdmUgdGhlIGF0dHJpYnV0ZSB3aXRoIHRoZSBzcGVjaWZpZWQgSUQgZnJvbSB0aGUgZm9ybVxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgdmFyICRmb3JtID0gJCh0aGlzKSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gJGZvcm0uZGF0YSgneWlpQWN0aXZlRm9ybScpLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAkLmVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlc1tpXVsnaWQnXSA9PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHVud2F0Y2hBdHRyaWJ1dGUoJGZvcm0sIGF0dHJpYnV0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbWFudWFsbHkgdHJpZ2dlciB0aGUgdmFsaWRhdGlvbiBvZiB0aGUgYXR0cmlidXRlIHdpdGggdGhlIHNwZWNpZmllZCBJRFxuICAgICAgICB2YWxpZGF0ZUF0dHJpYnV0ZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gbWV0aG9kcy5maW5kLmNhbGwodGhpcywgaWQpO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUF0dHJpYnV0ZSgkKHRoaXMpLCBhdHRyaWJ1dGUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGZpbmQgYW4gYXR0cmlidXRlIGNvbmZpZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGF0dHJpYnV0ZSBJRFxuICAgICAgICBmaW5kOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gJCh0aGlzKS5kYXRhKCd5aWlBY3RpdmVGb3JtJykuYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAkLmVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlc1tpXVsnaWQnXSA9PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICQodGhpcykub2ZmKCcueWlpQWN0aXZlRm9ybScpO1xuICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlRGF0YSgneWlpQWN0aXZlRm9ybScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgneWlpQWN0aXZlRm9ybScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHZhbGlkYXRlIGFsbCBhcHBsaWNhYmxlIGlucHV0cyBpbiB0aGUgZm9ybVxuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKGZvcmNlVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZVZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5kYXRhKCd5aWlBY3RpdmVGb3JtJykuc3VibWl0dGluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciAkZm9ybSA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgZGF0YSA9ICRmb3JtLmRhdGEoJ3lpaUFjdGl2ZUZvcm0nKSxcbiAgICAgICAgICAgICAgICBuZWVkQWpheFZhbGlkYXRpb24gPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlcyA9IHt9LFxuICAgICAgICAgICAgICAgIGRlZmVycmVkcyA9IGRlZmVycmVkQXJyYXkoKSxcbiAgICAgICAgICAgICAgICBzdWJtaXR0aW5nID0gZGF0YS5zdWJtaXR0aW5nO1xuXG4gICAgICAgICAgICBpZiAoc3VibWl0dGluZykge1xuICAgICAgICAgICAgICAgIHZhciBldmVudCA9ICQuRXZlbnQoZXZlbnRzLmJlZm9yZVZhbGlkYXRlKTtcbiAgICAgICAgICAgICAgICAkZm9ybS50cmlnZ2VyKGV2ZW50LCBbbWVzc2FnZXMsIGRlZmVycmVkc10pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zdWJtaXR0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHN1Ym1pdEZpbmFsaXplKCRmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2xpZW50LXNpZGUgdmFsaWRhdGlvblxuICAgICAgICAgICAgJC5lYWNoKGRhdGEuYXR0cmlidXRlcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGZvcm0gPSAkZm9ybTtcbiAgICAgICAgICAgICAgICB2YXIgJGlucHV0ID0gZmluZElucHV0KCRmb3JtLCB0aGlzKTtcblxuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQuaXMoXCI6ZGlzYWJsZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHBhc3MgU0VMRUNUIHdpdGhvdXQgb3B0aW9uc1xuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQubGVuZ3RoICYmICRpbnB1dFswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghJGlucHV0WzBdLm9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoJGlucHV0WzBdLm9wdGlvbnMubGVuZ3RoID09PSAxKSAmJiAoJGlucHV0WzBdLm9wdGlvbnNbMF0udmFsdWUgPT09ICcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBwZXJmb3JtIHZhbGlkYXRpb24gb25seSBpZiB0aGUgZm9ybSBpcyBiZWluZyBzdWJtaXR0ZWQgb3IgaWYgYW4gYXR0cmlidXRlIGlzIHBlbmRpbmcgdmFsaWRhdGlvblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnN1Ym1pdHRpbmcgfHwgdGhpcy5zdGF0dXMgPT09IDIgfHwgdGhpcy5zdGF0dXMgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IG1lc3NhZ2VzW3RoaXMuaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXNnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNbdGhpcy5pZF0gPSBtc2c7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSAkLkV2ZW50KGV2ZW50cy5iZWZvcmVWYWxpZGF0ZUF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICAgICRmb3JtLnRyaWdnZXIoZXZlbnQsIFt0aGlzLCBtc2csIGRlZmVycmVkc10pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQucmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlKHRoaXMsIGdldFZhbHVlKCRmb3JtLCB0aGlzKSwgbXNnLCBkZWZlcnJlZHMsICRmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZUFqYXhWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZEFqYXhWYWxpZGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBhamF4IHZhbGlkYXRpb25cbiAgICAgICAgICAgICQud2hlbi5hcHBseSh0aGlzLCBkZWZlcnJlZHMpLmFsd2F5cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZW1wdHkgbWVzc2FnZSBhcnJheXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBtZXNzYWdlc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXNzYWdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmVlZEFqYXhWYWxpZGF0aW9uICYmICgkLmlzRW1wdHlPYmplY3QobWVzc2FnZXMpIHx8IGRhdGEuc3VibWl0dGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRidXR0b24gPSBkYXRhLnN1Ym1pdE9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dERhdGEgPSAnJicgKyBkYXRhLnNldHRpbmdzLmFqYXhQYXJhbSArICc9JyArICRmb3JtLmF0dHIoJ2lkJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkYnV0dG9uICYmICRidXR0b24ubGVuZ3RoICYmICRidXR0b24uYXR0cignbmFtZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHREYXRhICs9ICcmJyArICRidXR0b24uYXR0cignbmFtZScpICsgJz0nICsgJGJ1dHRvbi5hdHRyKCd2YWx1ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGRhdGEuc2V0dGluZ3MudmFsaWRhdGlvblVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICRmb3JtLmF0dHIoJ21ldGhvZCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogJGZvcm0uc2VyaWFsaXplKCkgKyBleHREYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6IGRhdGEuc2V0dGluZ3MuYWpheERhdGFUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uIChqcVhIUiwgdGV4dFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRmb3JtLnRyaWdnZXIoZXZlbnRzLmFqYXhDb21wbGV0ZSwgW2pxWEhSLCB0ZXh0U3RhdHVzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24gKGpxWEhSLCBzZXR0aW5ncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRmb3JtLnRyaWdnZXIoZXZlbnRzLmFqYXhCZWZvcmVTZW5kLCBbanFYSFIsIHNldHRpbmdzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKG1zZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobXNncyAhPT0gbnVsbCAmJiB0eXBlb2YgbXNncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGRhdGEuYXR0cmlidXRlcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVuYWJsZUFqYXhWYWxpZGF0aW9uIHx8IHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1zZ3NbdGhpcy5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVJbnB1dHMoJGZvcm0sICQuZXh0ZW5kKG1lc3NhZ2VzLCBtc2dzKSwgc3VibWl0dGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSW5wdXRzKCRmb3JtLCBtZXNzYWdlcywgc3VibWl0dGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zdWJtaXR0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VibWl0RmluYWxpemUoJGZvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEuc3VibWl0dGluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWxheSBjYWxsYmFjayBzbyB0aGF0IHRoZSBmb3JtIGNhbiBiZSBzdWJtaXR0ZWQgd2l0aG91dCBwcm9ibGVtXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUlucHV0cygkZm9ybSwgbWVzc2FnZXMsIHN1Ym1pdHRpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUlucHV0cygkZm9ybSwgbWVzc2FnZXMsIHN1Ym1pdHRpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN1Ym1pdEZvcm06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAkZm9ybSA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgZGF0YSA9ICRmb3JtLmRhdGEoJ3lpaUFjdGl2ZUZvcm0nKTtcbiAgICAgICAgICAgIGlmIChkYXRhLnZhbGlkYXRlZCkge1xuICAgICAgICAgICAgICAgIC8vIFNlY29uZCBzdWJtaXQncyBjYWxsIChmcm9tIHZhbGlkYXRlL3VwZGF0ZUlucHV0cylcbiAgICAgICAgICAgICAgICBkYXRhLnN1Ym1pdHRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSAkLkV2ZW50KGV2ZW50cy5iZWZvcmVTdWJtaXQpO1xuICAgICAgICAgICAgICAgICRmb3JtLnRyaWdnZXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHN1Ym1pdEZpbmFsaXplKCRmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVIaWRkZW5CdXR0b24oJGZvcm0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAgIC8vIGNvbnRpbnVlIHN1Ym1pdHRpbmcgdGhlIGZvcm0gc2luY2UgdmFsaWRhdGlvbiBwYXNzZXNcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRmlyc3Qgc3VibWl0J3MgY2FsbCAoZnJvbSB5aWkuanMvaGFuZGxlQWN0aW9uKSAtIGV4ZWN1dGUgdmFsaWRhdGluZ1xuICAgICAgICAgICAgICAgIHNldFN1Ym1pdEZpbmFsaXplRGVmZXIoJGZvcm0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc2V0dGluZ3MudGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZGF0YS5zZXR0aW5ncy50aW1lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGEuc3VibWl0dGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWV0aG9kcy52YWxpZGF0ZS5jYWxsKCRmb3JtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzZXRGb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJGZvcm0gPSAkKHRoaXMpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSAkZm9ybS5kYXRhKCd5aWlBY3RpdmVGb3JtJyk7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIHdlIGJpbmQgZGlyZWN0bHkgdG8gYSBmb3JtIHJlc2V0IGV2ZW50IGluc3RlYWQgb2YgYSByZXNldCBidXR0b24gKHRoYXQgbWF5IG5vdCBleGlzdCksXG4gICAgICAgICAgICAvLyB3aGVuIHRoaXMgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgZm9ybSBpbnB1dCB2YWx1ZXMgaGF2ZSBub3QgYmVlbiByZXNldCB5ZXQuXG4gICAgICAgICAgICAvLyBUaGVyZWZvcmUgd2UgZG8gdGhlIGFjdHVhbCByZXNldCB3b3JrIHRocm91Z2ggc2V0VGltZW91dC5cbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkLmVhY2goZGF0YS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdpdGhvdXQgc2V0VGltZW91dCgpIHdlIHdvdWxkIGdldCB0aGUgaW5wdXQgdmFsdWVzIHRoYXQgYXJlIG5vdCByZXNldCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBnZXRWYWx1ZSgkZm9ybSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRjb250YWluZXIgPSAkZm9ybS5maW5kKHRoaXMuY29udGFpbmVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICRpbnB1dCA9IGZpbmRJbnB1dCgkZm9ybSwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAkZXJyb3JFbGVtZW50ID0gZGF0YS5zZXR0aW5ncy52YWxpZGF0aW9uU3RhdGVPbiA9PT0gJ2lucHV0JyA/ICRpbnB1dCA6ICRjb250YWluZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgJGVycm9yRWxlbWVudC5yZW1vdmVDbGFzcyhcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldHRpbmdzLnZhbGlkYXRpbmdDc3NDbGFzcyArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXR0aW5ncy5lcnJvckNzc0NsYXNzICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldHRpbmdzLnN1Y2Nlc3NDc3NDbGFzc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAkY29udGFpbmVyLmZpbmQodGhpcy5lcnJvcikuaHRtbCgnJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgJGZvcm0uZmluZChkYXRhLnNldHRpbmdzLmVycm9yU3VtbWFyeSkuaGlkZSgpLmZpbmQoJ3VsJykuaHRtbCgnJyk7XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyBlcnJvciBtZXNzYWdlcywgaW5wdXQgY29udGFpbmVycywgYW5kIG9wdGlvbmFsbHkgc3VtbWFyeSBhcyB3ZWxsLlxuICAgICAgICAgKiBJZiBhbiBhdHRyaWJ1dGUgaXMgbWlzc2luZyBmcm9tIG1lc3NhZ2VzLCBpdCBpcyBjb25zaWRlcmVkIHZhbGlkLlxuICAgICAgICAgKiBAcGFyYW0gbWVzc2FnZXMgYXJyYXkgdGhlIHZhbGlkYXRpb24gZXJyb3IgbWVzc2FnZXMsIGluZGV4ZWQgYnkgYXR0cmlidXRlIElEc1xuICAgICAgICAgKiBAcGFyYW0gc3VtbWFyeSB3aGV0aGVyIHRvIHVwZGF0ZSBzdW1tYXJ5IGFzIHdlbGwuXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVNZXNzYWdlczogZnVuY3Rpb24gKG1lc3NhZ2VzLCBzdW1tYXJ5KSB7XG4gICAgICAgICAgICB2YXIgJGZvcm0gPSAkKHRoaXMpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSAkZm9ybS5kYXRhKCd5aWlBY3RpdmVGb3JtJyk7XG4gICAgICAgICAgICAkLmVhY2goZGF0YS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlSW5wdXQoJGZvcm0sIHRoaXMsIG1lc3NhZ2VzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVTdW1tYXJ5KCRmb3JtLCBtZXNzYWdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgZXJyb3IgbWVzc2FnZXMgYW5kIGlucHV0IGNvbnRhaW5lciBvZiBhIHNpbmdsZSBhdHRyaWJ1dGUuXG4gICAgICAgICAqIElmIG1lc3NhZ2VzIGlzIGVtcHR5LCB0aGUgYXR0cmlidXRlIGlzIGNvbnNpZGVyZWQgdmFsaWQuXG4gICAgICAgICAqIEBwYXJhbSBpZCBhdHRyaWJ1dGUgSURcbiAgICAgICAgICogQHBhcmFtIG1lc3NhZ2VzIGFycmF5IHdpdGggZXJyb3IgbWVzc2FnZXNcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZUF0dHJpYnV0ZTogZnVuY3Rpb24oaWQsIG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gbWV0aG9kcy5maW5kLmNhbGwodGhpcywgaWQpO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0ge307XG4gICAgICAgICAgICAgICAgbXNnW2lkXSA9IG1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUlucHV0KCQodGhpcyksIGF0dHJpYnV0ZSwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgd2F0Y2hBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoJGZvcm0sIGF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgJGlucHV0ID0gZmluZElucHV0KCRmb3JtLCBhdHRyaWJ1dGUpO1xuICAgICAgICBpZiAoYXR0cmlidXRlLnZhbGlkYXRlT25DaGFuZ2UpIHtcbiAgICAgICAgICAgICRpbnB1dC5vbignY2hhbmdlLnlpaUFjdGl2ZUZvcm0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVBdHRyaWJ1dGUoJGZvcm0sIGF0dHJpYnV0ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZS52YWxpZGF0ZU9uQmx1cikge1xuICAgICAgICAgICAgJGlucHV0Lm9uKCdibHVyLnlpaUFjdGl2ZUZvcm0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5zdGF0dXMgPT0gMCB8fCBhdHRyaWJ1dGUuc3RhdHVzID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBdHRyaWJ1dGUoJGZvcm0sIGF0dHJpYnV0ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZS52YWxpZGF0ZU9uVHlwZSkge1xuICAgICAgICAgICAgJGlucHV0Lm9uKCdrZXl1cC55aWlBY3RpdmVGb3JtJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KGUud2hpY2gsIFsxNiwgMTcsIDE4LCAzNywgMzgsIDM5LCA0MF0pICE9PSAtMSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlLnZhbHVlICE9PSBnZXRWYWx1ZSgkZm9ybSwgYXR0cmlidXRlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUF0dHJpYnV0ZSgkZm9ybSwgYXR0cmlidXRlLCBmYWxzZSwgYXR0cmlidXRlLnZhbGlkYXRpb25EZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHVud2F0Y2hBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoJGZvcm0sIGF0dHJpYnV0ZSkge1xuICAgICAgICBmaW5kSW5wdXQoJGZvcm0sIGF0dHJpYnV0ZSkub2ZmKCcueWlpQWN0aXZlRm9ybScpO1xuICAgIH07XG5cbiAgICB2YXIgdmFsaWRhdGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoJGZvcm0sIGF0dHJpYnV0ZSwgZm9yY2VWYWxpZGF0ZSwgdmFsaWRhdGlvbkRlbGF5KSB7XG4gICAgICAgIHZhciBkYXRhID0gJGZvcm0uZGF0YSgneWlpQWN0aXZlRm9ybScpO1xuXG4gICAgICAgIGlmIChmb3JjZVZhbGlkYXRlKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGUuc3RhdHVzID0gMjtcbiAgICAgICAgfVxuICAgICAgICAkLmVhY2goZGF0YS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWlzRXF1YWwodGhpcy52YWx1ZSwgZ2V0VmFsdWUoJGZvcm0sIHRoaXMpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gMjtcbiAgICAgICAgICAgICAgICBmb3JjZVZhbGlkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZm9yY2VWYWxpZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEuc2V0dGluZ3MudGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRhdGEuc2V0dGluZ3MudGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEuc2V0dGluZ3MudGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5zdWJtaXR0aW5nIHx8ICRmb3JtLmlzKCc6aGlkZGVuJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkLmVhY2goZGF0YS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gMztcbiAgICAgICAgICAgICAgICAgICAgJGZvcm0uZmluZCh0aGlzLmNvbnRhaW5lcikuYWRkQ2xhc3MoZGF0YS5zZXR0aW5ncy52YWxpZGF0aW5nQ3NzQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWV0aG9kcy52YWxpZGF0ZS5jYWxsKCRmb3JtKTtcbiAgICAgICAgfSwgdmFsaWRhdGlvbkRlbGF5ID8gdmFsaWRhdGlvbkRlbGF5IDogMjAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdHdvIHZhbHVlIHdoYXRldmVyIGl0IG9iamVjdHMsIGFycmF5cyBvciBzaW1wbGUgdHlwZXNcbiAgICAgKiBAcGFyYW0gdmFsMVxuICAgICAqIEBwYXJhbSB2YWwyXG4gICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAqL1xuICAgIHZhciBpc0VxdWFsID0gZnVuY3Rpb24odmFsMSwgdmFsMikge1xuICAgICAgICAvLyBvYmplY3RzXG4gICAgICAgIGlmICh2YWwxIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaXNPYmplY3RzRXF1YWwodmFsMSwgdmFsMilcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFycmF5c1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwxKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXlzRXF1YWwodmFsMSwgdmFsMik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaW1wbGUgdHlwZXNcbiAgICAgICAgcmV0dXJuIHZhbDEgPT09IHZhbDI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHR3byBvYmplY3RzXG4gICAgICogQHBhcmFtIG9iajFcbiAgICAgKiBAcGFyYW0gb2JqMlxuICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgKi9cbiAgICB2YXIgaXNPYmplY3RzRXF1YWwgPSBmdW5jdGlvbihvYmoxLCBvYmoyKSB7XG4gICAgICAgIGlmICghKG9iajEgaW5zdGFuY2VvZiBPYmplY3QpIHx8ICEob2JqMiBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuICAgICAgICB2YXIga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcbiAgICAgICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMxLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIW9iajIuaGFzT3duUHJvcGVydHkoa2V5czFbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iajFba2V5czFbaV1dICE9PSBvYmoyW2tleXMxW2ldXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0d28gYXJyYXlzXG4gICAgICogQHBhcmFtIGFycjFcbiAgICAgKiBAcGFyYW0gYXJyMlxuICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheXNFcXVhbCA9IGZ1bmN0aW9uKGFycjEsIGFycjIpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycjEpIHx8ICFBcnJheS5pc0FycmF5KGFycjIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBwcm90b3R5cGUgd2l0aCBhIHNob3J0Y3V0IG1ldGhvZCBmb3IgYWRkaW5nIGEgbmV3IGRlZmVycmVkLlxuICAgICAqIFRoZSBjb250ZXh0IG9mIHRoZSBjYWxsYmFjayB3aWxsIGJlIHRoZSBkZWZlcnJlZCBvYmplY3Qgc28gaXQgY2FuIGJlIHJlc29sdmVkIGxpa2UgYGBgdGhpcy5yZXNvbHZlKClgYGBcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqL1xuICAgIHZhciBkZWZlcnJlZEFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgYXJyYXkuYWRkID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucHVzaChuZXcgJC5EZWZlcnJlZChjYWxsYmFjaykpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfTtcblxuICAgIHZhciBidXR0b25PcHRpb25zID0gWydhY3Rpb24nLCAndGFyZ2V0JywgJ21ldGhvZCcsICdlbmN0eXBlJ107XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGN1cnJlbnQgZm9ybSBvcHRpb25zXG4gICAgICogQHBhcmFtICRmb3JtXG4gICAgICogQHJldHVybnMgb2JqZWN0IE9iamVjdCB3aXRoIGJ1dHRvbiBvZiBmb3JtIG9wdGlvbnNcbiAgICAgKi9cbiAgICB2YXIgZ2V0Rm9ybU9wdGlvbnMgPSBmdW5jdGlvbiAoJGZvcm0pIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidXR0b25PcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzW2J1dHRvbk9wdGlvbnNbaV1dID0gJGZvcm0uYXR0cihidXR0b25PcHRpb25zW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRlbXBvcmFyeSBmb3JtIG9wdGlvbnMgcmVsYXRlZCB0byBzdWJtaXQgYnV0dG9uXG4gICAgICogQHBhcmFtICRmb3JtIHRoZSBmb3JtIGpRdWVyeSBvYmplY3RcbiAgICAgKiBAcGFyYW0gJGJ1dHRvbiB0aGUgYnV0dG9uIGpRdWVyeSBvYmplY3RcbiAgICAgKi9cbiAgICB2YXIgYXBwbHlCdXR0b25PcHRpb25zID0gZnVuY3Rpb24gKCRmb3JtLCAkYnV0dG9uKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnV0dG9uT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gJGJ1dHRvbi5hdHRyKCdmb3JtJyArIGJ1dHRvbk9wdGlvbnNbaV0pO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgJGZvcm0uYXR0cihidXR0b25PcHRpb25zW2ldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgb3JpZ2luYWwgZm9ybSBvcHRpb25zXG4gICAgICogQHBhcmFtICRmb3JtIHRoZSBmb3JtIGpRdWVyeSBvYmplY3RcbiAgICAgKi9cbiAgICB2YXIgcmVzdG9yZUJ1dHRvbk9wdGlvbnMgPSBmdW5jdGlvbiAoJGZvcm0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSAkZm9ybS5kYXRhKCd5aWlBY3RpdmVGb3JtJyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidXR0b25PcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAkZm9ybS5hdHRyKGJ1dHRvbk9wdGlvbnNbaV0sIGRhdGEub3B0aW9uc1tidXR0b25PcHRpb25zW2ldXSB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBlcnJvciBtZXNzYWdlcyBhbmQgdGhlIGlucHV0IGNvbnRhaW5lcnMgZm9yIGFsbCBhcHBsaWNhYmxlIGF0dHJpYnV0ZXNcbiAgICAgKiBAcGFyYW0gJGZvcm0gdGhlIGZvcm0galF1ZXJ5IG9iamVjdFxuICAgICAqIEBwYXJhbSBtZXNzYWdlcyBhcnJheSB0aGUgdmFsaWRhdGlvbiBlcnJvciBtZXNzYWdlc1xuICAgICAqIEBwYXJhbSBzdWJtaXR0aW5nIHdoZXRoZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGFmdGVyIHZhbGlkYXRpb24gdHJpZ2dlcmVkIGJ5IGZvcm0gc3VibWlzc2lvblxuICAgICAqL1xuICAgIHZhciB1cGRhdGVJbnB1dHMgPSBmdW5jdGlvbiAoJGZvcm0sIG1lc3NhZ2VzLCBzdWJtaXR0aW5nKSB7XG4gICAgICAgIHZhciBkYXRhID0gJGZvcm0uZGF0YSgneWlpQWN0aXZlRm9ybScpO1xuXG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlcnJvckF0dHJpYnV0ZXMgPSBbXSwgJGlucHV0O1xuICAgICAgICAkLmVhY2goZGF0YS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaGFzRXJyb3IgPSAoc3VibWl0dGluZyAmJiB1cGRhdGVJbnB1dCgkZm9ybSwgdGhpcywgbWVzc2FnZXMpKSB8fCAoIXN1Ym1pdHRpbmcgJiYgYXR0ckhhc0Vycm9yKCRmb3JtLCB0aGlzLCBtZXNzYWdlcykpO1xuICAgICAgICAgICAgJGlucHV0ID0gZmluZElucHV0KCRmb3JtLCB0aGlzKTtcblxuICAgICAgICAgICAgaWYgKCEkaW5wdXQuaXMoXCI6ZGlzYWJsZWRcIikgJiYgIXRoaXMuY2FuY2VsbGVkICYmIGhhc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JBdHRyaWJ1dGVzLnB1c2godGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRmb3JtLnRyaWdnZXIoZXZlbnRzLmFmdGVyVmFsaWRhdGUsIFttZXNzYWdlcywgZXJyb3JBdHRyaWJ1dGVzXSk7XG5cbiAgICAgICAgaWYgKHN1Ym1pdHRpbmcpIHtcbiAgICAgICAgICAgIHVwZGF0ZVN1bW1hcnkoJGZvcm0sIG1lc3NhZ2VzKTtcbiAgICAgICAgICAgIGlmIChlcnJvckF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc2V0dGluZ3Muc2Nyb2xsVG9FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wID0gJGZvcm0uZmluZCgkLm1hcChlcnJvckF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZS5pbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgfSkuam9pbignLCcpKS5maXJzdCgpLmNsb3Nlc3QoJzp2aXNpYmxlJykub2Zmc2V0KCkudG9wIC0gZGF0YS5zZXR0aW5ncy5zY3JvbGxUb0Vycm9yT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9wIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b3AgPiAkKGRvY3VtZW50KS5oZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gJChkb2N1bWVudCkuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHd0b3AgPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3AgPCB3dG9wIHx8IHRvcCA+IHd0b3AgKyAkKHdpbmRvdykuaGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQod2luZG93KS5zY3JvbGxUb3AodG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhLnN1Ym1pdHRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnN1Ym1pdE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBhcHBseUJ1dHRvbk9wdGlvbnMoJGZvcm0sIGRhdGEuc3VibWl0T2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc3VibWl0T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmVCdXR0b25PcHRpb25zKCRmb3JtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkLmVhY2goZGF0YS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNhbmNlbGxlZCAmJiAodGhpcy5zdGF0dXMgPT09IDIgfHwgdGhpcy5zdGF0dXMgPT09IDMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUlucHV0KCRmb3JtLCB0aGlzLCBtZXNzYWdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VibWl0RmluYWxpemUoJGZvcm0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGhpZGRlbiBmaWVsZCB0aGF0IHJlcHJlc2VudHMgY2xpY2tlZCBzdWJtaXQgYnV0dG9uLlxuICAgICAqIEBwYXJhbSAkZm9ybSB0aGUgZm9ybSBqUXVlcnkgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciB1cGRhdGVIaWRkZW5CdXR0b24gPSBmdW5jdGlvbiAoJGZvcm0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSAkZm9ybS5kYXRhKCd5aWlBY3RpdmVGb3JtJyk7XG4gICAgICAgIHZhciAkYnV0dG9uID0gZGF0YS5zdWJtaXRPYmplY3QgfHwgJGZvcm0uZmluZCgnOnN1Ym1pdDpmaXJzdCcpO1xuICAgICAgICAvLyBUT0RPOiBpZiB0aGUgc3VibWlzc2lvbiBpcyBjYXVzZWQgYnkgXCJjaGFuZ2VcIiBldmVudCwgaXQgd2lsbCBub3Qgd29ya1xuICAgICAgICBpZiAoJGJ1dHRvbi5sZW5ndGggJiYgJGJ1dHRvbi5hdHRyKCd0eXBlJykgPT0gJ3N1Ym1pdCcgJiYgJGJ1dHRvbi5hdHRyKCduYW1lJykpIHtcbiAgICAgICAgICAgIC8vIHNpbXVsYXRlIGJ1dHRvbiBpbnB1dCB2YWx1ZVxuICAgICAgICAgICAgdmFyICRoaWRkZW5CdXR0b24gPSAkKCdpbnB1dFt0eXBlPVwiaGlkZGVuXCJdW25hbWU9XCInICsgJGJ1dHRvbi5hdHRyKCduYW1lJykgKyAnXCJdJywgJGZvcm0pO1xuICAgICAgICAgICAgaWYgKCEkaGlkZGVuQnV0dG9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICQoJzxpbnB1dD4nKS5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICRidXR0b24uYXR0cignbmFtZScpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJGJ1dHRvbi5hdHRyKCd2YWx1ZScpXG4gICAgICAgICAgICAgICAgfSkuYXBwZW5kVG8oJGZvcm0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkaGlkZGVuQnV0dG9uLmF0dHIoJ3ZhbHVlJywgJGJ1dHRvbi5hdHRyKCd2YWx1ZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBlcnJvciBtZXNzYWdlIGFuZCB0aGUgaW5wdXQgY29udGFpbmVyIGZvciBhIHBhcnRpY3VsYXIgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSAkZm9ybSB0aGUgZm9ybSBqUXVlcnkgb2JqZWN0XG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZSBvYmplY3QgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIGEgcGFydGljdWxhciBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzIGFycmF5IHRoZSB2YWxpZGF0aW9uIGVycm9yIG1lc3NhZ2VzXG4gICAgICogQHJldHVybiBib29sZWFuIHdoZXRoZXIgdGhlcmUgaXMgYSB2YWxpZGF0aW9uIGVycm9yIGZvciB0aGUgc3BlY2lmaWVkIGF0dHJpYnV0ZVxuICAgICAqL1xuICAgIHZhciB1cGRhdGVJbnB1dCA9IGZ1bmN0aW9uICgkZm9ybSwgYXR0cmlidXRlLCBtZXNzYWdlcykge1xuICAgICAgICB2YXIgZGF0YSA9ICRmb3JtLmRhdGEoJ3lpaUFjdGl2ZUZvcm0nKSxcbiAgICAgICAgICAgICRpbnB1dCA9IGZpbmRJbnB1dCgkZm9ybSwgYXR0cmlidXRlKSxcbiAgICAgICAgICAgIGhhc0Vycm9yID0gYXR0ckhhc0Vycm9yKCRmb3JtLCBhdHRyaWJ1dGUsIG1lc3NhZ2VzKTtcblxuICAgICAgICBpZiAoISQuaXNBcnJheShtZXNzYWdlc1thdHRyaWJ1dGUuaWRdKSkge1xuICAgICAgICAgICAgbWVzc2FnZXNbYXR0cmlidXRlLmlkXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlLnN0YXR1cyA9IDE7XG4gICAgICAgIGlmICgkaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgJGNvbnRhaW5lciA9ICRmb3JtLmZpbmQoYXR0cmlidXRlLmNvbnRhaW5lcik7XG4gICAgICAgICAgICB2YXIgJGVycm9yID0gJGNvbnRhaW5lci5maW5kKGF0dHJpYnV0ZS5lcnJvcik7XG4gICAgICAgICAgICB1cGRhdGVBcmlhSW52YWxpZCgkZm9ybSwgYXR0cmlidXRlLCBoYXNFcnJvcik7XG5cbiAgICAgICAgICAgIHZhciAkZXJyb3JFbGVtZW50ID0gZGF0YS5zZXR0aW5ncy52YWxpZGF0aW9uU3RhdGVPbiA9PT0gJ2lucHV0JyA/ICRpbnB1dCA6ICRjb250YWluZXI7XG5cbiAgICAgICAgICAgIGlmIChoYXNFcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUuZW5jb2RlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgJGVycm9yLnRleHQobWVzc2FnZXNbYXR0cmlidXRlLmlkXVswXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJGVycm9yLmh0bWwobWVzc2FnZXNbYXR0cmlidXRlLmlkXVswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRlcnJvckVsZW1lbnQucmVtb3ZlQ2xhc3MoZGF0YS5zZXR0aW5ncy52YWxpZGF0aW5nQ3NzQ2xhc3MgKyAnICcgKyBkYXRhLnNldHRpbmdzLnN1Y2Nlc3NDc3NDbGFzcylcbiAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhkYXRhLnNldHRpbmdzLmVycm9yQ3NzQ2xhc3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkZXJyb3IuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAkZXJyb3JFbGVtZW50LnJlbW92ZUNsYXNzKGRhdGEuc2V0dGluZ3MudmFsaWRhdGluZ0Nzc0NsYXNzICsgJyAnICsgZGF0YS5zZXR0aW5ncy5lcnJvckNzc0NsYXNzICsgJyAnKVxuICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGRhdGEuc2V0dGluZ3Muc3VjY2Vzc0Nzc0NsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IGdldFZhbHVlKCRmb3JtLCBhdHRyaWJ1dGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgJGZvcm0udHJpZ2dlcihldmVudHMuYWZ0ZXJWYWxpZGF0ZUF0dHJpYnV0ZSwgW2F0dHJpYnV0ZSwgbWVzc2FnZXNbYXR0cmlidXRlLmlkXV0pO1xuXG4gICAgICAgIHJldHVybiBoYXNFcnJvcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgcGFydGljdWxhciBhdHRyaWJ1dGUgaGFzIGFuIGVycm9yXG4gICAgICogQHBhcmFtICRmb3JtIHRoZSBmb3JtIGpRdWVyeSBvYmplY3RcbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlIG9iamVjdCB0aGUgY29uZmlndXJhdGlvbiBmb3IgYSBwYXJ0aWN1bGFyIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZXMgYXJyYXkgdGhlIHZhbGlkYXRpb24gZXJyb3IgbWVzc2FnZXNcbiAgICAgKiBAcmV0dXJuIGJvb2xlYW4gd2hldGhlciB0aGVyZSBpcyBhIHZhbGlkYXRpb24gZXJyb3IgZm9yIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlXG4gICAgICovXG4gICAgdmFyIGF0dHJIYXNFcnJvciA9IGZ1bmN0aW9uICgkZm9ybSwgYXR0cmlidXRlLCBtZXNzYWdlcykge1xuICAgICAgICB2YXIgJGlucHV0ID0gZmluZElucHV0KCRmb3JtLCBhdHRyaWJ1dGUpLFxuICAgICAgICAgICAgaGFzRXJyb3IgPSBmYWxzZTtcblxuICAgICAgICBpZiAoISQuaXNBcnJheShtZXNzYWdlc1thdHRyaWJ1dGUuaWRdKSkge1xuICAgICAgICAgICAgbWVzc2FnZXNbYXR0cmlidXRlLmlkXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGhhc0Vycm9yID0gbWVzc2FnZXNbYXR0cmlidXRlLmlkXS5sZW5ndGggPiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhc0Vycm9yO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBlcnJvciBzdW1tYXJ5LlxuICAgICAqIEBwYXJhbSAkZm9ybSB0aGUgZm9ybSBqUXVlcnkgb2JqZWN0XG4gICAgICogQHBhcmFtIG1lc3NhZ2VzIGFycmF5IHRoZSB2YWxpZGF0aW9uIGVycm9yIG1lc3NhZ2VzXG4gICAgICovXG4gICAgdmFyIHVwZGF0ZVN1bW1hcnkgPSBmdW5jdGlvbiAoJGZvcm0sIG1lc3NhZ2VzKSB7XG4gICAgICAgIHZhciBkYXRhID0gJGZvcm0uZGF0YSgneWlpQWN0aXZlRm9ybScpLFxuICAgICAgICAgICAgJHN1bW1hcnkgPSAkZm9ybS5maW5kKGRhdGEuc2V0dGluZ3MuZXJyb3JTdW1tYXJ5KSxcbiAgICAgICAgICAgICR1bCA9ICRzdW1tYXJ5LmZpbmQoJ3VsJykuZW1wdHkoKTtcblxuICAgICAgICBpZiAoJHN1bW1hcnkubGVuZ3RoICYmIG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAkLmVhY2goZGF0YS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCQuaXNBcnJheShtZXNzYWdlc1t0aGlzLmlkXSkgJiYgbWVzc2FnZXNbdGhpcy5pZF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICQoJzxsaS8+Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnNldHRpbmdzLmVuY29kZUVycm9yU3VtbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IudGV4dChtZXNzYWdlc1t0aGlzLmlkXVswXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5odG1sKG1lc3NhZ2VzW3RoaXMuaWRdWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkdWwuYXBwZW5kKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzdW1tYXJ5LnRvZ2dsZSgkdWwuZmluZCgnbGknKS5sZW5ndGggPiAwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZ2V0VmFsdWUgPSBmdW5jdGlvbiAoJGZvcm0sIGF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgJGlucHV0ID0gZmluZElucHV0KCRmb3JtLCBhdHRyaWJ1dGUpO1xuICAgICAgICB2YXIgdHlwZSA9ICRpbnB1dC5hdHRyKCd0eXBlJyk7XG4gICAgICAgIGlmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgICAgIHZhciAkcmVhbElucHV0ID0gJGlucHV0LmZpbHRlcignOmNoZWNrZWQnKTtcbiAgICAgICAgICAgIGlmICgkcmVhbElucHV0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgJHJlYWxJbnB1dC5lYWNoKGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCQoJHJlYWxJbnB1dC5nZXQoaW5kZXgpKS52YWwoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEkcmVhbElucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICRyZWFsSW5wdXQgPSAkZm9ybS5maW5kKCdpbnB1dFt0eXBlPWhpZGRlbl1bbmFtZT1cIicgKyAkaW5wdXQuYXR0cignbmFtZScpICsgJ1wiXScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJHJlYWxJbnB1dC52YWwoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAkaW5wdXQudmFsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGZpbmRJbnB1dCA9IGZ1bmN0aW9uICgkZm9ybSwgYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciAkaW5wdXQgPSAkZm9ybS5maW5kKGF0dHJpYnV0ZS5pbnB1dCk7XG4gICAgICAgIGlmICgkaW5wdXQubGVuZ3RoICYmICRpbnB1dFswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdkaXYnKSB7XG4gICAgICAgICAgICAvLyBjaGVja2JveCBsaXN0IG9yIHJhZGlvIGxpc3RcbiAgICAgICAgICAgIHJldHVybiAkaW5wdXQuZmluZCgnaW5wdXQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAkaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUFyaWFJbnZhbGlkID0gZnVuY3Rpb24gKCRmb3JtLCBhdHRyaWJ1dGUsIGhhc0Vycm9yKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUudXBkYXRlQXJpYUludmFsaWQpIHtcbiAgICAgICAgICAgICRmb3JtLmZpbmQoYXR0cmlidXRlLmlucHV0KS5hdHRyKCdhcmlhLWludmFsaWQnLCBoYXNFcnJvciA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgICAgICB9XG4gICAgfVxufSkod2luZG93LmpRdWVyeSk7XG4iLCIvKipcbiAqIFlpaSBhdXRoIGNob2ljZSB3aWRnZXQuXG4gKlxuICogVGhpcyBpcyB0aGUgSmF2YVNjcmlwdCB3aWRnZXQgdXNlZCBieSB0aGUgeWlpXFxhdXRoY2xpZW50XFx3aWRnZXRzXFxBdXRoQ2hvaWNlIHdpZGdldC5cbiAqXG4gKiBAbGluayBodHRwOi8vd3d3LnlpaWZyYW1ld29yay5jb20vXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAwOCBZaWkgU29mdHdhcmUgTExDXG4gKiBAbGljZW5zZSBodHRwOi8vd3d3LnlpaWZyYW1ld29yay5jb20vbGljZW5zZS9cbiAqIEBhdXRob3IgUGF1bCBLbGltb3YgPGtsaW1vdi5wYXVsQGdtYWlsLmNvbT5cbiAqIEBzaW5jZSAyLjBcbiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpIHtcbiAgICAkLmZuLmF1dGhjaG9pY2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7XG4gICAgICAgICAgICB0cmlnZ2VyU2VsZWN0b3I6ICdhLmF1dGgtbGluaycsXG4gICAgICAgICAgICBwb3B1cDoge1xuICAgICAgICAgICAgICAgIHJlc2l6YWJsZTogJ3llcycsXG4gICAgICAgICAgICAgICAgc2Nyb2xsYmFyczogJ25vJyxcbiAgICAgICAgICAgICAgICB0b29sYmFyOiAnbm8nLFxuICAgICAgICAgICAgICAgIG1lbnViYXI6ICdubycsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdubycsXG4gICAgICAgICAgICAgICAgZGlyZWN0b3JpZXM6ICdubycsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAneWVzJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogNDUwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMzgwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgJGNvbnRhaW5lciA9ICQodGhpcyk7XG5cbiAgICAgICAgICAgICRjb250YWluZXIuZmluZChvcHRpb25zLnRyaWdnZXJTZWxlY3Rvcikub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIHZhciBhdXRoQ2hvaWNlUG9wdXAgPSAkY29udGFpbmVyLmRhdGEoJ2F1dGhDaG9pY2VQb3B1cCcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGF1dGhDaG9pY2VQb3B1cCkge1xuICAgICAgICAgICAgICAgICAgICBhdXRoQ2hvaWNlUG9wdXAuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gdGhpcy5ocmVmO1xuICAgICAgICAgICAgICAgIHZhciBwb3B1cE9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgb3B0aW9ucy5wb3B1cCk7IC8vIGNsb25lXG5cbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxQb3B1cFdpZHRoID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtcG9wdXAtd2lkdGgnKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxQb3B1cFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcHVwT3B0aW9ucy53aWR0aCA9IGxvY2FsUG9wdXBXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUG9wdXBIZWlnaHQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnZGF0YS1wb3B1cC1oZWlnaHQnKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxQb3B1cFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcHVwT3B0aW9ucy5oZWlnaHQgPSBsb2NhbFBvcHVwSGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvcHVwT3B0aW9ucy5sZWZ0ID0gKHdpbmRvdy5zY3JlZW4ud2lkdGggLSBwb3B1cE9wdGlvbnMud2lkdGgpIC8gMjtcbiAgICAgICAgICAgICAgICBwb3B1cE9wdGlvbnMudG9wID0gKHdpbmRvdy5zY3JlZW4uaGVpZ2h0IC0gcG9wdXBPcHRpb25zLmhlaWdodCkgLyAyO1xuXG4gICAgICAgICAgICAgICAgdmFyIHBvcHVwRmVhdHVyZVBhcnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcG9wdXBPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3B1cE9wdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3B1cEZlYXR1cmVQYXJ0cy5wdXNoKHByb3BOYW1lICsgJz0nICsgcG9wdXBPcHRpb25zW3Byb3BOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHBvcHVwRmVhdHVyZSA9IHBvcHVwRmVhdHVyZVBhcnRzLmpvaW4oJywnKTtcblxuICAgICAgICAgICAgICAgIGF1dGhDaG9pY2VQb3B1cCA9IHdpbmRvdy5vcGVuKHVybCwgJ3lpaV9hdXRoX2Nob2ljZScsIHBvcHVwRmVhdHVyZSk7XG4gICAgICAgICAgICAgICAgYXV0aENob2ljZVBvcHVwLmZvY3VzKCk7XG5cbiAgICAgICAgICAgICAgICAkY29udGFpbmVyLmRhdGEoJ2F1dGhDaG9pY2VQb3B1cCcsIGF1dGhDaG9pY2VQb3B1cCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuIiwiKGZ1bmN0aW9uICgkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgJC5mbi5tdWx0aXBsZUlucHV0ID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICBpZiAobWV0aG9kc1ttZXRob2RdKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kc1ttZXRob2RdLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdvYmplY3QnIHx8ICFtZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQuZXJyb3IoJ01ldGhvZCAnICsgbWV0aG9kICsgJyBkb2VzIG5vdCBleGlzdCBvbiBqUXVlcnkubXVsdGlwbGVJbnB1dCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBldmVudHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhZnRlckFkZFJvdyBldmVudCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgd2lkZ2V0J3MgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAqIFRoZSBzaWduYXR1cmUgb2YgdGhlIGV2ZW50IGhhbmRsZXIgc2hvdWxkIGJlOlxuICAgICAgICAgKiAgICAgZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICAgKiB3aGVyZSBldmVudCBpcyBhbiBFdmVudCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhZnRlckluaXQ6ICdhZnRlckluaXQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogYWZ0ZXJBZGRSb3cgZXZlbnQgaXMgdHJpZ2dlcmVkIGFmdGVyIHN1Y2Nlc3NmdWwgYWRkaW5nIG5ldyByb3cuXG4gICAgICAgICAqIFRoZSBzaWduYXR1cmUgb2YgdGhlIGV2ZW50IGhhbmRsZXIgc2hvdWxkIGJlOlxuICAgICAgICAgKiAgICAgZnVuY3Rpb24gKGV2ZW50LCByb3cpXG4gICAgICAgICAqIHdoZXJlIGV2ZW50IGlzIGFuIEV2ZW50IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGJlZm9yZUFkZFJvdzogJ2JlZm9yZUFkZFJvdycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhZnRlckFkZFJvdyBldmVudCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBhZGRpbmcgbmV3IHJvdy5cbiAgICAgICAgICogVGhlIHNpZ25hdHVyZSBvZiB0aGUgZXZlbnQgaGFuZGxlciBzaG91bGQgYmU6XG4gICAgICAgICAqICAgICBmdW5jdGlvbiAoZXZlbnQsIHJvdylcbiAgICAgICAgICogd2hlcmUgZXZlbnQgaXMgYW4gRXZlbnQgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYWZ0ZXJBZGRSb3c6ICdhZnRlckFkZFJvdycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBiZWZvcmVEZWxldGVSb3cgZXZlbnQgaXMgdHJpZ2dlcmVkIGJlZm9yZSByb3cgd2lsbCBiZSByZW1vdmVkLlxuICAgICAgICAgKiBUaGUgc2lnbmF0dXJlIG9mIHRoZSBldmVudCBoYW5kbGVyIHNob3VsZCBiZTpcbiAgICAgICAgICogICAgIGZ1bmN0aW9uIChldmVudCwgcm93KVxuICAgICAgICAgKiB3aGVyZSBldmVudCBpcyBhbiBFdmVudCBvYmplY3QgYW5kIHJvdyBpcyBodG1sIGNvbnRhaW5lciBvZiByb3cgZm9yIHJlbW92YWxcbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGhhbmRsZXIgcmV0dXJucyBhIGJvb2xlYW4gZmFsc2UsIGl0IHdpbGwgc3RvcCByZW1vdmFsIHRoZSByb3cuXG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVEZWxldGVSb3c6ICdiZWZvcmVEZWxldGVSb3cnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhZnRlckFkZFJvdyBldmVudCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgc3VjY2Vzc2Z1bCByZW1vdmFsIHRoZSByb3cuXG4gICAgICAgICAqIFRoZSBzaWduYXR1cmUgb2YgdGhlIGV2ZW50IGhhbmRsZXIgc2hvdWxkIGJlOlxuICAgICAgICAgKiAgICAgZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICAgKiB3aGVyZSBldmVudCBpcyBhbiBFdmVudCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhZnRlckRlbGV0ZVJvdzogJ2FmdGVyRGVsZXRlUm93JyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogYWZ0ZXJEcm9wUm93IGV2ZW50IGlzIHRyaWdnZXJlZCBhZnRlciBkcm9wIHRoZSByb3cgaW4gc29ydGFibGUgbW9kZS5cbiAgICAgICAgICogVGhlIHNpZ25hdHVyZSBvZiB0aGUgZXZlbnQgaGFuZGxlciBzaG91bGQgYmU6XG4gICAgICAgICAqICAgICBmdW5jdGlvbiAoZXZlbnQsIHJvdylcbiAgICAgICAgICogd2hlcmUgZXZlbnQgaXMgYW4gRXZlbnQgb2JqZWN0IGFuZCByb3cgaXMgaHRtbCBjb250YWluZXIgb2YgZHJhZ2dlZCByb3dcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyRHJvcFJvdzogJ2FmdGVyRHJvcFJvdydcbiAgICB9O1xuXG4gICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogdGhlIElEIG9mIHdpZGdldFxuICAgICAgICAgKi9cbiAgICAgICAgaWQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZSBJRCBvZiByZWxhdGVkIGlucHV0IGluIGNhc2Ugb2YgdXNpbmcgd2lkZ2V0IGZvciBhbiBhY3RpdmUgZmllbGRcbiAgICAgICAgICovXG4gICAgICAgIGlucHV0SWQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZSB0ZW1wbGF0ZSBvZiByb3dcbiAgICAgICAgICovXG4gICAgICAgIHRlbXBsYXRlOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhcnJheSB0aGF0IGNvbGxlY3QganMgdGVtcGxhdGVzIG9mIHdpZGdldHMgd2hpY2ggdXNlcyBpbiB0aGUgY29sdW1uc1xuICAgICAgICAgKi9cbiAgICAgICAganNUZW1wbGF0ZXM6IFtdLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhcnJheSBvZiBzY3JpcHRzIHdoaWNoIG5lZWQgdG8gZXhlY3V0ZSBiZWZvcmUgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICovXG4gICAgICAgIGpzSW5pdDogW10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhvdyBtYW55IHJvdyBhcmUgYWxsb3dlZCB0byByZW5kZXJcbiAgICAgICAgICovXG4gICAgICAgIG1heDogMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogYSBtaW5pbXVtIG51bWJlciBvZiByb3dzXG4gICAgICAgICAqL1xuICAgICAgICBtaW46IDEsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFjdGl2ZSBmb3JtIG9wdGlvbnMgb2YgYXR0cmlidXRlc1xuICAgICAgICAgKi9cbiAgICAgICAgYXR0cmlidXRlczoge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRlZmF1bHQgcHJlZml4IG9mIGEgd2lkZ2V0J3MgcGxhY2Vob2xkZXJcbiAgICAgICAgICovXG4gICAgICAgIGluZGV4UGxhY2Vob2xkZXI6ICdtdWx0aXBsZV9pbmRleCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZXRoZXIgbmVlZCB0byBzaG93IGdlbmVyYWwgZXJyb3IgbWVzc2FnZSBvciBub1xuICAgICAgICAgKi9cbiAgICAgICAgc2hvd0dlbmVyYWxFcnJvcjogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlmIG5lZWQgdG8gcHJlcGVuZCBuZXcgcm93LCBub3QgYXBwZW5kXG4gICAgICAgICAqL1xuICAgICAgICBwcmVwZW5kOiBmYWxzZVxuICAgIH07XG5cbiAgICB2YXIgaXNBY3RpdmVGb3JtRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgdmFyIG1ldGhvZHMgPSB7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignT3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gJC5leHRlbmQodHJ1ZSwge30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KSxcbiAgICAgICAgICAgICAgICAkd3JhcHBlciA9ICQoJyMnICsgc2V0dGluZ3MuaWQpLFxuICAgICAgICAgICAgICAgIGZvcm0gPSAkd3JhcHBlci5jbG9zZXN0KCdmb3JtJyksXG4gICAgICAgICAgICAgICAgaW5wdXRJZCA9IHNldHRpbmdzLmlucHV0SWQ7XG5cbiAgICAgICAgICAgIGZvciAoaSBpbiBzZXR0aW5ncy5qc0luaXQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuZXZhbChzZXR0aW5ncy5qc0luaXRbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkd3JhcHBlci5kYXRhKCdtdWx0aXBsZUlucHV0Jywge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzOiBzZXR0aW5ncyxcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXg6IDBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkd3JhcHBlci5vbignY2xpY2subXVsdGlwbGVJbnB1dCcsICcuanMtaW5wdXQtcmVtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUlucHV0KCQodGhpcykpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICR3cmFwcGVyLm9uKCdjbGljay5tdWx0aXBsZUlucHV0JywgJy5qcy1pbnB1dC1wbHVzJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGFkZElucHV0KCQodGhpcykpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICR3cmFwcGVyLm9uKCdjbGljay5tdWx0aXBsZUlucHV0JywgJy5qcy1pbnB1dC1jbG9uZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBhZGRJbnB1dCgkKHRoaXMpLCBnZXRSb3dWYWx1ZXMoJCh0aGlzKSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgICBldmVudCA9ICQuRXZlbnQoZXZlbnRzLmFmdGVySW5pdCk7XG5cbiAgICAgICAgICAgIHZhciBpbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybS5kYXRhKCd5aWlBY3RpdmVGb3JtJykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBmb3JtLnlpaUFjdGl2ZUZvcm0oJ2ZpbmQnLCBpbnB1dElkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRBdHRyaWJ1dGVPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZUFqYXhWYWxpZGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZU9uQmx1cjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVPbkNoYW5nZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVPblR5cGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25EZWxheTogNTAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZldGNoIGRlZmF1bHQgYXR0cmlidXRlIG9wdGlvbnMgZnJvbSBhY3RpdmUgZnJvbSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goYXR0cmlidXRlLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChbJ2lkJywgJ2lucHV0JywgJ2NvbnRhaW5lciddLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEF0dHJpYnV0ZU9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLnNob3dHZW5lcmFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnlpaUFjdGl2ZUZvcm0oJ3JlbW92ZScsIGlucHV0SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwZW5kIGRlZmF1bHQgb3B0aW9ucyB0byBvcHRpb24gZnJvbSBzZXR0aW5nc1xuICAgICAgICAgICAgICAgICAgICAkLmVhY2goc2V0dGluZ3MuYXR0cmlidXRlcywgZnVuY3Rpb24gKGF0dHJpYnV0ZSwgYXR0cmlidXRlT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlT3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0QXR0cmlidXRlT3B0aW9ucywgYXR0cmlidXRlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSBhdHRyaWJ1dGVPcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAkd3JhcHBlci5kYXRhKCdtdWx0aXBsZUlucHV0Jykuc2V0dGluZ3MgPSBzZXR0aW5ncztcblxuICAgICAgICAgICAgICAgICAgICAkd3JhcHBlci5maW5kKCcubXVsdGlwbGUtaW5wdXQtbGlzdCcpLmZpbmQoJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRBdHRyaWJ1dGUoJCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICR3cmFwcGVyLmRhdGEoJ211bHRpcGxlSW5wdXQnKS5jdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoJHdyYXBwZXIpO1xuICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZUZvcm1FbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSUQpO1xuICAgICAgICAgICAgICAgICAgICAkd3JhcHBlci50cmlnZ2VyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gd2FpdCBmb3IgaW5pdGlhbGl6YXRpb24gb2YgQWN0aXZlRm9ybSBhIHNlY29uZFxuICAgICAgICAgICAgICAgIC8vIElmIGFmdGVyIGEgc2Vjb25kIHN5c3RlbSBjb3VsZCBub3QgZGV0ZWN0IEFjdGl2ZUZvcm0gaXQgbWVhbnNcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdpZGdldCBpcyB1c2VkIHdpdGhvdXQgQWN0aXZlRm9ybSBhbmQgd2Ugc2hvdWxkIGp1c3QgY29tcGxldGUgaW5pdGlhbGl6YXRpb24gb2YgdGhlIHdpZGdldFxuICAgICAgICAgICAgICAgIGlmIChmb3JtLmxlbmd0aCA9PT0gMCB8fCBpID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgJHdyYXBwZXIuZGF0YSgnbXVsdGlwbGVJbnB1dCcpLmN1cnJlbnRJbmRleCA9IGdldEN1cnJlbnRJbmRleCgkd3JhcHBlcik7XG4gICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlRm9ybUVuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSUQpO1xuICAgICAgICAgICAgICAgICAgICAkd3JhcHBlci50cmlnZ2VyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICAgICAgYWRkSW5wdXQoJCh0aGlzKSwgdmFsdWVzKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgdmFyIHJvdyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJvdyA9ICQodGhpcykuZmluZCgnLmpzLWlucHV0LXJlbW92ZTplcSgnICsgaW5kZXggKyAnKScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3cgPSAkKHRoaXMpLmZpbmQoJy5qcy1pbnB1dC1yZW1vdmUnKS5sYXN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbW92ZUlucHV0KHJvdyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQodGhpcykuZmluZCgnLmpzLWlucHV0LXJlbW92ZScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUlucHV0KCQodGhpcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3B0aW9uOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSB8fCBudWxsO1xuXG4gICAgICAgICAgICB2YXIgZGF0YSA9ICQodGhpcykuZGF0YSgnbXVsdGlwbGVJbnB1dCcpLFxuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gZGF0YS5zZXR0aW5ncztcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gXCInICsgbmFtZSArICdcIiBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3NbbmFtZV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBkYXRhLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5kYXRhKCdtdWx0aXBsZUlucHV0JywgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGFkZElucHV0ID0gZnVuY3Rpb24gKGJ0biwgdmFsdWVzKSB7XG4gICAgICAgIHZhciAkd3JhcHBlciAgPSAkKGJ0bikuY2xvc2VzdCgnLm11bHRpcGxlLWlucHV0JykuZmlyc3QoKSxcbiAgICAgICAgICAgIGRhdGEgICAgICA9ICR3cmFwcGVyLmRhdGEoJ211bHRpcGxlSW5wdXQnKSxcbiAgICAgICAgICAgIHNldHRpbmdzICA9IGRhdGEuc2V0dGluZ3MsXG4gICAgICAgICAgICB0ZW1wbGF0ZSAgPSBzZXR0aW5ncy50ZW1wbGF0ZSxcbiAgICAgICAgICAgIGlucHV0TGlzdCA9ICR3cmFwcGVyLmNoaWxkcmVuKCcubXVsdGlwbGUtaW5wdXQtbGlzdCcpLmZpcnN0KCk7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLm1heCAhPT0gbnVsbCAmJiBnZXRDdXJyZW50SW5kZXgoJHdyYXBwZXIpID49IHNldHRpbmdzLm1heCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcGxhdGUgPSByZXBsYWNlQWxsKCd7JyArIHNldHRpbmdzLmluZGV4UGxhY2Vob2xkZXIgKyAnfScsIGRhdGEuY3VycmVudEluZGV4LCB0ZW1wbGF0ZSk7XG4gICAgICAgIHZhciAkYWRkZWRJbnB1dCA9ICQodGVtcGxhdGUpO1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gZGF0YS5jdXJyZW50SW5kZXg7XG5cbiAgICAgICAgdmFyIGJlZm9yZUFkZEV2ZW50ID0gJC5FdmVudChldmVudHMuYmVmb3JlQWRkUm93KTtcbiAgICAgICAgJHdyYXBwZXIudHJpZ2dlcihiZWZvcmVBZGRFdmVudCwgWyRhZGRlZElucHV0LCBjdXJyZW50SW5kZXhdKTtcblxuICAgICAgICBpZiAoYmVmb3JlQWRkRXZlbnQucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoc2V0dGluZ3MucHJlcGVuZCkge1xuICAgICAgICAgICAgJGFkZGVkSW5wdXQuaGlkZSgpLnByZXBlbmRUbyhpbnB1dExpc3QpLmZhZGVJbigzMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGFkZGVkSW5wdXQuaGlkZSgpLmFwcGVuZFRvKGlucHV0TGlzdCkuZmFkZUluKDMwMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKHZhbHVlc1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlcyA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBqc1RlbXBsYXRlO1xuXG4gICAgICAgIGZvciAodmFyIGkgaW4gc2V0dGluZ3MuanNUZW1wbGF0ZXMpIHtcbiAgICAgICAgICAgIGpzVGVtcGxhdGUgPSBzZXR0aW5ncy5qc1RlbXBsYXRlc1tpXTtcbiAgICAgICAgICAgIGpzVGVtcGxhdGUgPSByZXBsYWNlQWxsKCd7JyArIHNldHRpbmdzLmluZGV4UGxhY2Vob2xkZXIgKyAnfScsIGRhdGEuY3VycmVudEluZGV4LCBqc1RlbXBsYXRlKTtcbiAgICAgICAgICAgIGpzVGVtcGxhdGUgPSByZXBsYWNlQWxsKCclN0InICsgc2V0dGluZ3MuaW5kZXhQbGFjZWhvbGRlciArICclN0QnLCBkYXRhLmN1cnJlbnRJbmRleCwganNUZW1wbGF0ZSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5ldmFsKGpzVGVtcGxhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZGV4ID0gMDtcblxuICAgICAgICAkKHRlbXBsYXRlKS5maW5kKCdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYScpLmVhY2goZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgICAgIHZhciBlbGUgPSAkKHYpLFxuICAgICAgICAgICAgICAgIHRhZyA9IHYudGFnTmFtZSxcbiAgICAgICAgICAgICAgICBpZCAgPSBnZXRJbnB1dElkKGVsZSksXG4gICAgICAgICAgICAgICAgb2JqID0gJCgnIycgKyBpZCk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gdmFsdWVzW2luZGV4XTtcblxuICAgICAgICAgICAgICAgIGlmICh0YWcgPT09ICdJTlBVVCcgfHwgdGFnID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai52YWwodmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCAmJiB2YWwuaW5kZXhPZignb3B0aW9uJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmouYXBwZW5kKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gb2JqLmZpbmQoJ29wdGlvblt2YWx1ZT1cIicgKyB2YWwgKyAnXCJdJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai52YWwodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzQWN0aXZlRm9ybUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBhZGRBdHRyaWJ1dGUoZWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJHdyYXBwZXIuZGF0YSgnbXVsdGlwbGVJbnB1dCcpLmN1cnJlbnRJbmRleCsrO1xuXG4gICAgICAgIHZhciBhZnRlckFkZEV2ZW50ID0gJC5FdmVudChldmVudHMuYWZ0ZXJBZGRSb3cpO1xuICAgICAgICAkd3JhcHBlci50cmlnZ2VyKGFmdGVyQWRkRXZlbnQsIFskYWRkZWRJbnB1dCwgY3VycmVudEluZGV4XSk7XG4gICAgfTtcblxuICAgIHZhciByZW1vdmVJbnB1dCA9IGZ1bmN0aW9uICgkYnRuKSB7XG4gICAgICAgIHZhciAkd3JhcHBlciAgPSAkYnRuLmNsb3Nlc3QoJy5tdWx0aXBsZS1pbnB1dCcpLmZpcnN0KCksXG4gICAgICAgICAgICAkdG9EZWxldGUgPSAkYnRuLmNsb3Nlc3QoJy5tdWx0aXBsZS1pbnB1dC1saXN0X19pdGVtJyksXG4gICAgICAgICAgICBkYXRhICAgICAgPSAkd3JhcHBlci5kYXRhKCdtdWx0aXBsZUlucHV0JyksXG4gICAgICAgICAgICBzZXR0aW5ncyAgPSBkYXRhLnNldHRpbmdzO1xuXG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoJHdyYXBwZXIpO1xuICAgICAgICBpZiAoY3VycmVudEluZGV4ID4gc2V0dGluZ3MubWluKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSAkLkV2ZW50KGV2ZW50cy5iZWZvcmVEZWxldGVSb3cpO1xuICAgICAgICAgICAgJHdyYXBwZXIudHJpZ2dlcihldmVudCwgWyR0b0RlbGV0ZSwgY3VycmVudEluZGV4XSk7XG5cbiAgICAgICAgICAgIGlmIChldmVudC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNBY3RpdmVGb3JtRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICR0b0RlbGV0ZS5maW5kKCdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYScpLmVhY2goZnVuY3Rpb24gKGluZGV4LCBlbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQXR0cmlidXRlKCQoZWxlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICR0b0RlbGV0ZS5mYWRlT3V0KDMwMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICBldmVudCA9ICQuRXZlbnQoZXZlbnRzLmFmdGVyRGVsZXRlUm93KTtcbiAgICAgICAgICAgICAgICAkd3JhcHBlci50cmlnZ2VyKGV2ZW50LCBbJHRvRGVsZXRlLCBjdXJyZW50SW5kZXhdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBhdHRyaWJ1dGUgdG8gQWN0aXZlRm9ybS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqL1xuICAgIHZhciBhZGRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIGlkID0gZ2V0SW5wdXRJZChpbnB1dCk7XG5cbiAgICAgICAgLy8gc2tpcCBpZiB3ZSBjb3VsZCBub3QgZ2V0IGFuIElEIG9mIGlucHV0XG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZSA9ICQoJyMnICsgaWQpLFxuICAgICAgICAgICAgd3JhcHBlciA9IGVsZS5jbG9zZXN0KCcubXVsdGlwbGUtaW5wdXQnKS5maXJzdCgpLFxuICAgICAgICAgICAgZm9ybSA9IGVsZS5jbG9zZXN0KCdmb3JtJyk7XG5cblxuICAgICAgICAvLyBkbyBub3QgYWRkIGF0dHJpYnV0ZSB3aGljaCBhcmUgbm90IHRoZSBwYXJ0IG9mIHdpZGdldFxuICAgICAgICBpZiAod3JhcHBlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIHRoYXQgaW5wdXQgaGFzIGJlZW4gYWxyZWFkeSBhZGRlZCB0byB0aGUgYWN0aXZlRm9ybVxuICAgICAgICBpZiAodHlwZW9mIGZvcm0ueWlpQWN0aXZlRm9ybSgnZmluZCcsIGlkKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhID0gd3JhcHBlci5kYXRhKCdtdWx0aXBsZUlucHV0JyksXG4gICAgICAgICAgICBhdHRyaWJ1dGVPcHRpb25zID0ge307XG5cbiAgICAgICAgLy8gdHJ5IHRvIGZpbmQgb3B0aW9ucyBmb3IgZW1iZWRkZWQgYXR0cmlidXRlIGF0IGZpcnN0LlxuICAgICAgICAvLyBGb3IgZXhhbXBsZSB0aGUgaWQgb2YgbmV3IGlucHV0IGlzIGV4YW1wbGUtMS1maWVsZC0wLlxuICAgICAgICAvLyBXZSByZW1vdmUgbGFzdCBpbmRleCBhbmQgY2hlY2sgd2hldGhlciBhdHRyaWJ1dGUgd2l0aCBzdWNoIGlkIGV4aXN0cyBvciBub3QuXG4gICAgICAgIHZhciBiYXJlSWQgPSBpZC5yZXBsYWNlKC8tXFxkKy0oW15cXGRdKykkLywgJy0kMScpO1xuICAgICAgICBpZiAoZGF0YS5zZXR0aW5ncy5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGJhcmVJZCkpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZU9wdGlvbnMgPSBkYXRhLnNldHRpbmdzLmF0dHJpYnV0ZXNbYmFyZUlkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIGluIGNhc2Ugb2YgdXNpbmcgZmxhdHRlbiB3aWRnZXQgLSBqdXN0IHJlbW92ZSBhbGwgZGlnaXRhbCBpbmRleGVzXG4gICAgICAgICAgICAvLyBhbmQgY2hlY2sgd2hldGhlciBhdHRyaWJ1dGUgZXhpc3RzIG9yIG5vdC5cbiAgICAgICAgICAgIGJhcmVJZCA9IHJlcGxhY2VBbGwoLy1cXGQtLywgJy0nLCBiYXJlSWQpO1xuICAgICAgICAgICAgYmFyZUlkID0gcmVwbGFjZUFsbCgvLVxcZC8sICcnLCBiYXJlSWQpO1xuICAgICAgICAgICAgaWYgKGRhdGEuc2V0dGluZ3MuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShiYXJlSWQpKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlT3B0aW9ucyA9IGRhdGEuc2V0dGluZ3MuYXR0cmlidXRlc1tiYXJlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9ybS55aWlBY3RpdmVGb3JtKCdhZGQnLCAkLmV4dGVuZCh7fSwgYXR0cmlidXRlT3B0aW9ucywge1xuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAnaW5wdXQnOiAnIycgKyBpZCxcbiAgICAgICAgICAgICdjb250YWluZXInOiAnLmZpZWxkLScgKyBpZFxuICAgICAgICB9KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gQWN0aXZlRm9ybS5cbiAgICAgKi9cbiAgICB2YXIgcmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICB2YXIgaWQgPSBnZXRJbnB1dElkKGVsZSk7XG5cbiAgICAgICAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZm9ybSA9ICQoJyMnICsgaWQpLmNsb3Nlc3QoJ2Zvcm0nKTtcblxuICAgICAgICBpZiAoZm9ybS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGZvcm0ueWlpQWN0aXZlRm9ybSgncmVtb3ZlJywgaWQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBnZXRJbnB1dElkID0gZnVuY3Rpb24gKCRpbnB1dCkge1xuICAgICAgICB2YXIgaWQgPSAkaW5wdXQuYXR0cignaWQnKTtcblxuICAgICAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWQgPSAkaW5wdXQuZGF0YSgnaWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuXG4gICAgdmFyIGdldEN1cnJlbnRJbmRleCA9IGZ1bmN0aW9uKCR3cmFwcGVyKSB7XG4gICAgICAgIHJldHVybiAkd3JhcHBlclxuICAgICAgICAgICAgLmZpbmQoJy5tdWx0aXBsZS1pbnB1dC1saXN0IC5tdWx0aXBsZS1pbnB1dC1saXN0X19pdGVtJylcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5wYXJlbnRzKCcubXVsdGlwbGUtaW5wdXQnKS5maXJzdCgpLmF0dHIoJ2lkJykgPT09ICR3cmFwcGVyLmF0dHIoJ2lkJyk7XG4gICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgfTtcblxuICAgIHZhciBnZXRSb3dWYWx1ZXMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgdmFsdWVzID0ge307XG4gICAgICAgIGVsZW1lbnQuY2xvc2VzdCgndHInKS5maW5kKCd0ZCcpLmVhY2goZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgJCh2YWx1ZSkuZmluZCgnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEnKS5lYWNoKGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZSA9ICQodiksXG4gICAgICAgICAgICAgICAgICAgIGlkID0gZ2V0SW5wdXRJZChlbGUpLFxuICAgICAgICAgICAgICAgICAgICBvYmogPSAkKCcjJyArIGlkKTtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaWRdID0gb2JqLnZhbCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG5cbiAgICB2YXIgcmVwbGFjZUFsbCA9IGZ1bmN0aW9uIChzZWFyY2gsIHJlcGxhY2UsIHN1YmplY3QpIHtcbiAgICAgICAgaWYgKCEoc3ViamVjdCBpbnN0YW5jZW9mIFN0cmluZykgJiYgdHlwZW9mIHN1YmplY3QgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NhbGwgcmVwbGFjZUFsbCBmb3Igbm9uLXN0cmluZyB2YWx1ZTogJyArIHN1YmplY3QpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3ViamVjdC5zcGxpdChzZWFyY2gpLmpvaW4ocmVwbGFjZSk7XG4gICAgfTtcbn0pKHdpbmRvdy5qUXVlcnkpO1xuIiwiLyohXG4gKiBcbiAqICAgICAgICAgICAgIFNpbXBsZUJhci5qcyAtIHYyLjQuM1xuICogICAgICAgICAgICAgU2Nyb2xsYmFycywgc2ltcGxlci5cbiAqICAgICAgICAgICAgIGh0dHBzOi8vZ3JzbXRvLmdpdGh1Yi5pby9zaW1wbGViYXIvXG4gKiAgICAgICAgICAgICBcbiAqICAgICAgICAgICAgIE1hZGUgYnkgQWRyaWVuIEdyc210byBmcm9tIGEgZm9yayBieSBKb25hdGhhbiBOaWNvbFxuICogICAgICAgICAgICAgVW5kZXIgTUlUIExpY2Vuc2VcbiAqICAgICAgICAgXG4gKi9cbiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLGUpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuU2ltcGxlQmFyPWUoKTp0LlNpbXBsZUJhcj1lKCl9KHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShyKXtpZihuW3JdKXJldHVybiBuW3JdLmV4cG9ydHM7dmFyIGk9bltyXT17ZXhwb3J0czp7fSxpZDpyLGxvYWRlZDohMX07cmV0dXJuIHRbcl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsZSksaS5sb2FkZWQ9ITAsaS5leHBvcnRzfXZhciBuPXt9O3JldHVybiBlLm09dCxlLmM9bixlLnA9XCJcIixlKDApfShbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntcImRlZmF1bHRcIjp0fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1uKDMyKSxvPXIoaSkscz1uKDI5KSxjPXIocyksYT1uKDMwKSx1PXIoYSksbD1uKDMzKSxmPXIobCksaD1uKDM0KSxkPXIoaCkscD1uKDcyKSx2PXIocCksYj1uKDcwKSx5PXIoYiksbT1uKDcxKSxnPXIobSk7big2OSk7dmFyIEU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsbil7KDAsZi5kZWZhdWx0KSh0aGlzLHQpLHRoaXMuZWw9ZSx0aGlzLmZsYXNoVGltZW91dCx0aGlzLmNvbnRlbnRFbCx0aGlzLnNjcm9sbENvbnRlbnRFbCx0aGlzLmRyYWdPZmZzZXQ9e3g6MCx5OjB9LHRoaXMuaXNWaXNpYmxlPXt4OiEwLHk6ITB9LHRoaXMuc2Nyb2xsT2Zmc2V0QXR0cj17eDpcInNjcm9sbExlZnRcIix5Olwic2Nyb2xsVG9wXCJ9LHRoaXMuc2l6ZUF0dHI9e3g6XCJvZmZzZXRXaWR0aFwiLHk6XCJvZmZzZXRIZWlnaHRcIn0sdGhpcy5zY3JvbGxTaXplQXR0cj17eDpcInNjcm9sbFdpZHRoXCIseTpcInNjcm9sbEhlaWdodFwifSx0aGlzLm9mZnNldEF0dHI9e3g6XCJsZWZ0XCIseTpcInRvcFwifSx0aGlzLmdsb2JhbE9ic2VydmVyLHRoaXMubXV0YXRpb25PYnNlcnZlcix0aGlzLnJlc2l6ZU9ic2VydmVyLHRoaXMuY3VycmVudEF4aXMsdGhpcy5vcHRpb25zPSgwLHUuZGVmYXVsdCkoe30sdC5kZWZhdWx0T3B0aW9ucyxuKSx0aGlzLmNsYXNzTmFtZXM9dGhpcy5vcHRpb25zLmNsYXNzTmFtZXMsdGhpcy5zY3JvbGxiYXJXaWR0aD0oMCx2LmRlZmF1bHQpKCksdGhpcy5vZmZzZXRTaXplPTIwLHRoaXMuZmxhc2hTY3JvbGxiYXI9dGhpcy5mbGFzaFNjcm9sbGJhci5iaW5kKHRoaXMpLHRoaXMub25EcmFnWT10aGlzLm9uRHJhZ1kuYmluZCh0aGlzKSx0aGlzLm9uRHJhZ1g9dGhpcy5vbkRyYWdYLmJpbmQodGhpcyksdGhpcy5vblNjcm9sbFk9dGhpcy5vblNjcm9sbFkuYmluZCh0aGlzKSx0aGlzLm9uU2Nyb2xsWD10aGlzLm9uU2Nyb2xsWC5iaW5kKHRoaXMpLHRoaXMuZHJhZz10aGlzLmRyYWcuYmluZCh0aGlzKSx0aGlzLm9uRW5kRHJhZz10aGlzLm9uRW5kRHJhZy5iaW5kKHRoaXMpLHRoaXMub25Nb3VzZUVudGVyPXRoaXMub25Nb3VzZUVudGVyLmJpbmQodGhpcyksdGhpcy5yZWNhbGN1bGF0ZT0oMCx5LmRlZmF1bHQpKHRoaXMucmVjYWxjdWxhdGUsMTAwLHtsZWFkaW5nOiEwLHRyYWlsaW5nOiExfSksdGhpcy5pbml0KCl9cmV0dXJuKDAsZC5kZWZhdWx0KSh0LFt7a2V5OlwiaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5lbC5TaW1wbGVCYXI9dGhpcyx0aGlzLmluaXRET00oKSx0aGlzLnNjcm9sbGJhclg9dGhpcy50cmFja1gucXVlcnlTZWxlY3RvcihcIi5cIit0aGlzLmNsYXNzTmFtZXMuc2Nyb2xsYmFyKSx0aGlzLnNjcm9sbGJhclk9dGhpcy50cmFja1kucXVlcnlTZWxlY3RvcihcIi5cIit0aGlzLmNsYXNzTmFtZXMuc2Nyb2xsYmFyKSx0aGlzLnNjcm9sbENvbnRlbnRFbC5zdHlsZS5wYWRkaW5nUmlnaHQ9KHRoaXMuc2Nyb2xsYmFyV2lkdGh8fHRoaXMub2Zmc2V0U2l6ZSkrXCJweFwiLHRoaXMuc2Nyb2xsQ29udGVudEVsLnN0eWxlLm1hcmdpbkJvdHRvbT1cIi1cIisoMip0aGlzLnNjcm9sbGJhcldpZHRofHx0aGlzLm9mZnNldFNpemUpK1wicHhcIix0aGlzLmNvbnRlbnRFbC5zdHlsZS5wYWRkaW5nQm90dG9tPSh0aGlzLnNjcm9sbGJhcldpZHRofHx0aGlzLm9mZnNldFNpemUpK1wicHhcIiwwIT09dGhpcy5zY3JvbGxiYXJXaWR0aCYmKHRoaXMuY29udGVudEVsLnN0eWxlLm1hcmdpblJpZ2h0PVwiLVwiK3RoaXMuc2Nyb2xsYmFyV2lkdGgrXCJweFwiKSx0aGlzLnJlY2FsY3VsYXRlKCksdGhpcy5pbml0TGlzdGVuZXJzKCl9fSx7a2V5OlwiaW5pdERPTVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZigoMCxjLmRlZmF1bHQpKHRoaXMuZWwuY2hpbGRyZW4pLmZpbmQoZnVuY3Rpb24oZSl7cmV0dXJuIGUuY2xhc3NMaXN0LmNvbnRhaW5zKHQuY2xhc3NOYW1lcy5zY3JvbGxDb250ZW50KX0pKXRoaXMudHJhY2tYPXRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5cIit0aGlzLmNsYXNzTmFtZXMudHJhY2srXCIuaG9yaXpvbnRhbFwiKSx0aGlzLnRyYWNrWT10aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuXCIrdGhpcy5jbGFzc05hbWVzLnRyYWNrK1wiLnZlcnRpY2FsXCIpLHRoaXMuc2Nyb2xsQ29udGVudEVsPXRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5cIit0aGlzLmNsYXNzTmFtZXMuc2Nyb2xsQ29udGVudCksdGhpcy5jb250ZW50RWw9dGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiLlwiK3RoaXMuY2xhc3NOYW1lcy5jb250ZW50KTtlbHNle2Zvcih0aGlzLnNjcm9sbENvbnRlbnRFbD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuY29udGVudEVsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5zY3JvbGxDb250ZW50RWwuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZXMuc2Nyb2xsQ29udGVudCksdGhpcy5jb250ZW50RWwuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZXMuY29udGVudCk7dGhpcy5lbC5maXJzdENoaWxkOyl0aGlzLmNvbnRlbnRFbC5hcHBlbmRDaGlsZCh0aGlzLmVsLmZpcnN0Q2hpbGQpO3RoaXMuc2Nyb2xsQ29udGVudEVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsKSx0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsQ29udGVudEVsKX1pZighdGhpcy50cmFja1h8fCF0aGlzLnRyYWNrWSl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7ZS5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy50cmFjayksbi5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy5zY3JvbGxiYXIpLGUuYXBwZW5kQ2hpbGQobiksdGhpcy50cmFja1g9ZS5jbG9uZU5vZGUoITApLHRoaXMudHJhY2tYLmNsYXNzTGlzdC5hZGQoXCJob3Jpem9udGFsXCIpLHRoaXMudHJhY2tZPWUuY2xvbmVOb2RlKCEwKSx0aGlzLnRyYWNrWS5jbGFzc0xpc3QuYWRkKFwidmVydGljYWxcIiksdGhpcy5lbC5pbnNlcnRCZWZvcmUodGhpcy50cmFja1gsdGhpcy5lbC5maXJzdENoaWxkKSx0aGlzLmVsLmluc2VydEJlZm9yZSh0aGlzLnRyYWNrWSx0aGlzLmVsLmZpcnN0Q2hpbGQpfXRoaXMuZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1zaW1wbGViYXJcIixcImluaXRcIil9fSx7a2V5OlwiaW5pdExpc3RlbmVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLm9wdGlvbnMuYXV0b0hpZGUmJnRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIix0aGlzLm9uTW91c2VFbnRlciksdGhpcy5zY3JvbGxiYXJZLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIix0aGlzLm9uRHJhZ1kpLHRoaXMuc2Nyb2xsYmFyWC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsdGhpcy5vbkRyYWdYKSx0aGlzLnNjcm9sbENvbnRlbnRFbC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpcy5vblNjcm9sbFkpLHRoaXMuY29udGVudEVsLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIix0aGlzLm9uU2Nyb2xsWCksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXImJih0aGlzLm11dGF0aW9uT2JzZXJ2ZXI9bmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oZSl7ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpeyh0LmlzQ2hpbGROb2RlKGUudGFyZ2V0KXx8ZS5hZGRlZE5vZGVzLmxlbmd0aCkmJnQucmVjYWxjdWxhdGUoKX0pfSksdGhpcy5tdXRhdGlvbk9ic2VydmVyLm9ic2VydmUodGhpcy5lbCx7YXR0cmlidXRlczohMCxjaGlsZExpc3Q6ITAsY2hhcmFjdGVyRGF0YTohMCxzdWJ0cmVlOiEwfSkpLHRoaXMucmVzaXplT2JzZXJ2ZXI9bmV3IGcuZGVmYXVsdCh0aGlzLnJlY2FsY3VsYXRlLmJpbmQodGhpcykpLHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmVsKX19LHtrZXk6XCJyZW1vdmVMaXN0ZW5lcnNcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMub3B0aW9ucy5hdXRvSGlkZSYmdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLHRoaXMub25Nb3VzZUVudGVyKSx0aGlzLnNjcm9sbGJhclgucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLHRoaXMub25EcmFnWCksdGhpcy5zY3JvbGxiYXJZLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIix0aGlzLm9uRHJhZ1kpLHRoaXMuc2Nyb2xsQ29udGVudEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIix0aGlzLm9uU2Nyb2xsWSksdGhpcy5jb250ZW50RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXMub25TY3JvbGxYKSx0aGlzLm11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpLHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpfX0se2tleTpcIm9uRHJhZ1hcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLm9uRHJhZyh0LFwieFwiKX19LHtrZXk6XCJvbkRyYWdZXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5vbkRyYWcodCxcInlcIil9fSx7a2V5Olwib25EcmFnXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOlwieVwiO3QucHJldmVudERlZmF1bHQoKTt2YXIgbj1cInlcIj09PWU/dGhpcy5zY3JvbGxiYXJZOnRoaXMuc2Nyb2xsYmFyWCxyPVwieVwiPT09ZT90LnBhZ2VZOnQucGFnZVg7dGhpcy5kcmFnT2Zmc2V0W2VdPXItbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVt0aGlzLm9mZnNldEF0dHJbZV1dLHRoaXMuY3VycmVudEF4aXM9ZSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsdGhpcy5kcmFnKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHRoaXMub25FbmREcmFnKX19LHtrZXk6XCJkcmFnXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dm9pZCAwLG49dm9pZCAwLHI9dm9pZCAwO3QucHJldmVudERlZmF1bHQoKSxcInlcIj09PXRoaXMuY3VycmVudEF4aXM/KGU9dC5wYWdlWSxuPXRoaXMudHJhY2tZLHI9dGhpcy5zY3JvbGxDb250ZW50RWwpOihlPXQucGFnZVgsbj10aGlzLnRyYWNrWCxyPXRoaXMuY29udGVudEVsKTt2YXIgaT1lLW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbdGhpcy5vZmZzZXRBdHRyW3RoaXMuY3VycmVudEF4aXNdXS10aGlzLmRyYWdPZmZzZXRbdGhpcy5jdXJyZW50QXhpc10sbz1pL25bdGhpcy5zaXplQXR0clt0aGlzLmN1cnJlbnRBeGlzXV0scz1vKnRoaXMuY29udGVudEVsW3RoaXMuc2Nyb2xsU2l6ZUF0dHJbdGhpcy5jdXJyZW50QXhpc11dO3JbdGhpcy5zY3JvbGxPZmZzZXRBdHRyW3RoaXMuY3VycmVudEF4aXNdXT1zfX0se2tleTpcIm9uRW5kRHJhZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHRoaXMuZHJhZyksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIix0aGlzLm9uRW5kRHJhZyl9fSx7a2V5OlwicmVzaXplU2Nyb2xsYmFyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06XCJ5XCIsZT12b2lkIDAsbj12b2lkIDAscj12b2lkIDAsaT12b2lkIDAsbz12b2lkIDA7XCJ4XCI9PT10PyhlPXRoaXMudHJhY2tYLG49dGhpcy5zY3JvbGxiYXJYLHI9dGhpcy5jb250ZW50RWxbdGhpcy5zY3JvbGxPZmZzZXRBdHRyW3RdXSxpPXRoaXMuY29udGVudFNpemVYLG89dGhpcy5zY3JvbGxiYXJYU2l6ZSk6KGU9dGhpcy50cmFja1ksbj10aGlzLnNjcm9sbGJhclkscj10aGlzLnNjcm9sbENvbnRlbnRFbFt0aGlzLnNjcm9sbE9mZnNldEF0dHJbdF1dLGk9dGhpcy5jb250ZW50U2l6ZVksbz10aGlzLnNjcm9sbGJhcllTaXplKTt2YXIgcz1vL2ksYz1yLyhpLW8pLGE9TWF0aC5tYXgofn4ocyooby0yKSktMix0aGlzLm9wdGlvbnMuc2Nyb2xsYmFyTWluU2l6ZSksdT1+figoby00LWEpKmMrMik7dGhpcy5pc1Zpc2libGVbdF09bzxpLHRoaXMuaXNWaXNpYmxlW3RdPyhlLnN0eWxlLnZpc2liaWxpdHk9XCJ2aXNpYmxlXCIsXCJ4XCI9PT10PyhuLnN0eWxlLmxlZnQ9dStcInB4XCIsbi5zdHlsZS53aWR0aD1hK1wicHhcIik6KG4uc3R5bGUudG9wPXUrXCJweFwiLG4uc3R5bGUuaGVpZ2h0PWErXCJweFwiKSk6ZS5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCJ9fSx7a2V5Olwib25TY3JvbGxYXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmZsYXNoU2Nyb2xsYmFyKFwieFwiKX19LHtrZXk6XCJvblNjcm9sbFlcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZmxhc2hTY3JvbGxiYXIoXCJ5XCIpfX0se2tleTpcIm9uTW91c2VFbnRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5mbGFzaFNjcm9sbGJhcihcInhcIiksdGhpcy5mbGFzaFNjcm9sbGJhcihcInlcIil9fSx7a2V5OlwiZmxhc2hTY3JvbGxiYXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpcInlcIjt0aGlzLnJlc2l6ZVNjcm9sbGJhcih0KSx0aGlzLnNob3dTY3JvbGxiYXIodCl9fSx7a2V5Olwic2hvd1Njcm9sbGJhclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOlwieVwiO3RoaXMuaXNWaXNpYmxlW3RdJiYoXCJ4XCI9PT10P3RoaXMuc2Nyb2xsYmFyWC5jbGFzc0xpc3QuYWRkKFwidmlzaWJsZVwiKTp0aGlzLnNjcm9sbGJhclkuY2xhc3NMaXN0LmFkZChcInZpc2libGVcIiksdGhpcy5vcHRpb25zLmF1dG9IaWRlJiYoXCJudW1iZXJcIj09dHlwZW9mIHRoaXMuZmxhc2hUaW1lb3V0JiZ3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZmxhc2hUaW1lb3V0KSx0aGlzLmZsYXNoVGltZW91dD13aW5kb3cuc2V0VGltZW91dCh0aGlzLmhpZGVTY3JvbGxiYXIuYmluZCh0aGlzKSwxZTMpKSl9fSx7a2V5OlwiaGlkZVNjcm9sbGJhclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zY3JvbGxiYXJYLmNsYXNzTGlzdC5yZW1vdmUoXCJ2aXNpYmxlXCIpLHRoaXMuc2Nyb2xsYmFyWS5jbGFzc0xpc3QucmVtb3ZlKFwidmlzaWJsZVwiKSxcIm51bWJlclwiPT10eXBlb2YgdGhpcy5mbGFzaFRpbWVvdXQmJndpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5mbGFzaFRpbWVvdXQpfX0se2tleTpcInJlY2FsY3VsYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmNvbnRlbnRTaXplWD10aGlzLmNvbnRlbnRFbFt0aGlzLnNjcm9sbFNpemVBdHRyLnhdLHRoaXMuY29udGVudFNpemVZPXRoaXMuY29udGVudEVsW3RoaXMuc2Nyb2xsU2l6ZUF0dHIueV0tKHRoaXMuc2Nyb2xsYmFyV2lkdGh8fHRoaXMub2Zmc2V0U2l6ZSksdGhpcy5zY3JvbGxiYXJYU2l6ZT10aGlzLnRyYWNrWFt0aGlzLnNpemVBdHRyLnhdLHRoaXMuc2Nyb2xsYmFyWVNpemU9dGhpcy50cmFja1lbdGhpcy5zaXplQXR0ci55XSx0aGlzLnJlc2l6ZVNjcm9sbGJhcihcInhcIiksdGhpcy5yZXNpemVTY3JvbGxiYXIoXCJ5XCIpLHRoaXMub3B0aW9ucy5hdXRvSGlkZXx8KHRoaXMuc2hvd1Njcm9sbGJhcihcInhcIiksdGhpcy5zaG93U2Nyb2xsYmFyKFwieVwiKSl9fSx7a2V5OlwiZ2V0U2Nyb2xsRWxlbWVudFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2Nyb2xsQ29udGVudEVsfX0se2tleTpcImdldENvbnRlbnRFbGVtZW50XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb250ZW50RWx9fSx7a2V5OlwidW5Nb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5yZW1vdmVMaXN0ZW5lcnMoKSx0aGlzLmVsLlNpbXBsZUJhcj1udWxsfX0se2tleTpcImlzQ2hpbGROb2RlXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT10JiYodD09PXRoaXMuZWx8fHRoaXMuaXNDaGlsZE5vZGUodC5wYXJlbnROb2RlKSl9fV0sW3trZXk6XCJpbml0SHRtbEFwaVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5pbml0RE9NTG9hZGVkRWxlbWVudHM9dGhpcy5pbml0RE9NTG9hZGVkRWxlbWVudHMuYmluZCh0aGlzKSxcInVuZGVmaW5lZFwiIT10eXBlb2YgTXV0YXRpb25PYnNlcnZlciYmKHRoaXMuZ2xvYmFsT2JzZXJ2ZXI9bmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oZSl7ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpeygwLGMuZGVmYXVsdCkoZS5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpezE9PT1lLm5vZGVUeXBlJiYoZS5oYXNBdHRyaWJ1dGUoXCJkYXRhLXNpbXBsZWJhclwiKT8hZS5TaW1wbGVCYXImJm5ldyB0KGUsdC5nZXRFbE9wdGlvbnMoZSkpOigwLGMuZGVmYXVsdCkoZS5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtc2ltcGxlYmFyXVwiKSkuZm9yRWFjaChmdW5jdGlvbihlKXshZS5TaW1wbGVCYXImJm5ldyB0KGUsdC5nZXRFbE9wdGlvbnMoZSkpfSkpfSksKDAsYy5kZWZhdWx0KShlLnJlbW92ZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbih0KXsxPT09dC5ub2RlVHlwZSYmKHQuaGFzQXR0cmlidXRlKFwiZGF0YS1zaW1wbGViYXJcIik/dC5TaW1wbGVCYXImJnQuU2ltcGxlQmFyLnVuTW91bnQoKTooMCxjLmRlZmF1bHQpKHQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLXNpbXBsZWJhcl1cIikpLmZvckVhY2goZnVuY3Rpb24odCl7dC5TaW1wbGVCYXImJnQuU2ltcGxlQmFyLnVuTW91bnQoKX0pKX0pfSl9KSx0aGlzLmdsb2JhbE9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQse2NoaWxkTGlzdDohMCxzdWJ0cmVlOiEwfSkpLFwiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGV8fFwibG9hZGluZ1wiIT09ZG9jdW1lbnQucmVhZHlTdGF0ZSYmIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbD93aW5kb3cuc2V0VGltZW91dCh0aGlzLmluaXRET01Mb2FkZWRFbGVtZW50cy5iaW5kKHRoaXMpKTooZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIix0aGlzLmluaXRET01Mb2FkZWRFbGVtZW50cyksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsdGhpcy5pbml0RE9NTG9hZGVkRWxlbWVudHMpKX19LHtrZXk6XCJnZXRFbE9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgbj0oMCxvLmRlZmF1bHQpKHQuaHRtbEF0dHJpYnV0ZXMpLnJlZHVjZShmdW5jdGlvbihuLHIpe3ZhciBpPXQuaHRtbEF0dHJpYnV0ZXNbcl07cmV0dXJuIGUuaGFzQXR0cmlidXRlKGkpJiYobltyXT1KU09OLnBhcnNlKGUuZ2V0QXR0cmlidXRlKGkpfHwhMCkpLG59LHt9KTtyZXR1cm4gbn19LHtrZXk6XCJyZW1vdmVPYnNlcnZlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5nbG9iYWxPYnNlcnZlci5kaXNjb25uZWN0KCl9fSx7a2V5OlwiaW5pdERPTUxvYWRlZEVsZW1lbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXtkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLHRoaXMuaW5pdERPTUxvYWRlZEVsZW1lbnRzKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIix0aGlzLmluaXRET01Mb2FkZWRFbGVtZW50cyksKDAsYy5kZWZhdWx0KShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtc2ltcGxlYmFyXVwiKSkuZm9yRWFjaChmdW5jdGlvbihlKXtlLlNpbXBsZUJhcnx8bmV3IHQoZSx0LmdldEVsT3B0aW9ucyhlKSl9KX19LHtrZXk6XCJkZWZhdWx0T3B0aW9uc1wiLGdldDpmdW5jdGlvbigpe3JldHVybnthdXRvSGlkZTohMCxjbGFzc05hbWVzOntjb250ZW50Olwic2ltcGxlYmFyLWNvbnRlbnRcIixzY3JvbGxDb250ZW50Olwic2ltcGxlYmFyLXNjcm9sbC1jb250ZW50XCIsc2Nyb2xsYmFyOlwic2ltcGxlYmFyLXNjcm9sbGJhclwiLHRyYWNrOlwic2ltcGxlYmFyLXRyYWNrXCJ9LHNjcm9sbGJhck1pblNpemU6MjV9fX0se2tleTpcImh0bWxBdHRyaWJ1dGVzXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJue2F1dG9IaWRlOlwiZGF0YS1zaW1wbGViYXItYXV0b2hpZGVcIixzY3JvbGxiYXJNaW5TaXplOlwiZGF0YS1zaW1wbGViYXItc2Nyb2xsYmFyLW1pbi1zaXplXCJ9fX1dKSx0fSgpO2UuZGVmYXVsdD1FLEUuaW5pdEh0bWxBcGkoKSx0LmV4cG9ydHM9ZS5kZWZhdWx0fSxmdW5jdGlvbih0LGUpe3ZhciBuPXQuZXhwb3J0cz17dmVyc2lvbjpcIjIuNC4wXCJ9O1wibnVtYmVyXCI9PXR5cGVvZiBfX2UmJihfX2U9bil9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDI1KShcIndrc1wiKSxpPW4oMjgpLG89big1KS5TeW1ib2wscz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBvLGM9dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiByW3RdfHwoclt0XT1zJiZvW3RdfHwocz9vOmkpKFwiU3ltYm9sLlwiK3QpKX07Yy5zdG9yZT1yfSxmdW5jdGlvbih0LGUsbil7dC5leHBvcnRzPSFuKDgpKGZ1bmN0aW9uKCl7cmV0dXJuIDchPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcImFcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1KSxpPW4oMSksbz1uKDIwKSxzPW4oMTApLGM9XCJwcm90b3R5cGVcIixhPWZ1bmN0aW9uKHQsZSxuKXt2YXIgdSxsLGYsaD10JmEuRixkPXQmYS5HLHA9dCZhLlMsdj10JmEuUCxiPXQmYS5CLHk9dCZhLlcsbT1kP2k6aVtlXXx8KGlbZV09e30pLGc9bVtjXSxFPWQ/cjpwP3JbZV06KHJbZV18fHt9KVtjXTtkJiYobj1lKTtmb3IodSBpbiBuKWw9IWgmJkUmJnZvaWQgMCE9PUVbdV0sbCYmdSBpbiBtfHwoZj1sP0VbdV06blt1XSxtW3VdPWQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIEVbdV0/blt1XTpiJiZsP28oZixyKTp5JiZFW3VdPT1mP2Z1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKGUsbixyKXtpZih0aGlzIGluc3RhbmNlb2YgdCl7c3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbmV3IHQ7Y2FzZSAxOnJldHVybiBuZXcgdChlKTtjYXNlIDI6cmV0dXJuIG5ldyB0KGUsbil9cmV0dXJuIG5ldyB0KGUsbixyKX1yZXR1cm4gdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3JldHVybiBlW2NdPXRbY10sZX0oZik6diYmXCJmdW5jdGlvblwiPT10eXBlb2YgZj9vKEZ1bmN0aW9uLmNhbGwsZik6Zix2JiYoKG0udmlydHVhbHx8KG0udmlydHVhbD17fSkpW3VdPWYsdCZhLlImJmcmJiFnW3VdJiZzKGcsdSxmKSkpfTthLkY9MSxhLkc9MixhLlM9NCxhLlA9OCxhLkI9MTYsYS5XPTMyLGEuVT02NCxhLlI9MTI4LHQuZXhwb3J0cz1hfSxmdW5jdGlvbih0LGUpe3ZhciBuPXQuZXhwb3J0cz1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuTWF0aD09TWF0aD93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGYuTWF0aD09TWF0aD9zZWxmOkZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcIm51bWJlclwiPT10eXBlb2YgX19nJiYoX19nPW4pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big3KSxpPW4oNDQpLG89big2Mikscz1PYmplY3QuZGVmaW5lUHJvcGVydHk7ZS5mPW4oMyk/T2JqZWN0LmRlZmluZVByb3BlcnR5OmZ1bmN0aW9uKHQsZSxuKXtpZihyKHQpLGU9byhlLCEwKSxyKG4pLGkpdHJ5e3JldHVybiBzKHQsZSxuKX1jYXRjaChjKXt9aWYoXCJnZXRcImluIG58fFwic2V0XCJpbiBuKXRocm93IFR5cGVFcnJvcihcIkFjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIVwiKTtyZXR1cm5cInZhbHVlXCJpbiBuJiYodFtlXT1uLnZhbHVlKSx0fX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTMpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZighcih0KSl0aHJvdyBUeXBlRXJyb3IodCtcIiBpcyBub3QgYW4gb2JqZWN0IVwiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4hIXQoKX1jYXRjaChlKXtyZXR1cm4hMH19fSxmdW5jdGlvbih0LGUpe3ZhciBuPXt9Lmhhc093blByb3BlcnR5O3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3JldHVybiBuLmNhbGwodCxlKX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDYpLGk9bigxNik7dC5leHBvcnRzPW4oMyk/ZnVuY3Rpb24odCxlLG4pe3JldHVybiByLmYodCxlLGkoMSxuKSl9OmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdFtlXT1uLHR9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxMik7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3Qocih0KSl9fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZih2b2lkIDA9PXQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiK3QpO3JldHVybiB0fX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHQ/bnVsbCE9PXQ6XCJmdW5jdGlvblwiPT10eXBlb2YgdH19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPXt9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big1NiksaT1uKDIyKTt0LmV4cG9ydHM9T2JqZWN0LmtleXN8fGZ1bmN0aW9uKHQpe3JldHVybiByKHQsaSl9fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3JldHVybntlbnVtZXJhYmxlOiEoMSZ0KSxjb25maWd1cmFibGU6ISgyJnQpLHdyaXRhYmxlOiEoNCZ0KSx2YWx1ZTplfX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDI1KShcImtleXNcIiksaT1uKDI4KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHJbdF18fChyW3RdPWkodCkpfX0sZnVuY3Rpb24odCxlKXt2YXIgbj1NYXRoLmNlaWwscj1NYXRoLmZsb29yO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gaXNOYU4odD0rdCk/MDoodD4wP3I6bikodCl9fSxmdW5jdGlvbih0LGUpe3ZhciBuPXt9LnRvU3RyaW5nO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gbi5jYWxsKHQpLnNsaWNlKDgsLTEpfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMzkpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUsbil7aWYocih0KSx2b2lkIDA9PT1lKXJldHVybiB0O3N3aXRjaChuKXtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKG4pe3JldHVybiB0LmNhbGwoZSxuKX07Y2FzZSAyOnJldHVybiBmdW5jdGlvbihuLHIpe3JldHVybiB0LmNhbGwoZSxuLHIpfTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKG4scixpKXtyZXR1cm4gdC5jYWxsKGUsbixyLGkpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseShlLGFyZ3VtZW50cyl9fX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTMpLGk9big1KS5kb2N1bWVudCxvPXIoaSkmJnIoaS5jcmVhdGVFbGVtZW50KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIG8/aS5jcmVhdGVFbGVtZW50KHQpOnt9fX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9XCJjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2ZcIi5zcGxpdChcIixcIil9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDE5KTt0LmV4cG9ydHM9T2JqZWN0KFwielwiKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKT9PYmplY3Q6ZnVuY3Rpb24odCl7cmV0dXJuXCJTdHJpbmdcIj09cih0KT90LnNwbGl0KFwiXCIpOk9iamVjdCh0KX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDYpLmYsaT1uKDkpLG89bigyKShcInRvU3RyaW5nVGFnXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUsbil7dCYmIWkodD1uP3Q6dC5wcm90b3R5cGUsbykmJnIodCxvLHtjb25maWd1cmFibGU6ITAsdmFsdWU6ZX0pfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNSksaT1cIl9fY29yZS1qc19zaGFyZWRfX1wiLG89cltpXXx8KHJbaV09e30pO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gb1t0XXx8KG9bdF09e30pfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMjMpLGk9bigxMik7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiByKGkodCkpfX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTgpLGk9TWF0aC5taW47dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiB0PjA/aShyKHQpLDkwMDcxOTkyNTQ3NDA5OTEpOjB9fSxmdW5jdGlvbih0LGUpe3ZhciBuPTAscj1NYXRoLnJhbmRvbSgpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm5cIlN5bWJvbChcIi5jb25jYXQodm9pZCAwPT09dD9cIlwiOnQsXCIpX1wiLCgrK24rcikudG9TdHJpbmcoMzYpKX19LGZ1bmN0aW9uKHQsZSxuKXt0LmV4cG9ydHM9e1wiZGVmYXVsdFwiOm4oMzUpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih0LGUsbil7dC5leHBvcnRzPXtcImRlZmF1bHRcIjpuKDM2KSxfX2VzTW9kdWxlOiEwfX0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz17XCJkZWZhdWx0XCI6bigzNyksX19lc01vZHVsZTohMH19LGZ1bmN0aW9uKHQsZSxuKXt0LmV4cG9ydHM9e1wiZGVmYXVsdFwiOm4oMzgpLF9fZXNNb2R1bGU6ITB9fSxmdW5jdGlvbih0LGUpe1widXNlIHN0cmljdFwiO2UuX19lc01vZHVsZT0hMCxlLmRlZmF1bHQ9ZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntcImRlZmF1bHRcIjp0fX1lLl9fZXNNb2R1bGU9ITA7dmFyIGk9bigzMSksbz1yKGkpO2UuZGVmYXVsdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksKDAsby5kZWZhdWx0KSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKX0sZnVuY3Rpb24odCxlLG4pe24oNjgpLG4oNjQpLHQuZXhwb3J0cz1uKDEpLkFycmF5LmZyb219LGZ1bmN0aW9uKHQsZSxuKXtuKDY1KSx0LmV4cG9ydHM9bigxKS5PYmplY3QuYXNzaWdufSxmdW5jdGlvbih0LGUsbil7big2Nik7dmFyIHI9bigxKS5PYmplY3Q7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gci5kZWZpbmVQcm9wZXJ0eSh0LGUsbil9fSxmdW5jdGlvbih0LGUsbil7big2NyksdC5leHBvcnRzPW4oMSkuT2JqZWN0LmtleXN9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgVHlwZUVycm9yKHQrXCIgaXMgbm90IGEgZnVuY3Rpb24hXCIpO3JldHVybiB0fX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMjYpLGk9bigyNyksbz1uKDYxKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUsbixzKXt2YXIgYyxhPXIoZSksdT1pKGEubGVuZ3RoKSxsPW8ocyx1KTtpZih0JiZuIT1uKXtmb3IoO3U+bDspaWYoYz1hW2wrK10sYyE9YylyZXR1cm4hMH1lbHNlIGZvcig7dT5sO2wrKylpZigodHx8bCBpbiBhKSYmYVtsXT09PW4pcmV0dXJuIHR8fGx8fDA7cmV0dXJuIXQmJi0xfX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDE5KSxpPW4oMikoXCJ0b1N0cmluZ1RhZ1wiKSxvPVwiQXJndW1lbnRzXCI9PXIoZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKSxzPWZ1bmN0aW9uKHQsZSl7dHJ5e3JldHVybiB0W2VdfWNhdGNoKG4pe319O3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZSxuLGM7cmV0dXJuIHZvaWQgMD09PXQ/XCJVbmRlZmluZWRcIjpudWxsPT09dD9cIk51bGxcIjpcInN0cmluZ1wiPT10eXBlb2Yobj1zKGU9T2JqZWN0KHQpLGkpKT9uOm8/cihlKTpcIk9iamVjdFwiPT0oYz1yKGUpKSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5jYWxsZWU/XCJBcmd1bWVudHNcIjpjfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNiksaT1uKDE2KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe2UgaW4gdD9yLmYodCxlLGkoMCxuKSk6dFtlXT1ufX0sZnVuY3Rpb24odCxlLG4pe3QuZXhwb3J0cz1uKDUpLmRvY3VtZW50JiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnR9LGZ1bmN0aW9uKHQsZSxuKXt0LmV4cG9ydHM9IW4oMykmJiFuKDgpKGZ1bmN0aW9uKCl7cmV0dXJuIDchPU9iamVjdC5kZWZpbmVQcm9wZXJ0eShuKDIxKShcImRpdlwiKSxcImFcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYX0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxNCksaT1uKDIpKFwiaXRlcmF0b3JcIiksbz1BcnJheS5wcm90b3R5cGU7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10JiYoci5BcnJheT09PXR8fG9baV09PT10KX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDcpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUsbixpKXt0cnl7cmV0dXJuIGk/ZShyKG4pWzBdLG5bMV0pOmUobil9Y2F0Y2gobyl7dmFyIHM9dC5yZXR1cm47dGhyb3cgdm9pZCAwIT09cyYmcihzLmNhbGwodCkpLG99fX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNTIpLGk9bigxNiksbz1uKDI0KSxzPXt9O24oMTApKHMsbigyKShcIml0ZXJhdG9yXCIpLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSx0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe3QucHJvdG90eXBlPXIocyx7bmV4dDppKDEsbil9KSxvKHQsZStcIiBJdGVyYXRvclwiKX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDUwKSxpPW4oNCksbz1uKDU5KSxzPW4oMTApLGM9big5KSxhPW4oMTQpLHU9big0NyksbD1uKDI0KSxmPW4oNTUpLGg9bigyKShcIml0ZXJhdG9yXCIpLGQ9IShbXS5rZXlzJiZcIm5leHRcImluW10ua2V5cygpKSxwPVwiQEBpdGVyYXRvclwiLHY9XCJrZXlzXCIsYj1cInZhbHVlc1wiLHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuLG0sZyxFLF8pe3UobixlLG0pO3ZhciB4LE8sdyxTPWZ1bmN0aW9uKHQpe2lmKCFkJiZ0IGluIGopcmV0dXJuIGpbdF07c3dpdGNoKHQpe2Nhc2UgdjpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG4odGhpcyx0KX07Y2FzZSBiOnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgbih0aGlzLHQpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG4odGhpcyx0KX19LGs9ZStcIiBJdGVyYXRvclwiLE09Zz09YixBPSExLGo9dC5wcm90b3R5cGUsTD1qW2hdfHxqW3BdfHxnJiZqW2ddLEM9THx8UyhnKSxUPWc/TT9TKFwiZW50cmllc1wiKTpDOnZvaWQgMCx6PVwiQXJyYXlcIj09ZT9qLmVudHJpZXN8fEw6TDtpZih6JiYodz1mKHouY2FsbChuZXcgdCkpLHchPT1PYmplY3QucHJvdG90eXBlJiYobCh3LGssITApLHJ8fGModyxoKXx8cyh3LGgseSkpKSxNJiZMJiZMLm5hbWUhPT1iJiYoQT0hMCxDPWZ1bmN0aW9uKCl7cmV0dXJuIEwuY2FsbCh0aGlzKX0pLHImJiFffHwhZCYmIUEmJmpbaF18fHMoaixoLEMpLGFbZV09QyxhW2tdPXksZylpZih4PXt2YWx1ZXM6TT9DOlMoYiksa2V5czpFP0M6Uyh2KSxlbnRyaWVzOlR9LF8pZm9yKE8gaW4geClPIGluIGp8fG8oaixPLHhbT10pO2Vsc2UgaShpLlAraS5GKihkfHxBKSxlLHgpO3JldHVybiB4fX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMikoXCJpdGVyYXRvclwiKSxpPSExO3RyeXt2YXIgbz1bN11bcl0oKTtvLnJldHVybj1mdW5jdGlvbigpe2k9ITB9LEFycmF5LmZyb20obyxmdW5jdGlvbigpe3Rocm93IDJ9KX1jYXRjaChzKXt9dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7aWYoIWUmJiFpKXJldHVybiExO3ZhciBuPSExO3RyeXt2YXIgbz1bN10scz1vW3JdKCk7cy5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6bj0hMH19LG9bcl09ZnVuY3Rpb24oKXtyZXR1cm4gc30sdChvKX1jYXRjaChjKXt9cmV0dXJuIG59fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz0hMH0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMTUpLGk9big1NCksbz1uKDU3KSxzPW4oMTEpLGM9bigyMyksYT1PYmplY3QuYXNzaWduO3QuZXhwb3J0cz0hYXx8big4KShmdW5jdGlvbigpe3ZhciB0PXt9LGU9e30sbj1TeW1ib2woKSxyPVwiYWJjZGVmZ2hpamtsbW5vcHFyc3RcIjtyZXR1cm4gdFtuXT03LHIuc3BsaXQoXCJcIikuZm9yRWFjaChmdW5jdGlvbih0KXtlW3RdPXR9KSw3IT1hKHt9LHQpW25dfHxPYmplY3Qua2V5cyhhKHt9LGUpKS5qb2luKFwiXCIpIT1yfSk/ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49cyh0KSxhPWFyZ3VtZW50cy5sZW5ndGgsdT0xLGw9aS5mLGY9by5mO2E+dTspZm9yKHZhciBoLGQ9Yyhhcmd1bWVudHNbdSsrXSkscD1sP3IoZCkuY29uY2F0KGwoZCkpOnIoZCksdj1wLmxlbmd0aCxiPTA7dj5iOylmLmNhbGwoZCxoPXBbYisrXSkmJihuW2hdPWRbaF0pO3JldHVybiBufTphfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big3KSxpPW4oNTMpLG89bigyMikscz1uKDE3KShcIklFX1BST1RPXCIpLGM9ZnVuY3Rpb24oKXt9LGE9XCJwcm90b3R5cGVcIix1PWZ1bmN0aW9uKCl7dmFyIHQsZT1uKDIxKShcImlmcmFtZVwiKSxyPW8ubGVuZ3RoLGk9XCI8XCIscz1cIj5cIjtmb3IoZS5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLG4oNDMpLmFwcGVuZENoaWxkKGUpLGUuc3JjPVwiamF2YXNjcmlwdDpcIix0PWUuY29udGVudFdpbmRvdy5kb2N1bWVudCx0Lm9wZW4oKSx0LndyaXRlKGkrXCJzY3JpcHRcIitzK1wiZG9jdW1lbnQuRj1PYmplY3RcIitpK1wiL3NjcmlwdFwiK3MpLHQuY2xvc2UoKSx1PXQuRjtyLS07KWRlbGV0ZSB1W2FdW29bcl1dO3JldHVybiB1KCl9O3QuZXhwb3J0cz1PYmplY3QuY3JlYXRlfHxmdW5jdGlvbih0LGUpe3ZhciBuO3JldHVybiBudWxsIT09dD8oY1thXT1yKHQpLG49bmV3IGMsY1thXT1udWxsLG5bc109dCk6bj11KCksdm9pZCAwPT09ZT9uOmkobixlKX19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDYpLGk9big3KSxvPW4oMTUpO3QuZXhwb3J0cz1uKDMpP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzOmZ1bmN0aW9uKHQsZSl7aSh0KTtmb3IodmFyIG4scz1vKGUpLGM9cy5sZW5ndGgsYT0wO2M+YTspci5mKHQsbj1zW2ErK10sZVtuXSk7cmV0dXJuIHR9fSxmdW5jdGlvbih0LGUpe2UuZj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big5KSxpPW4oMTEpLG89bigxNykoXCJJRV9QUk9UT1wiKSxzPU9iamVjdC5wcm90b3R5cGU7dC5leHBvcnRzPU9iamVjdC5nZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24odCl7cmV0dXJuIHQ9aSh0KSxyKHQsbyk/dFtvXTpcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmNvbnN0cnVjdG9yJiZ0IGluc3RhbmNlb2YgdC5jb25zdHJ1Y3Rvcj90LmNvbnN0cnVjdG9yLnByb3RvdHlwZTp0IGluc3RhbmNlb2YgT2JqZWN0P3M6bnVsbH19LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDkpLGk9bigyNiksbz1uKDQwKSghMSkscz1uKDE3KShcIklFX1BST1RPXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciBuLGM9aSh0KSxhPTAsdT1bXTtmb3IobiBpbiBjKW4hPXMmJnIoYyxuKSYmdS5wdXNoKG4pO2Zvcig7ZS5sZW5ndGg+YTspcihjLG49ZVthKytdKSYmKH5vKHUsbil8fHUucHVzaChuKSk7cmV0dXJuIHV9fSxmdW5jdGlvbih0LGUpe2UuZj17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNCksaT1uKDEpLG89big4KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt2YXIgbj0oaS5PYmplY3R8fHt9KVt0XXx8T2JqZWN0W3RdLHM9e307c1t0XT1lKG4pLHIoci5TK3IuRipvKGZ1bmN0aW9uKCl7bigxKX0pLFwiT2JqZWN0XCIscyl9fSxmdW5jdGlvbih0LGUsbil7dC5leHBvcnRzPW4oMTApfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxOCksaT1uKDEyKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUsbil7dmFyIG8scyxjPVN0cmluZyhpKGUpKSxhPXIobiksdT1jLmxlbmd0aDtyZXR1cm4gYTwwfHxhPj11P3Q/XCJcIjp2b2lkIDA6KG89Yy5jaGFyQ29kZUF0KGEpLG88NTUyOTZ8fG8+NTYzMTl8fGErMT09PXV8fChzPWMuY2hhckNvZGVBdChhKzEpKTw1NjMyMHx8cz41NzM0Mz90P2MuY2hhckF0KGEpOm86dD9jLnNsaWNlKGEsYSsyKTooby01NTI5Njw8MTApKyhzLTU2MzIwKSs2NTUzNil9fX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oMTgpLGk9TWF0aC5tYXgsbz1NYXRoLm1pbjt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD1yKHQpLHQ8MD9pKHQrZSwwKTpvKHQsZSl9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxMyk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7aWYoIXIodCkpcmV0dXJuIHQ7dmFyIG4saTtpZihlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZihuPXQudG9TdHJpbmcpJiYhcihpPW4uY2FsbCh0KSkpcmV0dXJuIGk7aWYoXCJmdW5jdGlvblwiPT10eXBlb2Yobj10LnZhbHVlT2YpJiYhcihpPW4uY2FsbCh0KSkpcmV0dXJuIGk7aWYoIWUmJlwiZnVuY3Rpb25cIj09dHlwZW9mKG49dC50b1N0cmluZykmJiFyKGk9bi5jYWxsKHQpKSlyZXR1cm4gaTt0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIil9fSxmdW5jdGlvbih0LGUsbil7dmFyIHI9big0MSksaT1uKDIpKFwiaXRlcmF0b3JcIiksbz1uKDE0KTt0LmV4cG9ydHM9bigxKS5nZXRJdGVyYXRvck1ldGhvZD1mdW5jdGlvbih0KXtpZih2b2lkIDAhPXQpcmV0dXJuIHRbaV18fHRbXCJAQGl0ZXJhdG9yXCJdfHxvW3IodCldfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMjApLGk9big0KSxvPW4oMTEpLHM9big0NiksYz1uKDQ1KSxhPW4oMjcpLHU9big0MiksbD1uKDYzKTtpKGkuUytpLkYqIW4oNDkpKGZ1bmN0aW9uKHQpe0FycmF5LmZyb20odCl9KSxcIkFycmF5XCIse2Zyb206ZnVuY3Rpb24odCl7dmFyIGUsbixpLGYsaD1vKHQpLGQ9XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcz90aGlzOkFycmF5LHA9YXJndW1lbnRzLmxlbmd0aCx2PXA+MT9hcmd1bWVudHNbMV06dm9pZCAwLGI9dm9pZCAwIT09dix5PTAsbT1sKGgpO2lmKGImJih2PXIodixwPjI/YXJndW1lbnRzWzJdOnZvaWQgMCwyKSksdm9pZCAwPT1tfHxkPT1BcnJheSYmYyhtKSlmb3IoZT1hKGgubGVuZ3RoKSxuPW5ldyBkKGUpO2U+eTt5KyspdShuLHksYj92KGhbeV0seSk6aFt5XSk7ZWxzZSBmb3IoZj1tLmNhbGwoaCksbj1uZXcgZDshKGk9Zi5uZXh0KCkpLmRvbmU7eSsrKXUobix5LGI/cyhmLHYsW2kudmFsdWUseV0sITApOmkudmFsdWUpO3JldHVybiBuLmxlbmd0aD15LG59fSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uKDQpO3Ioci5TK3IuRixcIk9iamVjdFwiLHthc3NpZ246big1MSl9KX0sZnVuY3Rpb24odCxlLG4pe3ZhciByPW4oNCk7cihyLlMrci5GKiFuKDMpLFwiT2JqZWN0XCIse2RlZmluZVByb3BlcnR5Om4oNikuZn0pfSxmdW5jdGlvbih0LGUsbil7dmFyIHI9bigxMSksaT1uKDE1KTtuKDU4KShcImtleXNcIixmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gaShyKHQpKX19KX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oNjApKCEwKTtuKDQ4KShTdHJpbmcsXCJTdHJpbmdcIixmdW5jdGlvbih0KXt0aGlzLl90PVN0cmluZyh0KSx0aGlzLl9pPTB9LGZ1bmN0aW9uKCl7dmFyIHQsZT10aGlzLl90LG49dGhpcy5faTtyZXR1cm4gbj49ZS5sZW5ndGg/e3ZhbHVlOnZvaWQgMCxkb25lOiEwfToodD1yKGUsbiksdGhpcy5faSs9dC5sZW5ndGgse3ZhbHVlOnQsZG9uZTohMX0pfSl9LGZ1bmN0aW9uKHQsZSl7fSxmdW5jdGlvbih0LGUpeyhmdW5jdGlvbihlKXtmdW5jdGlvbiBuKHQsZSxuKXtmdW5jdGlvbiBpKGUpe3ZhciBuPXYscj1iO3JldHVybiB2PWI9dm9pZCAwLHc9ZSxtPXQuYXBwbHkocixuKX1mdW5jdGlvbiBvKHQpe3JldHVybiB3PXQsZz1zZXRUaW1lb3V0KGwsZSksUz9pKHQpOm19ZnVuY3Rpb24gYSh0KXt2YXIgbj10LU8scj10LXcsaT1lLW47cmV0dXJuIGs/XyhpLHktcik6aX1mdW5jdGlvbiB1KHQpe3ZhciBuPXQtTyxyPXQtdztyZXR1cm4gdm9pZCAwPT09T3x8bj49ZXx8bjwwfHxrJiZyPj15fWZ1bmN0aW9uIGwoKXt2YXIgdD14KCk7cmV0dXJuIHUodCk/Zih0KTp2b2lkKGc9c2V0VGltZW91dChsLGEodCkpKX1mdW5jdGlvbiBmKHQpe3JldHVybiBnPXZvaWQgMCxNJiZ2P2kodCk6KHY9Yj12b2lkIDAsbSl9ZnVuY3Rpb24gaCgpe3ZvaWQgMCE9PWcmJmNsZWFyVGltZW91dChnKSx3PTAsdj1PPWI9Zz12b2lkIDB9ZnVuY3Rpb24gZCgpe3JldHVybiB2b2lkIDA9PT1nP206Zih4KCkpfWZ1bmN0aW9uIHAoKXt2YXIgdD14KCksbj11KHQpO2lmKHY9YXJndW1lbnRzLGI9dGhpcyxPPXQsbil7aWYodm9pZCAwPT09ZylyZXR1cm4gbyhPKTtpZihrKXJldHVybiBnPXNldFRpbWVvdXQobCxlKSxpKE8pfXJldHVybiB2b2lkIDA9PT1nJiYoZz1zZXRUaW1lb3V0KGwsZSkpLG19dmFyIHYsYix5LG0sZyxPLHc9MCxTPSExLGs9ITEsTT0hMDtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoYyk7cmV0dXJuIGU9cyhlKXx8MCxyKG4pJiYoUz0hIW4ubGVhZGluZyxrPVwibWF4V2FpdFwiaW4gbix5PWs/RShzKG4ubWF4V2FpdCl8fDAsZSk6eSxNPVwidHJhaWxpbmdcImluIG4/ISFuLnRyYWlsaW5nOk0pLHAuY2FuY2VsPWgscC5mbHVzaD1kLHB9ZnVuY3Rpb24gcih0KXt2YXIgZT10eXBlb2YgdDtyZXR1cm4hIXQmJihcIm9iamVjdFwiPT1lfHxcImZ1bmN0aW9uXCI9PWUpfWZ1bmN0aW9uIGkodCl7cmV0dXJuISF0JiZcIm9iamVjdFwiPT10eXBlb2YgdH1mdW5jdGlvbiBvKHQpe3JldHVyblwic3ltYm9sXCI9PXR5cGVvZiB0fHxpKHQpJiZnLmNhbGwodCk9PXV9ZnVuY3Rpb24gcyh0KXtpZihcIm51bWJlclwiPT10eXBlb2YgdClyZXR1cm4gdDtpZihvKHQpKXJldHVybiBhO2lmKHIodCkpe3ZhciBlPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQudmFsdWVPZj90LnZhbHVlT2YoKTp0O3Q9cihlKT9lK1wiXCI6ZX1pZihcInN0cmluZ1wiIT10eXBlb2YgdClyZXR1cm4gMD09PXQ/dDordDt0PXQucmVwbGFjZShsLFwiXCIpO3ZhciBuPWgudGVzdCh0KTtyZXR1cm4gbnx8ZC50ZXN0KHQpP3AodC5zbGljZSgyKSxuPzI6OCk6Zi50ZXN0KHQpP2E6K3R9dmFyIGM9XCJFeHBlY3RlZCBhIGZ1bmN0aW9uXCIsYT1OYU4sdT1cIltvYmplY3QgU3ltYm9sXVwiLGw9L15cXHMrfFxccyskL2csZj0vXlstK10weFswLTlhLWZdKyQvaSxoPS9eMGJbMDFdKyQvaSxkPS9eMG9bMC03XSskL2kscD1wYXJzZUludCx2PVwib2JqZWN0XCI9PXR5cGVvZiBlJiZlJiZlLk9iamVjdD09PU9iamVjdCYmZSxiPVwib2JqZWN0XCI9PXR5cGVvZiBzZWxmJiZzZWxmJiZzZWxmLk9iamVjdD09PU9iamVjdCYmc2VsZix5PXZ8fGJ8fEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSxtPU9iamVjdC5wcm90b3R5cGUsZz1tLnRvU3RyaW5nLEU9TWF0aC5tYXgsXz1NYXRoLm1pbix4PWZ1bmN0aW9uKCl7cmV0dXJuIHkuRGF0ZS5ub3coKX07dC5leHBvcnRzPW59KS5jYWxsKGUsZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKSl9LGZ1bmN0aW9uKHQsZSxuKXsoZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUsbil7dC5leHBvcnRzPW4oKX0odGhpcyxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHQodCl7cmV0dXJuIHBhcnNlRmxvYXQodCl8fDB9ZnVuY3Rpb24gbihlKXt2YXIgbj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7cmV0dXJuIG4ucmVkdWNlKGZ1bmN0aW9uKG4scil7dmFyIGk9ZVtcImJvcmRlci1cIityK1wiLXdpZHRoXCJdO3JldHVybiBuK3QoaSl9LDApfWZ1bmN0aW9uIHIoZSl7Zm9yKHZhciBuPVtcInRvcFwiLFwicmlnaHRcIixcImJvdHRvbVwiLFwibGVmdFwiXSxyPXt9LGk9MCxvPW47aTxvLmxlbmd0aDtpKz0xKXt2YXIgcz1vW2ldLGM9ZVtcInBhZGRpbmctXCIrc107cltzXT10KGMpfXJldHVybiByfWZ1bmN0aW9uIGkodCl7dmFyIGU9dC5nZXRCQm94KCk7cmV0dXJuIHUoMCwwLGUud2lkdGgsZS5oZWlnaHQpfWZ1bmN0aW9uIG8oZSl7dmFyIGk9ZS5jbGllbnRXaWR0aCxvPWUuY2xpZW50SGVpZ2h0O2lmKCFpJiYhbylyZXR1cm4geDt2YXIgYz1nZXRDb21wdXRlZFN0eWxlKGUpLGE9cihjKSxsPWEubGVmdCthLnJpZ2h0LGY9YS50b3ArYS5ib3R0b20saD10KGMud2lkdGgpLGQ9dChjLmhlaWdodCk7aWYoXCJib3JkZXItYm94XCI9PT1jLmJveFNpemluZyYmKE1hdGgucm91bmQoaCtsKSE9PWkmJihoLT1uKGMsXCJsZWZ0XCIsXCJyaWdodFwiKStsKSxNYXRoLnJvdW5kKGQrZikhPT1vJiYoZC09bihjLFwidG9wXCIsXCJib3R0b21cIikrZikpLCFzKGUpKXt2YXIgcD1NYXRoLnJvdW5kKGgrbCktaSx2PU1hdGgucm91bmQoZCtmKS1vOzEhPT1NYXRoLmFicyhwKSYmKGgtPXApLDEhPT1NYXRoLmFicyh2KSYmKGQtPXYpfXJldHVybiB1KGEubGVmdCxhLnRvcCxoLGQpfWZ1bmN0aW9uIHModCl7cmV0dXJuIHQ9PT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnR9ZnVuY3Rpb24gYyh0KXtyZXR1cm4gaD9PKHQpP2kodCk6byh0KTp4fWZ1bmN0aW9uIGEodCl7dmFyIGU9dC54LG49dC55LHI9dC53aWR0aCxpPXQuaGVpZ2h0LG89XCJmdW5jdGlvblwiPT10eXBlb2YgRE9NUmVjdFJlYWRPbmx5P0RPTVJlY3RSZWFkT25seTpPYmplY3Qscz1PYmplY3QuY3JlYXRlKG8ucHJvdG90eXBlKTtyZXR1cm4gXyhzLHt4OmUseTpuLHdpZHRoOnIsaGVpZ2h0OmksdG9wOm4scmlnaHQ6ZStyLGJvdHRvbTppK24sbGVmdDplfSksc31mdW5jdGlvbiB1KHQsZSxuLHIpe3JldHVybnt4OnQseTplLHdpZHRoOm4saGVpZ2h0OnJ9fXZhciBsPWZ1bmN0aW9uKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGUmJmUuTWF0aD09PU1hdGg/ZTpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmc2VsZi5NYXRoPT09TWF0aD9zZWxmOlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5NYXRoPT09TWF0aD93aW5kb3c6RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfSgpLGY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dmFyIG49LTE7cmV0dXJuIHQuc29tZShmdW5jdGlvbih0LHIpe3JldHVybiB0WzBdPT09ZSYmKG49ciwhMCl9KSxufXJldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGwuTWFwP2wuTWFwOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3RoaXMuX19lbnRyaWVzX189W119dmFyIG49e3NpemU6e319O3JldHVybiBuLnNpemUuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX19lbnRyaWVzX18ubGVuZ3RofSxlLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oZSl7dmFyIG49dCh0aGlzLl9fZW50cmllc19fLGUpLHI9dGhpcy5fX2VudHJpZXNfX1tuXTtyZXR1cm4gciYmclsxXX0sZS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGUsbil7dmFyIHI9dCh0aGlzLl9fZW50cmllc19fLGUpO35yP3RoaXMuX19lbnRyaWVzX19bcl1bMV09bjp0aGlzLl9fZW50cmllc19fLnB1c2goW2Usbl0pfSxlLnByb3RvdHlwZS5kZWxldGU9ZnVuY3Rpb24oZSl7dmFyIG49dGhpcy5fX2VudHJpZXNfXyxyPXQobixlKTt+ciYmbi5zcGxpY2UociwxKX0sZS5wcm90b3R5cGUuaGFzPWZ1bmN0aW9uKGUpe3JldHVybiEhfnQodGhpcy5fX2VudHJpZXNfXyxlKX0sZS5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLl9fZW50cmllc19fLnNwbGljZSgwKX0sZS5wcm90b3R5cGUuZm9yRWFjaD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7dm9pZCAwPT09ZSYmKGU9bnVsbCk7Zm9yKHZhciByPTAsaT1uLl9fZW50cmllc19fO3I8aS5sZW5ndGg7cis9MSl7dmFyIG89aVtyXTt0LmNhbGwoZSxvWzFdLG9bMF0pfX0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsbiksZX0oKX0oKSxoPWwud2luZG93PT09bCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50LGQ9ZnVuY3Rpb24oKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU/cmVxdWVzdEFuaW1hdGlvbkZyYW1lOmZ1bmN0aW9uKHQpe3JldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIHQoRGF0ZS5ub3coKSl9LDFlMy82MCl9fSgpLHA9Mix2PWZ1bmN0aW9uKCl7dmFyIHQ9RGF0ZTtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgcGVyZm9ybWFuY2UmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHBlcmZvcm1hbmNlLm5vdyYmKHQ9cGVyZm9ybWFuY2UpLGZ1bmN0aW9uKCl7cmV0dXJuIHQubm93KCl9fSgpLGI9ZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIoKXtzPSExLHQoKSxjJiZvKCl9ZnVuY3Rpb24gaSgpe24/ZChyKTpyKCl9ZnVuY3Rpb24gbygpe3ZhciB0PXYoKTtpZihzKXtpZih0LWE8cClyZXR1cm47Yz0hMH1lbHNlIHM9ITAsYz0hMSxzZXRUaW1lb3V0KGksZSk7YT10fXZvaWQgMD09PW4mJihuPSExKTt2YXIgcz0hMSxjPSExLGE9MDtyZXR1cm4gb30seT0yMCxtPTgwLGc9XCJmdW5jdGlvblwiPT10eXBlb2YgTXV0YXRpb25PYnNlcnZlciYmXCJvYmplY3RcIj09dHlwZW9mIG5hdmlnYXRvciYmIShcIk5ldHNjYXBlXCI9PT1uYXZpZ2F0b3IuYXBwTmFtZSYmbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVHJpZGVudFxcLy4qcnY6MTEvKSksRT1mdW5jdGlvbigpe3RoaXMuaXNDeWNsZUNvbnRpbnVvdXNfPSFnLHRoaXMubGlzdGVuZXJzRW5hYmxlZF89ITEsdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl89bnVsbCx0aGlzLm9ic2VydmVyc189W10sdGhpcy5yZWZyZXNoPWIodGhpcy5yZWZyZXNoLmJpbmQodGhpcykseSwhMCksdGhpcy5jb250aW51b3VzVXBkYXRlSGFuZGxlcl89Yih0aGlzLnJlZnJlc2gsbSl9O0UucHJvdG90eXBlLmNvbm5lY3Q9ZnVuY3Rpb24odCl7dGhpcy5pc0Nvbm5lY3RlZCh0KXx8dGhpcy5vYnNlcnZlcnNfLnB1c2godCksdGhpcy5saXN0ZW5lcnNFbmFibGVkX3x8dGhpcy5hZGRMaXN0ZW5lcnNfKCl9LEUucHJvdG90eXBlLmRpc2Nvbm5lY3Q9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5vYnNlcnZlcnNfLG49ZS5pbmRleE9mKHQpO35uJiZlLnNwbGljZShuLDEpLCFlLmxlbmd0aCYmdGhpcy5saXN0ZW5lcnNFbmFibGVkXyYmdGhpcy5yZW1vdmVMaXN0ZW5lcnNfKCl9LEUucHJvdG90eXBlLmlzQ29ubmVjdGVkPWZ1bmN0aW9uKHQpe3JldHVybiEhfnRoaXMub2JzZXJ2ZXJzXy5pbmRleE9mKHQpfSxFLnByb3RvdHlwZS5yZWZyZXNoPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy51cGRhdGVPYnNlcnZlcnNfKCk7dD90aGlzLnJlZnJlc2goKTp0aGlzLmlzQ3ljbGVDb250aW51b3VzXyYmdGhpcy5saXN0ZW5lcnNFbmFibGVkXyYmdGhpcy5jb250aW51b3VzVXBkYXRlSGFuZGxlcl8oKX0sRS5wcm90b3R5cGUudXBkYXRlT2JzZXJ2ZXJzXz1mdW5jdGlvbigpe3ZhciB0PXRoaXMub2JzZXJ2ZXJzXy5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2F0aGVyQWN0aXZlKCksdC5oYXNBY3RpdmUoKX0pO3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHQuYnJvYWRjYXN0QWN0aXZlKCl9KSx0Lmxlbmd0aD4wfSxFLnByb3RvdHlwZS5hZGRMaXN0ZW5lcnNfPWZ1bmN0aW9uKCl7aCYmIXRoaXMubGlzdGVuZXJzRW5hYmxlZF8mJih3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHRoaXMucmVmcmVzaCksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIix0aGlzLnJlZnJlc2gpLGcmJih0aGlzLm11dGF0aW9uc09ic2VydmVyXz1uZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLnJlZnJlc2gpLHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLm9ic2VydmUoZG9jdW1lbnQse2F0dHJpYnV0ZXM6ITAsY2hpbGRMaXN0OiEwLGNoYXJhY3RlckRhdGE6ITAsc3VidHJlZTohMH0pKSx0aGlzLmxpc3RlbmVyc0VuYWJsZWRfPSEwLHRoaXMuaXNDeWNsZUNvbnRpbnVvdXNfJiZ0aGlzLnJlZnJlc2goKSl9LEUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyc189ZnVuY3Rpb24oKXtoJiZ0aGlzLmxpc3RlbmVyc0VuYWJsZWRfJiYod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIix0aGlzLnJlZnJlc2gpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsdGhpcy5yZWZyZXNoKSx0aGlzLm11dGF0aW9uc09ic2VydmVyXyYmdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8uZGlzY29ubmVjdCgpLHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfPW51bGwsdGhpcy5saXN0ZW5lcnNFbmFibGVkXz0hMSl9O3ZhciBfPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTAscj1PYmplY3Qua2V5cyhlKTtuPHIubGVuZ3RoO24rPTEpe3ZhciBpPXJbbl07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaSx7dmFsdWU6ZVtpXSxlbnVtZXJiYWxlOiExLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pfXJldHVybiB0fSx4PXUoMCwwLDAsMCksTz1mdW5jdGlvbigpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIFNWR0dyYXBoaWNzRWxlbWVudD9mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFNWR0dyYXBoaWNzRWxlbWVudH06ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBTVkdFbGVtZW50JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmdldEJCb3h9fSgpLHc9ZnVuY3Rpb24odCl7dGhpcy50YXJnZXQ9dCx0aGlzLmJyb2FkY2FzdFdpZHRoPTAsdGhpcy5icm9hZGNhc3RIZWlnaHQ9MCx0aGlzLmNvbnRlbnRSZWN0Xz11KDAsMCwwLDApfTt3LnByb3RvdHlwZS5pc0FjdGl2ZT1mdW5jdGlvbigpe3ZhciB0PWModGhpcy50YXJnZXQpO3JldHVybiB0aGlzLmNvbnRlbnRSZWN0Xz10LHQud2lkdGghPT10aGlzLmJyb2FkY2FzdFdpZHRofHx0LmhlaWdodCE9PXRoaXMuYnJvYWRjYXN0SGVpZ2h0fSx3LnByb3RvdHlwZS5icm9hZGNhc3RSZWN0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jb250ZW50UmVjdF87cmV0dXJuIHRoaXMuYnJvYWRjYXN0V2lkdGg9dC53aWR0aCx0aGlzLmJyb2FkY2FzdEhlaWdodD10LmhlaWdodCx0fTt2YXIgUz1mdW5jdGlvbih0LGUpe3ZhciBuPWEoZSk7Xyh0aGlzLHt0YXJnZXQ6dCxjb250ZW50UmVjdDpufSl9LGs9ZnVuY3Rpb24odCxlLG4pe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi5cIik7dGhpcy5hY3RpdmVUYXJnZXRzXz1bXSx0aGlzLm9ic2VydmF0aW9uVGFyZ2V0c189bmV3IGYsdGhpcy5jYWxsYmFja189dCx0aGlzLmNvbnRyb2xsZXJfPWUsdGhpcy5jYWxsYmFja0N0eF89bn07ay5wcm90b3R5cGUub2JzZXJ2ZT1mdW5jdGlvbih0KXtpZighYXJndW1lbnRzLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LlwiKTtpZihcIkVsZW1lbnRcImluIGwmJkVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3Qpe2lmKCEodCBpbnN0YW5jZW9mIEVsZW1lbnQpKXRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlIFwiRWxlbWVudFwiLicpO3ZhciBlPXRoaXMub2JzZXJ2YXRpb25UYXJnZXRzXztlLmhhcyh0KXx8KGUuc2V0KHQsbmV3IHcodCkpLHRoaXMuY29udHJvbGxlcl8uaXNDb25uZWN0ZWQodGhpcyl8fHRoaXMuY29udHJvbGxlcl8uY29ubmVjdCh0aGlzKSx0aGlzLmNvbnRyb2xsZXJfLnJlZnJlc2goKSl9fSxrLnByb3RvdHlwZS51bm9ic2VydmU9ZnVuY3Rpb24odCl7aWYoIWFyZ3VtZW50cy5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIjEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC5cIik7aWYoXCJFbGVtZW50XCJpbiBsJiZFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KXtpZighKHQgaW5zdGFuY2VvZiBFbGVtZW50KSl0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTt2YXIgZT10aGlzLm9ic2VydmF0aW9uVGFyZ2V0c187ZS5oYXModCkmJihlLmRlbGV0ZSh0KSxlLnNpemV8fHRoaXMuY29udHJvbGxlcl8uZGlzY29ubmVjdCh0aGlzKSl9fSxrLnByb3RvdHlwZS5kaXNjb25uZWN0PWZ1bmN0aW9uKCl7dGhpcy5jbGVhckFjdGl2ZSgpLHRoaXMub2JzZXJ2YXRpb25UYXJnZXRzXy5jbGVhcigpLHRoaXMuY29udHJvbGxlcl8uZGlzY29ubmVjdCh0aGlzKX0say5wcm90b3R5cGUuZ2F0aGVyQWN0aXZlPWZ1bmN0aW9uKCl7dGhpcy5jbGVhckFjdGl2ZSgpO3ZhciB0PXRoaXMuYWN0aXZlVGFyZ2V0c187dGhpcy5vYnNlcnZhdGlvblRhcmdldHNfLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5pc0FjdGl2ZSgpJiZ0LnB1c2goZSl9KX0say5wcm90b3R5cGUuYnJvYWRjYXN0QWN0aXZlPWZ1bmN0aW9uKCl7aWYodGhpcy5oYXNBY3RpdmUoKSl7dmFyIHQ9dGhpcy5jYWxsYmFja0N0eF8sZT10aGlzLmFjdGl2ZVRhcmdldHNfLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IFModC50YXJnZXQsdC5icm9hZGNhc3RSZWN0KCkpfSk7dGhpcy5jYWxsYmFja18uY2FsbCh0LGUsdCksdGhpcy5jbGVhckFjdGl2ZSgpfX0say5wcm90b3R5cGUuY2xlYXJBY3RpdmU9ZnVuY3Rpb24oKXt0aGlzLmFjdGl2ZVRhcmdldHNfLnNwbGljZSgwKX0say5wcm90b3R5cGUuaGFzQWN0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWN0aXZlVGFyZ2V0c18ubGVuZ3RoPjB9O3ZhciBNPW5ldyBFLEE9XCJmdW5jdGlvblwiPT10eXBlb2YgV2Vha01hcD9uZXcgV2Vha01hcDpuZXcgZixqPWZ1bmN0aW9uKHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIGopKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7aWYoIWFyZ3VtZW50cy5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIjEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC5cIik7dmFyIGU9bmV3IGsodCxNLHRoaXMpO0Euc2V0KHRoaXMsZSl9O1tcIm9ic2VydmVcIixcInVub2JzZXJ2ZVwiLFwiZGlzY29ubmVjdFwiXS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2oucHJvdG90eXBlW3RdPWZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuKGU9QS5nZXQodGhpcykpW3RdLmFwcGx5KGUsYXJndW1lbnRzKX19KTt2YXIgTD1mdW5jdGlvbigpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGwuUmVzaXplT2JzZXJ2ZXI/bC5SZXNpemVPYnNlcnZlcjpqfSgpO3JldHVybiBMfSl9KS5jYWxsKGUsZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKSl9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpLG87LyohIHNjcm9sbGJhcldpZHRoLmpzIHYwLjEuMCB8IGZlbGl4ZXh0ZXIgfCBNSVQgfCBodHRwczovL2dpdGh1Yi5jb20vZmVsaXhleHRlci9zY3JvbGxiYXJXaWR0aCAqL1xuIWZ1bmN0aW9uKG4scyl7aT1bXSxyPXMsbz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByP3IuYXBwbHkoZSxpKTpyLCEodm9pZCAwIT09byYmKHQuZXhwb3J0cz1vKSl9KHRoaXMsZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KCl7dmFyIHQsZT1kb2N1bWVudC5ib2R5LG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxyPW4uc3R5bGU7cmV0dXJuIHIucG9zaXRpb249XCJhYnNvbHV0ZVwiLHIudG9wPXIubGVmdD1cIi05OTk5cHhcIixyLndpZHRoPXIuaGVpZ2h0PVwiMTAwcHhcIixyLm92ZXJmbG93PVwic2Nyb2xsXCIsZS5hcHBlbmRDaGlsZChuKSx0PW4ub2Zmc2V0V2lkdGgtbi5jbGllbnRXaWR0aCxlLnJlbW92ZUNoaWxkKG4pLHR9cmV0dXJuIHR9KX1dKX0pOyIsIiFmdW5jdGlvbihlLG4pe1wiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiZXhwb3J0c1wiXSxuKTpuKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBleHBvcnRzP2V4cG9ydHM6ZS5kcmFnc2Nyb2xsPXt9KX0odGhpcyxmdW5jdGlvbihlKXt2YXIgbix0LG89d2luZG93LGw9ZG9jdW1lbnQsYz1cIm1vdXNlbW92ZVwiLHI9XCJtb3VzZXVwXCIsaT1cIm1vdXNlZG93blwiLG09XCJFdmVudExpc3RlbmVyXCIsZD1cImFkZFwiK20scz1cInJlbW92ZVwiK20sZj1bXSx1PWZ1bmN0aW9uKGUsbSl7Zm9yKGU9MDtlPGYubGVuZ3RoOyltPWZbZSsrXSxtPW0uY29udGFpbmVyfHxtLG1bc10oaSxtLm1kLDApLG9bc10ocixtLm11LDApLG9bc10oYyxtLm1tLDApO2ZvcihmPVtdLnNsaWNlLmNhbGwobC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZHJhZ3Njcm9sbFwiKSksZT0wO2U8Zi5sZW5ndGg7KSFmdW5jdGlvbihlLG0scyxmLHUsYSl7KGE9ZS5jb250YWluZXJ8fGUpW2RdKGksYS5tZD1mdW5jdGlvbihuKXtlLmhhc0F0dHJpYnV0ZShcIm5vY2hpbGRkcmFnXCIpJiZsLmVsZW1lbnRGcm9tUG9pbnQobi5wYWdlWCxuLnBhZ2VZKSE9YXx8KGY9MSxtPW4uY2xpZW50WCxzPW4uY2xpZW50WSxuLnByZXZlbnREZWZhdWx0KCkpfSwwKSxvW2RdKHIsYS5tdT1mdW5jdGlvbigpe2Y9MH0sMCksb1tkXShjLGEubW09ZnVuY3Rpb24obyl7ZiYmKCh1PWUuc2Nyb2xsZXJ8fGUpLnNjcm9sbExlZnQtPW49LW0rKG09by5jbGllbnRYKSx1LnNjcm9sbFRvcC09dD0tcysocz1vLmNsaWVudFkpLGU9PWwuYm9keSYmKCh1PWwuZG9jdW1lbnRFbGVtZW50KS5zY3JvbGxMZWZ0LT1uLHUuc2Nyb2xsVG9wLT10KSl9LDApfShmW2UrK10pfTtcImNvbXBsZXRlXCI9PWwucmVhZHlTdGF0ZT91KCk6b1tkXShcImxvYWRcIix1LDApLGUucmVzZXQ9dX0pOyIsIi8qXG4gKiBUb2FzdHJcbiAqIENvcHlyaWdodCAyMDEyLTIwMTVcbiAqIEF1dGhvcnM6IEpvaG4gUGFwYSwgSGFucyBGasOkbGxlbWFyaywgYW5kIFRpbSBGZXJyZWxsLlxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFVzZSwgcmVwcm9kdWN0aW9uLCBkaXN0cmlidXRpb24sIGFuZCBtb2RpZmljYXRpb24gb2YgdGhpcyBjb2RlIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIGFuZFxuICogY29uZGl0aW9ucyBvZiB0aGUgTUlUIGxpY2Vuc2UsIGF2YWlsYWJsZSBhdCBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICpcbiAqIEFSSUEgU3VwcG9ydDogR3JldGEgS3JhZnNpZ1xuICpcbiAqIFByb2plY3Q6IGh0dHBzOi8vZ2l0aHViLmNvbS9Db2RlU2V2ZW4vdG9hc3RyXG4gKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cbihmdW5jdGlvbiAoZGVmaW5lKSB7XG4gICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZ1bmN0aW9uICgkKSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICRjb250YWluZXI7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXI7XG4gICAgICAgICAgICB2YXIgdG9hc3RJZCA9IDA7XG4gICAgICAgICAgICB2YXIgdG9hc3RUeXBlID0ge1xuICAgICAgICAgICAgICAgIGVycm9yOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIGluZm86ICdpbmZvJyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgd2FybmluZzogJ3dhcm5pbmcnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgdG9hc3RyID0ge1xuICAgICAgICAgICAgICAgIGNsZWFyOiBjbGVhcixcbiAgICAgICAgICAgICAgICByZW1vdmU6IHJlbW92ZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgZ2V0Q29udGFpbmVyOiBnZXRDb250YWluZXIsXG4gICAgICAgICAgICAgICAgaW5mbzogaW5mbyxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgICAgIHZlcnNpb246ICcyLjEuMycsXG4gICAgICAgICAgICAgICAgd2FybmluZzogd2FybmluZ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHByZXZpb3VzVG9hc3Q7XG5cbiAgICAgICAgICAgIHJldHVybiB0b2FzdHI7XG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgICAgZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgdGl0bGUsIG9wdGlvbnNPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3RpZnkoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b2FzdFR5cGUuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzczogZ2V0T3B0aW9ucygpLmljb25DbGFzc2VzLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zT3ZlcnJpZGU6IG9wdGlvbnNPdmVycmlkZSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldENvbnRhaW5lcihvcHRpb25zLCBjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHsgb3B0aW9ucyA9IGdldE9wdGlvbnMoKTsgfVxuICAgICAgICAgICAgICAgICRjb250YWluZXIgPSAkKCcjJyArIG9wdGlvbnMuY29udGFpbmVySWQpO1xuICAgICAgICAgICAgICAgIGlmICgkY29udGFpbmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAkY29udGFpbmVyID0gY3JlYXRlQ29udGFpbmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJGNvbnRhaW5lcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaW5mbyhtZXNzYWdlLCB0aXRsZSwgb3B0aW9uc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdGlmeSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRvYXN0VHlwZS5pbmZvLFxuICAgICAgICAgICAgICAgICAgICBpY29uQ2xhc3M6IGdldE9wdGlvbnMoKS5pY29uQ2xhc3Nlcy5pbmZvLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zT3ZlcnJpZGU6IG9wdGlvbnNPdmVycmlkZSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN1Y2Nlc3MobWVzc2FnZSwgdGl0bGUsIG9wdGlvbnNPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3RpZnkoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b2FzdFR5cGUuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNsYXNzOiBnZXRPcHRpb25zKCkuaWNvbkNsYXNzZXMuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc092ZXJyaWRlOiBvcHRpb25zT3ZlcnJpZGUsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UsIHRpdGxlLCBvcHRpb25zT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90aWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9hc3RUeXBlLndhcm5pbmcsXG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzczogZ2V0T3B0aW9ucygpLmljb25DbGFzc2VzLndhcm5pbmcsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNPdmVycmlkZTogb3B0aW9uc092ZXJyaWRlLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY2xlYXIoJHRvYXN0RWxlbWVudCwgY2xlYXJPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRPcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgaWYgKCEkY29udGFpbmVyKSB7IGdldENvbnRhaW5lcihvcHRpb25zKTsgfVxuICAgICAgICAgICAgICAgIGlmICghY2xlYXJUb2FzdCgkdG9hc3RFbGVtZW50LCBvcHRpb25zLCBjbGVhck9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29udGFpbmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlKCR0b2FzdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGdldE9wdGlvbnMoKTtcbiAgICAgICAgICAgICAgICBpZiAoISRjb250YWluZXIpIHsgZ2V0Q29udGFpbmVyKG9wdGlvbnMpOyB9XG4gICAgICAgICAgICAgICAgaWYgKCR0b2FzdEVsZW1lbnQgJiYgJCgnOmZvY3VzJywgJHRvYXN0RWxlbWVudCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVRvYXN0KCR0b2FzdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkY29udGFpbmVyLmNoaWxkcmVuKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICRjb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbnRlcm5hbCBmdW5jdGlvbnNcblxuICAgICAgICAgICAgZnVuY3Rpb24gY2xlYXJDb250YWluZXIgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9hc3RzVG9DbGVhciA9ICRjb250YWluZXIuY2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdG9hc3RzVG9DbGVhci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRvYXN0KCQodG9hc3RzVG9DbGVhcltpXSksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY2xlYXJUb2FzdCAoJHRvYXN0RWxlbWVudCwgb3B0aW9ucywgY2xlYXJPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcmNlID0gY2xlYXJPcHRpb25zICYmIGNsZWFyT3B0aW9ucy5mb3JjZSA/IGNsZWFyT3B0aW9ucy5mb3JjZSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICgkdG9hc3RFbGVtZW50ICYmIChmb3JjZSB8fCAkKCc6Zm9jdXMnLCAkdG9hc3RFbGVtZW50KS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnRbb3B0aW9ucy5oaWRlTWV0aG9kXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5oaWRlRHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuaGlkZUVhc2luZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7IHJlbW92ZVRvYXN0KCR0b2FzdEVsZW1lbnQpOyB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVDb250YWluZXIob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICRjb250YWluZXIgPSAkKCc8ZGl2Lz4nKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCBvcHRpb25zLmNvbnRhaW5lcklkKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3Mob3B0aW9ucy5wb3NpdGlvbkNsYXNzKTtcblxuICAgICAgICAgICAgICAgICRjb250YWluZXIuYXBwZW5kVG8oJChvcHRpb25zLnRhcmdldCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkY29udGFpbmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXREZWZhdWx0cygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0YXBUb0Rpc21pc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRvYXN0Q2xhc3M6ICd0b2FzdCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcklkOiAndG9hc3QtY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgZGVidWc6IGZhbHNlLFxuXG4gICAgICAgICAgICAgICAgICAgIHNob3dNZXRob2Q6ICdmYWRlSW4nLCAvL2ZhZGVJbiwgc2xpZGVEb3duLCBhbmQgc2hvdyBhcmUgYnVpbHQgaW50byBqUXVlcnlcbiAgICAgICAgICAgICAgICAgICAgc2hvd0R1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgICAgICAgICAgIHNob3dFYXNpbmc6ICdzd2luZycsIC8vc3dpbmcgYW5kIGxpbmVhciBhcmUgYnVpbHQgaW50byBqUXVlcnlcbiAgICAgICAgICAgICAgICAgICAgb25TaG93bjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBoaWRlTWV0aG9kOiAnZmFkZU91dCcsXG4gICAgICAgICAgICAgICAgICAgIGhpZGVEdXJhdGlvbjogMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUVhc2luZzogJ3N3aW5nJyxcbiAgICAgICAgICAgICAgICAgICAgb25IaWRkZW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VNZXRob2Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZUR1cmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VFYXNpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZU9uSG92ZXI6IHRydWUsXG5cbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRUaW1lT3V0OiAxMDAwLFxuICAgICAgICAgICAgICAgICAgICBpY29uQ2xhc3Nlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICd0b2FzdC1lcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvOiAndG9hc3QtaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiAndG9hc3Qtc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nOiAndG9hc3Qtd2FybmluZydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNsYXNzOiAndG9hc3QtaW5mbycsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQ2xhc3M6ICd0b2FzdC10b3AtcmlnaHQnLFxuICAgICAgICAgICAgICAgICAgICB0aW1lT3V0OiA1MDAwLCAvLyBTZXQgdGltZU91dCBhbmQgZXh0ZW5kZWRUaW1lT3V0IHRvIDAgdG8gbWFrZSBpdCBzdGlja3lcbiAgICAgICAgICAgICAgICAgICAgdGl0bGVDbGFzczogJ3RvYXN0LXRpdGxlJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUNsYXNzOiAndG9hc3QtbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZUh0bWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6ICdib2R5JyxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VIdG1sOiAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCI+JnRpbWVzOzwvYnV0dG9uPicsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQ2xhc3M6ICd0b2FzdC1jbG9zZS1idXR0b24nLFxuICAgICAgICAgICAgICAgICAgICBuZXdlc3RPblRvcDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudER1cGxpY2F0ZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0JhcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQ2xhc3M6ICd0b2FzdC1wcm9ncmVzcycsXG4gICAgICAgICAgICAgICAgICAgIHJ0bDogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBwdWJsaXNoKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxpc3RlbmVyKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIGxpc3RlbmVyKGFyZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBub3RpZnkobWFwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRPcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgdmFyIGljb25DbGFzcyA9IG1hcC5pY29uQ2xhc3MgfHwgb3B0aW9ucy5pY29uQ2xhc3M7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChtYXAub3B0aW9uc092ZXJyaWRlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKG9wdGlvbnMsIG1hcC5vcHRpb25zT3ZlcnJpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpY29uQ2xhc3MgPSBtYXAub3B0aW9uc092ZXJyaWRlLmljb25DbGFzcyB8fCBpY29uQ2xhc3M7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEV4aXQob3B0aW9ucywgbWFwKSkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgICAgIHRvYXN0SWQrKztcblxuICAgICAgICAgICAgICAgICRjb250YWluZXIgPSBnZXRDb250YWluZXIob3B0aW9ucywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyICR0b2FzdEVsZW1lbnQgPSAkKCc8ZGl2Lz4nKTtcbiAgICAgICAgICAgICAgICB2YXIgJHRpdGxlRWxlbWVudCA9ICQoJzxkaXYvPicpO1xuICAgICAgICAgICAgICAgIHZhciAkbWVzc2FnZUVsZW1lbnQgPSAkKCc8ZGl2Lz4nKTtcbiAgICAgICAgICAgICAgICB2YXIgJHByb2dyZXNzRWxlbWVudCA9ICQoJzxkaXYvPicpO1xuICAgICAgICAgICAgICAgIHZhciAkY2xvc2VFbGVtZW50ID0gJChvcHRpb25zLmNsb3NlSHRtbCk7XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzQmFyID0ge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbElkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtYXhIaWRlVGltZTogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICB0b2FzdElkOiB0b2FzdElkLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogJ3Zpc2libGUnLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG1hcDogbWFwXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHBlcnNvbmFsaXplVG9hc3QoKTtcblxuICAgICAgICAgICAgICAgIGRpc3BsYXlUb2FzdCgpO1xuXG4gICAgICAgICAgICAgICAgaGFuZGxlRXZlbnRzKCk7XG5cbiAgICAgICAgICAgICAgICBwdWJsaXNoKHJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlYnVnICYmIGNvbnNvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAkdG9hc3RFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZXNjYXBlSHRtbChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCAnJiMzOTsnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwZXJzb25hbGl6ZVRvYXN0KCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRJY29uKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpdGxlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldE1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q2xvc2VCdXR0b24oKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0UHJvZ3Jlc3NCYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0UlRMKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFNlcXVlbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldEFyaWEoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRBcmlhKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJpYVZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWFwLmljb25DbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndG9hc3Qtc3VjY2Vzcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0b2FzdC1pbmZvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhVmFsdWUgPSAgJ3BvbGl0ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWFWYWx1ZSA9ICdhc3NlcnRpdmUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQuYXR0cignYXJpYS1saXZlJywgYXJpYVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVFdmVudHMoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNsb3NlT25Ib3Zlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5ob3ZlcihzdGlja0Fyb3VuZCwgZGVsYXllZEhpZGVUb2FzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMub25jbGljayAmJiBvcHRpb25zLnRhcFRvRGlzbWlzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5jbGljayhoaWRlVG9hc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2xvc2VCdXR0b24gJiYgJGNsb3NlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGNsb3NlRWxlbWVudC5jbGljayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuY2FuY2VsQnViYmxlICE9PSB1bmRlZmluZWQgJiYgZXZlbnQuY2FuY2VsQnViYmxlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25DbG9zZUNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25DbG9zZUNsaWNrKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlVG9hc3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uY2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQuY2xpY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbmNsaWNrKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlVG9hc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZGlzcGxheVRvYXN0KCkge1xuICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LmhpZGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50W29wdGlvbnMuc2hvd01ldGhvZF0oXG4gICAgICAgICAgICAgICAgICAgICAgICB7ZHVyYXRpb246IG9wdGlvbnMuc2hvd0R1cmF0aW9uLCBlYXNpbmc6IG9wdGlvbnMuc2hvd0Vhc2luZywgY29tcGxldGU6IG9wdGlvbnMub25TaG93bn1cbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aW1lT3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxJZCA9IHNldFRpbWVvdXQoaGlkZVRvYXN0LCBvcHRpb25zLnRpbWVPdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NCYXIubWF4SGlkZVRpbWUgPSBwYXJzZUZsb2F0KG9wdGlvbnMudGltZU91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0Jhci5oaWRlRXRhID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBwcm9ncmVzc0Jhci5tYXhIaWRlVGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnByb2dyZXNzQmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NCYXIuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHVwZGF0ZVByb2dyZXNzLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRJY29uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLmljb25DbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5hZGRDbGFzcyhvcHRpb25zLnRvYXN0Q2xhc3MpLmFkZENsYXNzKGljb25DbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRTZXF1ZW5jZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubmV3ZXN0T25Ub3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRjb250YWluZXIucHJlcGVuZCgkdG9hc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRjb250YWluZXIuYXBwZW5kKCR0b2FzdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0VGl0bGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAudGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWZmaXggPSBtYXAudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lc2NhcGVIdG1sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gZXNjYXBlSHRtbChtYXAudGl0bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgJHRpdGxlRWxlbWVudC5hcHBlbmQoc3VmZml4KS5hZGRDbGFzcyhvcHRpb25zLnRpdGxlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5hcHBlbmQoJHRpdGxlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRNZXNzYWdlKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWZmaXggPSBtYXAubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVzY2FwZUh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSBlc2NhcGVIdG1sKG1hcC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICRtZXNzYWdlRWxlbWVudC5hcHBlbmQoc3VmZml4KS5hZGRDbGFzcyhvcHRpb25zLm1lc3NhZ2VDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LmFwcGVuZCgkbWVzc2FnZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0Q2xvc2VCdXR0b24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNsb3NlQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkY2xvc2VFbGVtZW50LmFkZENsYXNzKG9wdGlvbnMuY2xvc2VDbGFzcykuYXR0cigncm9sZScsICdidXR0b24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQucHJlcGVuZCgkY2xvc2VFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldFByb2dyZXNzQmFyKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wcm9ncmVzc0Jhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHByb2dyZXNzRWxlbWVudC5hZGRDbGFzcyhvcHRpb25zLnByb2dyZXNzQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5wcmVwZW5kKCRwcm9ncmVzc0VsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0UlRMKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ydGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQuYWRkQ2xhc3MoJ3J0bCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2hvdWxkRXhpdChvcHRpb25zLCBtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJldmVudER1cGxpY2F0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXAubWVzc2FnZSA9PT0gcHJldmlvdXNUb2FzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1RvYXN0ID0gbWFwLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhpZGVUb2FzdChvdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gb3ZlcnJpZGUgJiYgb3B0aW9ucy5jbG9zZU1ldGhvZCAhPT0gZmFsc2UgPyBvcHRpb25zLmNsb3NlTWV0aG9kIDogb3B0aW9ucy5oaWRlTWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBvdmVycmlkZSAmJiBvcHRpb25zLmNsb3NlRHVyYXRpb24gIT09IGZhbHNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2xvc2VEdXJhdGlvbiA6IG9wdGlvbnMuaGlkZUR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWFzaW5nID0gb3ZlcnJpZGUgJiYgb3B0aW9ucy5jbG9zZUVhc2luZyAhPT0gZmFsc2UgPyBvcHRpb25zLmNsb3NlRWFzaW5nIDogb3B0aW9ucy5oaWRlRWFzaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJCgnOmZvY3VzJywgJHRvYXN0RWxlbWVudCkubGVuZ3RoICYmICFvdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChwcm9ncmVzc0Jhci5pbnRlcnZhbElkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0b2FzdEVsZW1lbnRbbWV0aG9kXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IGVhc2luZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVG9hc3QoJHRvYXN0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGludGVydmFsSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uSGlkZGVuICYmIHJlc3BvbnNlLnN0YXRlICE9PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uSGlkZGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnN0YXRlID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVibGlzaChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGF5ZWRIaWRlVG9hc3QoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbWVPdXQgPiAwIHx8IG9wdGlvbnMuZXh0ZW5kZWRUaW1lT3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxJZCA9IHNldFRpbWVvdXQoaGlkZVRvYXN0LCBvcHRpb25zLmV4dGVuZGVkVGltZU91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0Jhci5tYXhIaWRlVGltZSA9IHBhcnNlRmxvYXQob3B0aW9ucy5leHRlbmRlZFRpbWVPdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NCYXIuaGlkZUV0YSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgcHJvZ3Jlc3NCYXIubWF4SGlkZVRpbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzdGlja0Fyb3VuZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGludGVydmFsSWQpO1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0Jhci5oaWRlRXRhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5zdG9wKHRydWUsIHRydWUpW29wdGlvbnMuc2hvd01ldGhvZF0oXG4gICAgICAgICAgICAgICAgICAgICAgICB7ZHVyYXRpb246IG9wdGlvbnMuc2hvd0R1cmF0aW9uLCBlYXNpbmc6IG9wdGlvbnMuc2hvd0Vhc2luZ31cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVQcm9ncmVzcygpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcmNlbnRhZ2UgPSAoKHByb2dyZXNzQmFyLmhpZGVFdGEgLSAobmV3IERhdGUoKS5nZXRUaW1lKCkpKSAvIHByb2dyZXNzQmFyLm1heEhpZGVUaW1lKSAqIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgJHByb2dyZXNzRWxlbWVudC53aWR0aChwZXJjZW50YWdlICsgJyUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBnZXREZWZhdWx0cygpLCB0b2FzdHIub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZVRvYXN0KCR0b2FzdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoISRjb250YWluZXIpIHsgJGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpOyB9XG4gICAgICAgICAgICAgICAgaWYgKCR0b2FzdEVsZW1lbnQuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICgkY29udGFpbmVyLmNoaWxkcmVuKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICRjb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVG9hc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pKCk7XG4gICAgfSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChkZXBzLCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7IC8vTm9kZVxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy50b2FzdHIgPSBmYWN0b3J5KHdpbmRvdy5qUXVlcnkpO1xuICAgIH1cbn0pKTtcbiIsIi8qKlxuICogYm9vdGJveC5qcyBbdjQuNC4wXVxuICpcbiAqIGh0dHA6Ly9ib290Ym94anMuY29tL2xpY2Vuc2UudHh0XG4gKi9cblxuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFrZXVzYWJyZXcvYm9vdGJveC9pc3N1ZXMvMTgwXG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWtldXNhYnJldy9ib290Ym94L2lzc3Vlcy8xODZcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKFtcImpxdWVyeVwiXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcbiAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcbiAgICAvLyBsaWtlIE5vZGUuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgcm9vdC5ib290Ym94ID0gZmFjdG9yeShyb290LmpRdWVyeSk7XG4gIH1cblxufSh0aGlzLCBmdW5jdGlvbiBpbml0KCQsIHVuZGVmaW5lZCkge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8vIHRoZSBiYXNlIERPTSBzdHJ1Y3R1cmUgbmVlZGVkIHRvIGNyZWF0ZSBhIG1vZGFsXG4gIHZhciB0ZW1wbGF0ZXMgPSB7XG4gICAgZGlhbG9nOlxuICAgICAgXCI8ZGl2IGNsYXNzPSdib290Ym94IG1vZGFsJyB0YWJpbmRleD0nLTEnIHJvbGU9J2RpYWxvZyc+XCIgK1xuICAgICAgICBcIjxkaXYgY2xhc3M9J21vZGFsLWRpYWxvZyc+XCIgK1xuICAgICAgICAgIFwiPGRpdiBjbGFzcz0nbW9kYWwtY29udGVudCc+XCIgK1xuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdtb2RhbC1ib2R5Jz48ZGl2IGNsYXNzPSdib290Ym94LWJvZHknPjwvZGl2PjwvZGl2PlwiICtcbiAgICAgICAgICBcIjwvZGl2PlwiICtcbiAgICAgICAgXCI8L2Rpdj5cIiArXG4gICAgICBcIjwvZGl2PlwiLFxuICAgIGhlYWRlcjpcbiAgICAgIFwiPGRpdiBjbGFzcz0nbW9kYWwtaGVhZGVyJz5cIiArXG4gICAgICAgIFwiPGg0IGNsYXNzPSdtb2RhbC10aXRsZSc+PC9oND5cIiArXG4gICAgICBcIjwvZGl2PlwiLFxuICAgIGZvb3RlcjpcbiAgICAgIFwiPGRpdiBjbGFzcz0nbW9kYWwtZm9vdGVyJz48L2Rpdj5cIixcbiAgICBjbG9zZUJ1dHRvbjpcbiAgICAgIFwiPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdib290Ym94LWNsb3NlLWJ1dHRvbiBjbG9zZScgZGF0YS1kaXNtaXNzPSdtb2RhbCcgYXJpYS1oaWRkZW49J3RydWUnPiZ0aW1lczs8L2J1dHRvbj5cIixcbiAgICBmb3JtOlxuICAgICAgXCI8Zm9ybSBjbGFzcz0nYm9vdGJveC1mb3JtJz48L2Zvcm0+XCIsXG4gICAgaW5wdXRzOiB7XG4gICAgICB0ZXh0OlxuICAgICAgICBcIjxpbnB1dCBjbGFzcz0nYm9vdGJveC1pbnB1dCBib290Ym94LWlucHV0LXRleHQgZm9ybS1jb250cm9sJyBhdXRvY29tcGxldGU9b2ZmIHR5cGU9dGV4dCAvPlwiLFxuICAgICAgdGV4dGFyZWE6XG4gICAgICAgIFwiPHRleHRhcmVhIGNsYXNzPSdib290Ym94LWlucHV0IGJvb3Rib3gtaW5wdXQtdGV4dGFyZWEgZm9ybS1jb250cm9sJz48L3RleHRhcmVhPlwiLFxuICAgICAgZW1haWw6XG4gICAgICAgIFwiPGlucHV0IGNsYXNzPSdib290Ym94LWlucHV0IGJvb3Rib3gtaW5wdXQtZW1haWwgZm9ybS1jb250cm9sJyBhdXRvY29tcGxldGU9J29mZicgdHlwZT0nZW1haWwnIC8+XCIsXG4gICAgICBzZWxlY3Q6XG4gICAgICAgIFwiPHNlbGVjdCBjbGFzcz0nYm9vdGJveC1pbnB1dCBib290Ym94LWlucHV0LXNlbGVjdCBmb3JtLWNvbnRyb2wnPjwvc2VsZWN0PlwiLFxuICAgICAgY2hlY2tib3g6XG4gICAgICAgIFwiPGRpdiBjbGFzcz0nY2hlY2tib3gnPjxsYWJlbD48aW5wdXQgY2xhc3M9J2Jvb3Rib3gtaW5wdXQgYm9vdGJveC1pbnB1dC1jaGVja2JveCcgdHlwZT0nY2hlY2tib3gnIC8+PC9sYWJlbD48L2Rpdj5cIixcbiAgICAgIGRhdGU6XG4gICAgICAgIFwiPGlucHV0IGNsYXNzPSdib290Ym94LWlucHV0IGJvb3Rib3gtaW5wdXQtZGF0ZSBmb3JtLWNvbnRyb2wnIGF1dG9jb21wbGV0ZT1vZmYgdHlwZT0nZGF0ZScgLz5cIixcbiAgICAgIHRpbWU6XG4gICAgICAgIFwiPGlucHV0IGNsYXNzPSdib290Ym94LWlucHV0IGJvb3Rib3gtaW5wdXQtdGltZSBmb3JtLWNvbnRyb2wnIGF1dG9jb21wbGV0ZT1vZmYgdHlwZT0ndGltZScgLz5cIixcbiAgICAgIG51bWJlcjpcbiAgICAgICAgXCI8aW5wdXQgY2xhc3M9J2Jvb3Rib3gtaW5wdXQgYm9vdGJveC1pbnB1dC1udW1iZXIgZm9ybS1jb250cm9sJyBhdXRvY29tcGxldGU9b2ZmIHR5cGU9J251bWJlcicgLz5cIixcbiAgICAgIHBhc3N3b3JkOlxuICAgICAgICBcIjxpbnB1dCBjbGFzcz0nYm9vdGJveC1pbnB1dCBib290Ym94LWlucHV0LXBhc3N3b3JkIGZvcm0tY29udHJvbCcgYXV0b2NvbXBsZXRlPSdvZmYnIHR5cGU9J3Bhc3N3b3JkJyAvPlwiXG4gICAgfVxuICB9O1xuXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICAvLyBkZWZhdWx0IGxhbmd1YWdlXG4gICAgbG9jYWxlOiBcImVuXCIsXG4gICAgLy8gc2hvdyBiYWNrZHJvcCBvciBub3QuIERlZmF1bHQgdG8gc3RhdGljIHNvIHVzZXIgaGFzIHRvIGludGVyYWN0IHdpdGggZGlhbG9nXG4gICAgYmFja2Ryb3A6IFwic3RhdGljXCIsXG4gICAgLy8gYW5pbWF0ZSB0aGUgbW9kYWwgaW4vb3V0XG4gICAgYW5pbWF0ZTogdHJ1ZSxcbiAgICAvLyBhZGRpdGlvbmFsIGNsYXNzIHN0cmluZyBhcHBsaWVkIHRvIHRoZSB0b3AgbGV2ZWwgZGlhbG9nXG4gICAgY2xhc3NOYW1lOiBudWxsLFxuICAgIC8vIHdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgYSBjbG9zZSBidXR0b25cbiAgICBjbG9zZUJ1dHRvbjogdHJ1ZSxcbiAgICAvLyBzaG93IHRoZSBkaWFsb2cgaW1tZWRpYXRlbHkgYnkgZGVmYXVsdFxuICAgIHNob3c6IHRydWUsXG4gICAgLy8gZGlhbG9nIGNvbnRhaW5lclxuICAgIGNvbnRhaW5lcjogXCJib2R5XCJcbiAgfTtcblxuICAvLyBvdXIgcHVibGljIG9iamVjdDsgYXVnbWVudGVkIGFmdGVyIG91ciBwcml2YXRlIEFQSVxuICB2YXIgZXhwb3J0cyA9IHt9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3Qoa2V5KSB7XG4gICAgdmFyIGxvY2FsZSA9IGxvY2FsZXNbZGVmYXVsdHMubG9jYWxlXTtcbiAgICByZXR1cm4gbG9jYWxlID8gbG9jYWxlW2tleV0gOiBsb2NhbGVzLmVuW2tleV07XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzQ2FsbGJhY2soZSwgZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLy8gYnkgZGVmYXVsdCB3ZSBhc3N1bWUgYSBjYWxsYmFjayB3aWxsIGdldCByaWQgb2YgdGhlIGRpYWxvZyxcbiAgICAvLyBhbHRob3VnaCBpdCBpcyBnaXZlbiB0aGUgb3Bwb3J0dW5pdHkgdG8gb3ZlcnJpZGUgdGhpc1xuXG4gICAgLy8gc28sIGlmIHRoZSBjYWxsYmFjayBjYW4gYmUgaW52b2tlZCBhbmQgaXQgKmV4cGxpY2l0bHkgcmV0dXJucyBmYWxzZSpcbiAgICAvLyB0aGVuIHdlJ2xsIHNldCBhIGZsYWcgdG8ga2VlcCB0aGUgZGlhbG9nIGFjdGl2ZS4uLlxuICAgIHZhciBwcmVzZXJ2ZURpYWxvZyA9ICQuaXNGdW5jdGlvbihjYWxsYmFjaykgJiYgY2FsbGJhY2suY2FsbChkaWFsb2csIGUpID09PSBmYWxzZTtcblxuICAgIC8vIC4uLiBvdGhlcndpc2Ugd2UnbGwgYmluIGl0XG4gICAgaWYgKCFwcmVzZXJ2ZURpYWxvZykge1xuICAgICAgZGlhbG9nLm1vZGFsKFwiaGlkZVwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRLZXlMZW5ndGgob2JqKSB7XG4gICAgLy8gQFRPRE8gZGVmZXIgdG8gT2JqZWN0LmtleXMoeCkubGVuZ3RoIGlmIGF2YWlsYWJsZT9cbiAgICB2YXIgaywgdCA9IDA7XG4gICAgZm9yIChrIGluIG9iaikge1xuICAgICAgdCArKztcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cblxuICBmdW5jdGlvbiBlYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICAkLmVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgaXRlcmF0b3Ioa2V5LCB2YWx1ZSwgaW5kZXgrKyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzYW5pdGl6ZShvcHRpb25zKSB7XG4gICAgdmFyIGJ1dHRvbnM7XG4gICAgdmFyIHRvdGFsO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2Ugc3VwcGx5IGFuIG9iamVjdCBvZiBvcHRpb25zXCIpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2Ugc3BlY2lmeSBhIG1lc3NhZ2VcIik7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIGFueSBzdXBwbGllZCBvcHRpb25zIHRha2UgcHJlY2VkZW5jZSBvdmVyIGRlZmF1bHRzXG4gICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICBpZiAoIW9wdGlvbnMuYnV0dG9ucykge1xuICAgICAgb3B0aW9ucy5idXR0b25zID0ge307XG4gICAgfVxuXG4gICAgYnV0dG9ucyA9IG9wdGlvbnMuYnV0dG9ucztcblxuICAgIHRvdGFsID0gZ2V0S2V5TGVuZ3RoKGJ1dHRvbnMpO1xuXG4gICAgZWFjaChidXR0b25zLCBmdW5jdGlvbihrZXksIGJ1dHRvbiwgaW5kZXgpIHtcblxuICAgICAgaWYgKCQuaXNGdW5jdGlvbihidXR0b24pKSB7XG4gICAgICAgIC8vIHNob3J0IGZvcm0sIGFzc3VtZSB2YWx1ZSBpcyBvdXIgY2FsbGJhY2suIFNpbmNlIGJ1dHRvblxuICAgICAgICAvLyBpc24ndCBhbiBvYmplY3QgaXQgaXNuJ3QgYSByZWZlcmVuY2UgZWl0aGVyIHNvIHJlLWFzc2lnbiBpdFxuICAgICAgICBidXR0b24gPSBidXR0b25zW2tleV0gPSB7XG4gICAgICAgICAgY2FsbGJhY2s6IGJ1dHRvblxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBiZWZvcmUgYW55IGZ1cnRoZXIgY2hlY2tzIG1ha2Ugc3VyZSBieSBub3cgYnV0dG9uIGlzIHRoZSBjb3JyZWN0IHR5cGVcbiAgICAgIGlmICgkLnR5cGUoYnV0dG9uKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJidXR0b24gd2l0aCBrZXkgXCIgKyBrZXkgKyBcIiBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFidXR0b24ubGFiZWwpIHtcbiAgICAgICAgLy8gdGhlIGxhY2sgb2YgYW4gZXhwbGljaXQgbGFiZWwgbWVhbnMgd2UnbGwgYXNzdW1lIHRoZSBrZXkgaXMgZ29vZCBlbm91Z2hcbiAgICAgICAgYnV0dG9uLmxhYmVsID0ga2V5O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWJ1dHRvbi5jbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKHRvdGFsIDw9IDIgJiYgaW5kZXggPT09IHRvdGFsLTEpIHtcbiAgICAgICAgICAvLyBhbHdheXMgYWRkIGEgcHJpbWFyeSB0byB0aGUgbWFpbiBvcHRpb24gaW4gYSB0d28tYnV0dG9uIGRpYWxvZ1xuICAgICAgICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcImJ0bi1wcmltYXJ5XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnV0dG9uLmNsYXNzTmFtZSA9IFwiYnRuLWRlZmF1bHRcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogbWFwIGEgZmxleGlibGUgc2V0IG9mIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIHJldHVybmVkIG9iamVjdFxuICAgKiBpZiBhcmdzLmxlbmd0aCBpcyBhbHJlYWR5IG9uZSBqdXN0IHJldHVybiBpdCwgb3RoZXJ3aXNlXG4gICAqIHVzZSB0aGUgcHJvcGVydGllcyBhcmd1bWVudCB0byBtYXAgdGhlIHVubmFtZWQgYXJncyB0b1xuICAgKiBvYmplY3QgcHJvcGVydGllc1xuICAgKiBzbyBpbiB0aGUgbGF0dGVyIGNhc2U6XG4gICAqIG1hcEFyZ3VtZW50cyhbXCJmb29cIiwgJC5ub29wXSwgW1wibWVzc2FnZVwiLCBcImNhbGxiYWNrXCJdKVxuICAgKiAtPiB7IG1lc3NhZ2U6IFwiZm9vXCIsIGNhbGxiYWNrOiAkLm5vb3AgfVxuICAgKi9cbiAgZnVuY3Rpb24gbWFwQXJndW1lbnRzKGFyZ3MsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgYXJnbiA9IGFyZ3MubGVuZ3RoO1xuICAgIHZhciBvcHRpb25zID0ge307XG5cbiAgICBpZiAoYXJnbiA8IDEgfHwgYXJnbiA+IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnQgbGVuZ3RoXCIpO1xuICAgIH1cblxuICAgIGlmIChhcmduID09PSAyIHx8IHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBvcHRpb25zW3Byb3BlcnRpZXNbMF1dID0gYXJnc1swXTtcbiAgICAgIG9wdGlvbnNbcHJvcGVydGllc1sxXV0gPSBhcmdzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gYXJnc1swXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBtZXJnZSBhIHNldCBvZiBkZWZhdWx0IGRpYWxvZyBvcHRpb25zIHdpdGggdXNlciBzdXBwbGllZCBhcmd1bWVudHNcbiAgICovXG4gIGZ1bmN0aW9uIG1lcmdlQXJndW1lbnRzKGRlZmF1bHRzLCBhcmdzLCBwcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuICQuZXh0ZW5kKFxuICAgICAgLy8gZGVlcCBtZXJnZVxuICAgICAgdHJ1ZSxcbiAgICAgIC8vIGVuc3VyZSB0aGUgdGFyZ2V0IGlzIGFuIGVtcHR5LCB1bnJlZmVyZW5jZWQgb2JqZWN0XG4gICAgICB7fSxcbiAgICAgIC8vIHRoZSBiYXNlIG9wdGlvbnMgb2JqZWN0IGZvciB0aGlzIHR5cGUgb2YgZGlhbG9nIChvZnRlbiBqdXN0IGJ1dHRvbnMpXG4gICAgICBkZWZhdWx0cyxcbiAgICAgIC8vIGFyZ3MgY291bGQgYmUgYW4gb2JqZWN0IG9yIGFycmF5OyBpZiBpdCdzIGFuIGFycmF5IHByb3BlcnRpZXMgd2lsbFxuICAgICAgLy8gbWFwIGl0IHRvIGEgcHJvcGVyIG9wdGlvbnMgb2JqZWN0XG4gICAgICBtYXBBcmd1bWVudHMoXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIHByb3BlcnRpZXNcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIHRoaXMgZW50cnktbGV2ZWwgbWV0aG9kIG1ha2VzIGhlYXZ5IHVzZSBvZiBjb21wb3NpdGlvbiB0byB0YWtlIGEgc2ltcGxlXG4gICAqIHJhbmdlIG9mIGlucHV0cyBhbmQgcmV0dXJuIHZhbGlkIG9wdGlvbnMgc3VpdGFibGUgZm9yIHBhc3NpbmcgdG8gYm9vdGJveC5kaWFsb2dcbiAgICovXG4gIGZ1bmN0aW9uIG1lcmdlRGlhbG9nT3B0aW9ucyhjbGFzc05hbWUsIGxhYmVscywgcHJvcGVydGllcywgYXJncykge1xuICAgIC8vICBidWlsZCB1cCBhIGJhc2Ugc2V0IG9mIGRpYWxvZyBwcm9wZXJ0aWVzXG4gICAgdmFyIGJhc2VPcHRpb25zID0ge1xuICAgICAgY2xhc3NOYW1lOiBcImJvb3Rib3gtXCIgKyBjbGFzc05hbWUsXG4gICAgICBidXR0b25zOiBjcmVhdGVMYWJlbHMuYXBwbHkobnVsbCwgbGFiZWxzKVxuICAgIH07XG5cbiAgICAvLyBlbnN1cmUgdGhlIGJ1dHRvbnMgcHJvcGVydGllcyBnZW5lcmF0ZWQsICphZnRlciogbWVyZ2luZ1xuICAgIC8vIHdpdGggdXNlciBhcmdzIGFyZSBzdGlsbCB2YWxpZCBhZ2FpbnN0IHRoZSBzdXBwbGllZCBsYWJlbHNcbiAgICByZXR1cm4gdmFsaWRhdGVCdXR0b25zKFxuICAgICAgLy8gbWVyZ2UgdGhlIGdlbmVyYXRlZCBiYXNlIHByb3BlcnRpZXMgd2l0aCB1c2VyIHN1cHBsaWVkIGFyZ3VtZW50c1xuICAgICAgbWVyZ2VBcmd1bWVudHMoXG4gICAgICAgIGJhc2VPcHRpb25zLFxuICAgICAgICBhcmdzLFxuICAgICAgICAvLyBpZiBhcmdzLmxlbmd0aCA+IDEsIHByb3BlcnRpZXMgc3BlY2lmeSBob3cgZWFjaCBhcmcgbWFwcyB0byBhbiBvYmplY3Qga2V5XG4gICAgICAgIHByb3BlcnRpZXNcbiAgICAgICksXG4gICAgICBsYWJlbHNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIGZyb20gYSBnaXZlbiBsaXN0IG9mIGFyZ3VtZW50cyByZXR1cm4gYSBzdWl0YWJsZSBvYmplY3Qgb2YgYnV0dG9uIGxhYmVsc1xuICAgKiBhbGwgdGhpcyBkb2VzIGlzIG5vcm1hbGlzZSB0aGUgZ2l2ZW4gbGFiZWxzIGFuZCB0cmFuc2xhdGUgdGhlbSB3aGVyZSBwb3NzaWJsZVxuICAgKiBlLmcuIFwib2tcIiwgXCJjb25maXJtXCIgLT4geyBvazogXCJPSywgY2FuY2VsOiBcIkFubnVsZXJlblwiIH1cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUxhYmVscygpIHtcbiAgICB2YXIgYnV0dG9ucyA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB2YXIgYXJndW1lbnQgPSBhcmd1bWVudHNbaV07XG4gICAgICB2YXIga2V5ID0gYXJndW1lbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50LnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgIGJ1dHRvbnNba2V5XSA9IHtcbiAgICAgICAgbGFiZWw6IF90KHZhbHVlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnV0dG9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlQnV0dG9ucyhvcHRpb25zLCBidXR0b25zKSB7XG4gICAgdmFyIGFsbG93ZWRCdXR0b25zID0ge307XG4gICAgZWFjaChidXR0b25zLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBhbGxvd2VkQnV0dG9uc1t2YWx1ZV0gPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgZWFjaChvcHRpb25zLmJ1dHRvbnMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGFsbG93ZWRCdXR0b25zW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJidXR0b24ga2V5IFwiICsga2V5ICsgXCIgaXMgbm90IGFsbG93ZWQgKG9wdGlvbnMgYXJlIFwiICsgYnV0dG9ucy5qb2luKFwiXFxuXCIpICsgXCIpXCIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cblxuICBleHBvcnRzLmFsZXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9wdGlvbnM7XG5cbiAgICBvcHRpb25zID0gbWVyZ2VEaWFsb2dPcHRpb25zKFwiYWxlcnRcIiwgW1wib2tcIl0sIFtcIm1lc3NhZ2VcIiwgXCJjYWxsYmFja1wiXSwgYXJndW1lbnRzKTtcblxuICAgIGlmIChvcHRpb25zLmNhbGxiYWNrICYmICEkLmlzRnVuY3Rpb24ob3B0aW9ucy5jYWxsYmFjaykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImFsZXJ0IHJlcXVpcmVzIGNhbGxiYWNrIHByb3BlcnR5IHRvIGJlIGEgZnVuY3Rpb24gd2hlbiBwcm92aWRlZFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBvdmVycmlkZXNcbiAgICAgKi9cbiAgICBvcHRpb25zLmJ1dHRvbnMub2suY2FsbGJhY2sgPSBvcHRpb25zLm9uRXNjYXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoJC5pc0Z1bmN0aW9uKG9wdGlvbnMuY2FsbGJhY2spKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmNhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuZGlhbG9nKG9wdGlvbnMpO1xuICB9O1xuXG4gIGV4cG9ydHMuY29uZmlybSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcHRpb25zO1xuXG4gICAgb3B0aW9ucyA9IG1lcmdlRGlhbG9nT3B0aW9ucyhcImNvbmZpcm1cIiwgW1wiY2FuY2VsXCIsIFwiY29uZmlybVwiXSwgW1wibWVzc2FnZVwiLCBcImNhbGxiYWNrXCJdLCBhcmd1bWVudHMpO1xuXG4gICAgLyoqXG4gICAgICogb3ZlcnJpZGVzOyB1bmRvIGFueXRoaW5nIHRoZSB1c2VyIHRyaWVkIHRvIHNldCB0aGV5IHNob3VsZG4ndCBoYXZlXG4gICAgICovXG4gICAgb3B0aW9ucy5idXR0b25zLmNhbmNlbC5jYWxsYmFjayA9IG9wdGlvbnMub25Fc2NhcGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpO1xuICAgIH07XG5cbiAgICBvcHRpb25zLmJ1dHRvbnMuY29uZmlybS5jYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuY2FsbGJhY2suY2FsbCh0aGlzLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLy8gY29uZmlybSBzcGVjaWZpYyB2YWxpZGF0aW9uXG4gICAgaWYgKCEkLmlzRnVuY3Rpb24ob3B0aW9ucy5jYWxsYmFjaykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbmZpcm0gcmVxdWlyZXMgYSBjYWxsYmFja1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0cy5kaWFsb2cob3B0aW9ucyk7XG4gIH07XG5cbiAgZXhwb3J0cy5wcm9tcHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3B0aW9ucztcbiAgICB2YXIgZGVmYXVsdHM7XG4gICAgdmFyIGRpYWxvZztcbiAgICB2YXIgZm9ybTtcbiAgICB2YXIgaW5wdXQ7XG4gICAgdmFyIHNob3VsZFNob3c7XG4gICAgdmFyIGlucHV0T3B0aW9ucztcblxuICAgIC8vIHdlIGhhdmUgdG8gY3JlYXRlIG91ciBmb3JtIGZpcnN0IG90aGVyd2lzZVxuICAgIC8vIGl0cyB2YWx1ZSBpcyB1bmRlZmluZWQgd2hlbiBnZWFyaW5nIHVwIG91ciBvcHRpb25zXG4gICAgLy8gQFRPRE8gdGhpcyBjb3VsZCBiZSBzb2x2ZWQgYnkgYWxsb3dpbmcgbWVzc2FnZSB0b1xuICAgIC8vIGJlIGEgZnVuY3Rpb24gaW5zdGVhZC4uLlxuICAgIGZvcm0gPSAkKHRlbXBsYXRlcy5mb3JtKTtcblxuICAgIC8vIHByb21wdCBkZWZhdWx0cyBhcmUgbW9yZSBjb21wbGV4IHRoYW4gb3RoZXJzIGluIHRoYXRcbiAgICAvLyB1c2VycyBjYW4gb3ZlcnJpZGUgbW9yZSBkZWZhdWx0c1xuICAgIC8vIEBUT0RPIEkgZG9uJ3QgbGlrZSB0aGF0IHByb21wdCBoYXMgdG8gZG8gYSBsb3Qgb2YgaGVhdnlcbiAgICAvLyBsaWZ0aW5nIHdoaWNoIG1lcmdlRGlhbG9nT3B0aW9ucyBjYW4gKmFsbW9zdCogc3VwcG9ydCBhbHJlYWR5XG4gICAgLy8ganVzdCBiZWNhdXNlIG9mICd2YWx1ZScgYW5kICdpbnB1dFR5cGUnIC0gY2FuIHdlIHJlZmFjdG9yP1xuICAgIGRlZmF1bHRzID0ge1xuICAgICAgY2xhc3NOYW1lOiBcImJvb3Rib3gtcHJvbXB0XCIsXG4gICAgICBidXR0b25zOiBjcmVhdGVMYWJlbHMoXCJjYW5jZWxcIiwgXCJjb25maXJtXCIpLFxuICAgICAgdmFsdWU6IFwiXCIsXG4gICAgICBpbnB1dFR5cGU6IFwidGV4dFwiXG4gICAgfTtcblxuICAgIG9wdGlvbnMgPSB2YWxpZGF0ZUJ1dHRvbnMoXG4gICAgICBtZXJnZUFyZ3VtZW50cyhkZWZhdWx0cywgYXJndW1lbnRzLCBbXCJ0aXRsZVwiLCBcImNhbGxiYWNrXCJdKSxcbiAgICAgIFtcImNhbmNlbFwiLCBcImNvbmZpcm1cIl1cbiAgICApO1xuXG4gICAgLy8gY2FwdHVyZSB0aGUgdXNlcidzIHNob3cgdmFsdWU7IHdlIGFsd2F5cyBzZXQgdGhpcyB0byBmYWxzZSBiZWZvcmVcbiAgICAvLyBzcGF3bmluZyB0aGUgZGlhbG9nIHRvIGdpdmUgdXMgYSBjaGFuY2UgdG8gYXR0YWNoIHNvbWUgaGFuZGxlcnMgdG9cbiAgICAvLyBpdCwgYnV0IHdlIG5lZWQgdG8gbWFrZSBzdXJlIHdlIHJlc3BlY3QgYSBwcmVmZXJlbmNlIG5vdCB0byBzaG93IGl0XG4gICAgc2hvdWxkU2hvdyA9IChvcHRpb25zLnNob3cgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogb3B0aW9ucy5zaG93O1xuXG4gICAgLyoqXG4gICAgICogb3ZlcnJpZGVzOyB1bmRvIGFueXRoaW5nIHRoZSB1c2VyIHRyaWVkIHRvIHNldCB0aGV5IHNob3VsZG4ndCBoYXZlXG4gICAgICovXG4gICAgb3B0aW9ucy5tZXNzYWdlID0gZm9ybTtcblxuICAgIG9wdGlvbnMuYnV0dG9ucy5jYW5jZWwuY2FsbGJhY2sgPSBvcHRpb25zLm9uRXNjYXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5jYWxsYmFjay5jYWxsKHRoaXMsIG51bGwpO1xuICAgIH07XG5cbiAgICBvcHRpb25zLmJ1dHRvbnMuY29uZmlybS5jYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICBzd2l0Y2ggKG9wdGlvbnMuaW5wdXRUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICBjYXNlIFwiZW1haWxcIjpcbiAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgICBjYXNlIFwidGltZVwiOlxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGNhc2UgXCJwYXNzd29yZFwiOlxuICAgICAgICAgIHZhbHVlID0gaW5wdXQudmFsKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICAgICAgdmFyIGNoZWNrZWRJdGVtcyA9IGlucHV0LmZpbmQoXCJpbnB1dDpjaGVja2VkXCIpO1xuXG4gICAgICAgICAgLy8gd2UgYXNzdW1lIHRoYXQgY2hlY2tib3hlcyBhcmUgYWx3YXlzIG11bHRpcGxlLFxuICAgICAgICAgIC8vIGhlbmNlIHdlIGRlZmF1bHQgdG8gYW4gZW1wdHkgYXJyYXlcbiAgICAgICAgICB2YWx1ZSA9IFtdO1xuXG4gICAgICAgICAgZWFjaChjaGVja2VkSXRlbXMsIGZ1bmN0aW9uKF8sIGl0ZW0pIHtcbiAgICAgICAgICAgIHZhbHVlLnB1c2goJChpdGVtKS52YWwoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHRpb25zLmNhbGxiYWNrLmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH07XG5cbiAgICBvcHRpb25zLnNob3cgPSBmYWxzZTtcblxuICAgIC8vIHByb21wdCBzcGVjaWZpYyB2YWxpZGF0aW9uXG4gICAgaWYgKCFvcHRpb25zLnRpdGxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9tcHQgcmVxdWlyZXMgYSB0aXRsZVwiKTtcbiAgICB9XG5cbiAgICBpZiAoISQuaXNGdW5jdGlvbihvcHRpb25zLmNhbGxiYWNrKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvbXB0IHJlcXVpcmVzIGEgY2FsbGJhY2tcIik7XG4gICAgfVxuXG4gICAgaWYgKCF0ZW1wbGF0ZXMuaW5wdXRzW29wdGlvbnMuaW5wdXRUeXBlXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwcm9tcHQgdHlwZVwiKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgdGhlIGlucHV0IGJhc2VkIG9uIHRoZSBzdXBwbGllZCB0eXBlXG4gICAgaW5wdXQgPSAkKHRlbXBsYXRlcy5pbnB1dHNbb3B0aW9ucy5pbnB1dFR5cGVdKTtcblxuICAgIHN3aXRjaCAob3B0aW9ucy5pbnB1dFR5cGUpIHtcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgIGNhc2UgXCJlbWFpbFwiOlxuICAgICAgY2FzZSBcImRhdGVcIjpcbiAgICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjYXNlIFwicGFzc3dvcmRcIjpcbiAgICAgICAgaW5wdXQudmFsKG9wdGlvbnMudmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICB2YXIgZ3JvdXBzID0ge307XG4gICAgICAgIGlucHV0T3B0aW9ucyA9IG9wdGlvbnMuaW5wdXRPcHRpb25zIHx8IFtdO1xuXG4gICAgICAgIGlmICghJC5pc0FycmF5KGlucHV0T3B0aW9ucykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcGFzcyBhbiBhcnJheSBvZiBpbnB1dCBvcHRpb25zXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbnB1dE9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvbXB0IHdpdGggc2VsZWN0IHJlcXVpcmVzIG9wdGlvbnNcIik7XG4gICAgICAgIH1cblxuICAgICAgICBlYWNoKGlucHV0T3B0aW9ucywgZnVuY3Rpb24oXywgb3B0aW9uKSB7XG5cbiAgICAgICAgICAvLyBhc3N1bWUgdGhlIGVsZW1lbnQgdG8gYXR0YWNoIHRvIGlzIHRoZSBpbnB1dC4uLlxuICAgICAgICAgIHZhciBlbGVtID0gaW5wdXQ7XG5cbiAgICAgICAgICBpZiAob3B0aW9uLnZhbHVlID09PSB1bmRlZmluZWQgfHwgb3B0aW9uLnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2l2ZW4gb3B0aW9ucyBpbiB3cm9uZyBmb3JtYXRcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gLi4uIGJ1dCBvdmVycmlkZSB0aGF0IGVsZW1lbnQgaWYgdGhpcyBvcHRpb24gc2l0cyBpbiBhIGdyb3VwXG5cbiAgICAgICAgICBpZiAob3B0aW9uLmdyb3VwKSB7XG4gICAgICAgICAgICAvLyBpbml0aWFsaXNlIGdyb3VwIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgaWYgKCFncm91cHNbb3B0aW9uLmdyb3VwXSkge1xuICAgICAgICAgICAgICBncm91cHNbb3B0aW9uLmdyb3VwXSA9ICQoXCI8b3B0Z3JvdXAvPlwiKS5hdHRyKFwibGFiZWxcIiwgb3B0aW9uLmdyb3VwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbSA9IGdyb3Vwc1tvcHRpb24uZ3JvdXBdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW0uYXBwZW5kKFwiPG9wdGlvbiB2YWx1ZT0nXCIgKyBvcHRpb24udmFsdWUgKyBcIic+XCIgKyBvcHRpb24udGV4dCArIFwiPC9vcHRpb24+XCIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBlYWNoKGdyb3VwcywgZnVuY3Rpb24oXywgZ3JvdXApIHtcbiAgICAgICAgICBpbnB1dC5hcHBlbmQoZ3JvdXApO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzYWZlIHRvIHNldCBhIHNlbGVjdCdzIHZhbHVlIGFzIHBlciBhIG5vcm1hbCBpbnB1dFxuICAgICAgICBpbnB1dC52YWwob3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgICAgdmFyIHZhbHVlcyAgID0gJC5pc0FycmF5KG9wdGlvbnMudmFsdWUpID8gb3B0aW9ucy52YWx1ZSA6IFtvcHRpb25zLnZhbHVlXTtcbiAgICAgICAgaW5wdXRPcHRpb25zID0gb3B0aW9ucy5pbnB1dE9wdGlvbnMgfHwgW107XG5cbiAgICAgICAgaWYgKCFpbnB1dE9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvbXB0IHdpdGggY2hlY2tib3ggcmVxdWlyZXMgb3B0aW9uc1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaW5wdXRPcHRpb25zWzBdLnZhbHVlIHx8ICFpbnB1dE9wdGlvbnNbMF0udGV4dCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdpdmVuIG9wdGlvbnMgaW4gd3JvbmcgZm9ybWF0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2tib3hlcyBoYXZlIHRvIG5lc3Qgd2l0aGluIGEgY29udGFpbmluZyBlbGVtZW50LCBzb1xuICAgICAgICAvLyB0aGV5IGJyZWFrIHRoZSBydWxlcyBhIGJpdCBhbmQgd2UgZW5kIHVwIHJlLWFzc2lnbmluZ1xuICAgICAgICAvLyBvdXIgJ2lucHV0JyBlbGVtZW50IHRvIHRoaXMgY29udGFpbmVyIGluc3RlYWRcbiAgICAgICAgaW5wdXQgPSAkKFwiPGRpdi8+XCIpO1xuXG4gICAgICAgIGVhY2goaW5wdXRPcHRpb25zLCBmdW5jdGlvbihfLCBvcHRpb24pIHtcbiAgICAgICAgICB2YXIgY2hlY2tib3ggPSAkKHRlbXBsYXRlcy5pbnB1dHNbb3B0aW9ucy5pbnB1dFR5cGVdKTtcblxuICAgICAgICAgIGNoZWNrYm94LmZpbmQoXCJpbnB1dFwiKS5hdHRyKFwidmFsdWVcIiwgb3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICBjaGVja2JveC5maW5kKFwibGFiZWxcIikuYXBwZW5kKG9wdGlvbi50ZXh0KTtcblxuICAgICAgICAgIC8vIHdlJ3ZlIGVuc3VyZWQgdmFsdWVzIGlzIGFuIGFycmF5IHNvIHdlIGNhbiBhbHdheXMgaXRlcmF0ZSBvdmVyIGl0XG4gICAgICAgICAgZWFjaCh2YWx1ZXMsIGZ1bmN0aW9uKF8sIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG9wdGlvbi52YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVja2JveC5maW5kKFwiaW5wdXRcIikucHJvcChcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpbnB1dC5hcHBlbmQoY2hlY2tib3gpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gQFRPRE8gcHJvdmlkZSBhbiBhdHRyaWJ1dGVzIG9wdGlvbiBpbnN0ZWFkXG4gICAgLy8gYW5kIHNpbXBseSBtYXAgdGhhdCBhcyBrZXlzOiB2YWxzXG4gICAgaWYgKG9wdGlvbnMucGxhY2Vob2xkZXIpIHtcbiAgICAgIGlucHV0LmF0dHIoXCJwbGFjZWhvbGRlclwiLCBvcHRpb25zLnBsYWNlaG9sZGVyKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wYXR0ZXJuKSB7XG4gICAgICBpbnB1dC5hdHRyKFwicGF0dGVyblwiLCBvcHRpb25zLnBhdHRlcm4pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm1heGxlbmd0aCkge1xuICAgICAgaW5wdXQuYXR0cihcIm1heGxlbmd0aFwiLCBvcHRpb25zLm1heGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLy8gbm93IHBsYWNlIGl0IGluIG91ciBmb3JtXG4gICAgZm9ybS5hcHBlbmQoaW5wdXQpO1xuXG4gICAgZm9ybS5vbihcInN1Ym1pdFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAvLyBGaXggZm9yIFNhbW15SlMgKG9yIHNpbWlsYXIgSlMgcm91dGluZyBsaWJyYXJ5KSBoaWphY2tpbmcgdGhlIGZvcm0gcG9zdC5cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAvLyBAVE9ETyBjYW4gd2UgYWN0dWFsbHkgY2xpY2sgKnRoZSogYnV0dG9uIG9iamVjdCBpbnN0ZWFkP1xuICAgICAgLy8gZS5nLiBidXR0b25zLmNvbmZpcm0uY2xpY2soKSBvciBzaW1pbGFyXG4gICAgICBkaWFsb2cuZmluZChcIi5idG4tcHJpbWFyeVwiKS5jbGljaygpO1xuICAgIH0pO1xuXG4gICAgZGlhbG9nID0gZXhwb3J0cy5kaWFsb2cob3B0aW9ucyk7XG5cbiAgICAvLyBjbGVhciB0aGUgZXhpc3RpbmcgaGFuZGxlciBmb2N1c2luZyB0aGUgc3VibWl0IGJ1dHRvbi4uLlxuICAgIGRpYWxvZy5vZmYoXCJzaG93bi5icy5tb2RhbFwiKTtcblxuICAgIC8vIC4uLmFuZCByZXBsYWNlIGl0IHdpdGggb25lIGZvY3VzaW5nIG91ciBpbnB1dCwgaWYgcG9zc2libGVcbiAgICBkaWFsb2cub24oXCJzaG93bi5icy5tb2RhbFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIC8vIG5lZWQgdGhlIGNsb3N1cmUgaGVyZSBzaW5jZSBpbnB1dCBpc24ndFxuICAgICAgLy8gYW4gb2JqZWN0IG90aGVyd2lzZVxuICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICB9KTtcblxuICAgIGlmIChzaG91bGRTaG93ID09PSB0cnVlKSB7XG4gICAgICBkaWFsb2cubW9kYWwoXCJzaG93XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBkaWFsb2c7XG4gIH07XG5cbiAgZXhwb3J0cy5kaWFsb2cgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHNhbml0aXplKG9wdGlvbnMpO1xuXG4gICAgdmFyIGRpYWxvZyA9ICQodGVtcGxhdGVzLmRpYWxvZyk7XG4gICAgdmFyIGlubmVyRGlhbG9nID0gZGlhbG9nLmZpbmQoXCIubW9kYWwtZGlhbG9nXCIpO1xuICAgIHZhciBib2R5ID0gZGlhbG9nLmZpbmQoXCIubW9kYWwtYm9keVwiKTtcbiAgICB2YXIgYnV0dG9ucyA9IG9wdGlvbnMuYnV0dG9ucztcbiAgICB2YXIgYnV0dG9uU3RyID0gXCJcIjtcbiAgICB2YXIgY2FsbGJhY2tzID0ge1xuICAgICAgb25Fc2NhcGU6IG9wdGlvbnMub25Fc2NhcGVcbiAgICB9O1xuXG4gICAgaWYgKCQuZm4ubW9kYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIiQuZm4ubW9kYWwgaXMgbm90IGRlZmluZWQ7IHBsZWFzZSBkb3VibGUgY2hlY2sgeW91IGhhdmUgaW5jbHVkZWQgXCIgK1xuICAgICAgICBcInRoZSBCb290c3RyYXAgSmF2YVNjcmlwdCBsaWJyYXJ5LiBTZWUgaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8gXCIgK1xuICAgICAgICBcImZvciBtb3JlIGRldGFpbHMuXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZWFjaChidXR0b25zLCBmdW5jdGlvbihrZXksIGJ1dHRvbikge1xuXG4gICAgICAvLyBAVE9ETyBJIGRvbid0IGxpa2UgdGhpcyBzdHJpbmcgYXBwZW5kaW5nIHRvIGl0c2VsZjsgYml0IGRpcnR5LiBOZWVkcyByZXdvcmtpbmdcbiAgICAgIC8vIGNhbiB3ZSBqdXN0IGJ1aWxkIHVwIGJ1dHRvbiBlbGVtZW50cyBpbnN0ZWFkPyBzbG93ZXIgYnV0IG5lYXRlci4gVGhlbiBidXR0b25cbiAgICAgIC8vIGNhbiBqdXN0IGJlY29tZSBhIHRlbXBsYXRlIHRvb1xuICAgICAgYnV0dG9uU3RyICs9IFwiPGJ1dHRvbiBkYXRhLWJiLWhhbmRsZXI9J1wiICsga2V5ICsgXCInIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBcIiArIGJ1dHRvbi5jbGFzc05hbWUgKyBcIic+XCIgKyBidXR0b24ubGFiZWwgKyBcIjwvYnV0dG9uPlwiO1xuICAgICAgY2FsbGJhY2tzW2tleV0gPSBidXR0b24uY2FsbGJhY2s7XG4gICAgfSk7XG5cbiAgICBib2R5LmZpbmQoXCIuYm9vdGJveC1ib2R5XCIpLmh0bWwob3B0aW9ucy5tZXNzYWdlKTtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IHRydWUpIHtcbiAgICAgIGRpYWxvZy5hZGRDbGFzcyhcImZhZGVcIik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY2xhc3NOYW1lKSB7XG4gICAgICBkaWFsb2cuYWRkQ2xhc3Mob3B0aW9ucy5jbGFzc05hbWUpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNpemUgPT09IFwibGFyZ2VcIikge1xuICAgICAgaW5uZXJEaWFsb2cuYWRkQ2xhc3MoXCJtb2RhbC1sZ1wiKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2l6ZSA9PT0gXCJzbWFsbFwiKSB7XG4gICAgICBpbm5lckRpYWxvZy5hZGRDbGFzcyhcIm1vZGFsLXNtXCIpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRpdGxlKSB7XG4gICAgICBib2R5LmJlZm9yZSh0ZW1wbGF0ZXMuaGVhZGVyKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jbG9zZUJ1dHRvbikge1xuICAgICAgdmFyIGNsb3NlQnV0dG9uID0gJCh0ZW1wbGF0ZXMuY2xvc2VCdXR0b24pO1xuXG4gICAgICBpZiAob3B0aW9ucy50aXRsZSkge1xuICAgICAgICBkaWFsb2cuZmluZChcIi5tb2RhbC1oZWFkZXJcIikucHJlcGVuZChjbG9zZUJ1dHRvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9zZUJ1dHRvbi5jc3MoXCJtYXJnaW4tdG9wXCIsIFwiLTEwcHhcIikucHJlcGVuZFRvKGJvZHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRpdGxlKSB7XG4gICAgICBkaWFsb2cuZmluZChcIi5tb2RhbC10aXRsZVwiKS5odG1sKG9wdGlvbnMudGl0bGUpO1xuICAgIH1cblxuICAgIGlmIChidXR0b25TdHIubGVuZ3RoKSB7XG4gICAgICBib2R5LmFmdGVyKHRlbXBsYXRlcy5mb290ZXIpO1xuICAgICAgZGlhbG9nLmZpbmQoXCIubW9kYWwtZm9vdGVyXCIpLmh0bWwoYnV0dG9uU3RyKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEJvb3RzdHJhcCBldmVudCBsaXN0ZW5lcnM7IHVzZWQgaGFuZGxlIGV4dHJhXG4gICAgICogc2V0dXAgJiB0ZWFyZG93biByZXF1aXJlZCBhZnRlciB0aGUgdW5kZXJseWluZ1xuICAgICAqIG1vZGFsIGhhcyBwZXJmb3JtZWQgY2VydGFpbiBhY3Rpb25zXG4gICAgICovXG5cbiAgICBkaWFsb2cub24oXCJoaWRkZW4uYnMubW9kYWxcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgLy8gZW5zdXJlIHdlIGRvbid0IGFjY2lkZW50YWxseSBpbnRlcmNlcHQgaGlkZGVuIGV2ZW50cyB0cmlnZ2VyZWRcbiAgICAgIC8vIGJ5IGNoaWxkcmVuIG9mIHRoZSBjdXJyZW50IGRpYWxvZy4gV2Ugc2hvdWxkbid0IGFueW1vcmUgbm93IEJTXG4gICAgICAvLyBuYW1lc3BhY2VzIGl0cyBldmVudHM7IGJ1dCBzdGlsbCB3b3J0aCBkb2luZ1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzKSB7XG4gICAgICAgIGRpYWxvZy5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qXG4gICAgZGlhbG9nLm9uKFwic2hvdy5icy5tb2RhbFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIC8vIHNhZGx5IHRoaXMgZG9lc24ndCB3b3JrOyBzaG93IGlzIGNhbGxlZCAqanVzdCogYmVmb3JlXG4gICAgICAvLyB0aGUgYmFja2Ryb3AgaXMgYWRkZWQgc28gd2UnZCBuZWVkIGEgc2V0VGltZW91dCBoYWNrIG9yXG4gICAgICAvLyBvdGhlcndpc2UuLi4gbGVhdmluZyBpbiBhcyB3b3VsZCBiZSBuaWNlXG4gICAgICBpZiAob3B0aW9ucy5iYWNrZHJvcCkge1xuICAgICAgICBkaWFsb2cubmV4dChcIi5tb2RhbC1iYWNrZHJvcFwiKS5hZGRDbGFzcyhcImJvb3Rib3gtYmFja2Ryb3BcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgKi9cblxuICAgIGRpYWxvZy5vbihcInNob3duLmJzLm1vZGFsXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgZGlhbG9nLmZpbmQoXCIuYnRuLXByaW1hcnk6Zmlyc3RcIikuZm9jdXMoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEJvb3Rib3ggZXZlbnQgbGlzdGVuZXJzOyBleHBlcmltZW50YWwgYW5kIG1heSBub3QgbGFzdFxuICAgICAqIGp1c3QgYW4gYXR0ZW1wdCB0byBkZWNvdXBsZSBzb21lIGJlaGF2aW91cnMgZnJvbSB0aGVpclxuICAgICAqIHJlc3BlY3RpdmUgdHJpZ2dlcnNcbiAgICAgKi9cblxuICAgIGlmIChvcHRpb25zLmJhY2tkcm9wICE9PSBcInN0YXRpY1wiKSB7XG4gICAgICAvLyBBIGJvb2xlYW4gdHJ1ZS9mYWxzZSBhY2NvcmRpbmcgdG8gdGhlIEJvb3RzdHJhcCBkb2NzXG4gICAgICAvLyBzaG91bGQgc2hvdyBhIGRpYWxvZyB0aGUgdXNlciBjYW4gZGlzbWlzcyBieSBjbGlja2luZyBvblxuICAgICAgLy8gdGhlIGJhY2tncm91bmQuXG4gICAgICAvLyBXZSBhbHdheXMgb25seSBldmVyIHBhc3Mgc3RhdGljL2ZhbHNlIHRvIHRoZSBhY3R1YWxcbiAgICAgIC8vICQubW9kYWwgZnVuY3Rpb24gYmVjYXVzZSB3aXRoIGB0cnVlYCB3ZSBjYW4ndCB0cmFwXG4gICAgICAvLyB0aGlzIGV2ZW50ICh0aGUgLm1vZGFsLWJhY2tkcm9wIHN3YWxsb3dzIGl0KVxuICAgICAgLy8gSG93ZXZlciwgd2Ugc3RpbGwgd2FudCB0byBzb3J0IG9mIHJlc3BlY3QgdHJ1ZVxuICAgICAgLy8gYW5kIGludm9rZSB0aGUgZXNjYXBlIG1lY2hhbmlzbSBpbnN0ZWFkXG4gICAgICBkaWFsb2cub24oXCJjbGljay5kaXNtaXNzLmJzLm1vZGFsXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gQE5PVEU6IHRoZSB0YXJnZXQgdmFyaWVzIGluID49IDMuMy54IHJlbGVhc2VzIHNpbmNlIHRoZSBtb2RhbCBiYWNrZHJvcFxuICAgICAgICAvLyBtb3ZlZCAqaW5zaWRlKiB0aGUgb3V0ZXIgZGlhbG9nIHJhdGhlciB0aGFuICphbG9uZ3NpZGUqIGl0XG4gICAgICAgIGlmIChkaWFsb2cuY2hpbGRyZW4oXCIubW9kYWwtYmFja2Ryb3BcIikubGVuZ3RoKSB7XG4gICAgICAgICAgZS5jdXJyZW50VGFyZ2V0ID0gZGlhbG9nLmNoaWxkcmVuKFwiLm1vZGFsLWJhY2tkcm9wXCIpLmdldCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlhbG9nLnRyaWdnZXIoXCJlc2NhcGUuY2xvc2UuYmJcIik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBkaWFsb2cub24oXCJlc2NhcGUuY2xvc2UuYmJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGNhbGxiYWNrcy5vbkVzY2FwZSkge1xuICAgICAgICBwcm9jZXNzQ2FsbGJhY2soZSwgZGlhbG9nLCBjYWxsYmFja3Mub25Fc2NhcGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgalF1ZXJ5IGV2ZW50IGxpc3RlbmVyczsgdXNlZCB0byBoYW5kbGUgdXNlclxuICAgICAqIGludGVyYWN0aW9uIHdpdGggb3VyIGRpYWxvZ1xuICAgICAqL1xuXG4gICAgZGlhbG9nLm9uKFwiY2xpY2tcIiwgXCIubW9kYWwtZm9vdGVyIGJ1dHRvblwiLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgY2FsbGJhY2tLZXkgPSAkKHRoaXMpLmRhdGEoXCJiYi1oYW5kbGVyXCIpO1xuXG4gICAgICBwcm9jZXNzQ2FsbGJhY2soZSwgZGlhbG9nLCBjYWxsYmFja3NbY2FsbGJhY2tLZXldKTtcbiAgICB9KTtcblxuICAgIGRpYWxvZy5vbihcImNsaWNrXCIsIFwiLmJvb3Rib3gtY2xvc2UtYnV0dG9uXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIG9uRXNjYXBlIG1pZ2h0IGJlIGZhbHN5IGJ1dCB0aGF0J3MgZmluZTsgdGhlIGZhY3QgaXNcbiAgICAgIC8vIGlmIHRoZSB1c2VyIGhhcyBtYW5hZ2VkIHRvIGNsaWNrIHRoZSBjbG9zZSBidXR0b24gd2VcbiAgICAgIC8vIGhhdmUgdG8gY2xvc2UgdGhlIGRpYWxvZywgY2FsbGJhY2sgb3Igbm90XG4gICAgICBwcm9jZXNzQ2FsbGJhY2soZSwgZGlhbG9nLCBjYWxsYmFja3Mub25Fc2NhcGUpO1xuICAgIH0pO1xuXG4gICAgZGlhbG9nLm9uKFwia2V5dXBcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUud2hpY2ggPT09IDI3KSB7XG4gICAgICAgIGRpYWxvZy50cmlnZ2VyKFwiZXNjYXBlLmNsb3NlLmJiXCIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gdGhlIHJlbWFpbmRlciBvZiB0aGlzIG1ldGhvZCBzaW1wbHkgZGVhbHMgd2l0aCBhZGRpbmcgb3VyXG4gICAgLy8gZGlhbG9nZW50IHRvIHRoZSBET00sIGF1Z21lbnRpbmcgaXQgd2l0aCBCb290c3RyYXAncyBtb2RhbFxuICAgIC8vIGZ1bmN0aW9uYWxpdHkgYW5kIHRoZW4gZ2l2aW5nIHRoZSByZXN1bHRpbmcgb2JqZWN0IGJhY2tcbiAgICAvLyB0byBvdXIgY2FsbGVyXG5cbiAgICAkKG9wdGlvbnMuY29udGFpbmVyKS5hcHBlbmQoZGlhbG9nKTtcblxuICAgIGRpYWxvZy5tb2RhbCh7XG4gICAgICBiYWNrZHJvcDogb3B0aW9ucy5iYWNrZHJvcCA/IFwic3RhdGljXCI6IGZhbHNlLFxuICAgICAga2V5Ym9hcmQ6IGZhbHNlLFxuICAgICAgc2hvdzogZmFsc2VcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLnNob3cpIHtcbiAgICAgIGRpYWxvZy5tb2RhbChcInNob3dcIik7XG4gICAgfVxuXG4gICAgLy8gQFRPRE8gc2hvdWxkIHdlIHJldHVybiB0aGUgcmF3IGVsZW1lbnQgaGVyZSBvciBzaG91bGRcbiAgICAvLyB3ZSB3cmFwIGl0IGluIGFuIG9iamVjdCBvbiB3aGljaCB3ZSBjYW4gZXhwb3NlIHNvbWUgbmVhdGVyXG4gICAgLy8gbWV0aG9kcywgZS5nLiB2YXIgZCA9IGJvb3Rib3guYWxlcnQoKTsgZC5oaWRlKCk7IGluc3RlYWRcbiAgICAvLyBvZiBkLm1vZGFsKFwiaGlkZVwiKTtcblxuICAgLypcbiAgICBmdW5jdGlvbiBCQkRpYWxvZyhlbGVtKSB7XG4gICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIH1cblxuICAgIEJCRGlhbG9nLnByb3RvdHlwZSA9IHtcbiAgICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtLm1vZGFsKFwiaGlkZVwiKTtcbiAgICAgIH0sXG4gICAgICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbS5tb2RhbChcInNob3dcIik7XG4gICAgICB9XG4gICAgfTtcbiAgICAqL1xuXG4gICAgcmV0dXJuIGRpYWxvZztcblxuICB9O1xuXG4gIGV4cG9ydHMuc2V0RGVmYXVsdHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWVzID0ge307XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgLy8gYWxsb3cgcGFzc2luZyBvZiBzaW5nbGUga2V5L3ZhbHVlLi4uXG4gICAgICB2YWx1ZXNbYXJndW1lbnRzWzBdXSA9IGFyZ3VtZW50c1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gLi4uIGFuZCBhcyBhbiBvYmplY3QgdG9vXG4gICAgICB2YWx1ZXMgPSBhcmd1bWVudHNbMF07XG4gICAgfVxuXG4gICAgJC5leHRlbmQoZGVmYXVsdHMsIHZhbHVlcyk7XG4gIH07XG5cbiAgZXhwb3J0cy5oaWRlQWxsID0gZnVuY3Rpb24oKSB7XG4gICAgJChcIi5ib290Ym94XCIpLm1vZGFsKFwiaGlkZVwiKTtcblxuICAgIHJldHVybiBleHBvcnRzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIHN0YW5kYXJkIGxvY2FsZXMuIFBsZWFzZSBhZGQgbW9yZSBhY2NvcmRpbmcgdG8gSVNPIDYzOS0xIHN0YW5kYXJkLiBNdWx0aXBsZSBsYW5ndWFnZSB2YXJpYW50cyBhcmVcbiAgICogdW5saWtlbHkgdG8gYmUgcmVxdWlyZWQuIElmIHRoaXMgZ2V0cyB0b28gbGFyZ2UgaXQgY2FuIGJlIHNwbGl0IG91dCBpbnRvIHNlcGFyYXRlIEpTIGZpbGVzLlxuICAgKi9cbiAgdmFyIGxvY2FsZXMgPSB7XG4gICAgYmdfQkcgOiB7XG4gICAgICBPSyAgICAgIDogXCLQntC6XCIsXG4gICAgICBDQU5DRUwgIDogXCLQntGC0LrQsNC3XCIsXG4gICAgICBDT05GSVJNIDogXCLQn9C+0YLQstGK0YDQttC00LDQstCw0LxcIlxuICAgIH0sXG4gICAgYnIgOiB7XG4gICAgICBPSyAgICAgIDogXCJPS1wiLFxuICAgICAgQ0FOQ0VMICA6IFwiQ2FuY2VsYXJcIixcbiAgICAgIENPTkZJUk0gOiBcIlNpbVwiXG4gICAgfSxcbiAgICBjcyA6IHtcbiAgICAgIE9LICAgICAgOiBcIk9LXCIsXG4gICAgICBDQU5DRUwgIDogXCJacnXFoWl0XCIsXG4gICAgICBDT05GSVJNIDogXCJQb3R2cmRpdFwiXG4gICAgfSxcbiAgICBkYSA6IHtcbiAgICAgIE9LICAgICAgOiBcIk9LXCIsXG4gICAgICBDQU5DRUwgIDogXCJBbm51bGxlclwiLFxuICAgICAgQ09ORklSTSA6IFwiQWNjZXB0ZXJcIlxuICAgIH0sXG4gICAgZGUgOiB7XG4gICAgICBPSyAgICAgIDogXCJPS1wiLFxuICAgICAgQ0FOQ0VMICA6IFwiQWJicmVjaGVuXCIsXG4gICAgICBDT05GSVJNIDogXCJBa3plcHRpZXJlblwiXG4gICAgfSxcbiAgICBlbCA6IHtcbiAgICAgIE9LICAgICAgOiBcIs6Vzr3PhM6szr7Otc65XCIsXG4gICAgICBDQU5DRUwgIDogXCLOkc66z43Pgc+Jz4POt1wiLFxuICAgICAgQ09ORklSTSA6IFwizpXPgM65zrLOtc6yzrHOr8+Jz4POt1wiXG4gICAgfSxcbiAgICBlbiA6IHtcbiAgICAgIE9LICAgICAgOiBcIk9LXCIsXG4gICAgICBDQU5DRUwgIDogXCJDYW5jZWxcIixcbiAgICAgIENPTkZJUk0gOiBcIk9LXCJcbiAgICB9LFxuICAgIGVzIDoge1xuICAgICAgT0sgICAgICA6IFwiT0tcIixcbiAgICAgIENBTkNFTCAgOiBcIkNhbmNlbGFyXCIsXG4gICAgICBDT05GSVJNIDogXCJBY2VwdGFyXCJcbiAgICB9LFxuICAgIGV0IDoge1xuICAgICAgT0sgICAgICA6IFwiT0tcIixcbiAgICAgIENBTkNFTCAgOiBcIkthdGtlc3RhXCIsXG4gICAgICBDT05GSVJNIDogXCJPS1wiXG4gICAgfSxcbiAgICBmYSA6IHtcbiAgICAgIE9LICAgICAgOiBcItmC2KjZiNmEXCIsXG4gICAgICBDQU5DRUwgIDogXCLZhNi62YhcIixcbiAgICAgIENPTkZJUk0gOiBcItiq2KfbjNuM2K9cIlxuICAgIH0sXG4gICAgZmkgOiB7XG4gICAgICBPSyAgICAgIDogXCJPS1wiLFxuICAgICAgQ0FOQ0VMICA6IFwiUGVydXV0YVwiLFxuICAgICAgQ09ORklSTSA6IFwiT0tcIlxuICAgIH0sXG4gICAgZnIgOiB7XG4gICAgICBPSyAgICAgIDogXCJPS1wiLFxuICAgICAgQ0FOQ0VMICA6IFwiQW5udWxlclwiLFxuICAgICAgQ09ORklSTSA6IFwiRCdhY2NvcmRcIlxuICAgIH0sXG4gICAgaGUgOiB7XG4gICAgICBPSyAgICAgIDogXCLXkNeZ16nXldeoXCIsXG4gICAgICBDQU5DRUwgIDogXCLXkdeZ15jXldecXCIsXG4gICAgICBDT05GSVJNIDogXCLXkNeZ16nXldeoXCJcbiAgICB9LFxuICAgIGh1IDoge1xuICAgICAgT0sgICAgICA6IFwiT0tcIixcbiAgICAgIENBTkNFTCAgOiBcIk3DqWdzZW1cIixcbiAgICAgIENPTkZJUk0gOiBcIk1lZ2VyxZFzw610XCJcbiAgICB9LFxuICAgIGhyIDoge1xuICAgICAgT0sgICAgICA6IFwiT0tcIixcbiAgICAgIENBTkNFTCAgOiBcIk9kdXN0YW5pXCIsXG4gICAgICBDT05GSVJNIDogXCJQb3R2cmRpXCJcbiAgICB9LFxuICAgIGlkIDoge1xuICAgICAgT0sgICAgICA6IFwiT0tcIixcbiAgICAgIENBTkNFTCAgOiBcIkJhdGFsXCIsXG4gICAgICBDT05GSVJNIDogXCJPS1wiXG4gICAgfSxcbiAgICBpdCA6IHtcbiAgICAgIE9LICAgICAgOiBcIk9LXCIsXG4gICAgICBDQU5DRUwgIDogXCJBbm51bGxhXCIsXG4gICAgICBDT05GSVJNIDogXCJDb25mZXJtYVwiXG4gICAgfSxcbiAgICBqYSA6IHtcbiAgICAgIE9LICAgICAgOiBcIk9LXCIsXG4gICAgICBDQU5DRUwgIDogXCLjgq3jg6Pjg7Pjgrvjg6tcIixcbiAgICAgIENPTkZJUk0gOiBcIueiuuiqjVwiXG4gICAgfSxcbiAgICBsdCA6IHtcbiAgICAgIE9LICAgICAgOiBcIkdlcmFpXCIsXG4gICAgICBDQU5DRUwgIDogXCJBdMWhYXVrdGlcIixcbiAgICAgIENPTkZJUk0gOiBcIlBhdHZpcnRpbnRpXCJcbiAgICB9LFxuICAgIGx2IDoge1xuICAgICAgT0sgICAgICA6IFwiTGFiaVwiLFxuICAgICAgQ0FOQ0VMICA6IFwiQXRjZWx0XCIsXG4gICAgICBDT05GSVJNIDogXCJBcHN0aXByaW7EgXRcIlxuICAgIH0sXG4gICAgbmwgOiB7XG4gICAgICBPSyAgICAgIDogXCJPS1wiLFxuICAgICAgQ0FOQ0VMICA6IFwiQW5udWxlcmVuXCIsXG4gICAgICBDT05GSVJNIDogXCJBY2NlcHRlcmVuXCJcbiAgICB9LFxuICAgIG5vIDoge1xuICAgICAgT0sgICAgICA6IFwiT0tcIixcbiAgICAgIENBTkNFTCAgOiBcIkF2YnJ5dFwiLFxuICAgICAgQ09ORklSTSA6IFwiT0tcIlxuICAgIH0sXG4gICAgcGwgOiB7XG4gICAgICBPSyAgICAgIDogXCJPS1wiLFxuICAgICAgQ0FOQ0VMICA6IFwiQW51bHVqXCIsXG4gICAgICBDT05GSVJNIDogXCJQb3R3aWVyZMW6XCJcbiAgICB9LFxuICAgIHB0IDoge1xuICAgICAgT0sgICAgICA6IFwiT0tcIixcbiAgICAgIENBTkNFTCAgOiBcIkNhbmNlbGFyXCIsXG4gICAgICBDT05GSVJNIDogXCJDb25maXJtYXJcIlxuICAgIH0sXG4gICAgcnUgOiB7XG4gICAgICBPSyAgICAgIDogXCJPS1wiLFxuICAgICAgQ0FOQ0VMICA6IFwi0J7RgtC80LXQvdCwXCIsXG4gICAgICBDT05GSVJNIDogXCLQn9GA0LjQvNC10L3QuNGC0YxcIlxuICAgIH0sXG4gICAgc3EgOiB7XG4gICAgICBPSyA6IFwiT0tcIixcbiAgICAgIENBTkNFTCA6IFwiQW51bG9cIixcbiAgICAgIENPTkZJUk0gOiBcIlByYW5vXCJcbiAgICB9LFxuICAgIHN2IDoge1xuICAgICAgT0sgICAgICA6IFwiT0tcIixcbiAgICAgIENBTkNFTCAgOiBcIkF2YnJ5dFwiLFxuICAgICAgQ09ORklSTSA6IFwiT0tcIlxuICAgIH0sXG4gICAgdGggOiB7XG4gICAgICBPSyAgICAgIDogXCLguJXguIHguKXguIdcIixcbiAgICAgIENBTkNFTCAgOiBcIuC4ouC4geC5gOC4peC4tOC4gVwiLFxuICAgICAgQ09ORklSTSA6IFwi4Lii4Li34LiZ4Lii4Lix4LiZXCJcbiAgICB9LFxuICAgIHRyIDoge1xuICAgICAgT0sgICAgICA6IFwiVGFtYW1cIixcbiAgICAgIENBTkNFTCAgOiBcIsSwcHRhbFwiLFxuICAgICAgQ09ORklSTSA6IFwiT25heWxhXCJcbiAgICB9LFxuICAgIHpoX0NOIDoge1xuICAgICAgT0sgICAgICA6IFwiT0tcIixcbiAgICAgIENBTkNFTCAgOiBcIuWPlua2iFwiLFxuICAgICAgQ09ORklSTSA6IFwi56Gu6K6kXCJcbiAgICB9LFxuICAgIHpoX1RXIDoge1xuICAgICAgT0sgICAgICA6IFwiT0tcIixcbiAgICAgIENBTkNFTCAgOiBcIuWPlua2iFwiLFxuICAgICAgQ09ORklSTSA6IFwi56K66KqNXCJcbiAgICB9XG4gIH07XG5cbiAgZXhwb3J0cy5hZGRMb2NhbGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZXMpIHtcbiAgICAkLmVhY2goW1wiT0tcIiwgXCJDQU5DRUxcIiwgXCJDT05GSVJNXCJdLCBmdW5jdGlvbihfLCB2KSB7XG4gICAgICBpZiAoIXZhbHVlc1t2XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2Ugc3VwcGx5IGEgdHJhbnNsYXRpb24gZm9yICdcIiArIHYgKyBcIidcIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsb2NhbGVzW25hbWVdID0ge1xuICAgICAgT0s6IHZhbHVlcy5PSyxcbiAgICAgIENBTkNFTDogdmFsdWVzLkNBTkNFTCxcbiAgICAgIENPTkZJUk06IHZhbHVlcy5DT05GSVJNXG4gICAgfTtcblxuICAgIHJldHVybiBleHBvcnRzO1xuICB9O1xuXG4gIGV4cG9ydHMucmVtb3ZlTG9jYWxlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuXG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH07XG5cbiAgZXhwb3J0cy5zZXRMb2NhbGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuc2V0RGVmYXVsdHMoXCJsb2NhbGVcIiwgbmFtZSk7XG4gIH07XG5cbiAgZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oXyQpIHtcbiAgICByZXR1cm4gaW5pdChfJCB8fCAkKTtcbiAgfTtcblxuICByZXR1cm4gZXhwb3J0cztcbn0pKTtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqIENyb3BwaWVcclxuICogQ29weXJpZ2h0IDIwMTdcclxuICogRm9saW90ZWtcclxuICogVmVyc2lvbjogMi42LjFcclxuICoqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cclxuICAgICAgICBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cG9ydHMubm9kZU5hbWUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgLy8gQ29tbW9uSlNcclxuICAgICAgICBmYWN0b3J5KGV4cG9ydHMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcclxuICAgICAgICBmYWN0b3J5KChyb290LmNvbW1vbkpzU3RyaWN0ID0ge30pKTtcclxuICAgIH1cclxufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykge1xyXG5cclxuICAgIC8qIFBvbHlmaWxscyAqL1xyXG4gICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLyohIHByb21pc2UtcG9seWZpbGwgMy4xLjAgKi9cclxuICAgICAgICAhZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhLGIpe3JldHVybiBmdW5jdGlvbigpe2EuYXBwbHkoYixhcmd1bWVudHMpfX1mdW5jdGlvbiBjKGEpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0aGlzKXRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXdcIik7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgYSl0aHJvdyBuZXcgVHlwZUVycm9yKFwibm90IGEgZnVuY3Rpb25cIik7dGhpcy5fc3RhdGU9bnVsbCx0aGlzLl92YWx1ZT1udWxsLHRoaXMuX2RlZmVycmVkcz1bXSxpKGEsYihlLHRoaXMpLGIoZix0aGlzKSl9ZnVuY3Rpb24gZChhKXt2YXIgYj10aGlzO3JldHVybiBudWxsPT09dGhpcy5fc3RhdGU/dm9pZCB0aGlzLl9kZWZlcnJlZHMucHVzaChhKTp2b2lkIGsoZnVuY3Rpb24oKXt2YXIgYz1iLl9zdGF0ZT9hLm9uRnVsZmlsbGVkOmEub25SZWplY3RlZDtpZihudWxsPT09YylyZXR1cm4gdm9pZChiLl9zdGF0ZT9hLnJlc29sdmU6YS5yZWplY3QpKGIuX3ZhbHVlKTt2YXIgZDt0cnl7ZD1jKGIuX3ZhbHVlKX1jYXRjaChlKXtyZXR1cm4gdm9pZCBhLnJlamVjdChlKX1hLnJlc29sdmUoZCl9KX1mdW5jdGlvbiBlKGEpe3RyeXtpZihhPT09dGhpcyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi5cIik7aWYoYSYmKFwib2JqZWN0XCI9PXR5cGVvZiBhfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBhKSl7dmFyIGM9YS50aGVuO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGMpcmV0dXJuIHZvaWQgaShiKGMsYSksYihlLHRoaXMpLGIoZix0aGlzKSl9dGhpcy5fc3RhdGU9ITAsdGhpcy5fdmFsdWU9YSxnLmNhbGwodGhpcyl9Y2F0Y2goZCl7Zi5jYWxsKHRoaXMsZCl9fWZ1bmN0aW9uIGYoYSl7dGhpcy5fc3RhdGU9ITEsdGhpcy5fdmFsdWU9YSxnLmNhbGwodGhpcyl9ZnVuY3Rpb24gZygpe2Zvcih2YXIgYT0wLGI9dGhpcy5fZGVmZXJyZWRzLmxlbmd0aDtiPmE7YSsrKWQuY2FsbCh0aGlzLHRoaXMuX2RlZmVycmVkc1thXSk7dGhpcy5fZGVmZXJyZWRzPW51bGx9ZnVuY3Rpb24gaChhLGIsYyxkKXt0aGlzLm9uRnVsZmlsbGVkPVwiZnVuY3Rpb25cIj09dHlwZW9mIGE/YTpudWxsLHRoaXMub25SZWplY3RlZD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBiP2I6bnVsbCx0aGlzLnJlc29sdmU9Yyx0aGlzLnJlamVjdD1kfWZ1bmN0aW9uIGkoYSxiLGMpe3ZhciBkPSExO3RyeXthKGZ1bmN0aW9uKGEpe2R8fChkPSEwLGIoYSkpfSxmdW5jdGlvbihhKXtkfHwoZD0hMCxjKGEpKX0pfWNhdGNoKGUpe2lmKGQpcmV0dXJuO2Q9ITAsYyhlKX19dmFyIGo9c2V0VGltZW91dCxrPVwiZnVuY3Rpb25cIj09dHlwZW9mIHNldEltbWVkaWF0ZSYmc2V0SW1tZWRpYXRlfHxmdW5jdGlvbihhKXtqKGEsMSl9LGw9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oYSl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpfTtjLnByb3RvdHlwZVtcImNhdGNoXCJdPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnRoZW4obnVsbCxhKX0sYy5wcm90b3R5cGUudGhlbj1mdW5jdGlvbihhLGIpe3ZhciBlPXRoaXM7cmV0dXJuIG5ldyBjKGZ1bmN0aW9uKGMsZil7ZC5jYWxsKGUsbmV3IGgoYSxiLGMsZikpfSl9LGMuYWxsPWZ1bmN0aW9uKCl7dmFyIGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoMT09PWFyZ3VtZW50cy5sZW5ndGgmJmwoYXJndW1lbnRzWzBdKT9hcmd1bWVudHNbMF06YXJndW1lbnRzKTtyZXR1cm4gbmV3IGMoZnVuY3Rpb24oYixjKXtmdW5jdGlvbiBkKGYsZyl7dHJ5e2lmKGcmJihcIm9iamVjdFwiPT10eXBlb2YgZ3x8XCJmdW5jdGlvblwiPT10eXBlb2YgZykpe3ZhciBoPWcudGhlbjtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBoKXJldHVybiB2b2lkIGguY2FsbChnLGZ1bmN0aW9uKGEpe2QoZixhKX0sYyl9YVtmXT1nLDA9PT0tLWUmJmIoYSl9Y2F0Y2goaSl7YyhpKX19aWYoMD09PWEubGVuZ3RoKXJldHVybiBiKFtdKTtmb3IodmFyIGU9YS5sZW5ndGgsZj0wO2Y8YS5sZW5ndGg7ZisrKWQoZixhW2ZdKX0pfSxjLnJlc29sdmU9ZnVuY3Rpb24oYSl7cmV0dXJuIGEmJlwib2JqZWN0XCI9PXR5cGVvZiBhJiZhLmNvbnN0cnVjdG9yPT09Yz9hOm5ldyBjKGZ1bmN0aW9uKGIpe2IoYSl9KX0sYy5yZWplY3Q9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBjKGZ1bmN0aW9uKGIsYyl7YyhhKX0pfSxjLnJhY2U9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBjKGZ1bmN0aW9uKGIsYyl7Zm9yKHZhciBkPTAsZT1hLmxlbmd0aDtlPmQ7ZCsrKWFbZF0udGhlbihiLGMpfSl9LGMuX3NldEltbWVkaWF0ZUZuPWZ1bmN0aW9uKGEpe2s9YX0sXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9YzphLlByb21pc2V8fChhLlByb21pc2U9Yyl9KHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICggdHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCAhPT0gXCJmdW5jdGlvblwiICkge1xyXG4gICAgICAgIChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBDdXN0b21FdmVudCAoIGV2ZW50LCBwYXJhbXMgKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdW5kZWZpbmVkIH07XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoICdDdXN0b21FdmVudCcgKTtcclxuICAgICAgICAgICAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoIGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBldnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcclxuICAgICAgICAgICAgd2luZG93LkN1c3RvbUV2ZW50ID0gQ3VzdG9tRXZlbnQ7XHJcbiAgICAgICAgfSgpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIUhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZS50b0Jsb2IpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLCAndG9CbG9iJywge1xyXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGNhbGxiYWNrLCB0eXBlLCBxdWFsaXR5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmluU3RyID0gYXRvYiggdGhpcy50b0RhdGFVUkwodHlwZSwgcXVhbGl0eSkuc3BsaXQoJywnKVsxXSApLFxyXG4gICAgICAgICAgICAgICAgbGVuID0gYmluU3RyLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGFyciA9IG5ldyBVaW50OEFycmF5KGxlbik7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGxlbjsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFycltpXSA9IGJpblN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCBuZXcgQmxvYiggW2Fycl0sIHt0eXBlOiB0eXBlIHx8ICdpbWFnZS9wbmcnfSApICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qIEVuZCBQb2x5ZmlsbHMgKi9cclxuXHJcbiAgICB2YXIgY3NzUHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXSxcclxuICAgICAgICBlbXB0eVN0eWxlcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlLFxyXG4gICAgICAgIEVYSUZfTk9STSA9IFsxLDgsMyw2XSxcclxuICAgICAgICBFWElGX0ZMSVAgPSBbMiw3LDQsNV0sXHJcbiAgICAgICAgQ1NTX1RSQU5TX09SRyxcclxuICAgICAgICBDU1NfVFJBTlNGT1JNLFxyXG4gICAgICAgIENTU19VU0VSU0VMRUNUO1xyXG5cclxuICAgIGZ1bmN0aW9uIHZlbmRvclByZWZpeChwcm9wKSB7XHJcbiAgICAgICAgaWYgKHByb3AgaW4gZW1wdHlTdHlsZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3A7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY2FwUHJvcCA9IHByb3BbMF0udG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSksXHJcbiAgICAgICAgICAgIGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgcHJvcCA9IGNzc1ByZWZpeGVzW2ldICsgY2FwUHJvcDtcclxuICAgICAgICAgICAgaWYgKHByb3AgaW4gZW1wdHlTdHlsZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIENTU19UUkFOU0ZPUk0gPSB2ZW5kb3JQcmVmaXgoJ3RyYW5zZm9ybScpO1xyXG4gICAgQ1NTX1RSQU5TX09SRyA9IHZlbmRvclByZWZpeCgndHJhbnNmb3JtT3JpZ2luJyk7XHJcbiAgICBDU1NfVVNFUlNFTEVDVCA9IHZlbmRvclByZWZpeCgndXNlclNlbGVjdCcpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldEV4aWZPZmZzZXQob3JudCwgcm90YXRlKSB7XHJcbiAgICAgICAgdmFyIGFyciA9IEVYSUZfTk9STS5pbmRleE9mKG9ybnQpID4gLTEgPyBFWElGX05PUk0gOiBFWElGX0ZMSVAsXHJcbiAgICAgICAgICAgIGluZGV4ID0gYXJyLmluZGV4T2Yob3JudCksXHJcbiAgICAgICAgICAgIG9mZnNldCA9IChyb3RhdGUgLyA5MCkgJSBhcnIubGVuZ3RoOy8vIDE4MCA9IDIlNCA9IDIgc2hpZnQgZXhpZiBieSAyIGluZGV4ZXNcclxuXHJcbiAgICAgICAgcmV0dXJuIGFyclsoYXJyLmxlbmd0aCArIGluZGV4ICsgKG9mZnNldCAlIGFyci5sZW5ndGgpKSAlIGFyci5sZW5ndGhdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWRpdHMgdG8gOiBBbmRyZXcgRHVwb250IC0gaHR0cDovL2FuZHJld2R1cG9udC5uZXQvMjAwOS8wOC8yOC9kZWVwLWV4dGVuZGluZy1vYmplY3RzLWluLWphdmFzY3JpcHQvXHJcbiAgICBmdW5jdGlvbiBkZWVwRXh0ZW5kKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcclxuICAgICAgICBkZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uIHx8IHt9O1xyXG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xyXG4gICAgICAgICAgICBpZiAoc291cmNlW3Byb3BlcnR5XSAmJiBzb3VyY2VbcHJvcGVydHldLmNvbnN0cnVjdG9yICYmIHNvdXJjZVtwcm9wZXJ0eV0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gZGVzdGluYXRpb25bcHJvcGVydHldIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgZGVlcEV4dGVuZChkZXN0aW5hdGlvbltwcm9wZXJ0eV0sIHNvdXJjZVtwcm9wZXJ0eV0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2xvbmUob2JqZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZXBFeHRlbmQoe30sIG9iamVjdCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgdmFyIHRpbWVvdXQ7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmICghaW1tZWRpYXRlKSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XHJcbiAgICAgICAgICAgIGlmIChjYWxsTm93KSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hDaGFuZ2UoZWxlbWVudCkge1xyXG4gICAgICAgIGlmIChcImNyZWF0ZUV2ZW50XCIgaW4gZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiSFRNTEV2ZW50c1wiKTtcclxuICAgICAgICAgICAgZXZ0LmluaXRFdmVudChcImNoYW5nZVwiLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWxlbWVudC5maXJlRXZlbnQoXCJvbmNoYW5nZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9odHRwOi8vanNwZXJmLmNvbS92YW5pbGxhLWNzc1xyXG4gICAgZnVuY3Rpb24gY3NzKGVsLCBzdHlsZXMsIHZhbCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKHN0eWxlcykgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHZhciB0bXAgPSBzdHlsZXM7XHJcbiAgICAgICAgICAgIHN0eWxlcyA9IHt9O1xyXG4gICAgICAgICAgICBzdHlsZXNbdG1wXSA9IHZhbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGVzKSB7XHJcbiAgICAgICAgICAgIGVsLnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgYykge1xyXG4gICAgICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcclxuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsLmNsYXNzTmFtZSArPSAnICcgKyBjO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgYykge1xyXG4gICAgICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcclxuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKGMsICcnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbCwgYXR0cnMpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcclxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG51bSh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHYsIDEwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiBVdGlsaXRpZXMgKi9cclxuICAgIGZ1bmN0aW9uIGxvYWRJbWFnZShzcmMsIGRvRXhpZikge1xyXG4gICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICBpbWcuc3R5bGUub3BhY2l0eSA9IDA7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9yZXNvbHZlKCkge1xyXG4gICAgICAgICAgICAgICAgaW1nLnN0eWxlLm9wYWNpdHkgPSAxO1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpbWcpO1xyXG4gICAgICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGltZy5yZW1vdmVBdHRyaWJ1dGUoJ2Nyb3NzT3JpZ2luJyk7XHJcbiAgICAgICAgICAgIGlmIChzcmMubWF0Y2goL15odHRwcz86XFwvXFwvfF5cXC9cXC8vKSkge1xyXG4gICAgICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnY3Jvc3NPcmlnaW4nLCAnYW5vbnltb3VzJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9FeGlmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRVhJRi5nZXREYXRhKGltZywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Jlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaW1nLnNyYyA9IHNyYztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBuYXR1cmFsSW1hZ2VEaW1lbnNpb25zKGltZywgb3JudCkge1xyXG4gICAgICAgIHZhciB3ID0gaW1nLm5hdHVyYWxXaWR0aDtcclxuICAgICAgICB2YXIgaCA9IGltZy5uYXR1cmFsSGVpZ2h0O1xyXG4gICAgICAgIHZhciBvcmllbnQgPSBvcm50IHx8IGdldEV4aWZPcmllbnRhdGlvbihpbWcpO1xyXG4gICAgICAgIGlmIChvcmllbnQgJiYgb3JpZW50ID49IDUpIHtcclxuICAgICAgICAgICAgdmFyIHg9IHc7XHJcbiAgICAgICAgICAgIHcgPSBoO1xyXG4gICAgICAgICAgICBoID0geDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHcsIGhlaWdodDogaCB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qIENTUyBUcmFuc2Zvcm0gUHJvdG90eXBlICovXHJcbiAgICB2YXIgVFJBTlNMQVRFX09QVFMgPSB7XHJcbiAgICAgICAgJ3RyYW5zbGF0ZTNkJzoge1xyXG4gICAgICAgICAgICBzdWZmaXg6ICcsIDBweCdcclxuICAgICAgICB9LFxyXG4gICAgICAgICd0cmFuc2xhdGUnOiB7XHJcbiAgICAgICAgICAgIHN1ZmZpeDogJydcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh4LCB5LCBzY2FsZSkge1xyXG4gICAgICAgIHRoaXMueCA9IHBhcnNlRmxvYXQoeCk7XHJcbiAgICAgICAgdGhpcy55ID0gcGFyc2VGbG9hdCh5KTtcclxuICAgICAgICB0aGlzLnNjYWxlID0gcGFyc2VGbG9hdChzY2FsZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFRyYW5zZm9ybS5wYXJzZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKHYuc3R5bGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybS5wYXJzZSh2LnN0eWxlW0NTU19UUkFOU0ZPUk1dKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodi5pbmRleE9mKCdtYXRyaXgnKSA+IC0xIHx8IHYuaW5kZXhPZignbm9uZScpID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybS5mcm9tTWF0cml4KHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybS5mcm9tU3RyaW5nKHYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgVHJhbnNmb3JtLmZyb21NYXRyaXggPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciB2YWxzID0gdi5zdWJzdHJpbmcoNykuc3BsaXQoJywnKTtcclxuICAgICAgICBpZiAoIXZhbHMubGVuZ3RoIHx8IHYgPT09ICdub25lJykge1xyXG4gICAgICAgICAgICB2YWxzID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0obnVtKHZhbHNbNF0pLCBudW0odmFsc1s1XSksIHBhcnNlRmxvYXQodmFsc1swXSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBUcmFuc2Zvcm0uZnJvbVN0cmluZyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IHYuc3BsaXQoJykgJyksXHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZSA9IHZhbHVlc1swXS5zdWJzdHJpbmcoQ3JvcHBpZS5nbG9iYWxzLnRyYW5zbGF0ZS5sZW5ndGggKyAxKS5zcGxpdCgnLCcpLFxyXG4gICAgICAgICAgICBzY2FsZSA9IHZhbHVlcy5sZW5ndGggPiAxID8gdmFsdWVzWzFdLnN1YnN0cmluZyg2KSA6IDEsXHJcbiAgICAgICAgICAgIHggPSB0cmFuc2xhdGUubGVuZ3RoID4gMSA/IHRyYW5zbGF0ZVswXSA6IDAsXHJcbiAgICAgICAgICAgIHkgPSB0cmFuc2xhdGUubGVuZ3RoID4gMSA/IHRyYW5zbGF0ZVsxXSA6IDA7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKHgsIHksIHNjYWxlKTtcclxuICAgIH07XHJcblxyXG4gICAgVHJhbnNmb3JtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3VmZml4ID0gVFJBTlNMQVRFX09QVFNbQ3JvcHBpZS5nbG9iYWxzLnRyYW5zbGF0ZV0uc3VmZml4IHx8ICcnO1xyXG4gICAgICAgIHJldHVybiBDcm9wcGllLmdsb2JhbHMudHJhbnNsYXRlICsgJygnICsgdGhpcy54ICsgJ3B4LCAnICsgdGhpcy55ICsgJ3B4JyArIHN1ZmZpeCArICcpIHNjYWxlKCcgKyB0aGlzLnNjYWxlICsgJyknO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgVHJhbnNmb3JtT3JpZ2luID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgaWYgKCFlbCB8fCAhZWwuc3R5bGVbQ1NTX1RSQU5TX09SR10pIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gMDtcclxuICAgICAgICAgICAgdGhpcy55ID0gMDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY3NzID0gZWwuc3R5bGVbQ1NTX1RSQU5TX09SR10uc3BsaXQoJyAnKTtcclxuICAgICAgICB0aGlzLnggPSBwYXJzZUZsb2F0KGNzc1swXSk7XHJcbiAgICAgICAgdGhpcy55ID0gcGFyc2VGbG9hdChjc3NbMV0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBUcmFuc2Zvcm1PcmlnaW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnggKyAncHggJyArIHRoaXMueSArICdweCc7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldEV4aWZPcmllbnRhdGlvbiAoaW1nKSB7XHJcbiAgICAgICAgcmV0dXJuIGltZy5leGlmZGF0YSA/IGltZy5leGlmZGF0YS5PcmllbnRhdGlvbiA6IDE7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0NhbnZhcyhjYW52YXMsIGltZywgb3JpZW50YXRpb24pIHtcclxuICAgICAgICB2YXIgd2lkdGggPSBpbWcud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodCA9IGltZy5oZWlnaHQsXHJcbiAgICAgICAgICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgICAgICBjYW52YXMud2lkdGggPSBpbWcud2lkdGg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGltZy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgc3dpdGNoIChvcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aCwgMCk7XHJcbiAgICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xyXG4gICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgxODAqTWF0aC5QSS8xODApO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSB3aWR0aDtcclxuICAgICAgICAgICAgICBjdHgucm90YXRlKDkwKk1hdGguUEkvMTgwKTtcclxuICAgICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHdpZHRoO1xyXG4gICAgICAgICAgICAgIGN0eC5yb3RhdGUoOTAqTWF0aC5QSS8xODApO1xyXG4gICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgLWhlaWdodCk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGhlaWdodDtcclxuICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gd2lkdGg7XHJcbiAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgtOTAqTWF0aC5QSS8xODApO1xyXG4gICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSA4OlxyXG4gICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGhlaWdodDtcclxuICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gd2lkdGg7XHJcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCB3aWR0aCk7XHJcbiAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgtOTAqTWF0aC5QSS8xODApO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIFByaXZhdGUgTWV0aG9kcyAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZSgpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICAgIGNvbnRDbGFzcyA9ICdjcm9wcGllLWNvbnRhaW5lcicsXHJcbiAgICAgICAgICAgIGN1c3RvbVZpZXdwb3J0Q2xhc3MgPSBzZWxmLm9wdGlvbnMudmlld3BvcnQudHlwZSA/ICdjci12cC0nICsgc2VsZi5vcHRpb25zLnZpZXdwb3J0LnR5cGUgOiBudWxsLFxyXG4gICAgICAgICAgICBib3VuZGFyeSwgaW1nLCB2aWV3cG9ydCwgb3ZlcmxheSwgYncsIGJoO1xyXG5cclxuICAgICAgICBzZWxmLm9wdGlvbnMudXNlQ2FudmFzID0gc2VsZi5vcHRpb25zLmVuYWJsZU9yaWVudGF0aW9uIHx8IF9oYXNFeGlmLmNhbGwoc2VsZik7XHJcbiAgICAgICAgLy8gUHJvcGVydGllcyBvbiBjbGFzc1xyXG4gICAgICAgIHNlbGYuZGF0YSA9IHt9O1xyXG4gICAgICAgIHNlbGYuZWxlbWVudHMgPSB7fTtcclxuXHJcbiAgICAgICAgYm91bmRhcnkgPSBzZWxmLmVsZW1lbnRzLmJvdW5kYXJ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdmlld3BvcnQgPSBzZWxmLmVsZW1lbnRzLnZpZXdwb3J0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgaW1nID0gc2VsZi5lbGVtZW50cy5pbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuICAgICAgICBvdmVybGF5ID0gc2VsZi5lbGVtZW50cy5vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMudXNlQ2FudmFzKSB7XHJcbiAgICAgICAgICAgIHNlbGYuZWxlbWVudHMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIHNlbGYuZWxlbWVudHMucHJldmlldyA9IHNlbGYuZWxlbWVudHMuY2FudmFzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZi5lbGVtZW50cy5wcmV2aWV3ID0gc2VsZi5lbGVtZW50cy5pbWc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhZGRDbGFzcyhib3VuZGFyeSwgJ2NyLWJvdW5kYXJ5Jyk7XHJcbiAgICAgICAgYm91bmRhcnkuc2V0QXR0cmlidXRlKCdhcmlhLWRyb3BlZmZlY3QnLCAnbm9uZScpO1xyXG4gICAgICAgIGJ3ID0gc2VsZi5vcHRpb25zLmJvdW5kYXJ5LndpZHRoO1xyXG4gICAgICAgIGJoID0gc2VsZi5vcHRpb25zLmJvdW5kYXJ5LmhlaWdodDtcclxuICAgICAgICBjc3MoYm91bmRhcnksIHtcclxuICAgICAgICAgICAgd2lkdGg6IChidyArIChpc05hTihidykgPyAnJyA6ICdweCcpKSxcclxuICAgICAgICAgICAgaGVpZ2h0OiAoYmggKyAoaXNOYU4oYmgpID8gJycgOiAncHgnKSlcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgYWRkQ2xhc3Modmlld3BvcnQsICdjci12aWV3cG9ydCcpO1xyXG4gICAgICAgIGlmIChjdXN0b21WaWV3cG9ydENsYXNzKSB7XHJcbiAgICAgICAgICAgIGFkZENsYXNzKHZpZXdwb3J0LCBjdXN0b21WaWV3cG9ydENsYXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3NzKHZpZXdwb3J0LCB7XHJcbiAgICAgICAgICAgIHdpZHRoOiBzZWxmLm9wdGlvbnMudmlld3BvcnQud2lkdGggKyAncHgnLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHNlbGYub3B0aW9ucy52aWV3cG9ydC5oZWlnaHQgKyAncHgnXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmlld3BvcnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xyXG5cclxuICAgICAgICBhZGRDbGFzcyhzZWxmLmVsZW1lbnRzLnByZXZpZXcsICdjci1pbWFnZScpO1xyXG4gICAgICAgIHNldEF0dHJpYnV0ZXMoc2VsZi5lbGVtZW50cy5wcmV2aWV3LCB7ICdhbHQnOiAncHJldmlldycsICdhcmlhLWdyYWJiZWQnOiAnZmFsc2UnIH0pO1xyXG4gICAgICAgIGFkZENsYXNzKG92ZXJsYXksICdjci1vdmVybGF5Jyk7XHJcblxyXG4gICAgICAgIHNlbGYuZWxlbWVudC5hcHBlbmRDaGlsZChib3VuZGFyeSk7XHJcbiAgICAgICAgYm91bmRhcnkuYXBwZW5kQ2hpbGQoc2VsZi5lbGVtZW50cy5wcmV2aWV3KTtcclxuICAgICAgICBib3VuZGFyeS5hcHBlbmRDaGlsZCh2aWV3cG9ydCk7XHJcbiAgICAgICAgYm91bmRhcnkuYXBwZW5kQ2hpbGQob3ZlcmxheSk7XHJcblxyXG4gICAgICAgIGFkZENsYXNzKHNlbGYuZWxlbWVudCwgY29udENsYXNzKTtcclxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmN1c3RvbUNsYXNzKSB7XHJcbiAgICAgICAgICAgIGFkZENsYXNzKHNlbGYuZWxlbWVudCwgc2VsZi5vcHRpb25zLmN1c3RvbUNsYXNzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9pbml0RHJhZ2dhYmxlLmNhbGwodGhpcyk7XHJcblxyXG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMuZW5hYmxlWm9vbSkge1xyXG4gICAgICAgICAgICBfaW5pdGlhbGl6ZVpvb20uY2FsbChzZWxmKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGlmIChzZWxmLm9wdGlvbnMuZW5hYmxlT3JpZW50YXRpb24pIHtcclxuICAgICAgICAvLyAgICAgX2luaXRSb3RhdGlvbkNvbnRyb2xzLmNhbGwoc2VsZik7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmVuYWJsZVJlc2l6ZSkge1xyXG4gICAgICAgICAgICBfaW5pdGlhbGl6ZVJlc2l6ZS5jYWxsKHNlbGYpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBmdW5jdGlvbiBfaW5pdFJvdGF0aW9uQ29udHJvbHMgKCkge1xyXG4gICAgLy8gICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgIC8vICAgICAgICAgd3JhcCwgYnRuTGVmdCwgYnRuUmlnaHQsIGlMZWZ0LCBpUmlnaHQ7XHJcblxyXG4gICAgLy8gICAgIHdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIC8vICAgICBzZWxmLmVsZW1lbnRzLm9yaWVudGF0aW9uQnRuTGVmdCA9IGJ0bkxlZnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcclxuICAgIC8vICAgICBzZWxmLmVsZW1lbnRzLm9yaWVudGF0aW9uQnRuUmlnaHQgPSBidG5SaWdodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xyXG5cclxuICAgIC8vICAgICB3cmFwLmFwcGVuZENoaWxkKGJ0bkxlZnQpO1xyXG4gICAgLy8gICAgIHdyYXAuYXBwZW5kQ2hpbGQoYnRuUmlnaHQpO1xyXG5cclxuICAgIC8vICAgICBpTGVmdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2knKTtcclxuICAgIC8vICAgICBpUmlnaHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpJyk7XHJcbiAgICAvLyAgICAgYnRuTGVmdC5hcHBlbmRDaGlsZChpTGVmdCk7XHJcbiAgICAvLyAgICAgYnRuUmlnaHQuYXBwZW5kQ2hpbGQoaVJpZ2h0KTtcclxuXHJcbiAgICAvLyAgICAgYWRkQ2xhc3Mod3JhcCwgJ2NyLXJvdGF0ZS1jb250cm9scycpO1xyXG4gICAgLy8gICAgIGFkZENsYXNzKGJ0bkxlZnQsICdjci1yb3RhdGUtbCcpO1xyXG4gICAgLy8gICAgIGFkZENsYXNzKGJ0blJpZ2h0LCAnY3Itcm90YXRlLXInKTtcclxuXHJcbiAgICAvLyAgICAgc2VsZi5lbGVtZW50cy5ib3VuZGFyeS5hcHBlbmRDaGlsZCh3cmFwKTtcclxuXHJcbiAgICAvLyAgICAgYnRuTGVmdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgIC8vICAgICAgICAgc2VsZi5yb3RhdGUoLTkwKTtcclxuICAgIC8vICAgICB9KTtcclxuICAgIC8vICAgICBidG5SaWdodC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgIC8vICAgICAgICAgc2VsZi5yb3RhdGUoOTApO1xyXG4gICAgLy8gICAgIH0pO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9oYXNFeGlmKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZW5hYmxlRXhpZiAmJiB3aW5kb3cuRVhJRjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfaW5pdGlhbGl6ZVJlc2l6ZSAoKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciB3cmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdmFyIGlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICB2YXIgZGlyZWN0aW9uO1xyXG4gICAgICAgIHZhciBvcmlnaW5hbFg7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsWTtcclxuICAgICAgICB2YXIgbWluU2l6ZSA9IDUwO1xyXG4gICAgICAgIHZhciBtYXhXaWR0aDtcclxuICAgICAgICB2YXIgbWF4SGVpZ2h0O1xyXG4gICAgICAgIHZhciB2cjtcclxuICAgICAgICB2YXIgaHI7XHJcblxyXG4gICAgICAgIGFkZENsYXNzKHdyYXAsICdjci1yZXNpemVyJyk7XHJcbiAgICAgICAgY3NzKHdyYXAsIHtcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMub3B0aW9ucy52aWV3cG9ydC53aWR0aCArICdweCcsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5vcHRpb25zLnZpZXdwb3J0LmhlaWdodCArICdweCdcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXNpemVDb250cm9scy5oZWlnaHQpIHtcclxuICAgICAgICAgICAgdnIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgYWRkQ2xhc3ModnIsICdjci1yZXNpemVyLXZlcnRpY2FsJyk7XHJcbiAgICAgICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQodnIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXNpemVDb250cm9scy53aWR0aCkge1xyXG4gICAgICAgICAgICBociA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBhZGRDbGFzcyhociwgJ2NyLXJlc2l6ZXItaG9yaXNvbnRhbCcpO1xyXG4gICAgICAgICAgICB3cmFwLmFwcGVuZENoaWxkKGhyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG1vdXNlRG93bihldikge1xyXG4gICAgICAgICAgICBpZiAoZXYuYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgZXYuYnV0dG9uICE9PSAwKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBpZiAoaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgb3ZlcmxheVJlY3QgPSBzZWxmLmVsZW1lbnRzLm92ZXJsYXkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgICAgICAgICBpc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgb3JpZ2luYWxYID0gZXYucGFnZVg7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsWSA9IGV2LnBhZ2VZO1xyXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBldi5jdXJyZW50VGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKCd2ZXJ0aWNhbCcpICE9PSAtMSA/ICd2JyA6ICdoJztcclxuICAgICAgICAgICAgbWF4V2lkdGggPSBvdmVybGF5UmVjdC53aWR0aDtcclxuICAgICAgICAgICAgbWF4SGVpZ2h0ID0gb3ZlcmxheVJlY3QuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGV2LnRvdWNoZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b3VjaGVzID0gZXYudG91Y2hlc1swXTtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsWCA9IHRvdWNoZXMucGFnZVg7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFkgPSB0b3VjaGVzLnBhZ2VZO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VNb3ZlKTtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG1vdXNlTW92ZSk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VVcCk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG1vdXNlVXApO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlW0NTU19VU0VSU0VMRUNUXSA9ICdub25lJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG1vdXNlTW92ZShldikge1xyXG4gICAgICAgICAgICB2YXIgcGFnZVggPSBldi5wYWdlWDtcclxuICAgICAgICAgICAgdmFyIHBhZ2VZID0gZXYucGFnZVk7XHJcblxyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGV2LnRvdWNoZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b3VjaGVzID0gZXYudG91Y2hlc1swXTtcclxuICAgICAgICAgICAgICAgIHBhZ2VYID0gdG91Y2hlcy5wYWdlWDtcclxuICAgICAgICAgICAgICAgIHBhZ2VZID0gdG91Y2hlcy5wYWdlWTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRlbHRhWCA9IHBhZ2VYIC0gb3JpZ2luYWxYO1xyXG4gICAgICAgICAgICB2YXIgZGVsdGFZID0gcGFnZVkgLSBvcmlnaW5hbFk7XHJcbiAgICAgICAgICAgIHZhciBuZXdIZWlnaHQgPSBzZWxmLm9wdGlvbnMudmlld3BvcnQuaGVpZ2h0ICsgZGVsdGFZO1xyXG4gICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBzZWxmLm9wdGlvbnMudmlld3BvcnQud2lkdGggKyBkZWx0YVg7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAndicgJiYgbmV3SGVpZ2h0ID49IG1pblNpemUgJiYgbmV3SGVpZ2h0IDw9IG1heEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgY3NzKHdyYXAsIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG5ld0hlaWdodCArICdweCdcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYub3B0aW9ucy5ib3VuZGFyeS5oZWlnaHQgKz0gZGVsdGFZO1xyXG4gICAgICAgICAgICAgICAgY3NzKHNlbGYuZWxlbWVudHMuYm91bmRhcnksIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHNlbGYub3B0aW9ucy5ib3VuZGFyeS5oZWlnaHQgKyAncHgnXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLm9wdGlvbnMudmlld3BvcnQuaGVpZ2h0ICs9IGRlbHRhWTtcclxuICAgICAgICAgICAgICAgIGNzcyhzZWxmLmVsZW1lbnRzLnZpZXdwb3J0LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBzZWxmLm9wdGlvbnMudmlld3BvcnQuaGVpZ2h0ICsgJ3B4J1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnaCcgJiYgbmV3V2lkdGggPj0gbWluU2l6ZSAmJiBuZXdXaWR0aCA8PSBtYXhXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgY3NzKHdyYXAsIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbmV3V2lkdGggKyAncHgnXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLm9wdGlvbnMuYm91bmRhcnkud2lkdGggKz0gZGVsdGFYO1xyXG4gICAgICAgICAgICAgICAgY3NzKHNlbGYuZWxlbWVudHMuYm91bmRhcnksIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogc2VsZi5vcHRpb25zLmJvdW5kYXJ5LndpZHRoICsgJ3B4J1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zLnZpZXdwb3J0LndpZHRoICs9IGRlbHRhWDtcclxuICAgICAgICAgICAgICAgIGNzcyhzZWxmLmVsZW1lbnRzLnZpZXdwb3J0LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHNlbGYub3B0aW9ucy52aWV3cG9ydC53aWR0aCArICdweCdcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfdXBkYXRlT3ZlcmxheS5jYWxsKHNlbGYpO1xyXG4gICAgICAgICAgICBfdXBkYXRlWm9vbUxpbWl0cy5jYWxsKHNlbGYpO1xyXG4gICAgICAgICAgICBfdXBkYXRlQ2VudGVyUG9pbnQuY2FsbChzZWxmKTtcclxuICAgICAgICAgICAgX3RyaWdnZXJVcGRhdGUuY2FsbChzZWxmKTtcclxuICAgICAgICAgICAgb3JpZ2luYWxZID0gcGFnZVk7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsWCA9IHBhZ2VYO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbW91c2VVcCgpIHtcclxuICAgICAgICAgICAgaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VNb3ZlKTtcclxuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG1vdXNlTW92ZSk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VVcCk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG1vdXNlVXApO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlW0NTU19VU0VSU0VMRUNUXSA9ICcnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHZyKSB7XHJcbiAgICAgICAgICAgIHZyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlRG93bik7XHJcbiAgICAgICAgICAgIHZyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBtb3VzZURvd24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGhyKSB7XHJcbiAgICAgICAgICAgIGhyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlRG93bik7XHJcbiAgICAgICAgICAgIGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBtb3VzZURvd24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5lbGVtZW50cy5ib3VuZGFyeS5hcHBlbmRDaGlsZCh3cmFwKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfc2V0Wm9vbWVyVmFsKHYpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZVpvb20pIHtcclxuICAgICAgICAgICAgdmFyIHogPSB0aGlzLmVsZW1lbnRzLnpvb21lcixcclxuICAgICAgICAgICAgICAgIHZhbCA9IGZpeCh2LCA0KTtcclxuXHJcbiAgICAgICAgICAgIHoudmFsdWUgPSBNYXRoLm1heCh6Lm1pbiwgTWF0aC5taW4oei5tYXgsIHZhbCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfaW5pdGlhbGl6ZVpvb20oKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICB3cmFwID0gc2VsZi5lbGVtZW50cy56b29tZXJXcmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXHJcbiAgICAgICAgICAgIHpvb21lciA9IHNlbGYuZWxlbWVudHMuem9vbWVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuXHJcbiAgICAgICAgYWRkQ2xhc3Mod3JhcCwgJ2NyLXNsaWRlci13cmFwJyk7XHJcbiAgICAgICAgYWRkQ2xhc3Moem9vbWVyLCAnY3Itc2xpZGVyJyk7XHJcbiAgICAgICAgem9vbWVyLnR5cGUgPSAncmFuZ2UnO1xyXG4gICAgICAgIHpvb21lci5zdGVwID0gJzAuMDAwMSc7XHJcbiAgICAgICAgem9vbWVyLnZhbHVlID0gMTtcclxuICAgICAgICB6b29tZXIuc3R5bGUuZGlzcGxheSA9IHNlbGYub3B0aW9ucy5zaG93Wm9vbWVyID8gJycgOiAnbm9uZSc7XHJcbiAgICAgICAgem9vbWVyLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsICd6b29tJyk7XHJcblxyXG4gICAgICAgIHNlbGYuZWxlbWVudC5hcHBlbmRDaGlsZCh3cmFwKTtcclxuICAgICAgICB3cmFwLmFwcGVuZENoaWxkKHpvb21lcik7XHJcblxyXG4gICAgICAgIHNlbGYuX2N1cnJlbnRab29tID0gMTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY2hhbmdlKCkge1xyXG4gICAgICAgICAgICBfb25ab29tLmNhbGwoc2VsZiwge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQoem9vbWVyLnZhbHVlKSxcclxuICAgICAgICAgICAgICAgIG9yaWdpbjogbmV3IFRyYW5zZm9ybU9yaWdpbihzZWxmLmVsZW1lbnRzLnByZXZpZXcpLFxyXG4gICAgICAgICAgICAgICAgdmlld3BvcnRSZWN0OiBzZWxmLmVsZW1lbnRzLnZpZXdwb3J0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBUcmFuc2Zvcm0ucGFyc2Uoc2VsZi5lbGVtZW50cy5wcmV2aWV3KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHNjcm9sbChldikge1xyXG4gICAgICAgICAgICB2YXIgZGVsdGEsIHRhcmdldFpvb207XHJcblxyXG4gICAgICAgICAgICBpZihzZWxmLm9wdGlvbnMubW91c2VXaGVlbFpvb20gPT09ICdjdHJsJyAmJiBldi5jdHJsS2V5ICE9IHRydWUpeyBcclxuICAgICAgICAgICAgICByZXR1cm4gMDsgXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXYud2hlZWxEZWx0YSkge1xyXG4gICAgICAgICAgICAgICAgZGVsdGEgPSBldi53aGVlbERlbHRhIC8gMTIwMDsgLy93aGVlbERlbHRhIG1pbjogLTEyMCBtYXg6IDEyMCAvLyBtYXggeCAxMCB4IDJcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChldi5kZWx0YVkpIHtcclxuICAgICAgICAgICAgICAgIGRlbHRhID0gZXYuZGVsdGFZIC8gMTA2MDsgLy9kZWx0YVkgbWluOiAtNTMgbWF4OiA1MyAvLyBtYXggeCAxMCB4IDJcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChldi5kZXRhaWwpIHtcclxuICAgICAgICAgICAgICAgIGRlbHRhID0gZXYuZGV0YWlsIC8gLTYwOyAvL2RlbHRhIG1pbjogLTMgbWF4OiAzIC8vIG1heCB4IDEwIHggMlxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVsdGEgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0YXJnZXRab29tID0gc2VsZi5fY3VycmVudFpvb20gKyAoZGVsdGEgKiBzZWxmLl9jdXJyZW50Wm9vbSk7XHJcblxyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBfc2V0Wm9vbWVyVmFsLmNhbGwoc2VsZiwgdGFyZ2V0Wm9vbSk7XHJcbiAgICAgICAgICAgIGNoYW5nZS5jYWxsKHNlbGYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2VsZi5lbGVtZW50cy56b29tZXIuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBjaGFuZ2UpOy8vIHRoaXMgaXMgYmVpbmcgZmlyZWQgdHdpY2Ugb24ga2V5cHJlc3NcclxuICAgICAgICBzZWxmLmVsZW1lbnRzLnpvb21lci5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2UpO1xyXG5cclxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLm1vdXNlV2hlZWxab29tKSB7XHJcbiAgICAgICAgICAgIHNlbGYuZWxlbWVudHMuYm91bmRhcnkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHNjcm9sbCk7XHJcbiAgICAgICAgICAgIHNlbGYuZWxlbWVudHMuYm91bmRhcnkuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBzY3JvbGwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfb25ab29tKHVpKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSB1aSA/IHVpLnRyYW5zZm9ybSA6IFRyYW5zZm9ybS5wYXJzZShzZWxmLmVsZW1lbnRzLnByZXZpZXcpLFxyXG4gICAgICAgICAgICB2cFJlY3QgPSB1aSA/IHVpLnZpZXdwb3J0UmVjdCA6IHNlbGYuZWxlbWVudHMudmlld3BvcnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcbiAgICAgICAgICAgIG9yaWdpbiA9IHVpID8gdWkub3JpZ2luIDogbmV3IFRyYW5zZm9ybU9yaWdpbihzZWxmLmVsZW1lbnRzLnByZXZpZXcpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhcHBseUNzcygpIHtcclxuICAgICAgICAgICAgdmFyIHRyYW5zQ3NzID0ge307XHJcbiAgICAgICAgICAgIHRyYW5zQ3NzW0NTU19UUkFOU0ZPUk1dID0gdHJhbnNmb3JtLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHRyYW5zQ3NzW0NTU19UUkFOU19PUkddID0gb3JpZ2luLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGNzcyhzZWxmLmVsZW1lbnRzLnByZXZpZXcsIHRyYW5zQ3NzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGYuX2N1cnJlbnRab29tID0gdWkgPyB1aS52YWx1ZSA6IHNlbGYuX2N1cnJlbnRab29tO1xyXG4gICAgICAgIHRyYW5zZm9ybS5zY2FsZSA9IHNlbGYuX2N1cnJlbnRab29tO1xyXG4gICAgICAgIHNlbGYuZWxlbWVudHMuem9vbWVyLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW5vdycsIHNlbGYuX2N1cnJlbnRab29tKTtcclxuICAgICAgICBhcHBseUNzcygpO1xyXG5cclxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmVuZm9yY2VCb3VuZGFyeSkge1xyXG4gICAgICAgICAgICB2YXIgYm91bmRhcmllcyA9IF9nZXRWaXJ0dWFsQm91bmRhcmllcy5jYWxsKHNlbGYsIHZwUmVjdCksXHJcbiAgICAgICAgICAgICAgICB0cmFuc0JvdW5kYXJpZXMgPSBib3VuZGFyaWVzLnRyYW5zbGF0ZSxcclxuICAgICAgICAgICAgICAgIG9Cb3VuZGFyaWVzID0gYm91bmRhcmllcy5vcmlnaW47XHJcblxyXG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtLnggPj0gdHJhbnNCb3VuZGFyaWVzLm1heFgpIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbi54ID0gb0JvdW5kYXJpZXMubWluWDtcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybS54ID0gdHJhbnNCb3VuZGFyaWVzLm1heFg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0ueCA8PSB0cmFuc0JvdW5kYXJpZXMubWluWCkge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luLnggPSBvQm91bmRhcmllcy5tYXhYO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLnggPSB0cmFuc0JvdW5kYXJpZXMubWluWDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybS55ID49IHRyYW5zQm91bmRhcmllcy5tYXhZKSB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW4ueSA9IG9Cb3VuZGFyaWVzLm1pblk7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0ueSA9IHRyYW5zQm91bmRhcmllcy5tYXhZO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtLnkgPD0gdHJhbnNCb3VuZGFyaWVzLm1pblkpIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbi55ID0gb0JvdW5kYXJpZXMubWF4WTtcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybS55ID0gdHJhbnNCb3VuZGFyaWVzLm1pblk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYXBwbHlDc3MoKTtcclxuICAgICAgICBfZGVib3VuY2VkT3ZlcmxheS5jYWxsKHNlbGYpO1xyXG4gICAgICAgIF90cmlnZ2VyVXBkYXRlLmNhbGwoc2VsZik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldFZpcnR1YWxCb3VuZGFyaWVzKHZpZXdwb3J0KSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICBzY2FsZSA9IHNlbGYuX2N1cnJlbnRab29tLFxyXG4gICAgICAgICAgICB2cFdpZHRoID0gdmlld3BvcnQud2lkdGgsXHJcbiAgICAgICAgICAgIHZwSGVpZ2h0ID0gdmlld3BvcnQuaGVpZ2h0LFxyXG4gICAgICAgICAgICBjZW50ZXJGcm9tQm91bmRhcnlYID0gc2VsZi5lbGVtZW50cy5ib3VuZGFyeS5jbGllbnRXaWR0aCAvIDIsXHJcbiAgICAgICAgICAgIGNlbnRlckZyb21Cb3VuZGFyeVkgPSBzZWxmLmVsZW1lbnRzLmJvdW5kYXJ5LmNsaWVudEhlaWdodCAvIDIsXHJcbiAgICAgICAgICAgIGltZ1JlY3QgPSBzZWxmLmVsZW1lbnRzLnByZXZpZXcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcbiAgICAgICAgICAgIGN1ckltZ1dpZHRoID0gaW1nUmVjdC53aWR0aCxcclxuICAgICAgICAgICAgY3VySW1nSGVpZ2h0ID0gaW1nUmVjdC5oZWlnaHQsXHJcbiAgICAgICAgICAgIGhhbGZXaWR0aCA9IHZwV2lkdGggLyAyLFxyXG4gICAgICAgICAgICBoYWxmSGVpZ2h0ID0gdnBIZWlnaHQgLyAyO1xyXG5cclxuICAgICAgICB2YXIgbWF4WCA9ICgoaGFsZldpZHRoIC8gc2NhbGUpIC0gY2VudGVyRnJvbUJvdW5kYXJ5WCkgKiAtMTtcclxuICAgICAgICB2YXIgbWluWCA9IG1heFggLSAoKGN1ckltZ1dpZHRoICogKDEgLyBzY2FsZSkpIC0gKHZwV2lkdGggKiAoMSAvIHNjYWxlKSkpO1xyXG5cclxuICAgICAgICB2YXIgbWF4WSA9ICgoaGFsZkhlaWdodCAvIHNjYWxlKSAtIGNlbnRlckZyb21Cb3VuZGFyeVkpICogLTE7XHJcbiAgICAgICAgdmFyIG1pblkgPSBtYXhZIC0gKChjdXJJbWdIZWlnaHQgKiAoMSAvIHNjYWxlKSkgLSAodnBIZWlnaHQgKiAoMSAvIHNjYWxlKSkpO1xyXG5cclxuICAgICAgICB2YXIgb3JpZ2luTWluWCA9ICgxIC8gc2NhbGUpICogaGFsZldpZHRoO1xyXG4gICAgICAgIHZhciBvcmlnaW5NYXhYID0gKGN1ckltZ1dpZHRoICogKDEgLyBzY2FsZSkpIC0gb3JpZ2luTWluWDtcclxuXHJcbiAgICAgICAgdmFyIG9yaWdpbk1pblkgPSAoMSAvIHNjYWxlKSAqIGhhbGZIZWlnaHQ7XHJcbiAgICAgICAgdmFyIG9yaWdpbk1heFkgPSAoY3VySW1nSGVpZ2h0ICogKDEgLyBzY2FsZSkpIC0gb3JpZ2luTWluWTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHJhbnNsYXRlOiB7XHJcbiAgICAgICAgICAgICAgICBtYXhYOiBtYXhYLFxyXG4gICAgICAgICAgICAgICAgbWluWDogbWluWCxcclxuICAgICAgICAgICAgICAgIG1heFk6IG1heFksXHJcbiAgICAgICAgICAgICAgICBtaW5ZOiBtaW5ZXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9yaWdpbjoge1xyXG4gICAgICAgICAgICAgICAgbWF4WDogb3JpZ2luTWF4WCxcclxuICAgICAgICAgICAgICAgIG1pblg6IG9yaWdpbk1pblgsXHJcbiAgICAgICAgICAgICAgICBtYXhZOiBvcmlnaW5NYXhZLFxyXG4gICAgICAgICAgICAgICAgbWluWTogb3JpZ2luTWluWVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlQ2VudGVyUG9pbnQoKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICBzY2FsZSA9IHNlbGYuX2N1cnJlbnRab29tLFxyXG4gICAgICAgICAgICBkYXRhID0gc2VsZi5lbGVtZW50cy5wcmV2aWV3LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxyXG4gICAgICAgICAgICB2cERhdGEgPSBzZWxmLmVsZW1lbnRzLnZpZXdwb3J0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBUcmFuc2Zvcm0ucGFyc2Uoc2VsZi5lbGVtZW50cy5wcmV2aWV3LnN0eWxlW0NTU19UUkFOU0ZPUk1dKSxcclxuICAgICAgICAgICAgcGMgPSBuZXcgVHJhbnNmb3JtT3JpZ2luKHNlbGYuZWxlbWVudHMucHJldmlldyksXHJcbiAgICAgICAgICAgIHRvcCA9ICh2cERhdGEudG9wIC0gZGF0YS50b3ApICsgKHZwRGF0YS5oZWlnaHQgLyAyKSxcclxuICAgICAgICAgICAgbGVmdCA9ICh2cERhdGEubGVmdCAtIGRhdGEubGVmdCkgKyAodnBEYXRhLndpZHRoIC8gMiksXHJcbiAgICAgICAgICAgIGNlbnRlciA9IHt9LFxyXG4gICAgICAgICAgICBhZGogPSB7fTtcclxuXHJcbiAgICAgICAgY2VudGVyLnkgPSB0b3AgLyBzY2FsZTtcclxuICAgICAgICBjZW50ZXIueCA9IGxlZnQgLyBzY2FsZTtcclxuXHJcbiAgICAgICAgYWRqLnkgPSAoY2VudGVyLnkgLSBwYy55KSAqICgxIC0gc2NhbGUpO1xyXG4gICAgICAgIGFkai54ID0gKGNlbnRlci54IC0gcGMueCkgKiAoMSAtIHNjYWxlKTtcclxuXHJcbiAgICAgICAgdHJhbnNmb3JtLnggLT0gYWRqLng7XHJcbiAgICAgICAgdHJhbnNmb3JtLnkgLT0gYWRqLnk7XHJcblxyXG4gICAgICAgIHZhciBuZXdDc3MgPSB7fTtcclxuICAgICAgICBuZXdDc3NbQ1NTX1RSQU5TX09SR10gPSBjZW50ZXIueCArICdweCAnICsgY2VudGVyLnkgKyAncHgnO1xyXG4gICAgICAgIG5ld0Nzc1tDU1NfVFJBTlNGT1JNXSA9IHRyYW5zZm9ybS50b1N0cmluZygpO1xyXG4gICAgICAgIGNzcyhzZWxmLmVsZW1lbnRzLnByZXZpZXcsIG5ld0Nzcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2luaXREcmFnZ2FibGUoKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICBpc0RyYWdnaW5nID0gZmFsc2UsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsWCxcclxuICAgICAgICAgICAgb3JpZ2luYWxZLFxyXG4gICAgICAgICAgICBvcmlnaW5hbERpc3RhbmNlLFxyXG4gICAgICAgICAgICB2cFJlY3QsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYXNzaWduVHJhbnNmb3JtQ29vcmRpbmF0ZXMoZGVsdGFYLCBkZWx0YVkpIHtcclxuICAgICAgICAgICAgdmFyIGltZ1JlY3QgPSBzZWxmLmVsZW1lbnRzLnByZXZpZXcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcbiAgICAgICAgICAgICAgICB0b3AgPSB0cmFuc2Zvcm0ueSArIGRlbHRhWSxcclxuICAgICAgICAgICAgICAgIGxlZnQgPSB0cmFuc2Zvcm0ueCArIGRlbHRhWDtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuZW5mb3JjZUJvdW5kYXJ5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodnBSZWN0LnRvcCA+IGltZ1JlY3QudG9wICsgZGVsdGFZICYmIHZwUmVjdC5ib3R0b20gPCBpbWdSZWN0LmJvdHRvbSArIGRlbHRhWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS55ID0gdG9wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2cFJlY3QubGVmdCA+IGltZ1JlY3QubGVmdCArIGRlbHRhWCAmJiB2cFJlY3QucmlnaHQgPCBpbWdSZWN0LnJpZ2h0ICsgZGVsdGFYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLnggPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLnkgPSB0b3A7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0ueCA9IGxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHRvZ2dsZUdyYWJTdGF0ZShpc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICBzZWxmLmVsZW1lbnRzLnByZXZpZXcuc2V0QXR0cmlidXRlKCdhcmlhLWdyYWJiZWQnLCBpc0RyYWdnaW5nKTtcclxuICAgICAgICAgIHNlbGYuZWxlbWVudHMuYm91bmRhcnkuc2V0QXR0cmlidXRlKCdhcmlhLWRyb3BlZmZlY3QnLCBpc0RyYWdnaW5nPyAnbW92ZSc6ICdub25lJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBrZXlEb3duKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBMRUZUX0FSUk9XICA9IDM3LFxyXG4gICAgICAgICAgICAgICAgVVBfQVJST1cgICAgPSAzOCxcclxuICAgICAgICAgICAgICAgIFJJR0hUX0FSUk9XID0gMzksXHJcbiAgICAgICAgICAgICAgICBET1dOX0FSUk9XICA9IDQwO1xyXG5cclxuICAgICAgICAgICAgaWYgKGV2LnNoaWZ0S2V5ICYmIChldi5rZXlDb2RlID09IFVQX0FSUk9XIHx8IGV2LmtleUNvZGUgPT0gRE9XTl9BUlJPVykpIHtcclxuICAgICAgICAgICAgICAgIHZhciB6b29tID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2LmtleUNvZGUgPT0gVVBfQVJST1cpIHtcclxuICAgICAgICAgICAgICAgICAgICB6b29tID0gcGFyc2VGbG9hdChzZWxmLmVsZW1lbnRzLnpvb21lci52YWx1ZSwgMTApICsgcGFyc2VGbG9hdChzZWxmLmVsZW1lbnRzLnpvb21lci5zdGVwLCAxMClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHpvb20gPSBwYXJzZUZsb2F0KHNlbGYuZWxlbWVudHMuem9vbWVyLnZhbHVlLCAxMCkgLSBwYXJzZUZsb2F0KHNlbGYuZWxlbWVudHMuem9vbWVyLnN0ZXAsIDEwKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VsZi5zZXRab29tKHpvb20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYub3B0aW9ucy5lbmFibGVLZXlNb3ZlbWVudCAmJiAoZXYua2V5Q29kZSA+PSAzNyAmJiBldi5rZXlDb2RlIDw9IDQwKSkge1xyXG4gICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBtb3ZlbWVudCA9IHBhcnNlS2V5RG93bihldi5rZXlDb2RlKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gPSBUcmFuc2Zvcm0ucGFyc2Uoc2VsZi5lbGVtZW50cy5wcmV2aWV3KTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGVbQ1NTX1VTRVJTRUxFQ1RdID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgdnBSZWN0ID0gc2VsZi5lbGVtZW50cy52aWV3cG9ydC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgICAgIGtleU1vdmUobW92ZW1lbnQpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VLZXlEb3duKGtleSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIExFRlRfQVJST1c6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMSwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBVUF9BUlJPVzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFswLCAxXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFJJR0hUX0FSUk9XOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWy0xLCAwXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIERPV05fQVJST1c6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMCwgLTFdO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGtleU1vdmUobW92ZW1lbnQpIHtcclxuICAgICAgICAgICAgdmFyIGRlbHRhWCA9IG1vdmVtZW50WzBdLFxyXG4gICAgICAgICAgICAgICAgZGVsdGFZID0gbW92ZW1lbnRbMV0sXHJcbiAgICAgICAgICAgICAgICBuZXdDc3MgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGFzc2lnblRyYW5zZm9ybUNvb3JkaW5hdGVzKGRlbHRhWCwgZGVsdGFZKTtcclxuXHJcbiAgICAgICAgICAgIG5ld0Nzc1tDU1NfVFJBTlNGT1JNXSA9IHRyYW5zZm9ybS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjc3Moc2VsZi5lbGVtZW50cy5wcmV2aWV3LCBuZXdDc3MpO1xyXG4gICAgICAgICAgICBfdXBkYXRlT3ZlcmxheS5jYWxsKHNlbGYpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlW0NTU19VU0VSU0VMRUNUXSA9ICcnO1xyXG4gICAgICAgICAgICBfdXBkYXRlQ2VudGVyUG9pbnQuY2FsbChzZWxmKTtcclxuICAgICAgICAgICAgX3RyaWdnZXJVcGRhdGUuY2FsbChzZWxmKTtcclxuICAgICAgICAgICAgb3JpZ2luYWxEaXN0YW5jZSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBtb3VzZURvd24oZXYpIHtcclxuICAgICAgICAgICAgaWYgKGV2LmJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIGV2LmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgaWYgKGlzRHJhZ2dpbmcpIHJldHVybjtcclxuICAgICAgICAgICAgaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsWCA9IGV2LnBhZ2VYO1xyXG4gICAgICAgICAgICBvcmlnaW5hbFkgPSBldi5wYWdlWTtcclxuXHJcbiAgICAgICAgICAgIGlmIChldi50b3VjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG91Y2hlcyA9IGV2LnRvdWNoZXNbMF07XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFggPSB0b3VjaGVzLnBhZ2VYO1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxZID0gdG91Y2hlcy5wYWdlWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0b2dnbGVHcmFiU3RhdGUoaXNEcmFnZ2luZyk7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IFRyYW5zZm9ybS5wYXJzZShzZWxmLmVsZW1lbnRzLnByZXZpZXcpO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VNb3ZlKTtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG1vdXNlTW92ZSk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VVcCk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG1vdXNlVXApO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlW0NTU19VU0VSU0VMRUNUXSA9ICdub25lJztcclxuICAgICAgICAgICAgdnBSZWN0ID0gc2VsZi5lbGVtZW50cy52aWV3cG9ydC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG1vdXNlTW92ZShldikge1xyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB2YXIgcGFnZVggPSBldi5wYWdlWCxcclxuICAgICAgICAgICAgICAgIHBhZ2VZID0gZXYucGFnZVk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZXYudG91Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoZXMgPSBldi50b3VjaGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgcGFnZVggPSB0b3VjaGVzLnBhZ2VYO1xyXG4gICAgICAgICAgICAgICAgcGFnZVkgPSB0b3VjaGVzLnBhZ2VZO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGVsdGFYID0gcGFnZVggLSBvcmlnaW5hbFgsXHJcbiAgICAgICAgICAgICAgICBkZWx0YVkgPSBwYWdlWSAtIG9yaWdpbmFsWSxcclxuICAgICAgICAgICAgICAgIG5ld0NzcyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgaWYgKGV2LnR5cGUgPT0gJ3RvdWNobW92ZScpIHtcclxuICAgICAgICAgICAgICAgIGlmIChldi50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG91Y2gxID0gZXYudG91Y2hlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG91Y2gyID0gZXYudG91Y2hlc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IE1hdGguc3FydCgodG91Y2gxLnBhZ2VYIC0gdG91Y2gyLnBhZ2VYKSAqICh0b3VjaDEucGFnZVggLSB0b3VjaDIucGFnZVgpICsgKHRvdWNoMS5wYWdlWSAtIHRvdWNoMi5wYWdlWSkgKiAodG91Y2gxLnBhZ2VZIC0gdG91Y2gyLnBhZ2VZKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbERpc3RhbmNlID0gZGlzdCAvIHNlbGYuX2N1cnJlbnRab29tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gZGlzdCAvIG9yaWdpbmFsRGlzdGFuY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9zZXRab29tZXJWYWwuY2FsbChzZWxmLCBzY2FsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hDaGFuZ2Uoc2VsZi5lbGVtZW50cy56b29tZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYXNzaWduVHJhbnNmb3JtQ29vcmRpbmF0ZXMoZGVsdGFYLCBkZWx0YVkpO1xyXG5cclxuICAgICAgICAgICAgbmV3Q3NzW0NTU19UUkFOU0ZPUk1dID0gdHJhbnNmb3JtLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGNzcyhzZWxmLmVsZW1lbnRzLnByZXZpZXcsIG5ld0Nzcyk7XHJcbiAgICAgICAgICAgIF91cGRhdGVPdmVybGF5LmNhbGwoc2VsZik7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsWSA9IHBhZ2VZO1xyXG4gICAgICAgICAgICBvcmlnaW5hbFggPSBwYWdlWDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG1vdXNlVXAoKSB7XHJcbiAgICAgICAgICAgIGlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdG9nZ2xlR3JhYlN0YXRlKGlzRHJhZ2dpbmcpO1xyXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VNb3ZlKTtcclxuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG1vdXNlTW92ZSk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VVcCk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG1vdXNlVXApO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlW0NTU19VU0VSU0VMRUNUXSA9ICcnO1xyXG4gICAgICAgICAgICBfdXBkYXRlQ2VudGVyUG9pbnQuY2FsbChzZWxmKTtcclxuICAgICAgICAgICAgX3RyaWdnZXJVcGRhdGUuY2FsbChzZWxmKTtcclxuICAgICAgICAgICAgb3JpZ2luYWxEaXN0YW5jZSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZWxmLmVsZW1lbnRzLm92ZXJsYXkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2VEb3duKTtcclxuICAgICAgICBzZWxmLmVsZW1lbnRzLnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlEb3duKTtcclxuICAgICAgICBzZWxmLmVsZW1lbnRzLm92ZXJsYXkuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG1vdXNlRG93bik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3VwZGF0ZU92ZXJsYXkoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnRzKSByZXR1cm47IC8vIHNpbmNlIHRoaXMgaXMgZGVib3VuY2VkLCBpdCBjYW4gYmUgZmlyZWQgYWZ0ZXIgZGVzdHJveVxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgYm91bmRSZWN0ID0gc2VsZi5lbGVtZW50cy5ib3VuZGFyeS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcclxuICAgICAgICAgICAgaW1nRGF0YSA9IHNlbGYuZWxlbWVudHMucHJldmlldy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICAgICAgY3NzKHNlbGYuZWxlbWVudHMub3ZlcmxheSwge1xyXG4gICAgICAgICAgICB3aWR0aDogaW1nRGF0YS53aWR0aCArICdweCcsXHJcbiAgICAgICAgICAgIGhlaWdodDogaW1nRGF0YS5oZWlnaHQgKyAncHgnLFxyXG4gICAgICAgICAgICB0b3A6IChpbWdEYXRhLnRvcCAtIGJvdW5kUmVjdC50b3ApICsgJ3B4JyxcclxuICAgICAgICAgICAgbGVmdDogKGltZ0RhdGEubGVmdCAtIGJvdW5kUmVjdC5sZWZ0KSArICdweCdcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHZhciBfZGVib3VuY2VkT3ZlcmxheSA9IGRlYm91bmNlKF91cGRhdGVPdmVybGF5LCA1MDApO1xyXG5cclxuICAgIGZ1bmN0aW9uIF90cmlnZ2VyVXBkYXRlKCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgZGF0YSA9IHNlbGYuZ2V0KCksXHJcbiAgICAgICAgICAgIGV2O1xyXG5cclxuICAgICAgICBpZiAoIV9pc1Zpc2libGUuY2FsbChzZWxmKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZWxmLm9wdGlvbnMudXBkYXRlLmNhbGwoc2VsZiwgZGF0YSk7XHJcbiAgICAgICAgaWYgKHNlbGYuJCAmJiB0eXBlb2YgUHJvdG90eXBlID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHNlbGYuJChzZWxmLmVsZW1lbnQpLnRyaWdnZXIoJ3VwZGF0ZS5jcm9wcGllJywgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgZXY7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGV2ID0gbmV3IEN1c3RvbUV2ZW50KCd1cGRhdGUnLCB7IGRldGFpbDogZGF0YSB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XHJcbiAgICAgICAgICAgICAgICBldi5pbml0Q3VzdG9tRXZlbnQoJ3VwZGF0ZScsIHRydWUsIHRydWUsIGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWxmLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChldik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9pc1Zpc2libGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMucHJldmlldy5vZmZzZXRIZWlnaHQgPiAwICYmIHRoaXMuZWxlbWVudHMucHJldmlldy5vZmZzZXRXaWR0aCA+IDA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3VwZGF0ZVByb3BlcnRpZXNGcm9tSW1hZ2UoKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICBpbml0aWFsWm9vbSA9IDEsXHJcbiAgICAgICAgICAgIGNzc1Jlc2V0ID0ge30sXHJcbiAgICAgICAgICAgIGltZyA9IHNlbGYuZWxlbWVudHMucHJldmlldyxcclxuICAgICAgICAgICAgaW1nRGF0YSA9IG51bGwsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybVJlc2V0ID0gbmV3IFRyYW5zZm9ybSgwLCAwLCBpbml0aWFsWm9vbSksXHJcbiAgICAgICAgICAgIG9yaWdpblJlc2V0ID0gbmV3IFRyYW5zZm9ybU9yaWdpbigpLFxyXG4gICAgICAgICAgICBpc1Zpc2libGUgPSBfaXNWaXNpYmxlLmNhbGwoc2VsZik7XHJcblxyXG4gICAgICAgIGlmICghaXNWaXNpYmxlIHx8IHNlbGYuZGF0YS5ib3VuZCkgey8vIGlmIHRoZSBjcm9wcGllIGlzbid0IHZpc2libGUgb3IgaXQgZG9lc24ndCBuZWVkIGJpbmRpbmdcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2VsZi5kYXRhLmJvdW5kID0gdHJ1ZTtcclxuICAgICAgICBjc3NSZXNldFtDU1NfVFJBTlNGT1JNXSA9IHRyYW5zZm9ybVJlc2V0LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3NzUmVzZXRbQ1NTX1RSQU5TX09SR10gPSBvcmlnaW5SZXNldC50b1N0cmluZygpO1xyXG4gICAgICAgIGNzc1Jlc2V0WydvcGFjaXR5J10gPSAxO1xyXG4gICAgICAgIGNzcyhpbWcsIGNzc1Jlc2V0KTtcclxuXHJcbiAgICAgICAgaW1nRGF0YSA9IHNlbGYuZWxlbWVudHMucHJldmlldy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICAgICAgc2VsZi5fb3JpZ2luYWxJbWFnZVdpZHRoID0gaW1nRGF0YS53aWR0aDtcclxuICAgICAgICBzZWxmLl9vcmlnaW5hbEltYWdlSGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XHJcbiAgICAgICAgc2VsZi5kYXRhLm9yaWVudGF0aW9uID0gZ2V0RXhpZk9yaWVudGF0aW9uKHNlbGYuZWxlbWVudHMuaW1nKTtcclxuXHJcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5lbmFibGVab29tKSB7XHJcbiAgICAgICAgICAgIF91cGRhdGVab29tTGltaXRzLmNhbGwoc2VsZiwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZWxmLl9jdXJyZW50Wm9vbSA9IGluaXRpYWxab29tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJhbnNmb3JtUmVzZXQuc2NhbGUgPSBzZWxmLl9jdXJyZW50Wm9vbTtcclxuICAgICAgICBjc3NSZXNldFtDU1NfVFJBTlNGT1JNXSA9IHRyYW5zZm9ybVJlc2V0LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3NzKGltZywgY3NzUmVzZXQpO1xyXG5cclxuICAgICAgICBpZiAoc2VsZi5kYXRhLnBvaW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgX2JpbmRQb2ludHMuY2FsbChzZWxmLCBzZWxmLmRhdGEucG9pbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9jZW50ZXJJbWFnZS5jYWxsKHNlbGYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX3VwZGF0ZUNlbnRlclBvaW50LmNhbGwoc2VsZik7XHJcbiAgICAgICAgX3VwZGF0ZU92ZXJsYXkuY2FsbChzZWxmKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlWm9vbUxpbWl0cyAoaW5pdGlhbCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgbWluWm9vbSA9IDAsXHJcbiAgICAgICAgICAgIG1heFpvb20gPSBzZWxmLm9wdGlvbnMubWF4Wm9vbSB8fCAxLjUsXHJcbiAgICAgICAgICAgIGluaXRpYWxab29tLFxyXG4gICAgICAgICAgICBkZWZhdWx0SW5pdGlhbFpvb20sXHJcbiAgICAgICAgICAgIHpvb21lciA9IHNlbGYuZWxlbWVudHMuem9vbWVyLFxyXG4gICAgICAgICAgICBzY2FsZSA9IHBhcnNlRmxvYXQoem9vbWVyLnZhbHVlKSxcclxuICAgICAgICAgICAgYm91bmRhcnlEYXRhID0gc2VsZi5lbGVtZW50cy5ib3VuZGFyeS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcclxuICAgICAgICAgICAgaW1nRGF0YSA9IG5hdHVyYWxJbWFnZURpbWVuc2lvbnMoc2VsZi5lbGVtZW50cy5pbWcsIHNlbGYuZGF0YS5vcmllbnRhdGlvbiksXHJcbiAgICAgICAgICAgIHZwRGF0YSA9IHNlbGYuZWxlbWVudHMudmlld3BvcnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcbiAgICAgICAgICAgIG1pblcsXHJcbiAgICAgICAgICAgIG1pbkg7XHJcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5lbmZvcmNlQm91bmRhcnkpIHtcclxuICAgICAgICAgICAgbWluVyA9IHZwRGF0YS53aWR0aCAvIGltZ0RhdGEud2lkdGg7XHJcbiAgICAgICAgICAgIG1pbkggPSB2cERhdGEuaGVpZ2h0IC8gaW1nRGF0YS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIG1pblpvb20gPSBNYXRoLm1heChtaW5XLCBtaW5IKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtaW5ab29tID49IG1heFpvb20pIHtcclxuICAgICAgICAgICAgbWF4Wm9vbSA9IG1pblpvb20gKyAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgem9vbWVyLm1pbiA9IGZpeChtaW5ab29tLCA0KTtcclxuICAgICAgICB6b29tZXIubWF4ID0gZml4KG1heFpvb20sIDQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICghaW5pdGlhbCAmJiAoc2NhbGUgPCB6b29tZXIubWluIHx8IHNjYWxlID4gem9vbWVyLm1heCkpIHtcclxuICAgICAgICAgICAgX3NldFpvb21lclZhbC5jYWxsKHNlbGYsIHNjYWxlIDwgem9vbWVyLm1pbiA/IHpvb21lci5taW4gOiB6b29tZXIubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5pdGlhbCkge1xyXG4gICAgICAgICAgICBkZWZhdWx0SW5pdGlhbFpvb20gPSBNYXRoLm1heCgoYm91bmRhcnlEYXRhLndpZHRoIC8gaW1nRGF0YS53aWR0aCksIChib3VuZGFyeURhdGEuaGVpZ2h0IC8gaW1nRGF0YS5oZWlnaHQpKTtcclxuICAgICAgICAgICAgaW5pdGlhbFpvb20gPSBzZWxmLmRhdGEuYm91bmRab29tICE9PSBudWxsID8gc2VsZi5kYXRhLmJvdW5kWm9vbSA6IGRlZmF1bHRJbml0aWFsWm9vbTtcclxuICAgICAgICAgICAgX3NldFpvb21lclZhbC5jYWxsKHNlbGYsIGluaXRpYWxab29tKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRpc3BhdGNoQ2hhbmdlKHpvb21lcik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2JpbmRQb2ludHMocG9pbnRzKSB7XHJcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggIT0gNCkge1xyXG4gICAgICAgICAgICB0aHJvdyBcIkNyb3BwaWUgLSBJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgc3VwcGxpZWQ6IFwiICsgcG9pbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICAgIHBvaW50c1dpZHRoID0gcG9pbnRzWzJdIC0gcG9pbnRzWzBdLFxyXG4gICAgICAgICAgICAvLyBwb2ludHNIZWlnaHQgPSBwb2ludHNbM10gLSBwb2ludHNbMV0sXHJcbiAgICAgICAgICAgIHZwRGF0YSA9IHNlbGYuZWxlbWVudHMudmlld3BvcnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcbiAgICAgICAgICAgIGJvdW5kUmVjdCA9IHNlbGYuZWxlbWVudHMuYm91bmRhcnkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcbiAgICAgICAgICAgIHZwT2Zmc2V0ID0ge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogdnBEYXRhLmxlZnQgLSBib3VuZFJlY3QubGVmdCxcclxuICAgICAgICAgICAgICAgIHRvcDogdnBEYXRhLnRvcCAtIGJvdW5kUmVjdC50b3BcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2NhbGUgPSB2cERhdGEud2lkdGggLyBwb2ludHNXaWR0aCxcclxuICAgICAgICAgICAgb3JpZ2luVG9wID0gcG9pbnRzWzFdLFxyXG4gICAgICAgICAgICBvcmlnaW5MZWZ0ID0gcG9pbnRzWzBdLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1Ub3AgPSAoLTEgKiBwb2ludHNbMV0pICsgdnBPZmZzZXQudG9wLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1MZWZ0ID0gKC0xICogcG9pbnRzWzBdKSArIHZwT2Zmc2V0LmxlZnQsXHJcbiAgICAgICAgICAgIG5ld0NzcyA9IHt9O1xyXG5cclxuICAgICAgICBuZXdDc3NbQ1NTX1RSQU5TX09SR10gPSBvcmlnaW5MZWZ0ICsgJ3B4ICcgKyBvcmlnaW5Ub3AgKyAncHgnO1xyXG4gICAgICAgIG5ld0Nzc1tDU1NfVFJBTlNGT1JNXSA9IG5ldyBUcmFuc2Zvcm0odHJhbnNmb3JtTGVmdCwgdHJhbnNmb3JtVG9wLCBzY2FsZSkudG9TdHJpbmcoKTtcclxuICAgICAgICBjc3Moc2VsZi5lbGVtZW50cy5wcmV2aWV3LCBuZXdDc3MpO1xyXG5cclxuICAgICAgICBfc2V0Wm9vbWVyVmFsLmNhbGwoc2VsZiwgc2NhbGUpO1xyXG4gICAgICAgIHNlbGYuX2N1cnJlbnRab29tID0gc2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2NlbnRlckltYWdlKCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgaW1nRGltID0gc2VsZi5lbGVtZW50cy5wcmV2aWV3LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxyXG4gICAgICAgICAgICB2cERpbSA9IHNlbGYuZWxlbWVudHMudmlld3BvcnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcbiAgICAgICAgICAgIGJvdW5kRGltID0gc2VsZi5lbGVtZW50cy5ib3VuZGFyeS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcclxuICAgICAgICAgICAgdnBMZWZ0ID0gdnBEaW0ubGVmdCAtIGJvdW5kRGltLmxlZnQsXHJcbiAgICAgICAgICAgIHZwVG9wID0gdnBEaW0udG9wIC0gYm91bmREaW0udG9wLFxyXG4gICAgICAgICAgICB3ID0gdnBMZWZ0IC0gKChpbWdEaW0ud2lkdGggLSB2cERpbS53aWR0aCkgLyAyKSxcclxuICAgICAgICAgICAgaCA9IHZwVG9wIC0gKChpbWdEaW0uaGVpZ2h0IC0gdnBEaW0uaGVpZ2h0KSAvIDIpLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKHcsIGgsIHNlbGYuX2N1cnJlbnRab29tKTtcclxuXHJcbiAgICAgICAgY3NzKHNlbGYuZWxlbWVudHMucHJldmlldywgQ1NTX1RSQU5TRk9STSwgdHJhbnNmb3JtLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF90cmFuc2ZlckltYWdlVG9DYW52YXMoY3VzdG9tT3JpZW50YXRpb24pIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICAgIGNhbnZhcyA9IHNlbGYuZWxlbWVudHMuY2FudmFzLFxyXG4gICAgICAgICAgICBpbWcgPSBzZWxmLmVsZW1lbnRzLmltZyxcclxuICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyksXHJcbiAgICAgICAgICAgIGV4aWYgPSBfaGFzRXhpZi5jYWxsKHNlbGYpLFxyXG4gICAgICAgICAgICBjdXN0b21PcmllbnRhdGlvbiA9IHNlbGYub3B0aW9ucy5lbmFibGVPcmllbnRhdGlvbiAmJiBjdXN0b21PcmllbnRhdGlvbjtcclxuXHJcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKGV4aWYgJiYgIWN1c3RvbU9yaWVudGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBvcmllbnRhdGlvbiA9IGdldEV4aWZPcmllbnRhdGlvbihpbWcpO1xyXG4gICAgICAgICAgICBkcmF3Q2FudmFzKGNhbnZhcywgaW1nLCBudW0ob3JpZW50YXRpb24gfHwgMCwgMTApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3VzdG9tT3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgZHJhd0NhbnZhcyhjYW52YXMsIGltZywgY3VzdG9tT3JpZW50YXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0Q2FudmFzKGRhdGEpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICAgIHBvaW50cyA9IGRhdGEucG9pbnRzLFxyXG4gICAgICAgICAgICBsZWZ0ID0gbnVtKHBvaW50c1swXSksXHJcbiAgICAgICAgICAgIHRvcCA9IG51bShwb2ludHNbMV0pLFxyXG4gICAgICAgICAgICByaWdodCA9IG51bShwb2ludHNbMl0pLFxyXG4gICAgICAgICAgICBib3R0b20gPSBudW0ocG9pbnRzWzNdKSxcclxuICAgICAgICAgICAgd2lkdGggPSByaWdodC1sZWZ0LFxyXG4gICAgICAgICAgICBoZWlnaHQgPSBib3R0b20tdG9wLFxyXG4gICAgICAgICAgICBjaXJjbGUgPSBkYXRhLmNpcmNsZSxcclxuICAgICAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyksXHJcbiAgICAgICAgICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxyXG4gICAgICAgICAgICBzdGFydFggPSAwLFxyXG4gICAgICAgICAgICBzdGFydFkgPSAwLFxyXG4gICAgICAgICAgICBjYW52YXNXaWR0aCA9IGRhdGEub3V0cHV0V2lkdGggfHwgd2lkdGgsXHJcbiAgICAgICAgICAgIGNhbnZhc0hlaWdodCA9IGRhdGEub3V0cHV0SGVpZ2h0IHx8IGhlaWdodCxcclxuICAgICAgICAgICAgY3VzdG9tRGltZW5zaW9ucyA9IChkYXRhLm91dHB1dFdpZHRoICYmIGRhdGEub3V0cHV0SGVpZ2h0KSxcclxuICAgICAgICAgICAgb3V0cHV0V2lkdGhSYXRpbyA9IDE7XHJcbiAgICAgICAgICAgIG91dHB1dEhlaWdodFJhdGlvID0gMTtcclxuXHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKGRhdGEuYmFja2dyb3VuZENvbG9yKSB7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBkYXRhLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2lkdGg9TWF0aC5taW4od2lkdGgsIHNlbGYuX29yaWdpbmFsSW1hZ2VXaWR0aCk7XHJcbiAgICAgICAgaGVpZ2h0PU1hdGgubWluKGhlaWdodCwgc2VsZi5fb3JpZ2luYWxJbWFnZUhlaWdodClcclxuICAgIFxyXG4gICAgICAgIC8vIGNvbnNvbGUudGFibGUoeyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQgfSk7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmVsZW1lbnRzLnByZXZpZXcsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCwgc3RhcnRYLCBzdGFydFksIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xyXG4gICAgICAgIGlmIChjaXJjbGUpIHtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjZmZmJztcclxuICAgICAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1pbic7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmFyYyhjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMiwgY2FudmFzLndpZHRoIC8gMiwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjYW52YXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldEh0bWxSZXN1bHQoZGF0YSkge1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBkYXRhLnBvaW50cyxcclxuICAgICAgICAgICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXHJcbiAgICAgICAgICAgIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpLFxyXG4gICAgICAgICAgICB3aWR0aCA9IHBvaW50c1syXSAtIHBvaW50c1swXSxcclxuICAgICAgICAgICAgaGVpZ2h0ID0gcG9pbnRzWzNdIC0gcG9pbnRzWzFdO1xyXG5cclxuICAgICAgICBhZGRDbGFzcyhkaXYsICdjcm9wcGllLXJlc3VsdCcpO1xyXG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChpbWcpO1xyXG4gICAgICAgIGNzcyhpbWcsIHtcclxuICAgICAgICAgICAgbGVmdDogKC0xICogcG9pbnRzWzBdKSArICdweCcsXHJcbiAgICAgICAgICAgIHRvcDogKC0xICogcG9pbnRzWzFdKSArICdweCdcclxuICAgICAgICB9KTtcclxuICAgICAgICBpbWcuc3JjID0gZGF0YS51cmw7XHJcbiAgICAgICAgY3NzKGRpdiwge1xyXG4gICAgICAgICAgICB3aWR0aDogd2lkdGggKyAncHgnLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCArICdweCdcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRpdjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0QmFzZTY0UmVzdWx0KGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gX2dldENhbnZhcy5jYWxsKHRoaXMsIGRhdGEpLnRvRGF0YVVSTChkYXRhLmZvcm1hdCwgZGF0YS5xdWFsaXR5KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0QmxvYlJlc3VsdChkYXRhKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF9nZXRDYW52YXMuY2FsbChzZWxmLCBkYXRhKS50b0Jsb2IoZnVuY3Rpb24gKGJsb2IpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoYmxvYik7XHJcbiAgICAgICAgICAgIH0sIGRhdGEuZm9ybWF0LCBkYXRhLnF1YWxpdHkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9yZXBsYWNlSW1hZ2UoaW1nKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMuaW1nLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbCh0aGlzLmVsZW1lbnRzLmltZy5jbGFzc0xpc3QsIGZ1bmN0aW9uKGMpIHsgaW1nLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLmltZy5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChpbWcsIHRoaXMuZWxlbWVudHMuaW1nKTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5wcmV2aWV3ID0gaW1nOyAvLyBpZiB0aGUgaW1nIGlzIGF0dGFjaGVkIHRvIHRoZSBET00sIHRoZXkncmUgbm90IHVzaW5nIHRoZSBjYW52YXNcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbGVtZW50cy5pbWcgPSBpbWc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2JpbmQob3B0aW9ucywgY2IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICAgIHVybCxcclxuICAgICAgICAgICAgcG9pbnRzID0gW10sXHJcbiAgICAgICAgICAgIHpvb20gPSBudWxsLFxyXG4gICAgICAgICAgICBoYXNFeGlmID0gX2hhc0V4aWYuY2FsbChzZWxmKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiAob3B0aW9ucykgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHVybCA9IG9wdGlvbnM7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xyXG4gICAgICAgICAgICBwb2ludHMgPSBvcHRpb25zLnNsaWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAob3B0aW9ucykgPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5kYXRhLnVybCkgeyAvL3JlZnJlc2hpbmdcclxuICAgICAgICAgICAgX3VwZGF0ZVByb3BlcnRpZXNGcm9tSW1hZ2UuY2FsbChzZWxmKTtcclxuICAgICAgICAgICAgX3RyaWdnZXJVcGRhdGUuY2FsbChzZWxmKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1cmwgPSBvcHRpb25zLnVybDtcclxuICAgICAgICAgICAgcG9pbnRzID0gb3B0aW9ucy5wb2ludHMgfHwgW107XHJcbiAgICAgICAgICAgIHpvb20gPSB0eXBlb2Yob3B0aW9ucy56b29tKSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogb3B0aW9ucy56b29tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2VsZi5kYXRhLmJvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgc2VsZi5kYXRhLnVybCA9IHVybCB8fCBzZWxmLmRhdGEudXJsO1xyXG4gICAgICAgIHNlbGYuZGF0YS5ib3VuZFpvb20gPSB6b29tO1xyXG5cclxuICAgICAgICByZXR1cm4gbG9hZEltYWdlKHVybCwgaGFzRXhpZikudGhlbihmdW5jdGlvbiAoaW1nKSB7XHJcbiAgICAgICAgICAgIF9yZXBsYWNlSW1hZ2UuY2FsbChzZWxmLCBpbWcpO1xyXG4gICAgICAgICAgICBpZiAoIXBvaW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYXREaW0gPSBuYXR1cmFsSW1hZ2VEaW1lbnNpb25zKGltZyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHNlbGYuZWxlbWVudHMudmlld3BvcnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXNwZWN0UmF0aW8gPSByZWN0LndpZHRoIC8gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW1nQXNwZWN0UmF0aW8gPSBuYXREaW0ud2lkdGggLyBuYXREaW0uaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoLCBoZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGltZ0FzcGVjdFJhdGlvID4gYXNwZWN0UmF0aW8pIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBuYXREaW0uaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IG5hdERpbS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBuYXREaW0uaGVpZ2h0IC8gYXNwZWN0UmF0aW87XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHgwID0gKG5hdERpbS53aWR0aCAtIHdpZHRoKSAvIDI7XHJcbiAgICAgICAgICAgICAgICB2YXIgeTAgPSAobmF0RGltLmhlaWdodCAtIGhlaWdodCkgLyAyO1xyXG4gICAgICAgICAgICAgICAgdmFyIHgxID0geDAgKyB3aWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciB5MSA9IHkwICsgaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgc2VsZi5kYXRhLnBvaW50cyA9IFt4MCwgeTAsIHgxLCB5MV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5vcHRpb25zLnJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdICogaW1nLm5hdHVyYWxXaWR0aCAvIDEwMCxcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMV0gKiBpbWcubmF0dXJhbEhlaWdodCAvIDEwMCxcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMl0gKiBpbWcubmF0dXJhbFdpZHRoIC8gMTAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1szXSAqIGltZy5uYXR1cmFsSGVpZ2h0IC8gMTAwXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWxmLmRhdGEucG9pbnRzID0gcG9pbnRzLm1hcChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnVzZUNhbnZhcykge1xyXG4gICAgICAgICAgICAgICAgX3RyYW5zZmVySW1hZ2VUb0NhbnZhcy5jYWxsKHNlbGYsIG9wdGlvbnMub3JpZW50YXRpb24gfHwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3VwZGF0ZVByb3BlcnRpZXNGcm9tSW1hZ2UuY2FsbChzZWxmKTtcclxuICAgICAgICAgICAgX3RyaWdnZXJVcGRhdGUuY2FsbChzZWxmKTtcclxuICAgICAgICAgICAgY2IgJiYgY2IoKTtcclxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDcm9wcGllOlwiICsgZXJyKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmaXgodiwgZGVjaW1hbFBvaW50cykge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHYpLnRvRml4ZWQoZGVjaW1hbFBvaW50cyB8fCAwKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0KCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgaW1nRGF0YSA9IHNlbGYuZWxlbWVudHMucHJldmlldy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcclxuICAgICAgICAgICAgdnBEYXRhID0gc2VsZi5lbGVtZW50cy52aWV3cG9ydC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcclxuICAgICAgICAgICAgeDEgPSB2cERhdGEubGVmdCAtIGltZ0RhdGEubGVmdCxcclxuICAgICAgICAgICAgeTEgPSB2cERhdGEudG9wIC0gaW1nRGF0YS50b3AsXHJcbiAgICAgICAgICAgIHdpZHRoRGlmZiA9ICh2cERhdGEud2lkdGggLSBzZWxmLmVsZW1lbnRzLnZpZXdwb3J0Lm9mZnNldFdpZHRoKSAvIDIsIC8vYm9yZGVyXHJcbiAgICAgICAgICAgIGhlaWdodERpZmYgPSAodnBEYXRhLmhlaWdodCAtIHNlbGYuZWxlbWVudHMudmlld3BvcnQub2Zmc2V0SGVpZ2h0KSAvIDIsXHJcbiAgICAgICAgICAgIHgyID0geDEgKyBzZWxmLmVsZW1lbnRzLnZpZXdwb3J0Lm9mZnNldFdpZHRoICsgd2lkdGhEaWZmLFxyXG4gICAgICAgICAgICB5MiA9IHkxICsgc2VsZi5lbGVtZW50cy52aWV3cG9ydC5vZmZzZXRIZWlnaHQgKyBoZWlnaHREaWZmLFxyXG4gICAgICAgICAgICBzY2FsZSA9IHNlbGYuX2N1cnJlbnRab29tO1xyXG5cclxuICAgICAgICBpZiAoc2NhbGUgPT09IEluZmluaXR5IHx8IGlzTmFOKHNjYWxlKSkge1xyXG4gICAgICAgICAgICBzY2FsZSA9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbWF4ID0gc2VsZi5vcHRpb25zLmVuZm9yY2VCb3VuZGFyeSA/IDAgOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgICAgeDEgPSBNYXRoLm1heChtYXgsIHgxIC8gc2NhbGUpO1xyXG4gICAgICAgIHkxID0gTWF0aC5tYXgobWF4LCB5MSAvIHNjYWxlKTtcclxuICAgICAgICB4MiA9IE1hdGgubWF4KG1heCwgeDIgLyBzY2FsZSk7XHJcbiAgICAgICAgeTIgPSBNYXRoLm1heChtYXgsIHkyIC8gc2NhbGUpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwb2ludHM6IFtmaXgoeDEpLCBmaXgoeTEpLCBmaXgoeDIpLCBmaXgoeTIpXSxcclxuICAgICAgICAgICAgem9vbTogc2NhbGUsXHJcbiAgICAgICAgICAgIG9yaWVudGF0aW9uOiBzZWxmLmRhdGEub3JpZW50YXRpb25cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBSRVNVTFRfREVGQVVMVFMgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdjYW52YXMnLFxyXG4gICAgICAgICAgICBmb3JtYXQ6ICdwbmcnLFxyXG4gICAgICAgICAgICBxdWFsaXR5OiAxXHJcbiAgICAgICAgfSxcclxuICAgICAgICBSRVNVTFRfRk9STUFUUyA9IFsnanBlZycsICd3ZWJwJywgJ3BuZyddO1xyXG5cclxuICAgIGZ1bmN0aW9uIF9yZXN1bHQob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgZGF0YSA9IF9nZXQuY2FsbChzZWxmKSxcclxuICAgICAgICAgICAgb3B0cyA9IGRlZXBFeHRlbmQoY2xvbmUoUkVTVUxUX0RFRkFVTFRTKSwgY2xvbmUob3B0aW9ucykpLFxyXG4gICAgICAgICAgICByZXN1bHRUeXBlID0gKHR5cGVvZiAob3B0aW9ucykgPT09ICdzdHJpbmcnID8gb3B0aW9ucyA6IChvcHRzLnR5cGUgfHwgJ2Jhc2U2NCcpKSxcclxuICAgICAgICAgICAgc2l6ZSA9IG9wdHMuc2l6ZSB8fCAndmlld3BvcnQnLFxyXG4gICAgICAgICAgICBmb3JtYXQgPSBvcHRzLmZvcm1hdCxcclxuICAgICAgICAgICAgcXVhbGl0eSA9IG9wdHMucXVhbGl0eSxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgIGNpcmNsZSA9IHR5cGVvZiBvcHRzLmNpcmNsZSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5jaXJjbGUgOiAoc2VsZi5vcHRpb25zLnZpZXdwb3J0LnR5cGUgPT09ICdjaXJjbGUnKSxcclxuICAgICAgICAgICAgdnBSZWN0ID0gc2VsZi5lbGVtZW50cy52aWV3cG9ydC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcclxuICAgICAgICAgICAgcmF0aW8gPSB2cFJlY3Qud2lkdGggLyB2cFJlY3QuaGVpZ2h0LFxyXG4gICAgICAgICAgICBwcm9tO1xyXG5cclxuICAgICAgICBpZiAoc2l6ZSA9PT0gJ3ZpZXdwb3J0Jykge1xyXG4gICAgICAgICAgICBkYXRhLm91dHB1dFdpZHRoID0gdnBSZWN0LndpZHRoO1xyXG4gICAgICAgICAgICBkYXRhLm91dHB1dEhlaWdodCA9IHZwUmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgaWYgKHNpemUud2lkdGggJiYgc2l6ZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEub3V0cHV0V2lkdGggPSBzaXplLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgZGF0YS5vdXRwdXRIZWlnaHQgPSBzaXplLmhlaWdodDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaXplLndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhLm91dHB1dFdpZHRoID0gc2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgICAgIGRhdGEub3V0cHV0SGVpZ2h0ID0gc2l6ZS53aWR0aCAvIHJhdGlvO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNpemUuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhLm91dHB1dFdpZHRoID0gc2l6ZS5oZWlnaHQgKiByYXRpbztcclxuICAgICAgICAgICAgICAgIGRhdGEub3V0cHV0SGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChSRVNVTFRfRk9STUFUUy5pbmRleE9mKGZvcm1hdCkgPiAtMSkge1xyXG4gICAgICAgICAgICBkYXRhLmZvcm1hdCA9ICdpbWFnZS8nICsgZm9ybWF0O1xyXG4gICAgICAgICAgICBkYXRhLnF1YWxpdHkgPSBxdWFsaXR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGF0YS5jaXJjbGUgPSBjaXJjbGU7XHJcbiAgICAgICAgZGF0YS51cmwgPSBzZWxmLmRhdGEudXJsO1xyXG4gICAgICAgIGRhdGEuYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yO1xyXG5cclxuICAgICAgICBwcm9tID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBzd2l0Y2gocmVzdWx0VHlwZS50b0xvd2VyQ2FzZSgpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdyYXdjYW52YXMnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX2dldENhbnZhcy5jYWxsKHNlbGYsIGRhdGEpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NhbnZhcyc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdiYXNlNjQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX2dldEJhc2U2NFJlc3VsdC5jYWxsKHNlbGYsIGRhdGEpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2InOlxyXG4gICAgICAgICAgICAgICAgICAgIF9nZXRCbG9iUmVzdWx0LmNhbGwoc2VsZiwgZGF0YSkudGhlbihyZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShfZ2V0SHRtbFJlc3VsdC5jYWxsKHNlbGYsIGRhdGEpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9tO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9yZWZyZXNoKCkge1xyXG4gICAgICAgIF91cGRhdGVQcm9wZXJ0aWVzRnJvbUltYWdlLmNhbGwodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3JvdGF0ZShkZWcpIHtcclxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy51c2VDYW52YXMgfHwgIXRoaXMub3B0aW9ucy5lbmFibGVPcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICB0aHJvdyAnQ3JvcHBpZTogQ2Fubm90IHJvdGF0ZSB3aXRob3V0IGVuYWJsZU9yaWVudGF0aW9uICYmIEVYSUYuanMgaW5jbHVkZWQnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICBjYW52YXMgPSBzZWxmLmVsZW1lbnRzLmNhbnZhcyxcclxuICAgICAgICAgICAgb3JudDtcclxuXHJcbiAgICAgICAgc2VsZi5kYXRhLm9yaWVudGF0aW9uID0gZ2V0RXhpZk9mZnNldChzZWxmLmRhdGEub3JpZW50YXRpb24sIGRlZyk7XHJcbiAgICAgICAgZHJhd0NhbnZhcyhjYW52YXMsIHNlbGYuZWxlbWVudHMuaW1nLCBzZWxmLmRhdGEub3JpZW50YXRpb24pO1xyXG4gICAgICAgIF91cGRhdGVab29tTGltaXRzLmNhbGwoc2VsZik7XHJcbiAgICAgICAgX29uWm9vbS5jYWxsKHNlbGYpO1xyXG4gICAgICAgIGNvcHkgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9kZXN0cm95KCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICBzZWxmLmVsZW1lbnQucmVtb3ZlQ2hpbGQoc2VsZi5lbGVtZW50cy5ib3VuZGFyeSk7XHJcbiAgICAgICAgcmVtb3ZlQ2xhc3Moc2VsZi5lbGVtZW50LCAnY3JvcHBpZS1jb250YWluZXInKTtcclxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmVuYWJsZVpvb20pIHtcclxuICAgICAgICAgICAgc2VsZi5lbGVtZW50LnJlbW92ZUNoaWxkKHNlbGYuZWxlbWVudHMuem9vbWVyV3JhcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSBzZWxmLmVsZW1lbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh3aW5kb3cualF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyICQgPSB3aW5kb3cualF1ZXJ5O1xyXG4gICAgICAgICQuZm4uY3JvcHBpZSA9IGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgICAgIHZhciBvdCA9IHR5cGVvZiBvcHRzO1xyXG5cclxuICAgICAgICAgICAgaWYgKG90ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpbmdsZUluc3QgPSAkKHRoaXMpLmRhdGEoJ2Nyb3BwaWUnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob3B0cyA9PT0gJ2dldCcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2luZ2xlSW5zdC5nZXQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdHMgPT09ICdyZXN1bHQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbmdsZUluc3QucmVzdWx0LmFwcGx5KHNpbmdsZUluc3QsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0cyA9PT0gJ2JpbmQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbmdsZUluc3QuYmluZC5hcHBseShzaW5nbGVJbnN0LCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9ICQodGhpcykuZGF0YSgnY3JvcHBpZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gaVtvcHRzXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKG1ldGhvZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmFwcGx5KGksIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cyA9PT0gJ2Rlc3Ryb3knKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZURhdGEoJ2Nyb3BwaWUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0Nyb3BwaWUgJyArIG9wdHMgKyAnIG1ldGhvZCBub3QgZm91bmQnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBuZXcgQ3JvcHBpZSh0aGlzLCBvcHRzKTtcclxuICAgICAgICAgICAgICAgICAgICBpLiQgPSAkO1xyXG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuZGF0YSgnY3JvcHBpZScsIGkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIENyb3BwaWUoZWxlbWVudCwgb3B0cykge1xyXG4gICAgICAgIGlmIChlbGVtZW50LmNsYXNzTmFtZS5pbmRleE9mKCdjcm9wcGllLWNvbnRhaW5lcicpID4gLTEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3JvcHBpZTogQ2FuJ3QgaW5pdGlhbGl6ZSBjcm9wcGllIG1vcmUgdGhhbiBvbmNlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGRlZXBFeHRlbmQoY2xvbmUoQ3JvcHBpZS5kZWZhdWx0cyksIG9wdHMpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5lbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycpIHtcclxuICAgICAgICAgICAgdmFyIG9yaWdJbWFnZSA9IHRoaXMuZWxlbWVudDtcclxuICAgICAgICAgICAgYWRkQ2xhc3Mob3JpZ0ltYWdlLCAnY3Itb3JpZ2luYWwtaW1hZ2UnKTtcclxuICAgICAgICAgICAgc2V0QXR0cmlidXRlcyhvcmlnSW1hZ2UsIHsnYXJpYS1oaWRkZW4nIDogJ3RydWUnLCAnYWx0JyA6ICcnIH0pO1xyXG4gICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQocmVwbGFjZW1lbnREaXYpO1xyXG4gICAgICAgICAgICByZXBsYWNlbWVudERpdi5hcHBlbmRDaGlsZChvcmlnSW1hZ2UpO1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSByZXBsYWNlbWVudERpdjtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnVybCA9IHRoaXMub3B0aW9ucy51cmwgfHwgb3JpZ0ltYWdlLnNyYztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9jcmVhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVybCkge1xyXG4gICAgICAgICAgICB2YXIgYmluZE9wdHMgPSB7XHJcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMub3B0aW9ucy51cmwsXHJcbiAgICAgICAgICAgICAgICBwb2ludHM6IHRoaXMub3B0aW9ucy5wb2ludHNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9uc1sndXJsJ107XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnNbJ3BvaW50cyddO1xyXG4gICAgICAgICAgICBfYmluZC5jYWxsKHRoaXMsIGJpbmRPcHRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQ3JvcHBpZS5kZWZhdWx0cyA9IHtcclxuICAgICAgICB2aWV3cG9ydDoge1xyXG4gICAgICAgICAgICB3aWR0aDogMTAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDEwMCxcclxuICAgICAgICAgICAgdHlwZTogJ3NxdWFyZSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvdW5kYXJ5OiB7IH0sXHJcbiAgICAgICAgb3JpZW50YXRpb25Db250cm9sczoge1xyXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgICAgICBsZWZ0Q2xhc3M6ICcnLFxyXG4gICAgICAgICAgICByaWdodENsYXNzOiAnJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzaXplQ29udHJvbHM6IHtcclxuICAgICAgICAgICAgd2lkdGg6IHRydWUsXHJcbiAgICAgICAgICAgIGhlaWdodDogdHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3VzdG9tQ2xhc3M6ICcnLFxyXG4gICAgICAgIHNob3dab29tZXI6IHRydWUsXHJcbiAgICAgICAgZW5hYmxlWm9vbTogdHJ1ZSxcclxuICAgICAgICBlbmFibGVSZXNpemU6IGZhbHNlLFxyXG4gICAgICAgIG1vdXNlV2hlZWxab29tOiB0cnVlLFxyXG4gICAgICAgIGVuYWJsZUV4aWY6IGZhbHNlLFxyXG4gICAgICAgIGVuZm9yY2VCb3VuZGFyeTogdHJ1ZSxcclxuICAgICAgICBlbmFibGVPcmllbnRhdGlvbjogZmFsc2UsXHJcbiAgICAgICAgZW5hYmxlS2V5TW92ZW1lbnQ6IHRydWUsXHJcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7IH1cclxuICAgIH07XHJcblxyXG4gICAgQ3JvcHBpZS5nbG9iYWxzID0ge1xyXG4gICAgICAgIHRyYW5zbGF0ZTogJ3RyYW5zbGF0ZTNkJ1xyXG4gICAgfTtcclxuXHJcbiAgICBkZWVwRXh0ZW5kKENyb3BwaWUucHJvdG90eXBlLCB7XHJcbiAgICAgICAgYmluZDogZnVuY3Rpb24gKG9wdGlvbnMsIGNiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfYmluZC5jYWxsKHRoaXMsIG9wdGlvbnMsIGNiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IF9nZXQuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IGRhdGEucG9pbnRzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHNbMF0gLz0gdGhpcy5lbGVtZW50cy5pbWcubmF0dXJhbFdpZHRoIC8gMTAwO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzWzFdIC89IHRoaXMuZWxlbWVudHMuaW1nLm5hdHVyYWxIZWlnaHQgLyAxMDA7XHJcbiAgICAgICAgICAgICAgICBwb2ludHNbMl0gLz0gdGhpcy5lbGVtZW50cy5pbWcubmF0dXJhbFdpZHRoIC8gMTAwO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzWzNdIC89IHRoaXMuZWxlbWVudHMuaW1nLm5hdHVyYWxIZWlnaHQgLyAxMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXN1bHQ6IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0LmNhbGwodGhpcywgdHlwZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcmVmcmVzaC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0Wm9vbTogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgX3NldFpvb21lclZhbC5jYWxsKHRoaXMsIHYpO1xyXG4gICAgICAgICAgICBkaXNwYXRjaENoYW5nZSh0aGlzLmVsZW1lbnRzLnpvb21lcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByb3RhdGU6IGZ1bmN0aW9uIChkZWcpIHtcclxuICAgICAgICAgICAgX3JvdGF0ZS5jYWxsKHRoaXMsIGRlZyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZGVzdHJveS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGV4cG9ydHMuQ3JvcHBpZSA9IHdpbmRvdy5Dcm9wcGllID0gQ3JvcHBpZTtcclxufSkpO1xyXG4iLCIvKiEgRmlsZUFQSSAyLjEuMSAtIEJTRCB8IGdpdDovL2dpdGh1Yi5jb20vbWFpbHJ1L0ZpbGVBUEkuZ2l0XG4gKiBGaWxlQVBJIOKAlCBhIHNldCBvZiAgamF2YXNjcmlwdCB0b29scyBmb3Igd29ya2luZyB3aXRoIGZpbGVzLiBNdWx0aXVwbG9hZCwgZHJhZyduJ2Ryb3AgYW5kIGNodW5rZWQgZmlsZSB1cGxvYWQuIEltYWdlczogY3JvcCwgcmVzaXplIGFuZCBhdXRvIG9yaWVudGF0aW9uIGJ5IEVYSUYuXG4gKi9cblxuLypcbiAqIEphdmFTY3JpcHQgQ2FudmFzIHRvIEJsb2IgMi4wLjVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtQ2FudmFzLXRvLUJsb2JcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMiwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogQmFzZWQgb24gc3RhY2tvdmVyZmxvdyB1c2VyIFN0b2l2ZSdzIGNvZGUgc25pcHBldDpcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xLzQ5OTg5MDhcbiAqL1xuXG4vKmpzbGludCBub21lbjogdHJ1ZSwgcmVnZXhwOiB0cnVlICovXG4vKmdsb2JhbCB3aW5kb3csIGF0b2IsIEJsb2IsIEFycmF5QnVmZmVyLCBVaW50OEFycmF5ICovXG5cbihmdW5jdGlvbiAod2luZG93KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBDYW52YXNQcm90b3R5cGUgPSB3aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQgJiZcbiAgICAgICAgICAgIHdpbmRvdy5IVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUsXG4gICAgICAgIGhhc0Jsb2JDb25zdHJ1Y3RvciA9IHdpbmRvdy5CbG9iICYmIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKG5ldyBCbG9iKCkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSgpKSxcbiAgICAgICAgaGFzQXJyYXlCdWZmZXJWaWV3U3VwcG9ydCA9IGhhc0Jsb2JDb25zdHJ1Y3RvciAmJiB3aW5kb3cuVWludDhBcnJheSAmJlxuICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KDEwMCldKS5zaXplID09PSAxMDA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSgpKSxcbiAgICAgICAgQmxvYkJ1aWxkZXIgPSB3aW5kb3cuQmxvYkJ1aWxkZXIgfHwgd2luZG93LldlYktpdEJsb2JCdWlsZGVyIHx8XG4gICAgICAgICAgICB3aW5kb3cuTW96QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1TQmxvYkJ1aWxkZXIsXG4gICAgICAgIGRhdGFVUkx0b0Jsb2IgPSAoaGFzQmxvYkNvbnN0cnVjdG9yIHx8IEJsb2JCdWlsZGVyKSAmJiB3aW5kb3cuYXRvYiAmJlxuICAgICAgICAgICAgd2luZG93LkFycmF5QnVmZmVyICYmIHdpbmRvdy5VaW50OEFycmF5ICYmIGZ1bmN0aW9uIChkYXRhVVJJKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGVTdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgIGFycmF5QnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICBpbnRBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgbWltZVN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgYmI7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFVUkkuc3BsaXQoJywnKVswXS5pbmRleE9mKCdiYXNlNjQnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgYmFzZTY0IHRvIHJhdyBiaW5hcnkgZGF0YSBoZWxkIGluIGEgc3RyaW5nOlxuICAgICAgICAgICAgICAgICAgICBieXRlU3RyaW5nID0gYXRvYihkYXRhVVJJLnNwbGl0KCcsJylbMV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgYmFzZTY0L1VSTEVuY29kZWQgZGF0YSBjb21wb25lbnQgdG8gcmF3IGJpbmFyeSBkYXRhOlxuICAgICAgICAgICAgICAgICAgICBieXRlU3RyaW5nID0gZGVjb2RlVVJJQ29tcG9uZW50KGRhdGFVUkkuc3BsaXQoJywnKVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBieXRlcyBvZiB0aGUgc3RyaW5nIHRvIGFuIEFycmF5QnVmZmVyOlxuICAgICAgICAgICAgICAgIGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTdHJpbmcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYnl0ZVN0cmluZy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpbnRBcnJheVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VwYXJhdGUgb3V0IHRoZSBtaW1lIGNvbXBvbmVudDpcbiAgICAgICAgICAgICAgICBtaW1lU3RyaW5nID0gZGF0YVVSSS5zcGxpdCgnLCcpWzBdLnNwbGl0KCc6JylbMV0uc3BsaXQoJzsnKVswXTtcbiAgICAgICAgICAgICAgICAvLyBXcml0ZSB0aGUgQXJyYXlCdWZmZXIgKG9yIEFycmF5QnVmZmVyVmlldykgdG8gYSBibG9iOlxuICAgICAgICAgICAgICAgIGlmIChoYXNCbG9iQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFxuICAgICAgICAgICAgICAgICAgICAgICAgW2hhc0FycmF5QnVmZmVyVmlld1N1cHBvcnQgPyBpbnRBcnJheSA6IGFycmF5QnVmZmVyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlOiBtaW1lU3RyaW5nfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgIGJiLmFwcGVuZChhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJiLmdldEJsb2IobWltZVN0cmluZyk7XG4gICAgICAgICAgICB9O1xuICAgIGlmICh3aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQgJiYgIUNhbnZhc1Byb3RvdHlwZS50b0Jsb2IpIHtcbiAgICAgICAgaWYgKENhbnZhc1Byb3RvdHlwZS5tb3pHZXRBc0ZpbGUpIHtcbiAgICAgICAgICAgIENhbnZhc1Byb3RvdHlwZS50b0Jsb2IgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHR5cGUsIHF1YWxpdHkpIHtcbiAgICAgICAgICAgICAgICBpZiAocXVhbGl0eSAmJiBDYW52YXNQcm90b3R5cGUudG9EYXRhVVJMICYmIGRhdGFVUkx0b0Jsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YVVSTHRvQmxvYih0aGlzLnRvRGF0YVVSTCh0eXBlLCBxdWFsaXR5KSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMubW96R2V0QXNGaWxlKCdibG9iJywgdHlwZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoQ2FudmFzUHJvdG90eXBlLnRvRGF0YVVSTCAmJiBkYXRhVVJMdG9CbG9iKSB7XG4gICAgICAgICAgICBDYW52YXNQcm90b3R5cGUudG9CbG9iID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0eXBlLCBxdWFsaXR5KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YVVSTHRvQmxvYih0aGlzLnRvRGF0YVVSTCh0eXBlLCBxdWFsaXR5KSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aW5kb3cuZGF0YVVSTHRvQmxvYiA9IGRhdGFVUkx0b0Jsb2I7XG59KSh3aW5kb3cpO1xuXG4vKmpzbGludCBldmlsOiB0cnVlICovXG4vKmdsb2JhbCB3aW5kb3csIFVSTCwgd2Via2l0VVJMLCBBY3RpdmVYT2JqZWN0ICovXG5cbihmdW5jdGlvbiAod2luZG93LCB1bmRlZil7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXJcblx0XHRnaWQgPSAxLFxuXHRcdG5vb3AgPSBmdW5jdGlvbiAoKXt9LFxuXG5cdFx0ZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdFx0ZG9jdHlwZSA9IGRvY3VtZW50LmRvY3R5cGUgfHwge30sXG5cdFx0dXNlckFnZW50ID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQsXG5cdFx0c2FmYXJpID0gL3NhZmFyaVxcLy9pLnRlc3QodXNlckFnZW50KSAmJiAhL2Nocm9tZVxcLy9pLnRlc3QodXNlckFnZW50KSxcblx0XHRpZW1vYmlsZSA9IC9pZW1vYmlsZVxcLy9pLnRlc3QodXNlckFnZW50KSxcblx0XHRpbnNlY3VyZUNocm9tZSA9ICFzYWZhcmkgJiYgL2Nocm9tZVxcLy9pLnRlc3QodXNlckFnZW50KSAmJiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwOicsXG5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LUxvYWQtSW1hZ2UvYmxvYi9tYXN0ZXIvbG9hZC1pbWFnZS5qcyNMNDhcblx0XHRhcGlVUkwgPSAod2luZG93LmNyZWF0ZU9iamVjdFVSTCAmJiB3aW5kb3cpIHx8ICh3aW5kb3cuVVJMICYmIFVSTC5yZXZva2VPYmplY3RVUkwgJiYgVVJMKSB8fCAod2luZG93LndlYmtpdFVSTCAmJiB3ZWJraXRVUkwpLFxuXG5cdFx0QmxvYiA9IHdpbmRvdy5CbG9iLFxuXHRcdEZpbGUgPSB3aW5kb3cuRmlsZSxcblx0XHRGaWxlUmVhZGVyID0gd2luZG93LkZpbGVSZWFkZXIsXG5cdFx0Rm9ybURhdGEgPSB3aW5kb3cuRm9ybURhdGEsXG5cblxuXHRcdFhNTEh0dHBSZXF1ZXN0ID0gd2luZG93LlhNTEh0dHBSZXF1ZXN0LFxuXHRcdGpRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0XHRodG1sNSA9ICAgICEhKEZpbGUgJiYgKEZpbGVSZWFkZXIgJiYgKHdpbmRvdy5VaW50OEFycmF5IHx8IEZvcm1EYXRhIHx8IFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZW5kQXNCaW5hcnkpKSlcblx0XHRcdFx0JiYgIShzYWZhcmkgJiYgL3dpbmRvd3MvaS50ZXN0KHVzZXJBZ2VudCkgJiYgIWllbW9iaWxlKSwgLy8gQnVnRml4OiBodHRwczovL2dpdGh1Yi5jb20vbWFpbHJ1L0ZpbGVBUEkvaXNzdWVzLzI1XG5cblx0XHRjb3JzID0gaHRtbDUgJiYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIChuZXcgWE1MSHR0cFJlcXVlc3QpKSxcblxuXHRcdGNodW5rZWQgPSBodG1sNSAmJiAhIUJsb2IgJiYgISEoQmxvYi5wcm90b3R5cGUud2Via2l0U2xpY2UgfHwgQmxvYi5wcm90b3R5cGUubW96U2xpY2UgfHwgQmxvYi5wcm90b3R5cGUuc2xpY2UpLFxuXG5cdFx0bm9ybWFsaXplID0gKCcnICsgJycubm9ybWFsaXplKS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykgPiAwLFxuXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1DYW52YXMtdG8tQmxvYlxuXHRcdGRhdGFVUkx0b0Jsb2IgPSB3aW5kb3cuZGF0YVVSTHRvQmxvYixcblxuXG5cdFx0X3JpbWcgPSAvaW1nL2ksXG5cdFx0X3JjYW52YXMgPSAvY2FudmFzL2ksXG5cdFx0X3JpbWdjYW52YXMgPSAvaW1nfGNhbnZhcy9pLFxuXHRcdF9yaW5wdXQgPSAvaW5wdXQvaSxcblx0XHRfcmRhdGEgPSAvXmRhdGE6W14sXSssLyxcblxuXHRcdF90b1N0cmluZyA9IHt9LnRvU3RyaW5nLFxuXHRcdF9zdXBwb3J0Q29uc29sZUxvZyxcblx0XHRfc3VwcG9ydENvbnNvbGVMb2dBcHBseSxcblxuXG5cdFx0TWF0aCA9IHdpbmRvdy5NYXRoLFxuXG5cdFx0X1NJWkVfQ09OU1QgPSBmdW5jdGlvbiAocG93KXtcblx0XHRcdHBvdyA9IG5ldyB3aW5kb3cuTnVtYmVyKE1hdGgucG93KDEwMjQsIHBvdykpO1xuXHRcdFx0cG93LmZyb20gPSBmdW5jdGlvbiAoc3opeyByZXR1cm4gTWF0aC5yb3VuZChzeiAqIHRoaXMpOyB9O1xuXHRcdFx0cmV0dXJuXHRwb3c7XG5cdFx0fSxcblxuXHRcdF9lbEV2ZW50cyA9IHt9LCAvLyBlbGVtZW50IGV2ZW50IGxpc3RlbmVyc1xuXHRcdF9pbmZvUmVhZGVyID0gW10sIC8vIGxpc3Qgb2YgZmlsZSBpbmZvIHByb2Nlc3NvcnNcblxuXHRcdF9yZWFkZXJFdmVudHMgPSAnYWJvcnQgcHJvZ3Jlc3MgZXJyb3IgbG9hZCBsb2FkZW5kJyxcblx0XHRfeGhyUHJvcHNFeHBvcnQgPSAnc3RhdHVzIHN0YXR1c1RleHQgcmVhZHlTdGF0ZSByZXNwb25zZSByZXNwb25zZVhNTCByZXNwb25zZVRleHQgcmVzcG9uc2VCb2R5Jy5zcGxpdCgnICcpLFxuXG5cdFx0Y3VycmVudFRhcmdldCA9ICdjdXJyZW50VGFyZ2V0JywgLy8gZm9yIG1pbmltaXplXG5cdFx0cHJldmVudERlZmF1bHQgPSAncHJldmVudERlZmF1bHQnLCAvLyBhbmQgdGhpcyB0b29cblxuXHRcdF9pc0FycmF5ID0gZnVuY3Rpb24gKGFyKSB7XG5cdFx0XHRyZXR1cm5cdGFyICYmICgnbGVuZ3RoJyBpbiBhcik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEl0ZXJhdGUgb3ZlciBhIG9iamVjdCBvciBhcnJheVxuXHRcdCAqL1xuXHRcdF9lYWNoID0gZnVuY3Rpb24gKG9iaiwgZm4sIGN0eCl7XG5cdFx0XHRpZiggb2JqICl7XG5cdFx0XHRcdGlmKCBfaXNBcnJheShvYmopICl7XG5cdFx0XHRcdFx0Zm9yKCB2YXIgaSA9IDAsIG4gPSBvYmoubGVuZ3RoOyBpIDwgbjsgaSsrICl7XG5cdFx0XHRcdFx0XHRpZiggaSBpbiBvYmogKXtcblx0XHRcdFx0XHRcdFx0Zm4uY2FsbChjdHgsIG9ialtpXSwgaSwgb2JqKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Zm9yKCB2YXIga2V5IGluIG9iaiApe1xuXHRcdFx0XHRcdFx0aWYoIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICl7XG5cdFx0XHRcdFx0XHRcdGZuLmNhbGwoY3R4LCBvYmpba2V5XSwga2V5LCBvYmopO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBNZXJnZSB0aGUgY29udGVudHMgb2YgdHdvIG9yIG1vcmUgb2JqZWN0cyB0b2dldGhlciBpbnRvIHRoZSBmaXJzdCBvYmplY3Rcblx0XHQgKi9cblx0XHRfZXh0ZW5kID0gZnVuY3Rpb24gKGRzdCl7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cywgaSA9IDEsIF9leHQgPSBmdW5jdGlvbiAodmFsLCBrZXkpeyBkc3Rba2V5XSA9IHZhbDsgfTtcblx0XHRcdGZvciggOyBpIDwgYXJncy5sZW5ndGg7IGkrKyApe1xuXHRcdFx0XHRfZWFjaChhcmdzW2ldLCBfZXh0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAgZHN0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBZGQgZXZlbnQgbGlzdGVuZXJcblx0XHQgKi9cblx0XHRfb24gPSBmdW5jdGlvbiAoZWwsIHR5cGUsIGZuKXtcblx0XHRcdGlmKCBlbCApe1xuXHRcdFx0XHR2YXIgdWlkID0gYXBpLnVpZChlbCk7XG5cblx0XHRcdFx0aWYoICFfZWxFdmVudHNbdWlkXSApe1xuXHRcdFx0XHRcdF9lbEV2ZW50c1t1aWRdID0ge307XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaXNGaWxlUmVhZGVyID0gKEZpbGVSZWFkZXIgJiYgZWwpICYmIChlbCBpbnN0YW5jZW9mIEZpbGVSZWFkZXIpO1xuXHRcdFx0XHRfZWFjaCh0eXBlLnNwbGl0KC9cXHMrLyksIGZ1bmN0aW9uICh0eXBlKXtcblx0XHRcdFx0XHRpZiggalF1ZXJ5ICYmICFpc0ZpbGVSZWFkZXIpe1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZChlbCwgdHlwZSwgZm4pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiggIV9lbEV2ZW50c1t1aWRdW3R5cGVdICl7XG5cdFx0XHRcdFx0XHRcdF9lbEV2ZW50c1t1aWRdW3R5cGVdID0gW107XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdF9lbEV2ZW50c1t1aWRdW3R5cGVdLnB1c2goZm4pO1xuXG5cdFx0XHRcdFx0XHRpZiggZWwuYWRkRXZlbnRMaXN0ZW5lciApeyBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7IH1cblx0XHRcdFx0XHRcdGVsc2UgaWYoIGVsLmF0dGFjaEV2ZW50ICl7IGVsLmF0dGFjaEV2ZW50KCdvbicrdHlwZSwgZm4pOyB9XG5cdFx0XHRcdFx0XHRlbHNlIHsgZWxbJ29uJyt0eXBlXSA9IGZuOyB9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJcblx0XHQgKi9cblx0XHRfb2ZmID0gZnVuY3Rpb24gKGVsLCB0eXBlLCBmbil7XG5cdFx0XHRpZiggZWwgKXtcblx0XHRcdFx0dmFyIHVpZCA9IGFwaS51aWQoZWwpLCBldmVudHMgPSBfZWxFdmVudHNbdWlkXSB8fCB7fTtcblxuXHRcdFx0XHR2YXIgaXNGaWxlUmVhZGVyID0gKEZpbGVSZWFkZXIgJiYgZWwpICYmIChlbCBpbnN0YW5jZW9mIEZpbGVSZWFkZXIpO1xuXHRcdFx0XHRfZWFjaCh0eXBlLnNwbGl0KC9cXHMrLyksIGZ1bmN0aW9uICh0eXBlKXtcblx0XHRcdFx0XHRpZiggalF1ZXJ5ICYmICFpc0ZpbGVSZWFkZXIpe1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZShlbCwgdHlwZSwgZm4pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBmbnMgPSBldmVudHNbdHlwZV0gfHwgW10sIGkgPSBmbnMubGVuZ3RoO1xuXG5cdFx0XHRcdFx0XHR3aGlsZSggaS0tICl7XG5cdFx0XHRcdFx0XHRcdGlmKCBmbnNbaV0gPT09IGZuICl7XG5cdFx0XHRcdFx0XHRcdFx0Zm5zLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiggZWwuYWRkRXZlbnRMaXN0ZW5lciApeyBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7IH1cblx0XHRcdFx0XHRcdGVsc2UgaWYoIGVsLmRldGFjaEV2ZW50ICl7IGVsLmRldGFjaEV2ZW50KCdvbicrdHlwZSwgZm4pOyB9XG5cdFx0XHRcdFx0XHRlbHNlIHsgZWxbJ29uJyt0eXBlXSA9IG51bGw7IH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblxuXHRcdF9vbmUgPSBmdW5jdGlvbihlbCwgdHlwZSwgZm4pe1xuXHRcdFx0X29uKGVsLCB0eXBlLCBmdW5jdGlvbiBfKGV2dCl7XG5cdFx0XHRcdF9vZmYoZWwsIHR5cGUsIF8pO1xuXHRcdFx0XHRmbihldnQpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXG5cdFx0X2ZpeEV2ZW50ID0gZnVuY3Rpb24gKGV2dCl7XG5cdFx0XHRpZiggIWV2dC50YXJnZXQgKXsgZXZ0LnRhcmdldCA9IHdpbmRvdy5ldmVudCAmJiB3aW5kb3cuZXZlbnQuc3JjRWxlbWVudCB8fCBkb2N1bWVudDsgfVxuXHRcdFx0aWYoIGV2dC50YXJnZXQubm9kZVR5cGUgPT09IDMgKXsgZXZ0LnRhcmdldCA9IGV2dC50YXJnZXQucGFyZW50Tm9kZTsgfVxuXHRcdFx0cmV0dXJuICBldnQ7XG5cdFx0fSxcblxuXG5cdFx0X3N1cHBvcnRJbnB1dEF0dHIgPSBmdW5jdGlvbiAoYXR0cil7XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgXCJmaWxlXCIpO1xuXHRcdFx0cmV0dXJuIGF0dHIgaW4gaW5wdXQ7XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogRmlsZUFQSSAoY29yZSBvYmplY3QpXG5cdFx0ICovXG5cdFx0YXBpID0ge1xuXHRcdFx0dmVyc2lvbjogJzIuMS4xJyxcblxuXHRcdFx0Y29yczogZmFsc2UsXG5cdFx0XHRodG1sNTogdHJ1ZSxcblx0XHRcdG1lZGlhOiBmYWxzZSxcblx0XHRcdGZvcm1EYXRhOiB0cnVlLFxuXHRcdFx0bXVsdGlQYXNzUmVzaXplOiB0cnVlLFxuXHRcdFx0aW5zZWN1cmVDaHJvbWU6IGluc2VjdXJlQ2hyb21lLFxuXG5cdFx0XHRkZWJ1ZzogZmFsc2UsXG5cdFx0XHRwaW5nVXJsOiBmYWxzZSxcblx0XHRcdG11bHRpRmxhc2g6IGZhbHNlLFxuXHRcdFx0Zmxhc2hBYm9ydFRpbWVvdXQ6IDAsXG5cdFx0XHR3aXRoQ3JlZGVudGlhbHM6IHRydWUsXG5cblx0XHRcdHN0YXRpY1BhdGg6ICcuL2Rpc3QvJyxcblxuXHRcdFx0Zmxhc2hVcmw6IDAsIC8vIEBkZWZhdWx0OiAnLi9GaWxlQVBJLmZsYXNoLnN3Zidcblx0XHRcdGZsYXNoSW1hZ2VVcmw6IDAsIC8vIEBkZWZhdWx0OiAnLi9GaWxlQVBJLmZsYXNoLmltYWdlLnN3ZidcblxuXHRcdFx0cG9zdE5hbWVDb25jYXQ6IGZ1bmN0aW9uIChuYW1lLCBpZHgpe1xuXHRcdFx0XHRyZXR1cm5cdG5hbWUgKyAoaWR4ICE9IG51bGwgPyAnWycrIGlkeCArJ10nIDogJycpO1xuXHRcdFx0fSxcblxuXHRcdFx0ZXh0Mm1pbWU6IHtcblx0XHRcdFx0ICBqcGc6XHQnaW1hZ2UvanBlZydcblx0XHRcdFx0LCB0aWY6XHQnaW1hZ2UvdGlmZidcblx0XHRcdFx0LCB0eHQ6XHQndGV4dC9wbGFpbidcblx0XHRcdH0sXG5cblx0XHRcdC8vIEZhbGxiYWNrIGZvciBmbGFzaFxuXHRcdFx0YWNjZXB0OiB7XG5cdFx0XHRcdCAgJ2ltYWdlLyonOiAnYXJ0IGJtIGJtcCBkd2cgZHhmIGNiciBjYnogZmlmIGZweCBnaWYgaWNvIGllZnMgamZpZiBqcGUganBlZyBqcGcganBzIGp1dCBtY2YgbmFwIG5pZiBwYm0gcGN4IHBnbSBwaWN0IHBtIHBuZyBwbm0gcWlmIHF0aWYgcmFzIHJhc3QgcmYgcnAgc3ZmIHRnYSB0aWYgdGlmZiB4Ym0geGJtIHhwbSB4d2QnXG5cdFx0XHRcdCwgJ2F1ZGlvLyonOiAnbTRhIGZsYWMgYWFjIHJtIG1wYSB3YXYgd21hIG9nZyBtcDMgbXAyIG0zdSBtb2QgYW1mIGRtZiBkc20gZmFyIGdkbSBpbWYgaXQgbTE1IG1lZCBva3QgczNtIHN0bSBzZnggdWx0IHVuaSB4bSBzaWQgYWMzIGR0cyBjdWUgYWlmIGFpZmYgd3BsIGFwZSBtYWMgbXBjIG1wcCBzaG4gd3YgbnNmIHNwYyBneW0gYWRwbHVnIGFkeCBkc3AgYWRwIHltZiBhc3QgYWZjIGhwcyB4cydcblx0XHRcdFx0LCAndmlkZW8vKic6ICdtNHYgM2dwIG5zdiB0cyB0eSBzdHJtIHJtIHJtdmIgbTN1IGlmbyBtb3YgcXQgZGl2eCB4dmlkIGJpdnggdm9iIG5yZyBpbWcgaXNvIHB2YSB3bXYgYXNmIGFzeCBvZ20gbTJ2IGF2aSBiaW4gZGF0IGR2ci1tcyBtcGcgbXBlZyBtcDQgbWt2IGF2YyB2cDMgc3ZxMyBudXYgdml2IGR2IGZsaSBmbHYgd3BsJ1xuXHRcdFx0fSxcblxuXHRcdFx0dXBsb2FkUmV0cnkgOiAwLFxuXHRcdFx0bmV0d29ya0Rvd25SZXRyeVRpbWVvdXQgOiA1MDAwLCAvLyBtaWxsaXNlY29uZHMsIGRvbid0IGZsb29kIHdoZW4gbmV0d29yayBpcyBkb3duXG5cblx0XHRcdGNodW5rU2l6ZSA6IDAsXG5cdFx0XHRjaHVua1VwbG9hZFJldHJ5IDogMCxcblx0XHRcdGNodW5rTmV0d29ya0Rvd25SZXRyeVRpbWVvdXQgOiAyMDAwLCAvLyBtaWxsaXNlY29uZHMsIGRvbid0IGZsb29kIHdoZW4gbmV0d29yayBpcyBkb3duXG5cblx0XHRcdEtCOiBfU0laRV9DT05TVCgxKSxcblx0XHRcdE1COiBfU0laRV9DT05TVCgyKSxcblx0XHRcdEdCOiBfU0laRV9DT05TVCgzKSxcblx0XHRcdFRCOiBfU0laRV9DT05TVCg0KSxcblxuXHRcdFx0RU1QVFlfUE5HOiAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FZQUFBQWZGY1NKQUFBQUMwbEVRVlFJVzJOa0FBSUFBQW9BQWdnQTlHa0FBQUFBU1VWT1JLNUNZSUk9JyxcblxuXHRcdFx0ZXhwYW5kbzogJ2ZpbGVhcGknICsgKG5ldyBEYXRlKS5nZXRUaW1lKCksXG5cblx0XHRcdHVpZDogZnVuY3Rpb24gKG9iail7XG5cdFx0XHRcdHJldHVyblx0b2JqXG5cdFx0XHRcdFx0PyAob2JqW2FwaS5leHBhbmRvXSA9IG9ialthcGkuZXhwYW5kb10gfHwgYXBpLnVpZCgpKVxuXHRcdFx0XHRcdDogKCsrZ2lkLCBhcGkuZXhwYW5kbyArIGdpZClcblx0XHRcdFx0O1xuXHRcdFx0fSxcblxuXHRcdFx0bG9nOiBmdW5jdGlvbiAoKXtcblx0XHRcdFx0aWYoIGFwaS5kZWJ1ZyAmJiBfc3VwcG9ydENvbnNvbGVMb2cgKXtcblx0XHRcdFx0XHRpZiggX3N1cHBvcnRDb25zb2xlTG9nQXBwbHkgKXtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coW10uam9pbi5jYWxsKGFyZ3VtZW50cywgJyAnKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIENyZWF0ZSBuZXcgaW1hZ2Vcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gW3NyY11cblx0XHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl0gICAxLiBlcnJvciAtLSBib29sZWFuLCAyLiBpbWcgLS0gSW1hZ2UgZWxlbWVudFxuXHRcdFx0ICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuXHRcdFx0ICovXG5cdFx0XHRuZXdJbWFnZTogZnVuY3Rpb24gKHNyYywgZm4pe1xuXHRcdFx0XHR2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cdFx0XHRcdGlmKCBmbiApe1xuXHRcdFx0XHRcdGFwaS5ldmVudC5vbmUoaW1nLCAnZXJyb3IgbG9hZCcsIGZ1bmN0aW9uIChldnQpe1xuXHRcdFx0XHRcdFx0Zm4oZXZ0LnR5cGUgPT0gJ2Vycm9yJywgaW1nKTtcblx0XHRcdFx0XHRcdGltZyA9IG51bGw7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW1nLnNyYyA9IHNyYztcblx0XHRcdFx0cmV0dXJuXHRpbWc7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEdldCBYSFJcblx0XHRcdCAqIEByZXR1cm5zIHtYTUxIdHRwUmVxdWVzdH1cblx0XHRcdCAqL1xuXHRcdFx0Z2V0WEhSOiBmdW5jdGlvbiAoKXtcblx0XHRcdFx0dmFyIHhocjtcblxuXHRcdFx0XHRpZiggWE1MSHR0cFJlcXVlc3QgKXtcblx0XHRcdFx0XHR4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Q7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiggd2luZG93LkFjdGl2ZVhPYmplY3QgKXtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0eGhyID0gbmV3IEFjdGl2ZVhPYmplY3QoJ01TWE1MMi5YTUxIdHRwLjMuMCcpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHhociA9IG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAgeGhyO1xuXHRcdFx0fSxcblxuXHRcdFx0aXNBcnJheTogX2lzQXJyYXksXG5cblx0XHRcdHN1cHBvcnQ6IHtcblx0XHRcdFx0ZG5kOiAgICAgY29ycyAmJiAoJ29uZHJvcCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpLFxuXHRcdFx0XHRjb3JzOiAgICBjb3JzLFxuXHRcdFx0XHRodG1sNTogICBodG1sNSxcblx0XHRcdFx0Y2h1bmtlZDogY2h1bmtlZCxcblx0XHRcdFx0ZGF0YVVSSTogdHJ1ZSxcblx0XHRcdFx0YWNjZXB0OiAgIF9zdXBwb3J0SW5wdXRBdHRyKCdhY2NlcHQnKSxcblx0XHRcdFx0bXVsdGlwbGU6IF9zdXBwb3J0SW5wdXRBdHRyKCdtdWx0aXBsZScpXG5cdFx0XHR9LFxuXG5cdFx0XHRldmVudDoge1xuXHRcdFx0XHQgIG9uOiBfb25cblx0XHRcdFx0LCBvZmY6IF9vZmZcblx0XHRcdFx0LCBvbmU6IF9vbmVcblx0XHRcdFx0LCBmaXg6IF9maXhFdmVudFxuXHRcdFx0fSxcblxuXG5cdFx0XHR0aHJvdHRsZTogZnVuY3Rpb24oZm4sIGRlbGF5KSB7XG5cdFx0XHRcdHZhciBpZCwgYXJncztcblxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gX3Rocm90dGxlKCl7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdGlmKCAhaWQgKXtcblx0XHRcdFx0XHRcdGZuLmFwcGx5KHdpbmRvdywgYXJncyk7XG5cdFx0XHRcdFx0XHRpZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCl7XG5cdFx0XHRcdFx0XHRcdGlkID0gMDtcblx0XHRcdFx0XHRcdFx0Zm4uYXBwbHkod2luZG93LCBhcmdzKTtcblx0XHRcdFx0XHRcdH0sIGRlbGF5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXG5cblx0XHRcdEY6IGZ1bmN0aW9uICgpe30sXG5cblxuXHRcdFx0cGFyc2VKU09OOiBmdW5jdGlvbiAoc3RyKXtcblx0XHRcdFx0dmFyIGpzb247XG5cdFx0XHRcdGlmKCB3aW5kb3cuSlNPTiAmJiBKU09OLnBhcnNlICl7XG5cdFx0XHRcdFx0anNvbiA9IEpTT04ucGFyc2Uoc3RyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRqc29uID0gKG5ldyBGdW5jdGlvbigncmV0dXJuICgnK3N0ci5yZXBsYWNlKC8oW1xcclxcbl0pL2csICdcXFxcJDEnKSsnKTsnKSkoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ganNvbjtcblx0XHRcdH0sXG5cblxuXHRcdFx0dHJpbTogZnVuY3Rpb24gKHN0cil7XG5cdFx0XHRcdHN0ciA9IFN0cmluZyhzdHIpO1xuXHRcdFx0XHRyZXR1cm5cdHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNpbXBsZSBEZWZlclxuXHRcdFx0ICogQHJldHVyblx0e09iamVjdH1cblx0XHRcdCAqL1xuXHRcdFx0ZGVmZXI6IGZ1bmN0aW9uICgpe1xuXHRcdFx0XHR2YXJcblx0XHRcdFx0XHQgIGxpc3QgPSBbXVxuXHRcdFx0XHRcdCwgcmVzdWx0XG5cdFx0XHRcdFx0LCBlcnJvclxuXHRcdFx0XHRcdCwgZGVmZXIgPSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlOiBmdW5jdGlvbiAoZXJyLCByZXMpe1xuXHRcdFx0XHRcdFx0XHRkZWZlci5yZXNvbHZlID0gbm9vcDtcblx0XHRcdFx0XHRcdFx0ZXJyb3JcdD0gZXJyIHx8IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRcdD0gcmVzO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlKCByZXMgPSBsaXN0LnNoaWZ0KCkgKXtcblx0XHRcdFx0XHRcdFx0XHRyZXMoZXJyb3IsIHJlc3VsdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdHRoZW46IGZ1bmN0aW9uIChmbil7XG5cdFx0XHRcdFx0XHRcdGlmKCBlcnJvciAhPT0gdW5kZWYgKXtcblx0XHRcdFx0XHRcdFx0XHRmbihlcnJvciwgcmVzdWx0KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goZm4pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmV0dXJuXHRkZWZlcjtcblx0XHRcdH0sXG5cblx0XHRcdHF1ZXVlOiBmdW5jdGlvbiAoZm4pe1xuXHRcdFx0XHR2YXJcblx0XHRcdFx0XHQgIF9pZHggPSAwXG5cdFx0XHRcdFx0LCBfbGVuZ3RoID0gMFxuXHRcdFx0XHRcdCwgX2ZhaWwgPSBmYWxzZVxuXHRcdFx0XHRcdCwgX2VuZCA9IGZhbHNlXG5cdFx0XHRcdFx0LCBxdWV1ZSA9IHtcblx0XHRcdFx0XHRcdGluYzogZnVuY3Rpb24gKCl7XG5cdFx0XHRcdFx0XHRcdF9sZW5ndGgrKztcblx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdG5leHQ6IGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRcdFx0XHRfaWR4Kys7XG5cdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQocXVldWUuY2hlY2ssIDApO1xuXHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0Y2hlY2s6IGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRcdFx0XHQoX2lkeCA+PSBfbGVuZ3RoKSAmJiAhX2ZhaWwgJiYgcXVldWUuZW5kKCk7XG5cdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRpc0ZhaWw6IGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gX2ZhaWw7XG5cdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRmYWlsOiBmdW5jdGlvbiAoKXtcblx0XHRcdFx0XHRcdFx0IV9mYWlsICYmIGZuKF9mYWlsID0gdHJ1ZSk7XG5cdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRlbmQ6IGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRcdFx0XHRpZiggIV9lbmQgKXtcblx0XHRcdFx0XHRcdFx0XHRfZW5kID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRmbigpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQ7XG5cdFx0XHRcdHJldHVybiBxdWV1ZTtcblx0XHRcdH0sXG5cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBGb3IgZWFjaCBvYmplY3Rcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW1cdHtPYmplY3R8QXJyYXl9XHRvYmpcblx0XHRcdCAqIEBwYXJhbVx0e0Z1bmN0aW9ufVx0XHRmblxuXHRcdFx0ICogQHBhcmFtXHR7Kn1cdFx0XHRcdFtjdHhdXG5cdFx0XHQgKi9cblx0XHRcdGVhY2g6IF9lYWNoLFxuXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQXN5bmMgZm9yXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuXHRcdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0XHRcdCAqL1xuXHRcdFx0YWZvcjogZnVuY3Rpb24gKGFycmF5LCBjYWxsYmFjayl7XG5cdFx0XHRcdHZhciBpID0gMCwgbiA9IGFycmF5Lmxlbmd0aDtcblxuXHRcdFx0XHRpZiggX2lzQXJyYXkoYXJyYXkpICYmIG4tLSApe1xuXHRcdFx0XHRcdChmdW5jdGlvbiBfbmV4dCgpe1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sobiAhPSBpICYmIF9uZXh0LCBhcnJheVtpXSwgaSsrKTtcblx0XHRcdFx0XHR9KSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGNhbGxiYWNrKGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIE1lcmdlIHRoZSBjb250ZW50cyBvZiB0d28gb3IgbW9yZSBvYmplY3RzIHRvZ2V0aGVyIGludG8gdGhlIGZpcnN0IG9iamVjdFxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbVx0e09iamVjdH1cdGRzdFxuXHRcdFx0ICogQHJldHVyblx0e09iamVjdH1cblx0XHRcdCAqL1xuXHRcdFx0ZXh0ZW5kOiBfZXh0ZW5kLFxuXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogSXMgZmlsZT9cblx0XHRcdCAqIEBwYXJhbSAge0ZpbGV9ICBmaWxlXG5cdFx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHRcdFx0ICovXG5cdFx0XHRpc0ZpbGU6IGZ1bmN0aW9uIChmaWxlKXtcblx0XHRcdFx0cmV0dXJuIF90b1N0cmluZy5jYWxsKGZpbGUpID09PSAnW29iamVjdCBGaWxlXSc7XG5cdFx0XHR9LFxuXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogSXMgYmxvYj9cblx0XHRcdCAqIEBwYXJhbSAgIHtCbG9ifSAgYmxvYlxuXHRcdFx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdFx0XHQgKi9cblx0XHRcdGlzQmxvYjogZnVuY3Rpb24gKGJsb2IpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuaXNGaWxlKGJsb2IpIHx8IChfdG9TdHJpbmcuY2FsbChibG9iKSA9PT0gJ1tvYmplY3QgQmxvYl0nKTtcblx0XHRcdH0sXG5cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBJcyBjYW52YXMgZWxlbWVudFxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbVx0e0hUTUxFbGVtZW50fVx0ZWxcblx0XHRcdCAqIEByZXR1cm5cdHtCb29sZWFufVxuXHRcdFx0ICovXG5cdFx0XHRpc0NhbnZhczogZnVuY3Rpb24gKGVsKXtcblx0XHRcdFx0cmV0dXJuXHRlbCAmJiBfcmNhbnZhcy50ZXN0KGVsLm5vZGVOYW1lKTtcblx0XHRcdH0sXG5cblxuXHRcdFx0Z2V0RmlsZXNGaWx0ZXI6IGZ1bmN0aW9uIChmaWx0ZXIpe1xuXHRcdFx0XHRmaWx0ZXIgPSB0eXBlb2YgZmlsdGVyID09ICdzdHJpbmcnID8gZmlsdGVyIDogKGZpbHRlci5nZXRBdHRyaWJ1dGUgJiYgZmlsdGVyLmdldEF0dHJpYnV0ZSgnYWNjZXB0JykgfHwgJycpO1xuXHRcdFx0XHRyZXR1cm5cdGZpbHRlciA/IG5ldyBSZWdFeHAoJygnKyBmaWx0ZXIucmVwbGFjZSgvXFwuL2csICdcXFxcLicpLnJlcGxhY2UoLywvZywgJ3wnKSArJykkJywgJ2knKSA6IC8uLztcblx0XHRcdH0sXG5cblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJlYWQgYXMgRGF0YVVSTFxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RmlsZXxFbGVtZW50fSBmaWxlXG5cdFx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHRcdFx0ICovXG5cdFx0XHRyZWFkQXNEYXRhVVJMOiBmdW5jdGlvbiAoZmlsZSwgZm4pe1xuXHRcdFx0XHRpZiggYXBpLmlzQ2FudmFzKGZpbGUpICl7XG5cdFx0XHRcdFx0X2VtaXQoZmlsZSwgZm4sICdsb2FkJywgYXBpLnRvRGF0YVVSTChmaWxlKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0X3JlYWRBcyhmaWxlLCBmbiwgJ0RhdGFVUkwnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJlYWQgYXMgQmluYXJ5IHN0cmluZ1xuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RmlsZX0gZmlsZVxuXHRcdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZEFzQmluYXJ5U3RyaW5nOiBmdW5jdGlvbiAoZmlsZSwgZm4pe1xuXHRcdFx0XHRpZiggX2hhc1N1cHBvcnRSZWFkQXMoJ0JpbmFyeVN0cmluZycpICl7XG5cdFx0XHRcdFx0X3JlYWRBcyhmaWxlLCBmbiwgJ0JpbmFyeVN0cmluZycpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEhlbGxvIElFMTAhXG5cdFx0XHRcdFx0X3JlYWRBcyhmaWxlLCBmdW5jdGlvbiAoZXZ0KXtcblx0XHRcdFx0XHRcdGlmKCBldnQudHlwZSA9PSAnbG9hZCcgKXtcblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHQvLyBkYXRhVVJMIC0+IGJpbmFyeVN0cmluZ1xuXHRcdFx0XHRcdFx0XHRcdGV2dC5yZXN1bHQgPSBhcGkudG9CaW5hcnlTdHJpbmcoZXZ0LnJlc3VsdCk7XG5cdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGUpe1xuXHRcdFx0XHRcdFx0XHRcdGV2dC50eXBlID0gJ2Vycm9yJztcblx0XHRcdFx0XHRcdFx0XHRldnQubWVzc2FnZSA9IGUudG9TdHJpbmcoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Zm4oZXZ0KTtcblx0XHRcdFx0XHR9LCAnRGF0YVVSTCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmVhZCBhcyBBcnJheUJ1ZmZlclxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RmlsZX0gZmlsZVxuXHRcdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0XHRcdCAqL1xuXHRcdFx0cmVhZEFzQXJyYXlCdWZmZXI6IGZ1bmN0aW9uKGZpbGUsIGZuKXtcblx0XHRcdFx0X3JlYWRBcyhmaWxlLCBmbiwgJ0FycmF5QnVmZmVyJyk7XG5cdFx0XHR9LFxuXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmVhZCBhcyB0ZXh0XG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtGaWxlfSBmaWxlXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2Rpbmdcblx0XHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cblx0XHRcdCAqL1xuXHRcdFx0cmVhZEFzVGV4dDogZnVuY3Rpb24oZmlsZSwgZW5jb2RpbmcsIGZuKXtcblx0XHRcdFx0aWYoICFmbiApe1xuXHRcdFx0XHRcdGZuXHQ9IGVuY29kaW5nO1xuXHRcdFx0XHRcdGVuY29kaW5nID0gJ3V0Zi04Jztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9yZWFkQXMoZmlsZSwgZm4sICdUZXh0JywgZW5jb2RpbmcpO1xuXHRcdFx0fSxcblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIENvbnZlcnQgaW1hZ2Ugb3IgY2FudmFzIHRvIERhdGFVUkxcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0gICB7RWxlbWVudH0gIGVsICAgICAgSW1hZ2Ugb3IgQ2FudmFzIGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgW3R5cGVdICBtaW1lLXR5cGVcblx0XHRcdCAqIEByZXR1cm4gIHtTdHJpbmd9XG5cdFx0XHQgKi9cblx0XHRcdHRvRGF0YVVSTDogZnVuY3Rpb24gKGVsLCB0eXBlKXtcblx0XHRcdFx0aWYoIHR5cGVvZiBlbCA9PSAnc3RyaW5nJyApe1xuXHRcdFx0XHRcdHJldHVybiAgZWw7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiggZWwudG9EYXRhVVJMICl7XG5cdFx0XHRcdFx0cmV0dXJuICBlbC50b0RhdGFVUkwodHlwZSB8fCAnaW1hZ2UvcG5nJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDYW52ZXJ0IHN0cmluZywgaW1hZ2Ugb3IgY2FudmFzIHRvIGJpbmFyeSBzdHJpbmdcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0gICB7U3RyaW5nfEVsZW1lbnR9IHZhbFxuXHRcdFx0ICogQHJldHVybiAge1N0cmluZ31cblx0XHRcdCAqL1xuXHRcdFx0dG9CaW5hcnlTdHJpbmc6IGZ1bmN0aW9uICh2YWwpe1xuXHRcdFx0XHRyZXR1cm4gIHdpbmRvdy5hdG9iKGFwaS50b0RhdGFVUkwodmFsKS5yZXBsYWNlKF9yZGF0YSwgJycpKTtcblx0XHRcdH0sXG5cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZWFkIGZpbGUgb3IgRGF0YVVSTCBhcyBJbWFnZUVsZW1lbnRcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW1cdHtGaWxlfFN0cmluZ31cdGZpbGVcblx0XHRcdCAqIEBwYXJhbVx0e0Z1bmN0aW9ufVx0XHRmblxuXHRcdFx0ICogQHBhcmFtXHR7Qm9vbGVhbn1cdFx0W3Byb2dyZXNzXVxuXHRcdFx0ICovXG5cdFx0XHRyZWFkQXNJbWFnZTogZnVuY3Rpb24gKGZpbGUsIGZuLCBwcm9ncmVzcyl7XG5cdFx0XHRcdGlmKCBhcGkuaXNCbG9iKGZpbGUpICl7XG5cdFx0XHRcdFx0aWYoIGFwaVVSTCApe1xuXHRcdFx0XHRcdFx0LyoqIEBuYW1lc3BhY2UgYXBpVVJMLmNyZWF0ZU9iamVjdFVSTCAqL1xuXHRcdFx0XHRcdFx0dmFyIGRhdGEgPSBhcGlVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuXHRcdFx0XHRcdFx0aWYoIGRhdGEgPT09IHVuZGVmICl7XG5cdFx0XHRcdFx0XHRcdF9lbWl0KGZpbGUsIGZuLCAnZXJyb3InKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRhcGkucmVhZEFzSW1hZ2UoZGF0YSwgZm4sIHByb2dyZXNzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRhcGkucmVhZEFzRGF0YVVSTChmaWxlLCBmdW5jdGlvbiAoZXZ0KXtcblx0XHRcdFx0XHRcdFx0aWYoIGV2dC50eXBlID09ICdsb2FkJyApe1xuXHRcdFx0XHRcdFx0XHRcdGFwaS5yZWFkQXNJbWFnZShldnQucmVzdWx0LCBmbiwgcHJvZ3Jlc3MpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYoIHByb2dyZXNzIHx8IGV2dC50eXBlID09ICdlcnJvcicgKXtcblx0XHRcdFx0XHRcdFx0XHRfZW1pdChmaWxlLCBmbiwgZXZ0LCBudWxsLCB7IGxvYWRlZDogZXZ0LmxvYWRlZCwgdG90YWw6IGV2dC50b3RhbCB9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYoIGFwaS5pc0NhbnZhcyhmaWxlKSApe1xuXHRcdFx0XHRcdF9lbWl0KGZpbGUsIGZuLCAnbG9hZCcsIGZpbGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYoIF9yaW1nLnRlc3QoZmlsZS5ub2RlTmFtZSkgKXtcblx0XHRcdFx0XHRpZiggZmlsZS5jb21wbGV0ZSApe1xuXHRcdFx0XHRcdFx0X2VtaXQoZmlsZSwgZm4sICdsb2FkJywgZmlsZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIGV2ZW50cyA9ICdlcnJvciBhYm9ydCBsb2FkJztcblx0XHRcdFx0XHRcdF9vbmUoZmlsZSwgZXZlbnRzLCBmdW5jdGlvbiBfZm4oZXZ0KXtcblx0XHRcdFx0XHRcdFx0aWYoIGV2dC50eXBlID09ICdsb2FkJyAmJiBhcGlVUkwgKXtcblx0XHRcdFx0XHRcdFx0XHQvKiogQG5hbWVzcGFjZSBhcGlVUkwucmV2b2tlT2JqZWN0VVJMICovXG5cdFx0XHRcdFx0XHRcdFx0YXBpVVJMLnJldm9rZU9iamVjdFVSTChmaWxlLnNyYyk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRfb2ZmKGZpbGUsIGV2ZW50cywgX2ZuKTtcblx0XHRcdFx0XHRcdFx0X2VtaXQoZmlsZSwgZm4sIGV2dCwgZmlsZSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiggZmlsZS5pZnJhbWUgKXtcblx0XHRcdFx0XHRfZW1pdChmaWxlLCBmbiwgeyB0eXBlOiAnZXJyb3InIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIENyZWF0ZWQgaW1hZ2Vcblx0XHRcdFx0XHR2YXIgaW1nID0gYXBpLm5ld0ltYWdlKGZpbGUuZGF0YVVSTCB8fCBmaWxlKTtcblx0XHRcdFx0XHRhcGkucmVhZEFzSW1hZ2UoaW1nLCBmbiwgcHJvZ3Jlc3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogTWFrZSBmaWxlIGJ5IG5hbWVcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW1cdHtTdHJpbmd9XHRuYW1lXG5cdFx0XHQgKiBAcmV0dXJuXHR7QXJyYXl9XG5cdFx0XHQgKi9cblx0XHRcdGNoZWNrRmlsZU9iajogZnVuY3Rpb24gKG5hbWUpe1xuXHRcdFx0XHR2YXIgZmlsZSA9IHt9LCBhY2NlcHQgPSBhcGkuYWNjZXB0O1xuXG5cdFx0XHRcdGlmKCB0eXBlb2YgbmFtZSA9PSAnb2JqZWN0JyApe1xuXHRcdFx0XHRcdGZpbGUgPSBuYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGZpbGUubmFtZSA9IChuYW1lICsgJycpLnNwbGl0KC9cXFxcfFxcLy9nKS5wb3AoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKCBmaWxlLnR5cGUgPT0gbnVsbCApe1xuXHRcdFx0XHRcdGZpbGUudHlwZSA9IGZpbGUubmFtZS5zcGxpdCgnLicpLnBvcCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2VhY2goYWNjZXB0LCBmdW5jdGlvbiAoZXh0LCB0eXBlKXtcblx0XHRcdFx0XHRleHQgPSBuZXcgUmVnRXhwKGV4dC5yZXBsYWNlKC9cXHMvZywgJ3wnKSwgJ2knKTtcblx0XHRcdFx0XHRpZiggZXh0LnRlc3QoZmlsZS50eXBlKSB8fCBhcGkuZXh0Mm1pbWVbZmlsZS50eXBlXSApe1xuXHRcdFx0XHRcdFx0ZmlsZS50eXBlID0gYXBpLmV4dDJtaW1lW2ZpbGUudHlwZV0gfHwgKHR5cGUuc3BsaXQoJy8nKVswXSArJy8nKyBmaWxlLnR5cGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuXHRmaWxlO1xuXHRcdFx0fSxcblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEdldCBkcm9wIGZpbGVzXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtXHR7RXZlbnR9XHRldnRcblx0XHRcdCAqIEBwYXJhbVx0e0Z1bmN0aW9ufSBjYWxsYmFja1xuXHRcdFx0ICovXG5cdFx0XHRnZXREcm9wRmlsZXM6IGZ1bmN0aW9uIChldnQsIGNhbGxiYWNrKXtcblx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0ICBmaWxlcyA9IFtdXG5cdFx0XHRcdFx0LCBhbGwgPSBbXVxuXHRcdFx0XHRcdCwgaXRlbXNcblx0XHRcdFx0XHQsIGRhdGFUcmFuc2ZlciA9IF9nZXREYXRhVHJhbnNmZXIoZXZ0KVxuXHRcdFx0XHRcdCwgdHJhbnNGaWxlcyA9IGRhdGFUcmFuc2Zlci5maWxlc1xuXHRcdFx0XHRcdCwgdHJhbnNJdGVtcyA9IGRhdGFUcmFuc2Zlci5pdGVtc1xuXHRcdFx0XHRcdCwgZW50cnlTdXBwb3J0ID0gX2lzQXJyYXkodHJhbnNJdGVtcykgJiYgdHJhbnNJdGVtc1swXSAmJiBfZ2V0QXNFbnRyeSh0cmFuc0l0ZW1zWzBdKVxuXHRcdFx0XHRcdCwgcXVldWUgPSBhcGkucXVldWUoZnVuY3Rpb24gKCl7IGNhbGxiYWNrKGZpbGVzLCBhbGwpOyB9KVxuXHRcdFx0XHQ7XG5cblx0XHRcdFx0aWYoIGVudHJ5U3VwcG9ydCApe1xuXHRcdFx0XHRcdGlmKCBub3JtYWxpemUgJiYgdHJhbnNGaWxlcyApe1xuXHRcdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0XHRcdGkgPSB0cmFuc0ZpbGVzLmxlbmd0aFxuXHRcdFx0XHRcdFx0XHQsIGZpbGVcblx0XHRcdFx0XHRcdFx0LCBlbnRyeVxuXHRcdFx0XHRcdFx0O1xuXG5cdFx0XHRcdFx0XHRpdGVtcyA9IG5ldyBBcnJheShpKTtcblx0XHRcdFx0XHRcdHdoaWxlKCBpLS0gKXtcblx0XHRcdFx0XHRcdFx0ZmlsZSA9IHRyYW5zRmlsZXNbaV07XG5cblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRlbnRyeSA9IF9nZXRBc0VudHJ5KHRyYW5zSXRlbXNbaV0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGNhdGNoKCBlcnIgKXtcblx0XHRcdFx0XHRcdFx0XHRhcGkubG9nKCdbZXJyXSBnZXREcm9wRmlsZXM6ICcsIGVycik7XG5cdFx0XHRcdFx0XHRcdFx0ZW50cnkgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYoIF9pc0VudHJ5KGVudHJ5KSApe1xuXHRcdFx0XHRcdFx0XHRcdC8vIE9TWCBmaWxlc3lzdGVtcyB1c2UgVW5pY29kZSBOb3JtYWxpemF0aW9uIEZvcm0gRCAoTkZEKSxcblx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgZW50cnkuZmlsZSjigKYpIGNhbid0IHJlYWQgdGhlIGZpbGVzIHdpdGggdGhlIHNhbWUgbmFtZXNcblx0XHRcdFx0XHRcdFx0XHRpZiggZW50cnkuaXNEaXJlY3RvcnkgfHwgKGVudHJ5LmlzRmlsZSAmJiBmaWxlLm5hbWUgPT0gZmlsZS5uYW1lLm5vcm1hbGl6ZSgnTkZDJykpICl7XG5cdFx0XHRcdFx0XHRcdFx0XHRpdGVtc1tpXSA9IGVudHJ5O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGl0ZW1zW2ldID0gZmlsZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0aXRlbXNbaV0gPSBmaWxlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0aXRlbXMgPSB0cmFuc0l0ZW1zO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpdGVtcyA9IHRyYW5zRmlsZXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfZWFjaChpdGVtcyB8fCBbXSwgZnVuY3Rpb24gKGl0ZW0pe1xuXHRcdFx0XHRcdHF1ZXVlLmluYygpO1xuXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGlmKCBlbnRyeVN1cHBvcnQgJiYgX2lzRW50cnkoaXRlbSkgKXtcblx0XHRcdFx0XHRcdFx0X3JlYWRFbnRyeUFzRmlsZXMoaXRlbSwgZnVuY3Rpb24gKGVyciwgZW50cnlGaWxlcywgYWxsRW50cmllcyl7XG5cdFx0XHRcdFx0XHRcdFx0aWYoIGVyciApe1xuXHRcdFx0XHRcdFx0XHRcdFx0YXBpLmxvZygnW2Vycl0gZ2V0RHJvcEZpbGVzOicsIGVycik7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZpbGVzLnB1c2guYXBwbHkoZmlsZXMsIGVudHJ5RmlsZXMpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRhbGwucHVzaC5hcHBseShhbGwsIGFsbEVudHJpZXMpO1xuXG5cdFx0XHRcdFx0XHRcdFx0cXVldWUubmV4dCgpO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRfaXNSZWd1bGFyRmlsZShpdGVtLCBmdW5jdGlvbiAoeWVzLCBlcnIpe1xuXHRcdFx0XHRcdFx0XHRcdGlmKCB5ZXMgKXtcblx0XHRcdFx0XHRcdFx0XHRcdGZpbGVzLnB1c2goaXRlbSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aXRlbS5lcnJvciA9IGVycjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YWxsLnB1c2goaXRlbSk7XG5cblx0XHRcdFx0XHRcdFx0XHRxdWV1ZS5uZXh0KCk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXRjaCggZXJyICl7XG5cdFx0XHRcdFx0XHRxdWV1ZS5uZXh0KCk7XG5cdFx0XHRcdFx0XHRhcGkubG9nKCdbZXJyXSBnZXREcm9wRmlsZXM6ICcsIGVycik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRxdWV1ZS5jaGVjaygpO1xuXHRcdFx0fSxcblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEdldCBmaWxlIGxpc3Rcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW1cdHtIVE1MSW5wdXRFbGVtZW50fEV2ZW50fVx0aW5wdXRcblx0XHRcdCAqIEBwYXJhbVx0e1N0cmluZ3xGdW5jdGlvbn1cdFtmaWx0ZXJdXG5cdFx0XHQgKiBAcGFyYW1cdHtGdW5jdGlvbn1cdFx0XHRbY2FsbGJhY2tdXG5cdFx0XHQgKiBAcmV0dXJuXHR7QXJyYXl8TnVsbH1cblx0XHRcdCAqL1xuXHRcdFx0Z2V0RmlsZXM6IGZ1bmN0aW9uIChpbnB1dCwgZmlsdGVyLCBjYWxsYmFjayl7XG5cdFx0XHRcdHZhciBmaWxlcyA9IFtdO1xuXG5cdFx0XHRcdGlmKCBjYWxsYmFjayApe1xuXHRcdFx0XHRcdGFwaS5maWx0ZXJGaWxlcyhhcGkuZ2V0RmlsZXMoaW5wdXQpLCBmaWx0ZXIsIGNhbGxiYWNrKTtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKCBpbnB1dC5qcXVlcnkgKXtcblx0XHRcdFx0XHQvLyBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0aW5wdXQuZWFjaChmdW5jdGlvbiAoKXtcblx0XHRcdFx0XHRcdGZpbGVzID0gZmlsZXMuY29uY2F0KGFwaS5nZXRGaWxlcyh0aGlzKSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0aW5wdXRcdD0gZmlsZXM7XG5cdFx0XHRcdFx0ZmlsZXNcdD0gW107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiggdHlwZW9mIGZpbHRlciA9PSAnc3RyaW5nJyApe1xuXHRcdFx0XHRcdGZpbHRlclx0PSBhcGkuZ2V0RmlsZXNGaWx0ZXIoZmlsdGVyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKCBpbnB1dC5vcmlnaW5hbEV2ZW50ICl7XG5cdFx0XHRcdFx0Ly8galF1ZXJ5IGV2ZW50XG5cdFx0XHRcdFx0aW5wdXQgPSBfZml4RXZlbnQoaW5wdXQub3JpZ2luYWxFdmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiggaW5wdXQuc3JjRWxlbWVudCApe1xuXHRcdFx0XHRcdC8vIElFIEV2ZW50XG5cdFx0XHRcdFx0aW5wdXQgPSBfZml4RXZlbnQoaW5wdXQpO1xuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRpZiggaW5wdXQuZGF0YVRyYW5zZmVyICl7XG5cdFx0XHRcdFx0Ly8gRHJhZyduJ0Ryb3Bcblx0XHRcdFx0XHRpbnB1dCA9IGlucHV0LmRhdGFUcmFuc2Zlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKCBpbnB1dC50YXJnZXQgKXtcblx0XHRcdFx0XHQvLyBFdmVudFxuXHRcdFx0XHRcdGlucHV0ID0gaW5wdXQudGFyZ2V0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoIGlucHV0LmZpbGVzICl7XG5cdFx0XHRcdFx0Ly8gSW5wdXRbdHlwZT1cImZpbGVcIl1cblx0XHRcdFx0XHRmaWxlcyA9IGlucHV0LmZpbGVzO1xuXG5cdFx0XHRcdFx0aWYoICFodG1sNSApe1xuXHRcdFx0XHRcdFx0Ly8gUGFydGlhbCBzdXBwb3J0IGZvciBmaWxlIGFwaVxuXHRcdFx0XHRcdFx0ZmlsZXNbMF0uYmxvYlx0PSBpbnB1dDtcblx0XHRcdFx0XHRcdGZpbGVzWzBdLmlmcmFtZVx0PSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKCAhaHRtbDUgJiYgaXNJbnB1dEZpbGUoaW5wdXQpICl7XG5cdFx0XHRcdFx0aWYoIGFwaS50cmltKGlucHV0LnZhbHVlKSApe1xuXHRcdFx0XHRcdFx0ZmlsZXMgPSBbYXBpLmNoZWNrRmlsZU9iaihpbnB1dC52YWx1ZSldO1xuXHRcdFx0XHRcdFx0ZmlsZXNbMF0uYmxvYiAgID0gaW5wdXQ7XG5cdFx0XHRcdFx0XHRmaWxlc1swXS5pZnJhbWUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKCBfaXNBcnJheShpbnB1dCkgKXtcblx0XHRcdFx0XHRmaWxlc1x0PSBpbnB1dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVyblx0YXBpLmZpbHRlcihmaWxlcywgZnVuY3Rpb24gKGZpbGUpeyByZXR1cm4gIWZpbHRlciB8fCBmaWx0ZXIudGVzdChmaWxlLm5hbWUpOyB9KTtcblx0XHRcdH0sXG5cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBHZXQgdG90YWwgZmlsZSBzaXplXG5cdFx0XHQgKiBAcGFyYW1cdHtBcnJheX1cdGZpbGVzXG5cdFx0XHQgKiBAcmV0dXJuXHR7TnVtYmVyfVxuXHRcdFx0ICovXG5cdFx0XHRnZXRUb3RhbFNpemU6IGZ1bmN0aW9uIChmaWxlcyl7XG5cdFx0XHRcdHZhciBzaXplID0gMCwgaSA9IGZpbGVzICYmIGZpbGVzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUoIGktLSApe1xuXHRcdFx0XHRcdHNpemUgKz0gZmlsZXNbaV0uc2l6ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm5cdHNpemU7XG5cdFx0XHR9LFxuXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogR2V0IGltYWdlIGluZm9ybWF0aW9uXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtXHR7RmlsZX1cdFx0ZmlsZVxuXHRcdFx0ICogQHBhcmFtXHR7RnVuY3Rpb259XHRmblxuXHRcdFx0ICovXG5cdFx0XHRnZXRJbmZvOiBmdW5jdGlvbiAoZmlsZSwgZm4pe1xuXHRcdFx0XHR2YXIgaW5mbyA9IHt9LCByZWFkZXJzID0gX2luZm9SZWFkZXIuY29uY2F0KCk7XG5cblx0XHRcdFx0aWYoIGFwaS5pc0Jsb2IoZmlsZSkgKXtcblx0XHRcdFx0XHQoZnVuY3Rpb24gX25leHQoKXtcblx0XHRcdFx0XHRcdHZhciByZWFkZXIgPSByZWFkZXJzLnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHRpZiggcmVhZGVyICl7XG5cdFx0XHRcdFx0XHRcdGlmKCByZWFkZXIudGVzdChmaWxlLnR5cGUpICl7XG5cdFx0XHRcdFx0XHRcdFx0cmVhZGVyKGZpbGUsIGZ1bmN0aW9uIChlcnIsIHJlcyl7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiggZXJyICl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuKGVycik7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0X2V4dGVuZChpbmZvLCByZXMpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRfbmV4dCgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdF9uZXh0KCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRmbihmYWxzZSwgaW5mbyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRmbignbm90X3N1cHBvcnRfaW5mbycsIGluZm8pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQWRkIGluZm9ybWF0aW9uIHJlYWRlclxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7UmVnRXhwfSBtaW1lXG5cdFx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHRcdFx0ICovXG5cdFx0XHRhZGRJbmZvUmVhZGVyOiBmdW5jdGlvbiAobWltZSwgZm4pe1xuXHRcdFx0XHRmbi50ZXN0ID0gZnVuY3Rpb24gKHR5cGUpeyByZXR1cm4gbWltZS50ZXN0KHR5cGUpOyB9O1xuXHRcdFx0XHRfaW5mb1JlYWRlci5wdXNoKGZuKTtcblx0XHRcdH0sXG5cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBGaWx0ZXIgb2YgYXJyYXlcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW1cdHtBcnJheX1cdFx0aW5wdXRcblx0XHRcdCAqIEBwYXJhbVx0e0Z1bmN0aW9ufVx0Zm5cblx0XHRcdCAqIEByZXR1cm5cdHtBcnJheX1cblx0XHRcdCAqL1xuXHRcdFx0ZmlsdGVyOiBmdW5jdGlvbiAoaW5wdXQsIGZuKXtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFtdLCBpID0gMCwgbiA9IGlucHV0Lmxlbmd0aCwgdmFsO1xuXG5cdFx0XHRcdGZvciggOyBpIDwgbjsgaSsrICl7XG5cdFx0XHRcdFx0aWYoIGkgaW4gaW5wdXQgKXtcblx0XHRcdFx0XHRcdHZhbCA9IGlucHV0W2ldO1xuXHRcdFx0XHRcdFx0aWYoIGZuLmNhbGwodmFsLCB2YWwsIGksIGlucHV0KSApe1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQucHVzaCh2YWwpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVyblx0cmVzdWx0O1xuXHRcdFx0fSxcblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEZpbHRlciBmaWxlc1xuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbVx0e0FycmF5fVx0XHRmaWxlc1xuXHRcdFx0ICogQHBhcmFtXHR7RnVuY3Rpb259XHRlYWNoRm5cblx0XHRcdCAqIEBwYXJhbVx0e0Z1bmN0aW9ufVx0cmVzdWx0Rm5cblx0XHRcdCAqL1xuXHRcdFx0ZmlsdGVyRmlsZXM6IGZ1bmN0aW9uIChmaWxlcywgZWFjaEZuLCByZXN1bHRGbil7XG5cdFx0XHRcdGlmKCBmaWxlcy5sZW5ndGggKXtcblx0XHRcdFx0XHQvLyBIVE1MNSBvciBGbGFzaFxuXHRcdFx0XHRcdHZhciBxdWV1ZSA9IGZpbGVzLmNvbmNhdCgpLCBmaWxlLCByZXN1bHQgPSBbXSwgZGVsZXRlZCA9IFtdO1xuXG5cdFx0XHRcdFx0KGZ1bmN0aW9uIF9uZXh0KCl7XG5cdFx0XHRcdFx0XHRpZiggcXVldWUubGVuZ3RoICl7XG5cdFx0XHRcdFx0XHRcdGZpbGUgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0XHRhcGkuZ2V0SW5mbyhmaWxlLCBmdW5jdGlvbiAoZXJyLCBpbmZvKXtcblx0XHRcdFx0XHRcdFx0XHQoZWFjaEZuKGZpbGUsIGVyciA/IGZhbHNlIDogaW5mbykgPyByZXN1bHQgOiBkZWxldGVkKS5wdXNoKGZpbGUpO1xuXHRcdFx0XHRcdFx0XHRcdF9uZXh0KCk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdEZuKHJlc3VsdCwgZGVsZXRlZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRyZXN1bHRGbihbXSwgZmlsZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cblx0XHRcdHVwbG9hZDogZnVuY3Rpb24gKG9wdGlvbnMpe1xuXHRcdFx0XHRvcHRpb25zID0gX2V4dGVuZCh7XG5cdFx0XHRcdFx0ICBqc29ucDogJ2NhbGxiYWNrJ1xuXHRcdFx0XHRcdCwgcHJlcGFyZTogYXBpLkZcblx0XHRcdFx0XHQsIGJlZm9yZXVwbG9hZDogYXBpLkZcblx0XHRcdFx0XHQsIHVwbG9hZDogYXBpLkZcblx0XHRcdFx0XHQsIGZpbGV1cGxvYWQ6IGFwaS5GXG5cdFx0XHRcdFx0LCBmaWxlcHJvZ3Jlc3M6IGFwaS5GXG5cdFx0XHRcdFx0LCBmaWxlY29tcGxldGU6IGFwaS5GXG5cdFx0XHRcdFx0LCBwcm9ncmVzczogYXBpLkZcblx0XHRcdFx0XHQsIGNvbXBsZXRlOiBhcGkuRlxuXHRcdFx0XHRcdCwgcGF1c2U6IGFwaS5GXG5cdFx0XHRcdFx0LCBpbWFnZU9yaWdpbmFsOiB0cnVlXG5cdFx0XHRcdFx0LCBjaHVua1NpemU6IGFwaS5jaHVua1NpemVcblx0XHRcdFx0XHQsIGNodW5rVXBsb2FkUmV0cnk6IGFwaS5jaHVua1VwbG9hZFJldHJ5XG5cdFx0XHRcdFx0LCB1cGxvYWRSZXRyeTogYXBpLnVwbG9hZFJldHJ5XG5cdFx0XHRcdH0sIG9wdGlvbnMpO1xuXG5cblx0XHRcdFx0aWYoIG9wdGlvbnMuaW1hZ2VBdXRvT3JpZW50YXRpb24gJiYgIW9wdGlvbnMuaW1hZ2VUcmFuc2Zvcm0gKXtcblx0XHRcdFx0XHRvcHRpb25zLmltYWdlVHJhbnNmb3JtID0geyByb3RhdGU6ICdhdXRvJyB9O1xuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHR2YXJcblx0XHRcdFx0XHQgIHByb3h5WEhSID0gbmV3IGFwaS5YSFIob3B0aW9ucylcblx0XHRcdFx0XHQsIGRhdGFBcnJheSA9IHRoaXMuX2dldEZpbGVzRGF0YUFycmF5KG9wdGlvbnMuZmlsZXMpXG5cdFx0XHRcdFx0LCBfdGhpcyA9IHRoaXNcblx0XHRcdFx0XHQsIF90b3RhbCA9IDBcblx0XHRcdFx0XHQsIF9sb2FkZWQgPSAwXG5cdFx0XHRcdFx0LCBfbmV4dEZpbGVcblx0XHRcdFx0XHQsIF9jb21wbGV0ZSA9IGZhbHNlXG5cdFx0XHRcdDtcblxuXG5cdFx0XHRcdC8vIGNhbGMgdG90YWwgc2l6ZVxuXHRcdFx0XHRfZWFjaChkYXRhQXJyYXksIGZ1bmN0aW9uIChkYXRhKXtcblx0XHRcdFx0XHRfdG90YWwgKz0gZGF0YS5zaXplO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBBcnJheSBvZiBmaWxlc1xuXHRcdFx0XHRwcm94eVhIUi5maWxlcyA9IFtdO1xuXHRcdFx0XHRfZWFjaChkYXRhQXJyYXksIGZ1bmN0aW9uIChkYXRhKXtcblx0XHRcdFx0XHRwcm94eVhIUi5maWxlcy5wdXNoKGRhdGEuZmlsZSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIFNldCB1cGxvYWQgc3RhdHVzIHByb3BzXG5cdFx0XHRcdHByb3h5WEhSLnRvdGFsXHQ9IF90b3RhbDtcblx0XHRcdFx0cHJveHlYSFIubG9hZGVkXHQ9IDA7XG5cdFx0XHRcdHByb3h5WEhSLmZpbGVzTGVmdCA9IGRhdGFBcnJheS5sZW5ndGg7XG5cblx0XHRcdFx0Ly8gZW1pdCBcImJlZm9yZXVwbG9hZFwiICBldmVudFxuXHRcdFx0XHRvcHRpb25zLmJlZm9yZXVwbG9hZChwcm94eVhIUiwgb3B0aW9ucyk7XG5cblx0XHRcdFx0Ly8gVXBsb2FkIGJ5IGZpbGVcblx0XHRcdFx0X25leHRGaWxlID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0XHQgIGRhdGEgPSBkYXRhQXJyYXkuc2hpZnQoKVxuXHRcdFx0XHRcdFx0LCBfZmlsZSA9IGRhdGEgJiYgZGF0YS5maWxlXG5cdFx0XHRcdFx0XHQsIF9maWxlTG9hZGVkID0gZmFsc2Vcblx0XHRcdFx0XHRcdCwgX2ZpbGVPcHRpb25zID0gX3NpbXBsZUNsb25lKG9wdGlvbnMpXG5cdFx0XHRcdFx0O1xuXG5cdFx0XHRcdFx0cHJveHlYSFIuZmlsZXNMZWZ0ID0gZGF0YUFycmF5Lmxlbmd0aDtcblxuXHRcdFx0XHRcdGlmKCBfZmlsZSAmJiBfZmlsZS5uYW1lID09PSBhcGkuZXhwYW5kbyApe1xuXHRcdFx0XHRcdFx0X2ZpbGUgPSBudWxsO1xuXHRcdFx0XHRcdFx0YXBpLmxvZygnW3dhcm5dIEZpbGVBUEkudXBsb2FkKCkg4oCUIGNhbGxlZCB3aXRob3V0IGZpbGVzJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYoICggcHJveHlYSFIuc3RhdHVzVGV4dCAhPSAnYWJvcnQnIHx8IHByb3h5WEhSLmN1cnJlbnQgKSAmJiBkYXRhICl7XG5cdFx0XHRcdFx0XHQvLyBNYXJrIGFjdGl2ZSBqb2Jcblx0XHRcdFx0XHRcdF9jb21wbGV0ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHQvLyBTZXQgY3VycmVudCB1cGxvYWQgZmlsZVxuXHRcdFx0XHRcdFx0cHJveHlYSFIuY3VycmVudEZpbGUgPSBfZmlsZTtcblxuXHRcdFx0XHRcdFx0Ly8gUHJlcGFyZSBmaWxlIG9wdGlvbnNcblx0XHRcdFx0XHRcdGlmIChfZmlsZSAmJiBvcHRpb25zLnByZXBhcmUoX2ZpbGUsIF9maWxlT3B0aW9ucykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRcdF9uZXh0RmlsZS5jYWxsKF90aGlzKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0X2ZpbGVPcHRpb25zLmZpbGUgPSBfZmlsZTtcblxuXHRcdFx0XHRcdFx0X3RoaXMuX2dldEZvcm1EYXRhKF9maWxlT3B0aW9ucywgZGF0YSwgZnVuY3Rpb24gKGZvcm0pe1xuXHRcdFx0XHRcdFx0XHRpZiggIV9sb2FkZWQgKXtcblx0XHRcdFx0XHRcdFx0XHQvLyBlbWl0IFwidXBsb2FkXCIgZXZlbnRcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLnVwbG9hZChwcm94eVhIUiwgb3B0aW9ucyk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR2YXIgeGhyID0gbmV3IGFwaS5YSFIoX2V4dGVuZCh7fSwgX2ZpbGVPcHRpb25zLCB7XG5cblx0XHRcdFx0XHRcdFx0XHR1cGxvYWQ6IF9maWxlID8gZnVuY3Rpb24gKCl7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBlbWl0IFwiZmlsZXVwbG9hZFwiIGV2ZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLmZpbGV1cGxvYWQoX2ZpbGUsIHhociwgX2ZpbGVPcHRpb25zKTtcblx0XHRcdFx0XHRcdFx0XHR9IDogbm9vcCxcblxuXHRcdFx0XHRcdFx0XHRcdHByb2dyZXNzOiBfZmlsZSA/IGZ1bmN0aW9uIChldnQpe1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoICFfZmlsZUxvYWRlZCApe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgaWdub3JlIHRoZSBkb3VibGUgY2FsbHMuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9maWxlTG9hZGVkID0gKGV2dC5sb2FkZWQgPT09IGV2dC50b3RhbCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gZW1pdCBcImZpbGVwcm9ncmVzc1wiIGV2ZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMuZmlsZXByb2dyZXNzKHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgIHR5cGU6ICAgJ3Byb2dyZXNzJ1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCwgdG90YWw6ICBkYXRhLnRvdGFsID0gZXZ0LnRvdGFsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LCBsb2FkZWQ6IGRhdGEubG9hZGVkID0gZXZ0LmxvYWRlZFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LCBfZmlsZSwgeGhyLCBfZmlsZU9wdGlvbnMpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGVtaXQgXCJwcm9ncmVzc1wiIGV2ZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMucHJvZ3Jlc3Moe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgdHlwZTogICAncHJvZ3Jlc3MnXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LCB0b3RhbDogIF90b3RhbFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCwgbG9hZGVkOiBwcm94eVhIUi5sb2FkZWQgPSAoX2xvYWRlZCArIGRhdGEuc2l6ZSAqIChldnQubG9hZGVkL2V2dC50b3RhbCkpIHx8IDBcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSwgX2ZpbGUsIHhociwgX2ZpbGVPcHRpb25zKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IDogbm9vcCxcblxuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlOiBmdW5jdGlvbiAoZXJyKXtcblx0XHRcdFx0XHRcdFx0XHRcdF9lYWNoKF94aHJQcm9wc0V4cG9ydCwgZnVuY3Rpb24gKG5hbWUpe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwcm94eVhIUltuYW1lXSA9IHhocltuYW1lXTtcblx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiggX2ZpbGUgKXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS50b3RhbCA9IChkYXRhLnRvdGFsIHx8IGRhdGEuc2l6ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGEubG9hZGVkXHQ9IGRhdGEudG90YWw7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoICFlcnIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gZW11bGF0ZSAxMDAlIFwicHJvZ3Jlc3NcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMucHJvZ3Jlc3MoZGF0YSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBmaXhlZCB0aHJvdHRsZSBldmVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9maWxlTG9hZGVkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGJ5dGVzIGxvYWRlZFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9sb2FkZWQgKz0gZGF0YS5zaXplOyAvLyBkYXRhLnNpemUgIT0gZGF0YS50b3RhbCwgaXQncyBkZXNpcmFibGUgZml4IHRoaXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm94eVhIUi5sb2FkZWQgPSBfbG9hZGVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gZW1pdCBcImZpbGVjb21wbGV0ZVwiIGV2ZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMuZmlsZWNvbXBsZXRlKGVyciwgeGhyLCBfZmlsZSwgX2ZpbGVPcHRpb25zKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gdXBsb2FkIG5leHQgZmlsZVxuXHRcdFx0XHRcdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7X25leHRGaWxlLmNhbGwoX3RoaXMpO30sIDApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSkpOyAvLyB4aHJcblxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLlxuXHRcdFx0XHRcdFx0XHRwcm94eVhIUi5hYm9ydCA9IGZ1bmN0aW9uIChjdXJyZW50KXtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIWN1cnJlbnQpIHsgZGF0YUFycmF5Lmxlbmd0aCA9IDA7IH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN0YXJ0IHVwbG9hZFxuXHRcdFx0XHRcdFx0XHR4aHIuc2VuZChmb3JtKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBzdWNjZXNzZnVsID0gcHJveHlYSFIuc3RhdHVzID09IDIwMCB8fCBwcm94eVhIUi5zdGF0dXMgPT0gMjAxIHx8IHByb3h5WEhSLnN0YXR1cyA9PSAyMDQ7XG5cdFx0XHRcdFx0XHRvcHRpb25zLmNvbXBsZXRlKHN1Y2Nlc3NmdWwgPyBmYWxzZSA6IChwcm94eVhIUi5zdGF0dXNUZXh0IHx8ICdlcnJvcicpLCBwcm94eVhIUiwgb3B0aW9ucyk7XG5cdFx0XHRcdFx0XHQvLyBNYXJrIGRvbmUgc3RhdGVcblx0XHRcdFx0XHRcdF9jb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cblx0XHRcdFx0Ly8gTmV4dCB0aWNrXG5cdFx0XHRcdHNldFRpbWVvdXQoX25leHRGaWxlLCAwKTtcblxuXG5cdFx0XHRcdC8vIEFwcGVuZCBtb3JlIGZpbGVzIHRvIHRoZSBleGlzdGluZyByZXF1ZXN0XG5cdFx0XHRcdC8vIGZpcnN0IC0gYWRkIHRoZW0gdG8gdGhlIHF1ZXVlIGhlYWQvdGFpbFxuXHRcdFx0XHRwcm94eVhIUi5hcHBlbmQgPSBmdW5jdGlvbiAoZmlsZXMsIGZpcnN0KSB7XG5cdFx0XHRcdFx0ZmlsZXMgPSBhcGkuX2dldEZpbGVzRGF0YUFycmF5KFtdLmNvbmNhdChmaWxlcykpO1xuXG5cdFx0XHRcdFx0X2VhY2goZmlsZXMsIGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRcdFx0XHRfdG90YWwgKz0gZGF0YS5zaXplO1xuXHRcdFx0XHRcdFx0cHJveHlYSFIuZmlsZXMucHVzaChkYXRhLmZpbGUpO1xuXHRcdFx0XHRcdFx0aWYgKGZpcnN0KSB7XG5cdFx0XHRcdFx0XHRcdGRhdGFBcnJheS51bnNoaWZ0KGRhdGEpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZGF0YUFycmF5LnB1c2goZGF0YSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRwcm94eVhIUi5zdGF0dXNUZXh0ID0gXCJcIjtcblxuXHRcdFx0XHRcdGlmKCBfY29tcGxldGUgKXtcblx0XHRcdFx0XHRcdF9uZXh0RmlsZS5jYWxsKF90aGlzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblxuXHRcdFx0XHQvLyBSZW1vdmVzIGZpbGUgZnJvbSBxdWV1ZSBieSBmaWxlIHJlZmVyZW5jZSBhbmQgcmV0dXJucyBpdFxuXHRcdFx0XHRwcm94eVhIUi5yZW1vdmUgPSBmdW5jdGlvbiAoZmlsZSkge1xuXHRcdFx0XHQgICAgdmFyIGkgPSBkYXRhQXJyYXkubGVuZ3RoLCBfZmlsZTtcblx0XHRcdFx0ICAgIHdoaWxlKCBpLS0gKXtcblx0XHRcdFx0XHRcdGlmKCBkYXRhQXJyYXlbaV0uZmlsZSA9PSBmaWxlICl7XG5cdFx0XHRcdFx0XHRcdF9maWxlID0gZGF0YUFycmF5LnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0X3RvdGFsIC09IF9maWxlLnNpemU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVyblx0X2ZpbGU7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmV0dXJuIHByb3h5WEhSO1xuXHRcdFx0fSxcblxuXG5cdFx0XHRfZ2V0RmlsZXNEYXRhQXJyYXk6IGZ1bmN0aW9uIChkYXRhKXtcblx0XHRcdFx0dmFyIGZpbGVzID0gW10sIG9GaWxlcyA9IHt9O1xuXG5cdFx0XHRcdGlmKCBpc0lucHV0RmlsZShkYXRhKSApe1xuXHRcdFx0XHRcdHZhciB0bXAgPSBhcGkuZ2V0RmlsZXMoZGF0YSk7XG5cdFx0XHRcdFx0b0ZpbGVzW2RhdGEubmFtZSB8fCAnZmlsZSddID0gZGF0YS5nZXRBdHRyaWJ1dGUoJ211bHRpcGxlJykgIT09IG51bGwgPyB0bXAgOiB0bXBbMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiggX2lzQXJyYXkoZGF0YSkgJiYgaXNJbnB1dEZpbGUoZGF0YVswXSkgKXtcblx0XHRcdFx0XHRfZWFjaChkYXRhLCBmdW5jdGlvbiAoaW5wdXQpe1xuXHRcdFx0XHRcdFx0b0ZpbGVzW2lucHV0Lm5hbWUgfHwgJ2ZpbGUnXSA9IGFwaS5nZXRGaWxlcyhpbnB1dCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0b0ZpbGVzID0gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9lYWNoKG9GaWxlcywgZnVuY3Rpb24gYWRkKGZpbGUsIG5hbWUpe1xuXHRcdFx0XHRcdGlmKCBfaXNBcnJheShmaWxlKSApe1xuXHRcdFx0XHRcdFx0X2VhY2goZmlsZSwgZnVuY3Rpb24gKGZpbGUpe1xuXHRcdFx0XHRcdFx0XHRhZGQoZmlsZSwgbmFtZSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiggZmlsZSAmJiAoZmlsZS5uYW1lIHx8IGZpbGUuaW1hZ2UpICl7XG5cdFx0XHRcdFx0XHRmaWxlcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0ICBuYW1lOiBuYW1lXG5cdFx0XHRcdFx0XHRcdCwgZmlsZTogZmlsZVxuXHRcdFx0XHRcdFx0XHQsIHNpemU6IGZpbGUuc2l6ZVxuXHRcdFx0XHRcdFx0XHQsIHRvdGFsOiBmaWxlLnNpemVcblx0XHRcdFx0XHRcdFx0LCBsb2FkZWQ6IDBcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYoICFmaWxlcy5sZW5ndGggKXtcblx0XHRcdFx0XHQvLyBDcmVhdGUgZmFrZSBgZmlsZWAgb2JqZWN0XG5cdFx0XHRcdFx0ZmlsZXMucHVzaCh7IGZpbGU6IHsgbmFtZTogYXBpLmV4cGFuZG8gfSB9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVyblx0ZmlsZXM7XG5cdFx0XHR9LFxuXG5cblx0XHRcdF9nZXRGb3JtRGF0YTogZnVuY3Rpb24gKG9wdGlvbnMsIGRhdGEsIGZuKXtcblx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0ICBmaWxlID0gZGF0YS5maWxlXG5cdFx0XHRcdFx0LCBuYW1lID0gZGF0YS5uYW1lXG5cdFx0XHRcdFx0LCBmaWxlbmFtZSA9IGZpbGUubmFtZVxuXHRcdFx0XHRcdCwgZmlsZXR5cGUgPSBmaWxlLnR5cGVcblx0XHRcdFx0XHQsIHRyYW5zID0gYXBpLnN1cHBvcnQudHJhbnNmb3JtICYmIG9wdGlvbnMuaW1hZ2VUcmFuc2Zvcm1cblx0XHRcdFx0XHQsIEZvcm0gPSBuZXcgYXBpLkZvcm1cblx0XHRcdFx0XHQsIHF1ZXVlID0gYXBpLnF1ZXVlKGZ1bmN0aW9uICgpeyBmbihGb3JtKTsgfSlcblx0XHRcdFx0XHQsIGlzT3JpZ25UcmFucyA9IHRyYW5zICYmIF9pc09yaWdpblRyYW5zZm9ybSh0cmFucylcblx0XHRcdFx0XHQsIHBvc3ROYW1lQ29uY2F0ID0gYXBpLnBvc3ROYW1lQ29uY2F0XG5cdFx0XHRcdDtcblxuXHRcdFx0XHQvLyBBcHBlbmQgZGF0YVxuXHRcdFx0XHRfZWFjaChvcHRpb25zLmRhdGEsIGZ1bmN0aW9uIGFkZCh2YWwsIG5hbWUpe1xuXHRcdFx0XHRcdGlmKCB0eXBlb2YgdmFsID09ICdvYmplY3QnICl7XG5cdFx0XHRcdFx0XHRfZWFjaCh2YWwsIGZ1bmN0aW9uICh2LCBpKXtcblx0XHRcdFx0XHRcdFx0YWRkKHYsIHBvc3ROYW1lQ29uY2F0KG5hbWUsIGkpKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdEZvcm0uYXBwZW5kKG5hbWUsIHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQoZnVuY3Rpb24gX2FkZEZpbGUoZmlsZS8qKk9iamVjdCovKXtcblx0XHRcdFx0XHRpZiggZmlsZS5pbWFnZSApeyAvLyBUaGlzIGlzIGEgRmlsZUFQSS5JbWFnZVxuXHRcdFx0XHRcdFx0cXVldWUuaW5jKCk7XG5cblx0XHRcdFx0XHRcdGZpbGUudG9EYXRhKGZ1bmN0aW9uIChlcnIsIGltYWdlKXtcblx0XHRcdFx0XHRcdFx0Ly8gQHRvZG86INGC0YDQtdCx0YPQtdGCINGA0LXRhNCw0LrRgtC+0YDQuNC90LPQsCDQuCDQvtCx0YDQsNCx0L7RgtC60Lgg0L7RiNC40LHQutC4XG5cdFx0XHRcdFx0XHRcdGlmIChmaWxlLmZpbGUpIHtcblx0XHRcdFx0XHRcdFx0XHRpbWFnZS50eXBlID0gZmlsZS5maWxlLnR5cGU7XG5cdFx0XHRcdFx0XHRcdFx0aW1hZ2UucXVhbGl0eSA9IGZpbGUubWF0cml4LnF1YWxpdHk7XG5cdFx0XHRcdFx0XHRcdFx0ZmlsZW5hbWUgPSBmaWxlLmZpbGUgJiYgZmlsZS5maWxlLm5hbWU7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRmaWxlbmFtZSA9IGZpbGVuYW1lIHx8IChuZXcgRGF0ZSkuZ2V0VGltZSgpKycucG5nJztcblxuXHRcdFx0XHRcdFx0XHRfYWRkRmlsZShpbWFnZSk7XG5cdFx0XHRcdFx0XHRcdHF1ZXVlLm5leHQoKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmKCBhcGkuSW1hZ2UgJiYgdHJhbnMgJiYgKC9eaW1hZ2UvLnRlc3QoZmlsZS50eXBlKSB8fCBfcmltZ2NhbnZhcy50ZXN0KGZpbGUubm9kZU5hbWUpKSApe1xuXHRcdFx0XHRcdFx0cXVldWUuaW5jKCk7XG5cblx0XHRcdFx0XHRcdGlmKCBpc09yaWduVHJhbnMgKXtcblx0XHRcdFx0XHRcdFx0Ly8gQ29udmVydCB0byBhcnJheSBmb3IgdHJhbnNmb3JtIGZ1bmN0aW9uXG5cdFx0XHRcdFx0XHRcdHRyYW5zID0gW3RyYW5zXTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YXBpLkltYWdlLnRyYW5zZm9ybShmaWxlLCB0cmFucywgb3B0aW9ucy5pbWFnZUF1dG9PcmllbnRhdGlvbiwgZnVuY3Rpb24gKGVyciwgaW1hZ2VzKXtcblx0XHRcdFx0XHRcdFx0aWYoIGlzT3JpZ25UcmFucyAmJiAhZXJyICl7XG5cdFx0XHRcdFx0XHRcdFx0aWYoICFkYXRhVVJMdG9CbG9iICYmICFhcGkuZmxhc2hFbmdpbmUgKXtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIENhbnZhcy50b0Jsb2Igb3IgRmxhc2ggbm90IHN1cHBvcnRlZCwgdXNlIG11bHRpcGFydFxuXHRcdFx0XHRcdFx0XHRcdFx0Rm9ybS5tdWx0aXBhcnQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdEZvcm0uYXBwZW5kKG5hbWUsIGltYWdlc1swXSwgZmlsZW5hbWUsICB0cmFuc1swXS50eXBlIHx8IGZpbGV0eXBlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgYWRkT3JpZ2luID0gMDtcblxuXHRcdFx0XHRcdFx0XHRcdGlmKCAhZXJyICl7XG5cdFx0XHRcdFx0XHRcdFx0XHRfZWFjaChpbWFnZXMsIGZ1bmN0aW9uIChpbWFnZSwgaWR4KXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoICFkYXRhVVJMdG9CbG9iICYmICFhcGkuZmxhc2hFbmdpbmUgKXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRGb3JtLm11bHRpcGFydCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiggIXRyYW5zW2lkeF0ucG9zdE5hbWUgKXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRPcmlnaW4gPSAxO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Rm9ybS5hcHBlbmQodHJhbnNbaWR4XS5wb3N0TmFtZSB8fCBwb3N0TmFtZUNvbmNhdChuYW1lLCBpZHgpLCBpbWFnZSwgZmlsZW5hbWUsIHRyYW5zW2lkeF0udHlwZSB8fCBmaWxldHlwZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRpZiggZXJyIHx8IG9wdGlvbnMuaW1hZ2VPcmlnaW5hbCApe1xuXHRcdFx0XHRcdFx0XHRcdFx0Rm9ybS5hcHBlbmQocG9zdE5hbWVDb25jYXQobmFtZSwgKGFkZE9yaWdpbiA/ICdvcmlnaW5hbCcgOiBudWxsKSksIGZpbGUsIGZpbGVuYW1lLCBmaWxldHlwZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0cXVldWUubmV4dCgpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYoIGZpbGVuYW1lICE9PSBhcGkuZXhwYW5kbyApe1xuXHRcdFx0XHRcdFx0Rm9ybS5hcHBlbmQobmFtZSwgZmlsZSwgZmlsZW5hbWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkoZmlsZSk7XG5cblx0XHRcdFx0cXVldWUuY2hlY2soKTtcblx0XHRcdH0sXG5cblxuXHRcdFx0cmVzZXQ6IGZ1bmN0aW9uIChpbnAsIG5vdFJlbW92ZSl7XG5cdFx0XHRcdHZhciBwYXJlbnQsIGNsb25lO1xuXG5cdFx0XHRcdGlmKCBqUXVlcnkgKXtcblx0XHRcdFx0XHRjbG9uZSA9IGpRdWVyeShpbnApLmNsb25lKHRydWUpLmluc2VydEJlZm9yZShpbnApLnZhbCgnJylbMF07XG5cdFx0XHRcdFx0aWYoICFub3RSZW1vdmUgKXtcblx0XHRcdFx0XHRcdGpRdWVyeShpbnApLnJlbW92ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXJlbnQgID0gaW5wLnBhcmVudE5vZGU7XG5cdFx0XHRcdFx0Y2xvbmUgICA9IHBhcmVudC5pbnNlcnRCZWZvcmUoaW5wLmNsb25lTm9kZSh0cnVlKSwgaW5wKTtcblx0XHRcdFx0XHRjbG9uZS52YWx1ZSA9ICcnO1xuXG5cdFx0XHRcdFx0aWYoICFub3RSZW1vdmUgKXtcblx0XHRcdFx0XHRcdHBhcmVudC5yZW1vdmVDaGlsZChpbnApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9lYWNoKF9lbEV2ZW50c1thcGkudWlkKGlucCldLCBmdW5jdGlvbiAoZm5zLCB0eXBlKXtcblx0XHRcdFx0XHRcdF9lYWNoKGZucywgZnVuY3Rpb24gKGZuKXtcblx0XHRcdFx0XHRcdFx0X29mZihpbnAsIHR5cGUsIGZuKTtcblx0XHRcdFx0XHRcdFx0X29uKGNsb25lLCB0eXBlLCBmbik7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAgY2xvbmU7XG5cdFx0XHR9LFxuXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogTG9hZCByZW1vdGUgZmlsZVxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgIHVybFxuXHRcdFx0ICogQHBhcmFtICAge0Z1bmN0aW9ufSAgZm5cblx0XHRcdCAqIEByZXR1cm4gIHtYTUxIdHRwUmVxdWVzdH1cblx0XHRcdCAqL1xuXHRcdFx0bG9hZDogZnVuY3Rpb24gKHVybCwgZm4pe1xuXHRcdFx0XHR2YXIgeGhyID0gYXBpLmdldFhIUigpO1xuXHRcdFx0XHRpZiggeGhyICl7XG5cdFx0XHRcdFx0eGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG5cblx0XHRcdFx0XHRpZiggeGhyLm92ZXJyaWRlTWltZVR5cGUgKXtcblx0XHRcdFx0ICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9vbih4aHIsICdwcm9ncmVzcycsIGZ1bmN0aW9uICgvKipFdmVudCovZXZ0KXtcblx0XHRcdFx0XHRcdC8qKiBAbmFtZXNwYWNlIGV2dC5sZW5ndGhDb21wdXRhYmxlICovXG5cdFx0XHRcdFx0XHRpZiggZXZ0Lmxlbmd0aENvbXB1dGFibGUgKXtcblx0XHRcdFx0XHRcdFx0Zm4oeyB0eXBlOiBldnQudHlwZSwgbG9hZGVkOiBldnQubG9hZGVkLCB0b3RhbDogZXZ0LnRvdGFsIH0sIHhocik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdGlmKCB4aHIucmVhZHlTdGF0ZSA9PSA0ICl7XG5cdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRpZiggeGhyLnN0YXR1cyA9PSAyMDAgKXtcblx0XHRcdFx0XHRcdFx0XHR1cmwgPSB1cmwuc3BsaXQoJy8nKTtcblx0XHRcdFx0XHRcdFx0XHQvKiogQG5hbWVzcGFjZSB4aHIucmVzcG9uc2VCb2R5ICovXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGZpbGUgPSB7XG5cdFx0XHRcdFx0XHRcdFx0ICAgICAgbmFtZTogdXJsW3VybC5sZW5ndGgtMV1cblx0XHRcdFx0XHRcdFx0XHRcdCwgc2l6ZTogeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LUxlbmd0aCcpXG5cdFx0XHRcdFx0XHRcdFx0XHQsIHR5cGU6IHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJylcblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRcdGZpbGUuZGF0YVVSTCA9ICdkYXRhOicrZmlsZS50eXBlKyc7YmFzZTY0LCcgKyBhcGkuZW5jb2RlNjQoeGhyLnJlc3BvbnNlQm9keSB8fCB4aHIucmVzcG9uc2VUZXh0KTtcblx0XHRcdFx0XHRcdFx0XHRmbih7IHR5cGU6ICdsb2FkJywgcmVzdWx0OiBmaWxlIH0sIHhocik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm4oeyB0eXBlOiAnZXJyb3InIH0sIHhocik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQgICAgfVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdCAgICB4aHIuc2VuZChudWxsKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmbih7IHR5cGU6ICdlcnJvcicgfSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gIHhocjtcblx0XHRcdH0sXG5cblx0XHRcdGVuY29kZTY0OiBmdW5jdGlvbiAoc3RyKXtcblx0XHRcdFx0dmFyIGI2NCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPScsIG91dFN0ciA9ICcnLCBpID0gMDtcblxuXHRcdFx0XHRpZiggdHlwZW9mIHN0ciAhPT0gJ3N0cmluZycgKXtcblx0XHRcdFx0XHRzdHJcdD0gU3RyaW5nKHN0cik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3aGlsZSggaSA8IHN0ci5sZW5ndGggKXtcblx0XHRcdFx0XHQvL2FsbCB0aHJlZSBcIiYgMHhmZlwiIGFkZGVkIGJlbG93IGFyZSB0aGVyZSB0byBmaXggYSBrbm93biBidWdcblx0XHRcdFx0XHQvL3dpdGggYnl0ZXMgcmV0dXJuZWQgYnkgeGhyLnJlc3BvbnNlVGV4dFxuXHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdFx0ICBieXRlMSA9IHN0ci5jaGFyQ29kZUF0KGkrKykgJiAweGZmXG5cdFx0XHRcdFx0XHQsIGJ5dGUyID0gc3RyLmNoYXJDb2RlQXQoaSsrKSAmIDB4ZmZcblx0XHRcdFx0XHRcdCwgYnl0ZTMgPSBzdHIuY2hhckNvZGVBdChpKyspICYgMHhmZlxuXHRcdFx0XHRcdFx0LCBlbmMxID0gYnl0ZTEgPj4gMlxuXHRcdFx0XHRcdFx0LCBlbmMyID0gKChieXRlMSAmIDMpIDw8IDQpIHwgKGJ5dGUyID4+IDQpXG5cdFx0XHRcdFx0XHQsIGVuYzMsIGVuYzRcblx0XHRcdFx0XHQ7XG5cblx0XHRcdFx0XHRpZiggaXNOYU4oYnl0ZTIpICl7XG5cdFx0XHRcdFx0XHRlbmMzID0gZW5jNCA9IDY0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRlbmMzID0gKChieXRlMiAmIDE1KSA8PCAyKSB8IChieXRlMyA+PiA2KTtcblx0XHRcdFx0XHRcdGVuYzQgPSBpc05hTihieXRlMykgPyA2NCA6IGJ5dGUzICYgNjM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0U3RyICs9IGI2NC5jaGFyQXQoZW5jMSkgKyBiNjQuY2hhckF0KGVuYzIpICsgYjY0LmNoYXJBdChlbmMzKSArIGI2NC5jaGFyQXQoZW5jNCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gIG91dFN0cjtcblx0XHRcdH1cblxuXHRcdH0gLy8gYXBpXG5cdDtcblxuXG5cdGZ1bmN0aW9uIF9lbWl0KHRhcmdldCwgZm4sIG5hbWUsIHJlcywgZXh0KXtcblx0XHR2YXIgZXZ0ID0ge1xuXHRcdFx0ICB0eXBlOlx0XHRuYW1lLnR5cGUgfHwgbmFtZVxuXHRcdFx0LCB0YXJnZXQ6XHR0YXJnZXRcblx0XHRcdCwgcmVzdWx0Olx0cmVzXG5cdFx0fTtcblx0XHRfZXh0ZW5kKGV2dCwgZXh0KTtcblx0XHRmbihldnQpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBfaGFzU3VwcG9ydFJlYWRBcyhtZXRob2Qpe1xuXHRcdHJldHVyblx0RmlsZVJlYWRlciAmJiAhIUZpbGVSZWFkZXIucHJvdG90eXBlWydyZWFkQXMnICsgbWV0aG9kXTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gX3JlYWRBcyhmaWxlLCBmbiwgbWV0aG9kLCBlbmNvZGluZyl7XG5cdFx0aWYoIGFwaS5pc0Jsb2IoZmlsZSkgJiYgX2hhc1N1cHBvcnRSZWFkQXMobWV0aG9kKSApe1xuXHRcdFx0dmFyIFJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xuXG5cdFx0XHQvLyBBZGQgZXZlbnQgbGlzdGVuZXJcblx0XHRcdF9vbihSZWFkZXIsIF9yZWFkZXJFdmVudHMsIGZ1bmN0aW9uIF9mbihldnQpe1xuXHRcdFx0XHR2YXIgdHlwZSA9IGV2dC50eXBlO1xuXHRcdFx0XHRpZiggdHlwZSA9PSAncHJvZ3Jlc3MnICl7XG5cdFx0XHRcdFx0X2VtaXQoZmlsZSwgZm4sIGV2dCwgZXZ0LnRhcmdldC5yZXN1bHQsIHsgbG9hZGVkOiBldnQubG9hZGVkLCB0b3RhbDogZXZ0LnRvdGFsIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYoIHR5cGUgPT0gJ2xvYWRlbmQnICl7XG5cdFx0XHRcdFx0X29mZihSZWFkZXIsIF9yZWFkZXJFdmVudHMsIF9mbik7XG5cdFx0XHRcdFx0UmVhZGVyID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRfZW1pdChmaWxlLCBmbiwgZXZ0LCBldnQudGFyZ2V0LnJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIFJlYWRBcyAuLi5cblx0XHRcdFx0aWYoIGVuY29kaW5nICl7XG5cdFx0XHRcdFx0UmVhZGVyWydyZWFkQXMnICsgbWV0aG9kXShmaWxlLCBlbmNvZGluZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0UmVhZGVyWydyZWFkQXMnICsgbWV0aG9kXShmaWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGVycil7XG5cdFx0XHRcdF9lbWl0KGZpbGUsIGZuLCAnZXJyb3InLCB1bmRlZiwgeyBlcnJvcjogZXJyLnRvU3RyaW5nKCkgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0X2VtaXQoZmlsZSwgZm4sICdlcnJvcicsIHVuZGVmLCB7IGVycm9yOiAnZmlscmVhZGVyX25vdF9zdXBwb3J0XycgKyBtZXRob2QgfSk7XG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiBfaXNSZWd1bGFyRmlsZShmaWxlLCBjYWxsYmFjayl7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84ODU2NjI4L2RldGVjdGluZy1mb2xkZXJzLWRpcmVjdG9yaWVzLWluLWphdmFzY3JpcHQtZmlsZWxpc3Qtb2JqZWN0c1xuXHRcdGlmKCAhZmlsZS50eXBlICYmIChzYWZhcmkgfHwgKChmaWxlLnNpemUgJSA0MDk2KSA9PT0gMCAmJiAoZmlsZS5zaXplIDw9IDEwMjQwMCkpKSApe1xuXHRcdFx0aWYoIEZpbGVSZWFkZXIgKXtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuXHRcdFx0XHRcdF9vbmUocmVhZGVyLCBfcmVhZGVyRXZlbnRzLCBmdW5jdGlvbiAoZXZ0KXtcblx0XHRcdFx0XHRcdHZhciBpc0ZpbGUgPSBldnQudHlwZSAhPSAnZXJyb3InO1xuXHRcdFx0XHRcdFx0aWYoIGlzRmlsZSApe1xuXHRcdFx0XHRcdFx0XHRpZiAoIHJlYWRlci5yZWFkeVN0YXRlID09IG51bGwgfHwgcmVhZGVyLnJlYWR5U3RhdGUgPT09IHJlYWRlci5MT0FESU5HICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlYWRlci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKGlzRmlsZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soZmFsc2UsIHJlYWRlci5lcnJvcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRyZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcblx0XHRcdFx0fSBjYXRjaCggZXJyICl7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZmFsc2UsIGVycik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRjYWxsYmFjayhudWxsLCBuZXcgRXJyb3IoJ0ZpbGVSZWFkZXIgaXMgbm90IHN1cHBvcnRlZCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRjYWxsYmFjayh0cnVlKTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIF9pc0VudHJ5KGl0ZW0pe1xuXHRcdHJldHVybiBpdGVtICYmIChpdGVtLmlzRmlsZSB8fCBpdGVtLmlzRGlyZWN0b3J5KTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gX2dldEFzRW50cnkoaXRlbSl7XG5cdFx0dmFyIGVudHJ5O1xuXHRcdGlmKCBpdGVtLmdldEFzRW50cnkgKXsgZW50cnkgPSBpdGVtLmdldEFzRW50cnkoKTsgfVxuXHRcdGVsc2UgaWYoIGl0ZW0ud2Via2l0R2V0QXNFbnRyeSApeyBlbnRyeSA9IGl0ZW0ud2Via2l0R2V0QXNFbnRyeSgpOyB9XG5cdFx0cmV0dXJuXHRlbnRyeTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gX3JlYWRFbnRyeUFzRmlsZXMoZW50cnksIGNhbGxiYWNrKXtcblx0XHRpZiggIWVudHJ5ICl7XG5cdFx0XHQvLyBlcnJvclxuXHRcdFx0dmFyIGVyciA9IG5ldyBFcnJvcignaW52YWxpZCBlbnRyeScpO1xuXHRcdFx0ZW50cnkgPSBuZXcgT2JqZWN0KGVudHJ5KTtcblx0XHRcdGVudHJ5LmVycm9yID0gZXJyO1xuXHRcdFx0Y2FsbGJhY2soZXJyLm1lc3NhZ2UsIFtdLCBbZW50cnldKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiggZW50cnkuaXNGaWxlICl7XG5cdFx0XHQvLyBSZWFkIGFzIGZpbGVcblx0XHRcdGVudHJ5LmZpbGUoZnVuY3Rpb24gKGZpbGUpe1xuXHRcdFx0XHQvLyBzdWNjZXNzXG5cdFx0XHRcdGZpbGUuZnVsbFBhdGggPSBlbnRyeS5mdWxsUGF0aDtcblx0XHRcdFx0Y2FsbGJhY2soZmFsc2UsIFtmaWxlXSwgW2ZpbGVdKTtcblx0XHRcdH0sIGZ1bmN0aW9uIChlcnIpe1xuXHRcdFx0XHQvLyBlcnJvclxuXHRcdFx0XHRlbnRyeS5lcnJvciA9IGVycjtcblx0XHRcdFx0Y2FsbGJhY2soJ0ZpbGVFcnJvci5jb2RlOiAnICsgZXJyLmNvZGUsIFtdLCBbZW50cnldKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRlbHNlIGlmKCBlbnRyeS5pc0RpcmVjdG9yeSApe1xuXHRcdFx0dmFyXG5cdFx0XHRcdHJlYWRlciA9IGVudHJ5LmNyZWF0ZVJlYWRlcigpXG5cdFx0XHRcdCwgZmlyc3RBdHRlbXB0ID0gdHJ1ZVxuXHRcdFx0XHQsIGZpbGVzID0gW11cblx0XHRcdFx0LCBhbGwgPSBbZW50cnldXG5cdFx0XHQ7XG5cblx0XHRcdHZhciBvbmVycm9yID0gZnVuY3Rpb24gKGVycil7XG5cdFx0XHRcdC8vIGVycm9yXG5cdFx0XHRcdGVudHJ5LmVycm9yID0gZXJyO1xuXHRcdFx0XHRjYWxsYmFjaygnRGlyZWN0b3J5RXJyb3IuY29kZTogJyArIGVyci5jb2RlLCBmaWxlcywgYWxsKTtcblx0XHRcdH07XG5cdFx0XHR2YXIgb25kb25lID0gZnVuY3Rpb24gb25kb25lKGVudHJpZXMpe1xuXHRcdFx0XHRpZiggZmlyc3RBdHRlbXB0ICl7XG5cdFx0XHRcdFx0Zmlyc3RBdHRlbXB0ID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYoICFlbnRyaWVzLmxlbmd0aCApe1xuXHRcdFx0XHRcdFx0ZW50cnkuZXJyb3IgPSBuZXcgRXJyb3IoJ2RpcmVjdG9yeSBpcyBlbXB0eScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHN1Y2Nlc3Ncblx0XHRcdFx0aWYoIGVudHJpZXMubGVuZ3RoICl7XG5cdFx0XHRcdFx0YXBpLmFmb3IoZW50cmllcywgZnVuY3Rpb24gKG5leHQsIGVudHJ5KXtcblx0XHRcdFx0XHRcdF9yZWFkRW50cnlBc0ZpbGVzKGVudHJ5LCBmdW5jdGlvbiAoZXJyLCBlbnRyeUZpbGVzLCBhbGxFbnRyaWVzKXtcblx0XHRcdFx0XHRcdFx0aWYoICFlcnIgKXtcblx0XHRcdFx0XHRcdFx0XHRmaWxlcyA9IGZpbGVzLmNvbmNhdChlbnRyeUZpbGVzKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRhbGwgPSBhbGwuY29uY2F0KGFsbEVudHJpZXMpO1xuXG5cdFx0XHRcdFx0XHRcdGlmKCBuZXh0ICl7XG5cdFx0XHRcdFx0XHRcdFx0bmV4dCgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHJlYWRlci5yZWFkRW50cmllcyhvbmRvbmUsIG9uZXJyb3IpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsYmFjayhmYWxzZSwgZmlsZXMsIGFsbCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdHJlYWRlci5yZWFkRW50cmllcyhvbmRvbmUsIG9uZXJyb3IpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdF9yZWFkRW50cnlBc0ZpbGVzKF9nZXRBc0VudHJ5KGVudHJ5KSwgY2FsbGJhY2spO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gX3NpbXBsZUNsb25lKG9iail7XG5cdFx0dmFyIGNvcHkgPSB7fTtcblx0XHRfZWFjaChvYmosIGZ1bmN0aW9uICh2YWwsIGtleSl7XG5cdFx0XHRpZiggdmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JykgJiYgKHZhbC5ub2RlVHlwZSA9PT0gdm9pZCAwKSApe1xuXHRcdFx0XHR2YWwgPSBfZXh0ZW5kKHt9LCB2YWwpO1xuXHRcdFx0fVxuXHRcdFx0Y29weVtrZXldID0gdmFsO1xuXHRcdH0pO1xuXHRcdHJldHVyblx0Y29weTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gaXNJbnB1dEZpbGUoZWwpe1xuXHRcdHJldHVyblx0X3JpbnB1dC50ZXN0KGVsICYmIGVsLnRhZ05hbWUpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBfZ2V0RGF0YVRyYW5zZmVyKGV2dCl7XG5cdFx0cmV0dXJuXHQoZXZ0Lm9yaWdpbmFsRXZlbnQgfHwgZXZ0IHx8ICcnKS5kYXRhVHJhbnNmZXIgfHwge307XG5cdH1cblxuXG5cdGZ1bmN0aW9uIF9pc09yaWdpblRyYW5zZm9ybSh0cmFucyl7XG5cdFx0dmFyIGtleTtcblx0XHRmb3IoIGtleSBpbiB0cmFucyApe1xuXHRcdFx0aWYoIHRyYW5zLmhhc093blByb3BlcnR5KGtleSkgKXtcblx0XHRcdFx0aWYoICEodHJhbnNba2V5XSBpbnN0YW5jZW9mIE9iamVjdCB8fCBrZXkgPT09ICdvdmVybGF5JyB8fCBrZXkgPT09ICdmaWx0ZXInKSApe1xuXHRcdFx0XHRcdHJldHVyblx0dHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm5cdGZhbHNlO1xuXHR9XG5cblxuXHQvLyBBZGQgZGVmYXVsdCBpbWFnZSBpbmZvIHJlYWRlclxuXHRhcGkuYWRkSW5mb1JlYWRlcigvXmltYWdlLywgZnVuY3Rpb24gKGZpbGUvKipGaWxlKi8sIGNhbGxiYWNrLyoqRnVuY3Rpb24qLyl7XG5cdFx0aWYoICFmaWxlLl9fZGltZW5zaW9ucyApe1xuXHRcdFx0dmFyIGRlZmVyID0gZmlsZS5fX2RpbWVuc2lvbnMgPSBhcGkuZGVmZXIoKTtcblxuXHRcdFx0YXBpLnJlYWRBc0ltYWdlKGZpbGUsIGZ1bmN0aW9uIChldnQpe1xuXHRcdFx0XHR2YXIgaW1nID0gZXZ0LnRhcmdldDtcblx0XHRcdFx0ZGVmZXIucmVzb2x2ZShldnQudHlwZSA9PSAnbG9hZCcgPyBmYWxzZSA6ICdlcnJvcicsIHtcblx0XHRcdFx0XHQgIHdpZHRoOiAgaW1nLndpZHRoXG5cdFx0XHRcdFx0LCBoZWlnaHQ6IGltZy5oZWlnaHRcblx0XHRcdFx0fSk7XG4gICAgICAgICAgICAgICAgaW1nLnNyYyA9IGFwaS5FTVBUWV9QTkc7XG5cdFx0XHRcdGltZyA9IG51bGw7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmaWxlLl9fZGltZW5zaW9ucy50aGVuKGNhbGxiYWNrKTtcblx0fSk7XG5cblxuXHQvKipcblx0ICogRHJhZyduJ0Ryb3Agc3BlY2lhbCBldmVudFxuXHQgKlxuXHQgKiBAcGFyYW1cdHtIVE1MRWxlbWVudH1cdGVsXG5cdCAqIEBwYXJhbVx0e0Z1bmN0aW9ufVx0XHRvbkhvdmVyXG5cdCAqIEBwYXJhbVx0e0Z1bmN0aW9ufVx0XHRvbkRyb3Bcblx0ICovXG5cdGFwaS5ldmVudC5kbmQgPSBmdW5jdGlvbiAoZWwsIG9uSG92ZXIsIG9uRHJvcCl7XG5cdFx0dmFyIF9pZCwgX3R5cGU7XG5cblx0XHRpZiggIW9uRHJvcCApe1xuXHRcdFx0b25Ecm9wID0gb25Ib3Zlcjtcblx0XHRcdG9uSG92ZXIgPSBhcGkuRjtcblx0XHR9XG5cblx0XHRpZiggRmlsZVJlYWRlciApe1xuXHRcdFx0Ly8gSG92ZXJcblx0XHRcdF9vbihlbCwgJ2RyYWdlbnRlciBkcmFnbGVhdmUgZHJhZ292ZXInLCBvbkhvdmVyLmZmID0gb25Ib3Zlci5mZiB8fCBmdW5jdGlvbiAoZXZ0KXtcblx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0ICB0eXBlcyA9IF9nZXREYXRhVHJhbnNmZXIoZXZ0KS50eXBlc1xuXHRcdFx0XHRcdCwgaSA9IHR5cGVzICYmIHR5cGVzLmxlbmd0aFxuXHRcdFx0XHRcdCwgZGVib3VuY2VUcmlnZ2VyID0gZmFsc2Vcblx0XHRcdFx0O1xuXG5cdFx0XHRcdHdoaWxlKCBpLS0gKXtcblx0XHRcdFx0XHRpZiggfnR5cGVzW2ldLmluZGV4T2YoJ0ZpbGUnKSApe1xuXHRcdFx0XHRcdFx0ZXZ0W3ByZXZlbnREZWZhdWx0XSgpO1xuXG5cdFx0XHRcdFx0XHRpZiggX3R5cGUgIT09IGV2dC50eXBlICl7XG5cdFx0XHRcdFx0XHRcdF90eXBlID0gZXZ0LnR5cGU7IC8vIFN0b3JlIGN1cnJlbnQgdHlwZSBvZiBldmVudFxuXG5cdFx0XHRcdFx0XHRcdGlmKCBfdHlwZSAhPSAnZHJhZ2xlYXZlJyApe1xuXHRcdFx0XHRcdFx0XHRcdG9uSG92ZXIuY2FsbChldnRbY3VycmVudFRhcmdldF0sIHRydWUsIGV2dCk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRkZWJvdW5jZVRyaWdnZXIgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhazsgLy8gZXhpdCBmcm9tIFwid2hpbGVcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKCBkZWJvdW5jZVRyaWdnZXIgKXtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoX2lkKTtcblx0XHRcdFx0XHRfaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRcdFx0b25Ib3Zlci5jYWxsKGV2dFtjdXJyZW50VGFyZ2V0XSwgX3R5cGUgIT0gJ2RyYWdsZWF2ZScsIGV2dCk7XG5cdFx0XHRcdFx0fSwgNTApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXG5cdFx0XHQvLyBEcm9wXG5cdFx0XHRfb24oZWwsICdkcm9wJywgb25Ecm9wLmZmID0gb25Ecm9wLmZmIHx8IGZ1bmN0aW9uIChldnQpe1xuXHRcdFx0XHRldnRbcHJldmVudERlZmF1bHRdKCk7XG5cblx0XHRcdFx0X3R5cGUgPSAwO1xuXG5cdFx0XHRcdGFwaS5nZXREcm9wRmlsZXMoZXZ0LCBmdW5jdGlvbiAoZmlsZXMsIGFsbCl7XG5cdFx0XHRcdFx0b25Ecm9wLmNhbGwoZXZ0W2N1cnJlbnRUYXJnZXRdLCBmaWxlcywgYWxsLCBldnQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdG9uSG92ZXIuY2FsbChldnRbY3VycmVudFRhcmdldF0sIGZhbHNlLCBldnQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0YXBpLmxvZyhcIkRyYWcnbidEcm9wIC0tIG5vdCBzdXBwb3J0ZWRcIik7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBkcmFnJ24nZHJvcFxuXHQgKiBAcGFyYW1cdHtIVE1MRWxlbWVudH1cdGVsXG5cdCAqIEBwYXJhbVx0e0Z1bmN0aW9ufVx0XHRvbkhvdmVyXG5cdCAqIEBwYXJhbVx0e0Z1bmN0aW9ufVx0XHRvbkRyb3Bcblx0ICovXG5cdGFwaS5ldmVudC5kbmQub2ZmID0gZnVuY3Rpb24gKGVsLCBvbkhvdmVyLCBvbkRyb3Ape1xuXHRcdF9vZmYoZWwsICdkcmFnZW50ZXIgZHJhZ2xlYXZlIGRyYWdvdmVyJywgb25Ib3Zlci5mZik7XG5cdFx0X29mZihlbCwgJ2Ryb3AnLCBvbkRyb3AuZmYpO1xuXHR9O1xuXG5cblx0Ly8gU3VwcG9ydCBqUXVlcnlcblx0aWYoIGpRdWVyeSAmJiAhalF1ZXJ5LmZuLmRuZCApe1xuXHRcdGpRdWVyeS5mbi5kbmQgPSBmdW5jdGlvbiAob25Ib3Zlciwgb25Ecm9wKXtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCl7XG5cdFx0XHRcdGFwaS5ldmVudC5kbmQodGhpcywgb25Ib3Zlciwgb25Ecm9wKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZm4ub2ZmZG5kID0gZnVuY3Rpb24gKG9uSG92ZXIsIG9uRHJvcCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRhcGkuZXZlbnQuZG5kLm9mZih0aGlzLCBvbkhvdmVyLCBvbkRyb3ApO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0fVxuXG5cdC8vIEBleHBvcnRcblx0d2luZG93LkZpbGVBUEkgID0gX2V4dGVuZChhcGksIHdpbmRvdy5GaWxlQVBJKTtcblxuXG5cdC8vIERlYnVnIGluZm9cblx0YXBpLmxvZygnRmlsZUFQSTogJyArIGFwaS52ZXJzaW9uKTtcblx0YXBpLmxvZygncHJvdG9jb2w6ICcgKyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wpO1xuXHRhcGkubG9nKCdkb2N0eXBlOiBbJyArIGRvY3R5cGUubmFtZSArICddICcgKyBkb2N0eXBlLnB1YmxpY0lkICsgJyAnICsgZG9jdHlwZS5zeXN0ZW1JZCk7XG5cblxuXHQvLyBAZGV0ZWN0ICd4LXVhLWNvbXBhdGlibGUnXG5cdF9lYWNoKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdtZXRhJyksIGZ1bmN0aW9uIChtZXRhKXtcblx0XHRpZiggL3gtdWEtY29tcGF0aWJsZS9pLnRlc3QobWV0YS5nZXRBdHRyaWJ1dGUoJ2h0dHAtZXF1aXYnKSkgKXtcblx0XHRcdGFwaS5sb2coJ21ldGEuaHR0cC1lcXVpdjogJyArIG1ldGEuZ2V0QXR0cmlidXRlKCdjb250ZW50JykpO1xuXHRcdH1cblx0fSk7XG5cblxuXHQvLyBDb25maWd1cmF0aW9uXG5cdHRyeSB7XG5cdFx0X3N1cHBvcnRDb25zb2xlTG9nID0gISFjb25zb2xlLmxvZztcblx0XHRfc3VwcG9ydENvbnNvbGVMb2dBcHBseSA9ICEhY29uc29sZS5sb2cuYXBwbHk7XG5cdH1cblx0Y2F0Y2ggKGVycikge31cblxuXHRpZiggIWFwaS5mbGFzaFVybCApeyBhcGkuZmxhc2hVcmwgPSBhcGkuc3RhdGljUGF0aCArICdGaWxlQVBJLmZsYXNoLnN3Zic7IH1cblx0aWYoICFhcGkuZmxhc2hJbWFnZVVybCApeyBhcGkuZmxhc2hJbWFnZVVybCA9IGFwaS5zdGF0aWNQYXRoICsgJ0ZpbGVBUEkuZmxhc2guaW1hZ2Uuc3dmJzsgfVxuXHRpZiggIWFwaS5mbGFzaFdlYmNhbVVybCApeyBhcGkuZmxhc2hXZWJjYW1VcmwgPSBhcGkuc3RhdGljUGF0aCArICdGaWxlQVBJLmZsYXNoLmNhbWVyYS5zd2YnOyB9XG59KSh3aW5kb3csIHZvaWQgMCk7XG5cbi8qZ2xvYmFsIHdpbmRvdywgRmlsZUFQSSwgZG9jdW1lbnQgKi9cblxuKGZ1bmN0aW9uIChhcGksIGRvY3VtZW50LCB1bmRlZikge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyXG5cdFx0bWluID0gTWF0aC5taW4sXG5cdFx0cm91bmQgPSBNYXRoLnJvdW5kLFxuXHRcdGdldENhbnZhcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyB9LFxuXHRcdHN1cHBvcnQgPSBmYWxzZSxcblx0XHRleGlmT3JpZW50YXRpb24gPSB7XG5cdFx0XHQgIDg6XHQyNzBcblx0XHRcdCwgMzpcdDE4MFxuXHRcdFx0LCA2Olx0OTBcblx0XHRcdCwgNzpcdDI3MFxuXHRcdFx0LCA0Olx0MTgwXG5cdFx0XHQsIDU6XHQ5MFxuXHRcdH1cblx0O1xuXG5cdHRyeSB7XG5cdFx0c3VwcG9ydCA9IGdldENhbnZhcygpLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJykuaW5kZXhPZignZGF0YTppbWFnZS9wbmcnKSA+IC0xO1xuXHR9XG5cdGNhdGNoIChlKXt9XG5cblxuXHRmdW5jdGlvbiBJbWFnZShmaWxlKXtcblx0XHRpZiggZmlsZSBpbnN0YW5jZW9mIEltYWdlICl7XG5cdFx0XHR2YXIgaW1nID0gbmV3IEltYWdlKGZpbGUuZmlsZSk7XG5cdFx0XHRhcGkuZXh0ZW5kKGltZy5tYXRyaXgsIGZpbGUubWF0cml4KTtcblx0XHRcdHJldHVyblx0aW1nO1xuXHRcdH1cblx0XHRlbHNlIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBJbWFnZSkgKXtcblx0XHRcdHJldHVyblx0bmV3IEltYWdlKGZpbGUpO1xuXHRcdH1cblxuXHRcdHRoaXMuZmlsZSAgID0gZmlsZTtcblx0XHR0aGlzLnNpemUgICA9IGZpbGUuc2l6ZSB8fCAxMDA7XG5cblx0XHR0aGlzLm1hdHJpeFx0PSB7XG5cdFx0XHRzeDogMCxcblx0XHRcdHN5OiAwLFxuXHRcdFx0c3c6IDAsXG5cdFx0XHRzaDogMCxcblx0XHRcdGR4OiAwLFxuXHRcdFx0ZHk6IDAsXG5cdFx0XHRkdzogMCxcblx0XHRcdGRoOiAwLFxuXHRcdFx0cmVzaXplOiAwLCAvLyBtaW4sIG1heCBPUiBwcmV2aWV3XG5cdFx0XHRkZWc6IDAsXG5cdFx0XHRxdWFsaXR5OiAxLCAvLyBqcGVnIHF1YWxpdHlcblx0XHRcdGZpbHRlcjogMFxuXHRcdH07XG5cdH1cblxuXG5cdEltYWdlLnByb3RvdHlwZSA9IHtcblx0XHRpbWFnZTogdHJ1ZSxcblx0XHRjb25zdHJ1Y3RvcjogSW1hZ2UsXG5cblx0XHRzZXQ6IGZ1bmN0aW9uIChhdHRycyl7XG5cdFx0XHRhcGkuZXh0ZW5kKHRoaXMubWF0cml4LCBhdHRycyk7XG5cdFx0XHRyZXR1cm5cdHRoaXM7XG5cdFx0fSxcblxuXHRcdGNyb3A6IGZ1bmN0aW9uICh4LCB5LCB3LCBoKXtcblx0XHRcdGlmKCB3ID09PSB1bmRlZiApe1xuXHRcdFx0XHR3XHQ9IHg7XG5cdFx0XHRcdGhcdD0geTtcblx0XHRcdFx0eCA9IHkgPSAwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuXHR0aGlzLnNldCh7IHN4OiB4LCBzeTogeSwgc3c6IHcsIHNoOiBoIHx8IHcgfSk7XG5cdFx0fSxcblxuXHRcdHJlc2l6ZTogZnVuY3Rpb24gKHcsIGgsIHN0cmF0ZWd5KXtcblx0XHRcdGlmKCAvbWlufG1heHxoZWlnaHR8d2lkdGgvLnRlc3QoaCkgKXtcblx0XHRcdFx0c3RyYXRlZ3kgPSBoO1xuXHRcdFx0XHRoID0gdztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuXHR0aGlzLnNldCh7IGR3OiB3LCBkaDogaCB8fCB3LCByZXNpemU6IHN0cmF0ZWd5IH0pO1xuXHRcdH0sXG5cblx0XHRwcmV2aWV3OiBmdW5jdGlvbiAodywgaCl7XG5cdFx0XHRyZXR1cm5cdHRoaXMucmVzaXplKHcsIGggfHwgdywgJ3ByZXZpZXcnKTtcblx0XHR9LFxuXG5cdFx0cm90YXRlOiBmdW5jdGlvbiAoZGVnKXtcblx0XHRcdHJldHVyblx0dGhpcy5zZXQoeyBkZWc6IGRlZyB9KTtcblx0XHR9LFxuXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiAoZmlsdGVyKXtcblx0XHRcdHJldHVyblx0dGhpcy5zZXQoeyBmaWx0ZXI6IGZpbHRlciB9KTtcblx0XHR9LFxuXG5cdFx0b3ZlcmxheTogZnVuY3Rpb24gKGltYWdlcyl7XG5cdFx0XHRyZXR1cm5cdHRoaXMuc2V0KHsgb3ZlcmxheTogaW1hZ2VzIH0pO1xuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCl7XG5cdFx0XHRyZXR1cm5cdG5ldyBJbWFnZSh0aGlzKTtcblx0XHR9LFxuXG5cdFx0X2xvYWQ6IGZ1bmN0aW9uIChpbWFnZSwgZm4pe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0XHRpZiggL2ltZ3x2aWRlby9pLnRlc3QoaW1hZ2Uubm9kZU5hbWUpICl7XG5cdFx0XHRcdGZuLmNhbGwoc2VsZiwgbnVsbCwgaW1hZ2UpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGFwaS5yZWFkQXNJbWFnZShpbWFnZSwgZnVuY3Rpb24gKGV2dCl7XG5cdFx0XHRcdFx0Zm4uY2FsbChzZWxmLCBldnQudHlwZSAhPSAnbG9hZCcsIGV2dC5yZXN1bHQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2FwcGx5OiBmdW5jdGlvbiAoaW1hZ2UsIGZuKXtcblx0XHRcdHZhclxuXHRcdFx0XHQgIGNhbnZhcyA9IGdldENhbnZhcygpXG5cdFx0XHRcdCwgbSA9IHRoaXMuZ2V0TWF0cml4KGltYWdlKVxuXHRcdFx0XHQsIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG5cdFx0XHRcdCwgd2lkdGggPSBpbWFnZS52aWRlb1dpZHRoIHx8IGltYWdlLndpZHRoXG5cdFx0XHRcdCwgaGVpZ2h0ID0gaW1hZ2UudmlkZW9IZWlnaHQgfHwgaW1hZ2UuaGVpZ2h0XG5cdFx0XHRcdCwgZGVnID0gbS5kZWdcblx0XHRcdFx0LCBkdyA9IG0uZHdcblx0XHRcdFx0LCBkaCA9IG0uZGhcblx0XHRcdFx0LCB3ID0gd2lkdGhcblx0XHRcdFx0LCBoID0gaGVpZ2h0XG5cdFx0XHRcdCwgZmlsdGVyID0gbS5maWx0ZXJcblx0XHRcdFx0LCBjb3B5IC8vIGNhbnZhcyBjb3B5XG5cdFx0XHRcdCwgYnVmZmVyID0gaW1hZ2Vcblx0XHRcdFx0LCBvdmVybGF5ID0gbS5vdmVybGF5XG5cdFx0XHRcdCwgcXVldWUgPSBhcGkucXVldWUoZnVuY3Rpb24gKCl7IGltYWdlLnNyYyA9IGFwaS5FTVBUWV9QTkc7IGZuKGZhbHNlLCBjYW52YXMpOyB9KVxuXHRcdFx0XHQsIHJlbmRlckltYWdlVG9DYW52YXMgPSBhcGkucmVuZGVySW1hZ2VUb0NhbnZhc1xuXHRcdFx0O1xuXG5cdFx0XHQvLyBOb3JtYWxpemUgYW5nbGVcblx0XHRcdGRlZyA9IGRlZyAtIE1hdGguZmxvb3IoZGVnLzM2MCkqMzYwO1xuXG5cdFx0XHQvLyBGb3IgYHJlbmRlckltYWdlVG9DYW52YXNgXG5cdFx0XHRpbWFnZS5fdHlwZSA9IHRoaXMuZmlsZS50eXBlO1xuXG5cdFx0XHR3aGlsZShtLm11bHRpcGFzcyAmJiBtaW4ody9kdywgaC9kaCkgPiAyICl7XG5cdFx0XHRcdHcgPSAody8yICsgMC41KXwwO1xuXHRcdFx0XHRoID0gKGgvMiArIDAuNSl8MDtcblxuXHRcdFx0XHRjb3B5ID0gZ2V0Q2FudmFzKCk7XG5cdFx0XHRcdGNvcHkud2lkdGggID0gdztcblx0XHRcdFx0Y29weS5oZWlnaHQgPSBoO1xuXG5cdFx0XHRcdGlmKCBidWZmZXIgIT09IGltYWdlICl7XG5cdFx0XHRcdFx0cmVuZGVySW1hZ2VUb0NhbnZhcyhjb3B5LCBidWZmZXIsIDAsIDAsIGJ1ZmZlci53aWR0aCwgYnVmZmVyLmhlaWdodCwgMCwgMCwgdywgaCk7XG5cdFx0XHRcdFx0YnVmZmVyID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRidWZmZXIgPSBjb3B5O1xuXHRcdFx0XHRcdHJlbmRlckltYWdlVG9DYW52YXMoYnVmZmVyLCBpbWFnZSwgbS5zeCwgbS5zeSwgbS5zdywgbS5zaCwgMCwgMCwgdywgaCk7XG5cdFx0XHRcdFx0bS5zeCA9IG0uc3kgPSBtLnN3ID0gbS5zaCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXG5cdFx0XHRjYW52YXMud2lkdGggID0gKGRlZyAlIDE4MCkgPyBkaCA6IGR3O1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IChkZWcgJSAxODApID8gZHcgOiBkaDtcblxuXHRcdFx0Y2FudmFzLnR5cGUgPSBtLnR5cGU7XG5cdFx0XHRjYW52YXMucXVhbGl0eSA9IG0ucXVhbGl0eTtcblxuXHRcdFx0Y3R4LnJvdGF0ZShkZWcgKiBNYXRoLlBJIC8gMTgwKTtcblx0XHRcdHJlbmRlckltYWdlVG9DYW52YXMoY3R4LmNhbnZhcywgYnVmZmVyXG5cdFx0XHRcdCwgbS5zeCwgbS5zeVxuXHRcdFx0XHQsIG0uc3cgfHwgYnVmZmVyLndpZHRoXG5cdFx0XHRcdCwgbS5zaCB8fCBidWZmZXIuaGVpZ2h0XG5cdFx0XHRcdCwgKGRlZyA9PSAxODAgfHwgZGVnID09IDI3MCA/IC1kdyA6IDApXG5cdFx0XHRcdCwgKGRlZyA9PSA5MCB8fCBkZWcgPT0gMTgwID8gLWRoIDogMClcblx0XHRcdFx0LCBkdywgZGhcblx0XHRcdCk7XG5cdFx0XHRkdyA9IGNhbnZhcy53aWR0aDtcblx0XHRcdGRoID0gY2FudmFzLmhlaWdodDtcblxuXHRcdFx0Ly8gQXBwbHkgb3ZlcmxheVxuXHRcdFx0b3ZlcmxheSAmJiBhcGkuZWFjaChbXS5jb25jYXQob3ZlcmxheSksIGZ1bmN0aW9uIChvdmVyKXtcblx0XHRcdFx0cXVldWUuaW5jKCk7XG5cdFx0XHRcdC8vIHByZWxvYWRcblx0XHRcdFx0dmFyIGltZyA9IG5ldyB3aW5kb3cuSW1hZ2UsIGZuID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0XHQgIHggPSBvdmVyLnh8MFxuXHRcdFx0XHRcdFx0LCB5ID0gb3Zlci55fDBcblx0XHRcdFx0XHRcdCwgdyA9IG92ZXIudyB8fCBpbWcud2lkdGhcblx0XHRcdFx0XHRcdCwgaCA9IG92ZXIuaCB8fCBpbWcuaGVpZ2h0XG5cdFx0XHRcdFx0XHQsIHJlbCA9IG92ZXIucmVsXG5cdFx0XHRcdFx0O1xuXG5cdFx0XHRcdFx0Ly8gY2VudGVyICB8ICByaWdodCAgfCAgbGVmdFxuXHRcdFx0XHRcdHggPSAocmVsID09IDEgfHwgcmVsID09IDQgfHwgcmVsID09IDcpID8gKGR3IC0gdyArIHgpLzIgOiAocmVsID09IDIgfHwgcmVsID09IDUgfHwgcmVsID09IDggPyBkdyAtICh3ICsgeCkgOiB4KTtcblxuXHRcdFx0XHRcdC8vIGNlbnRlciAgfCAgYm90dG9tICB8ICB0b3Bcblx0XHRcdFx0XHR5ID0gKHJlbCA9PSAzIHx8IHJlbCA9PSA0IHx8IHJlbCA9PSA1KSA/IChkaCAtIGggKyB5KS8yIDogKHJlbCA+PSA2ID8gZGggLSAoaCArIHkpIDogeSk7XG5cblx0XHRcdFx0XHRhcGkuZXZlbnQub2ZmKGltZywgJ2Vycm9yIGxvYWQgYWJvcnQnLCBmbik7XG5cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3Zlci5vcGFjaXR5IHx8IDE7XG5cdFx0XHRcdFx0XHRjdHguZHJhd0ltYWdlKGltZywgeCwgeSwgdywgaCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlcil7fVxuXG5cdFx0XHRcdFx0cXVldWUubmV4dCgpO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGFwaS5ldmVudC5vbihpbWcsICdlcnJvciBsb2FkIGFib3J0JywgZm4pO1xuXHRcdFx0XHRpbWcuc3JjID0gb3Zlci5zcmM7XG5cblx0XHRcdFx0aWYoIGltZy5jb21wbGV0ZSApe1xuXHRcdFx0XHRcdGZuKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRpZiggZmlsdGVyICl7XG5cdFx0XHRcdHF1ZXVlLmluYygpO1xuXHRcdFx0XHRJbWFnZS5hcHBseUZpbHRlcihjYW52YXMsIGZpbHRlciwgcXVldWUubmV4dCk7XG5cdFx0XHR9XG5cblx0XHRcdHF1ZXVlLmNoZWNrKCk7XG5cdFx0fSxcblxuXHRcdGdldE1hdHJpeDogZnVuY3Rpb24gKGltYWdlKXtcblx0XHRcdHZhclxuXHRcdFx0XHQgIG0gID0gYXBpLmV4dGVuZCh7fSwgdGhpcy5tYXRyaXgpXG5cdFx0XHRcdCwgc3cgPSBtLnN3ID0gbS5zdyB8fCBpbWFnZS52aWRlb1dpZHRoIHx8IGltYWdlLm5hdHVyYWxXaWR0aCB8fCAgaW1hZ2Uud2lkdGhcblx0XHRcdFx0LCBzaCA9IG0uc2ggPSBtLnNoIHx8IGltYWdlLnZpZGVvSGVpZ2h0IHx8IGltYWdlLm5hdHVyYWxIZWlnaHQgfHwgaW1hZ2UuaGVpZ2h0XG5cdFx0XHRcdCwgZHcgPSBtLmR3ID0gbS5kdyB8fCBzd1xuXHRcdFx0XHQsIGRoID0gbS5kaCA9IG0uZGggfHwgc2hcblx0XHRcdFx0LCBzZiA9IHN3L3NoLCBkZiA9IGR3L2RoXG5cdFx0XHRcdCwgc3RyYXRlZ3kgPSBtLnJlc2l6ZVxuXHRcdFx0O1xuXG5cdFx0XHRpZiggc3RyYXRlZ3kgPT0gJ3ByZXZpZXcnICl7XG5cdFx0XHRcdGlmKCBkdyAhPSBzdyB8fCBkaCAhPSBzaCApe1xuXHRcdFx0XHRcdC8vIE1ha2UgcHJldmlld1xuXHRcdFx0XHRcdHZhciB3LCBoO1xuXG5cdFx0XHRcdFx0aWYoIGRmID49IHNmICl7XG5cdFx0XHRcdFx0XHR3XHQ9IHN3O1xuXHRcdFx0XHRcdFx0aFx0PSB3IC8gZGY7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGhcdD0gc2g7XG5cdFx0XHRcdFx0XHR3XHQ9IGggKiBkZjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiggdyAhPSBzdyB8fCBoICE9IHNoICl7XG5cdFx0XHRcdFx0XHRtLnN4XHQ9IH5+KChzdyAtIHcpLzIpO1xuXHRcdFx0XHRcdFx0bS5zeVx0PSB+figoc2ggLSBoKS8yKTtcblx0XHRcdFx0XHRcdHN3XHRcdD0gdztcblx0XHRcdFx0XHRcdHNoXHRcdD0gaDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoIHN0cmF0ZWd5ID09ICdoZWlnaHQnICl7XG5cdFx0XHRcdGR3ID0gZGggKiBzZjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoIHN0cmF0ZWd5ID09ICd3aWR0aCcgKXtcblx0XHRcdFx0ZGggPSBkdyAvIHNmO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiggc3RyYXRlZ3kgKXtcblx0XHRcdFx0aWYoICEoc3cgPiBkdyB8fCBzaCA+IGRoKSApe1xuXHRcdFx0XHRcdGR3ID0gc3c7XG5cdFx0XHRcdFx0ZGggPSBzaDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKCBzdHJhdGVneSA9PSAnbWluJyApe1xuXHRcdFx0XHRcdGR3ID0gcm91bmQoc2YgPCBkZiA/IG1pbihzdywgZHcpIDogZGgqc2YpO1xuXHRcdFx0XHRcdGRoID0gcm91bmQoc2YgPCBkZiA/IGR3L3NmIDogbWluKHNoLCBkaCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGR3ID0gcm91bmQoc2YgPj0gZGYgPyBtaW4oc3csIGR3KSA6IGRoKnNmKTtcblx0XHRcdFx0XHRkaCA9IHJvdW5kKHNmID49IGRmID8gZHcvc2YgOiBtaW4oc2gsIGRoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bS5zdyA9IHN3O1xuXHRcdFx0bS5zaCA9IHNoO1xuXHRcdFx0bS5kdyA9IGR3O1xuXHRcdFx0bS5kaCA9IGRoO1xuXHRcdFx0bS5tdWx0aXBhc3MgPSBhcGkubXVsdGlQYXNzUmVzaXplO1xuXHRcdFx0cmV0dXJuXHRtO1xuXHRcdH0sXG5cblx0XHRfdHJhbnM6IGZ1bmN0aW9uIChmbil7XG5cdFx0XHR0aGlzLl9sb2FkKHRoaXMuZmlsZSwgZnVuY3Rpb24gKGVyciwgaW1hZ2Upe1xuXHRcdFx0XHRpZiggZXJyICl7XG5cdFx0XHRcdFx0Zm4oZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dGhpcy5fYXBwbHkoaW1hZ2UsIGZuKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlcnIpe1xuXHRcdFx0XHRcdFx0YXBpLmxvZygnW2Vycl0gRmlsZUFQSS5JbWFnZS5mbi5fYXBwbHk6JywgZXJyKTtcblx0XHRcdFx0XHRcdGZuKGVycik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cblx0XHRnZXQ6IGZ1bmN0aW9uIChmbil7XG5cdFx0XHRpZiggYXBpLnN1cHBvcnQudHJhbnNmb3JtICl7XG5cdFx0XHRcdHZhciBfdGhpcyA9IHRoaXMsIG1hdHJpeCA9IF90aGlzLm1hdHJpeDtcblxuXHRcdFx0XHRpZiggbWF0cml4LmRlZyA9PSAnYXV0bycgKXtcblx0XHRcdFx0XHRhcGkuZ2V0SW5mbyhfdGhpcy5maWxlLCBmdW5jdGlvbiAoZXJyLCBpbmZvKXtcblx0XHRcdFx0XHRcdC8vIHJvdGF0ZSBieSBleGlmIG9yaWVudGF0aW9uXG5cdFx0XHRcdFx0XHRtYXRyaXguZGVnID0gZXhpZk9yaWVudGF0aW9uW2luZm8gJiYgaW5mby5leGlmICYmIGluZm8uZXhpZi5PcmllbnRhdGlvbl0gfHwgMDtcblx0XHRcdFx0XHRcdF90aGlzLl90cmFucyhmbik7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0X3RoaXMuX3RyYW5zKGZuKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGZuKCdub3Rfc3VwcG9ydF90cmFuc2Zvcm0nKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXG5cdFx0dG9EYXRhOiBmdW5jdGlvbiAoZm4pe1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KGZuKTtcblx0XHR9XG5cblx0fTtcblxuXG5cdEltYWdlLmV4aWZPcmllbnRhdGlvbiA9IGV4aWZPcmllbnRhdGlvbjtcblxuXG5cdEltYWdlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChmaWxlLCB0cmFuc2Zvcm0sIGF1dG9PcmllbnRhdGlvbiwgZm4pe1xuXHRcdGZ1bmN0aW9uIF90cmFuc2Zvcm0oZXJyLCBpbWcpe1xuXHRcdFx0Ly8gaW1nIC0tIGluZm8gb2JqZWN0XG5cdFx0XHR2YXJcblx0XHRcdFx0ICBpbWFnZXMgPSB7fVxuXHRcdFx0XHQsIHF1ZXVlID0gYXBpLnF1ZXVlKGZ1bmN0aW9uIChlcnIpe1xuXHRcdFx0XHRcdGZuKGVyciwgaW1hZ2VzKTtcblx0XHRcdFx0fSlcblx0XHRcdDtcblxuXHRcdFx0aWYoICFlcnIgKXtcblx0XHRcdFx0YXBpLmVhY2godHJhbnNmb3JtLCBmdW5jdGlvbiAocGFyYW1zLCBuYW1lKXtcblx0XHRcdFx0XHRpZiggIXF1ZXVlLmlzRmFpbCgpICl7XG5cdFx0XHRcdFx0XHR2YXIgSW1nVHJhbnMgPSBuZXcgSW1hZ2UoaW1nLm5vZGVUeXBlID8gaW1nIDogZmlsZSksIGlzRm4gPSB0eXBlb2YgcGFyYW1zID09ICdmdW5jdGlvbic7XG5cblx0XHRcdFx0XHRcdGlmKCBpc0ZuICl7XG5cdFx0XHRcdFx0XHRcdHBhcmFtcyhpbWcsIEltZ1RyYW5zKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYoIHBhcmFtcy53aWR0aCApe1xuXHRcdFx0XHRcdFx0XHRJbWdUcmFuc1twYXJhbXMucHJldmlldyA/ICdwcmV2aWV3JyA6ICdyZXNpemUnXShwYXJhbXMud2lkdGgsIHBhcmFtcy5oZWlnaHQsIHBhcmFtcy5zdHJhdGVneSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0aWYoIHBhcmFtcy5tYXhXaWR0aCAmJiAoaW1nLndpZHRoID4gcGFyYW1zLm1heFdpZHRoIHx8IGltZy5oZWlnaHQgPiBwYXJhbXMubWF4SGVpZ2h0KSApe1xuXHRcdFx0XHRcdFx0XHRcdEltZ1RyYW5zLnJlc2l6ZShwYXJhbXMubWF4V2lkdGgsIHBhcmFtcy5tYXhIZWlnaHQsICdtYXgnKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiggcGFyYW1zLmNyb3AgKXtcblx0XHRcdFx0XHRcdFx0dmFyIGNyb3AgPSBwYXJhbXMuY3JvcDtcblx0XHRcdFx0XHRcdFx0SW1nVHJhbnMuY3JvcChjcm9wLnh8MCwgY3JvcC55fDAsIGNyb3AudyB8fCBjcm9wLndpZHRoLCBjcm9wLmggfHwgY3JvcC5oZWlnaHQpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiggcGFyYW1zLnJvdGF0ZSA9PT0gdW5kZWYgJiYgYXV0b09yaWVudGF0aW9uICl7XG5cdFx0XHRcdFx0XHRcdHBhcmFtcy5yb3RhdGUgPSAnYXV0byc7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdEltZ1RyYW5zLnNldCh7IHR5cGU6IEltZ1RyYW5zLm1hdHJpeC50eXBlIHx8IHBhcmFtcy50eXBlIHx8IGZpbGUudHlwZSB8fCAnaW1hZ2UvcG5nJyB9KTtcblxuXHRcdFx0XHRcdFx0aWYoICFpc0ZuICl7XG5cdFx0XHRcdFx0XHRcdEltZ1RyYW5zLnNldCh7XG5cdFx0XHRcdFx0XHRcdFx0ICBkZWc6IHBhcmFtcy5yb3RhdGVcblx0XHRcdFx0XHRcdFx0XHQsIG92ZXJsYXk6IHBhcmFtcy5vdmVybGF5XG5cdFx0XHRcdFx0XHRcdFx0LCBmaWx0ZXI6IHBhcmFtcy5maWx0ZXJcblx0XHRcdFx0XHRcdFx0XHQsIHF1YWxpdHk6IHBhcmFtcy5xdWFsaXR5IHx8IDFcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHF1ZXVlLmluYygpO1xuXHRcdFx0XHRcdFx0SW1nVHJhbnMudG9EYXRhKGZ1bmN0aW9uIChlcnIsIGltYWdlKXtcblx0XHRcdFx0XHRcdFx0aWYoIGVyciApe1xuXHRcdFx0XHRcdFx0XHRcdHF1ZXVlLmZhaWwoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRpbWFnZXNbbmFtZV0gPSBpbWFnZTtcblx0XHRcdFx0XHRcdFx0XHRxdWV1ZS5uZXh0KCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cXVldWUuZmFpbCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0Ly8gQHRvZG86INCe0LvQvi3Qu9C+LCDQvdGD0LbQvdC+INGA0LXRhNCw0LrRgtC+0YDQuNGC0Ywg0Y3RgtC+INC80LXRgdGC0L5cblx0XHRpZiggZmlsZS53aWR0aCApe1xuXHRcdFx0X3RyYW5zZm9ybShmYWxzZSwgZmlsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFwaS5nZXRJbmZvKGZpbGUsIF90cmFuc2Zvcm0pO1xuXHRcdH1cblx0fTtcblxuXG5cdC8vIEBjb25zdFxuXHRhcGkuZWFjaChbJ1RPUCcsICdDRU5URVInLCAnQk9UVE9NJ10sIGZ1bmN0aW9uICh4LCBpKXtcblx0XHRhcGkuZWFjaChbJ0xFRlQnLCAnQ0VOVEVSJywgJ1JJR0hUJ10sIGZ1bmN0aW9uICh5LCBqKXtcblx0XHRcdEltYWdlW3grJ18nK3ldID0gaSozICsgajtcblx0XHRcdEltYWdlW3krJ18nK3hdID0gaSozICsgajtcblx0XHR9KTtcblx0fSk7XG5cblxuXHQvKipcblx0ICogVHJhYnNmb3JtIGVsZW1lbnQgdG8gY2FudmFzXG5cdCAqXG5cdCAqIEBwYXJhbSAgICB7SW1hZ2V8SFRNTFZpZGVvRWxlbWVudH0gICBlbFxuXHQgKiBAcmV0dXJucyAge0NhbnZhc31cblx0ICovXG5cdEltYWdlLnRvQ2FudmFzID0gZnVuY3Rpb24oZWwpe1xuXHRcdHZhciBjYW52YXNcdFx0PSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRjYW52YXMud2lkdGhcdD0gZWwudmlkZW9XaWR0aCB8fCBlbC53aWR0aDtcblx0XHRjYW52YXMuaGVpZ2h0XHQ9IGVsLnZpZGVvSGVpZ2h0IHx8IGVsLmhlaWdodDtcblx0XHRjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoZWwsIDAsIDApO1xuXHRcdHJldHVyblx0Y2FudmFzO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBpbWFnZSBmcm9tIERhdGFVUkxcblx0ICogQHBhcmFtICB7U3RyaW5nfSAgZGF0YVVSTFxuXHQgKiBAcGFyYW0gIHtPYmplY3R9ICBzaXplXG5cdCAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2tcblx0ICovXG5cdEltYWdlLmZyb21EYXRhVVJMID0gZnVuY3Rpb24gKGRhdGFVUkwsIHNpemUsIGNhbGxiYWNrKXtcblx0XHR2YXIgaW1nID0gYXBpLm5ld0ltYWdlKGRhdGFVUkwpO1xuXHRcdGFwaS5leHRlbmQoaW1nLCBzaXplKTtcblx0XHRjYWxsYmFjayhpbWcpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEFwcGx5IGZpbHRlciAoY2FtYW4uanMpXG5cdCAqXG5cdCAqIEBwYXJhbSAge0NhbnZhc3xJbWFnZX0gICBjYW52YXNcblx0ICogQHBhcmFtICB7U3RyaW5nfEZ1bmN0aW9ufSAgZmlsdGVyXG5cdCAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgZG9uZUZuXG5cdCAqL1xuXHRJbWFnZS5hcHBseUZpbHRlciA9IGZ1bmN0aW9uIChjYW52YXMsIGZpbHRlciwgZG9uZUZuKXtcblx0XHRpZiggdHlwZW9mIGZpbHRlciA9PSAnZnVuY3Rpb24nICl7XG5cdFx0XHRmaWx0ZXIoY2FudmFzLCBkb25lRm4pO1xuXHRcdH1cblx0XHRlbHNlIGlmKCB3aW5kb3cuQ2FtYW4gKXtcblx0XHRcdC8vIGh0dHA6Ly9jYW1hbmpzLmNvbS9ndWlkZXMvXG5cdFx0XHR3aW5kb3cuQ2FtYW4oY2FudmFzLnRhZ05hbWUgPT0gJ0lNRycgPyBJbWFnZS50b0NhbnZhcyhjYW52YXMpIDogY2FudmFzLCBmdW5jdGlvbiAoKXtcblx0XHRcdFx0aWYoIHR5cGVvZiBmaWx0ZXIgPT0gJ3N0cmluZycgKXtcblx0XHRcdFx0XHR0aGlzW2ZpbHRlcl0oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRhcGkuZWFjaChmaWx0ZXIsIGZ1bmN0aW9uICh2YWwsIG1ldGhvZCl7XG5cdFx0XHRcdFx0XHR0aGlzW21ldGhvZF0odmFsKTtcblx0XHRcdFx0XHR9LCB0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnJlbmRlcihkb25lRm4pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEZvciBsb2FkLWltYWdlLWlvcy5qc1xuXHQgKi9cblx0YXBpLnJlbmRlckltYWdlVG9DYW52YXMgPSBmdW5jdGlvbiAoY2FudmFzLCBpbWcsIHN4LCBzeSwgc3csIHNoLCBkeCwgZHksIGR3LCBkaCl7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoaW1nLCBzeCwgc3ksIHN3LCBzaCwgZHgsIGR5LCBkdywgZGgpO1xuXHRcdH0gY2F0Y2ggKGV4KSB7XG5cdFx0XHRhcGkubG9nKCdyZW5kZXJJbWFnZVRvQ2FudmFzIGZhaWxlZCcpO1xuXHRcdFx0dGhyb3cgZXg7XG5cdFx0fVxuXHR9O1xuXG5cblx0Ly8gQGV4cG9ydFxuXHRhcGkuc3VwcG9ydC5jYW52YXMgPSBhcGkuc3VwcG9ydC50cmFuc2Zvcm0gPSBzdXBwb3J0O1xuXHRhcGkuSW1hZ2UgPSBJbWFnZTtcbn0pKEZpbGVBUEksIGRvY3VtZW50KTtcblxuLypcbiAqIEphdmFTY3JpcHQgTG9hZCBJbWFnZSBpT1Mgc2NhbGluZyBmaXhlcyAxLjAuM1xuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1Mb2FkLUltYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBpT1MgaW1hZ2Ugc2NhbGluZyBmaXhlcyBiYXNlZCBvblxuICogaHR0cHM6Ly9naXRodWIuY29tL3N0b21pdGEvaW9zLWltYWdlZmlsZS1tZWdhcGl4ZWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5cbi8qanNsaW50IG5vbWVuOiB0cnVlLCBiaXR3aXNlOiB0cnVlICovXG4vKmdsb2JhbCBGaWxlQVBJLCB3aW5kb3csIGRvY3VtZW50ICovXG5cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHQndXNlIHN0cmljdCc7XG5cdGZhY3RvcnkoRmlsZUFQSSk7XG59KGZ1bmN0aW9uIChsb2FkSW1hZ2UpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBPbmx5IGFwcGx5IGZpeGVzIG9uIHRoZSBpT1MgcGxhdGZvcm06XG4gICAgaWYgKCF3aW5kb3cubmF2aWdhdG9yIHx8ICF3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtIHx8XG4gICAgICAgICAgICAgISgvaVAoaG9uZXxvZHxhZCkvKS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3JpZ2luYWxSZW5kZXJNZXRob2QgPSBsb2FkSW1hZ2UucmVuZGVySW1hZ2VUb0NhbnZhcztcblxuICAgIC8vIERldGVjdHMgc3Vic2FtcGxpbmcgaW4gSlBFRyBpbWFnZXM6XG4gICAgbG9hZEltYWdlLmRldGVjdFN1YnNhbXBsaW5nID0gZnVuY3Rpb24gKGltZykge1xuICAgICAgICB2YXIgY2FudmFzLFxuICAgICAgICAgICAgY29udGV4dDtcbiAgICAgICAgaWYgKGltZy53aWR0aCAqIGltZy5oZWlnaHQgPiAxMDI0ICogMTAyNCkgeyAvLyBvbmx5IGNvbnNpZGVyIG1leGFwaXhlbCBpbWFnZXNcbiAgICAgICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7XG4gICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIC1pbWcud2lkdGggKyAxLCAwKTtcbiAgICAgICAgICAgIC8vIHN1YnNhbXBsZWQgaW1hZ2UgYmVjb21lcyBoYWxmIHNtYWxsZXIgaW4gcmVuZGVyaW5nIHNpemUuXG4gICAgICAgICAgICAvLyBjaGVjayBhbHBoYSBjaGFubmVsIHZhbHVlIHRvIGNvbmZpcm0gaW1hZ2UgaXMgY292ZXJpbmcgZWRnZSBwaXhlbCBvciBub3QuXG4gICAgICAgICAgICAvLyBpZiBhbHBoYSB2YWx1ZSBpcyAwIGltYWdlIGlzIG5vdCBjb3ZlcmluZywgaGVuY2Ugc3Vic2FtcGxlZC5cbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhWzNdID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gRGV0ZWN0cyB2ZXJ0aWNhbCBzcXVhc2ggaW4gSlBFRyBpbWFnZXM6XG4gICAgbG9hZEltYWdlLmRldGVjdFZlcnRpY2FsU3F1YXNoID0gZnVuY3Rpb24gKGltZywgc3Vic2FtcGxlZCkge1xuICAgICAgICB2YXIgbmF0dXJhbEhlaWdodCA9IGltZy5uYXR1cmFsSGVpZ2h0IHx8IGltZy5oZWlnaHQsXG4gICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcbiAgICAgICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBzeSxcbiAgICAgICAgICAgIGV5LFxuICAgICAgICAgICAgcHksXG4gICAgICAgICAgICBhbHBoYTtcbiAgICAgICAgaWYgKHN1YnNhbXBsZWQpIHtcbiAgICAgICAgICAgIG5hdHVyYWxIZWlnaHQgLz0gMjtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMud2lkdGggPSAxO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gbmF0dXJhbEhlaWdodDtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIG5hdHVyYWxIZWlnaHQpLmRhdGE7XG4gICAgICAgIC8vIHNlYXJjaCBpbWFnZSBlZGdlIHBpeGVsIHBvc2l0aW9uIGluIGNhc2UgaXQgaXMgc3F1YXNoZWQgdmVydGljYWxseTpcbiAgICAgICAgc3kgPSAwO1xuICAgICAgICBleSA9IG5hdHVyYWxIZWlnaHQ7XG4gICAgICAgIHB5ID0gbmF0dXJhbEhlaWdodDtcbiAgICAgICAgd2hpbGUgKHB5ID4gc3kpIHtcbiAgICAgICAgICAgIGFscGhhID0gZGF0YVsocHkgLSAxKSAqIDQgKyAzXTtcbiAgICAgICAgICAgIGlmIChhbHBoYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGV5ID0gcHk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5ID0gcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBweSA9IChleSArIHN5KSA+PiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocHkgLyBuYXR1cmFsSGVpZ2h0KSB8fCAxO1xuICAgIH07XG5cbiAgICAvLyBSZW5kZXJzIGltYWdlIHRvIGNhbnZhcyB3aGlsZSB3b3JraW5nIGFyb3VuZCBpT1MgaW1hZ2Ugc2NhbGluZyBidWdzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTG9hZC1JbWFnZS9pc3N1ZXMvMTNcbiAgICBsb2FkSW1hZ2UucmVuZGVySW1hZ2VUb0NhbnZhcyA9IGZ1bmN0aW9uIChcbiAgICAgICAgY2FudmFzLFxuICAgICAgICBpbWcsXG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHNvdXJjZVdpZHRoLFxuICAgICAgICBzb3VyY2VIZWlnaHQsXG4gICAgICAgIGRlc3RYLFxuICAgICAgICBkZXN0WSxcbiAgICAgICAgZGVzdFdpZHRoLFxuICAgICAgICBkZXN0SGVpZ2h0XG4gICAgKSB7XG4gICAgICAgIGlmIChpbWcuX3R5cGUgPT09ICdpbWFnZS9qcGVnJykge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICAgICAgICB0bXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcbiAgICAgICAgICAgICAgICB0aWxlU2l6ZSA9IDEwMjQsXG4gICAgICAgICAgICAgICAgdG1wQ29udGV4dCA9IHRtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgICAgICAgIHN1YnNhbXBsZWQsXG4gICAgICAgICAgICAgICAgdmVydFNxdWFzaFJhdGlvLFxuICAgICAgICAgICAgICAgIHRpbGVYLFxuICAgICAgICAgICAgICAgIHRpbGVZO1xuICAgICAgICAgICAgdG1wQ2FudmFzLndpZHRoID0gdGlsZVNpemU7XG4gICAgICAgICAgICB0bXBDYW52YXMuaGVpZ2h0ID0gdGlsZVNpemU7XG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIHN1YnNhbXBsZWQgPSBsb2FkSW1hZ2UuZGV0ZWN0U3Vic2FtcGxpbmcoaW1nKTtcbiAgICAgICAgICAgIGlmIChzdWJzYW1wbGVkKSB7XG4gICAgICAgICAgICAgICAgc291cmNlWCAvPSAyO1xuICAgICAgICAgICAgICAgIHNvdXJjZVkgLz0gMjtcbiAgICAgICAgICAgICAgICBzb3VyY2VXaWR0aCAvPSAyO1xuICAgICAgICAgICAgICAgIHNvdXJjZUhlaWdodCAvPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmVydFNxdWFzaFJhdGlvID0gbG9hZEltYWdlLmRldGVjdFZlcnRpY2FsU3F1YXNoKGltZywgc3Vic2FtcGxlZCk7XG4gICAgICAgICAgICBpZiAoc3Vic2FtcGxlZCB8fCB2ZXJ0U3F1YXNoUmF0aW8gIT09IDEpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VZICo9IHZlcnRTcXVhc2hSYXRpbztcbiAgICAgICAgICAgICAgICBkZXN0V2lkdGggPSBNYXRoLmNlaWwodGlsZVNpemUgKiBkZXN0V2lkdGggLyBzb3VyY2VXaWR0aCk7XG4gICAgICAgICAgICAgICAgZGVzdEhlaWdodCA9IE1hdGguY2VpbChcbiAgICAgICAgICAgICAgICAgICAgdGlsZVNpemUgKiBkZXN0SGVpZ2h0IC8gc291cmNlSGVpZ2h0IC8gdmVydFNxdWFzaFJhdGlvXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkZXN0WSA9IDA7XG4gICAgICAgICAgICAgICAgdGlsZVkgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aWxlWSA8IHNvdXJjZUhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBkZXN0WCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRpbGVYID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRpbGVYIDwgc291cmNlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcENvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRpbGVTaXplLCB0aWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBDb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtdGlsZVgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLXRpbGVZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcENhbnZhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlWCArPSB0aWxlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RYICs9IGRlc3RXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aWxlWSArPSB0aWxlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVzdFkgKz0gZGVzdEhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxSZW5kZXJNZXRob2QoXG4gICAgICAgICAgICBjYW52YXMsXG4gICAgICAgICAgICBpbWcsXG4gICAgICAgICAgICBzb3VyY2VYLFxuICAgICAgICAgICAgc291cmNlWSxcbiAgICAgICAgICAgIHNvdXJjZVdpZHRoLFxuICAgICAgICAgICAgc291cmNlSGVpZ2h0LFxuICAgICAgICAgICAgZGVzdFgsXG4gICAgICAgICAgICBkZXN0WSxcbiAgICAgICAgICAgIGRlc3RXaWR0aCxcbiAgICAgICAgICAgIGRlc3RIZWlnaHRcbiAgICAgICAgKTtcbiAgICB9O1xuXG59KSk7XG5cbi8qZ2xvYmFsIHdpbmRvdywgRmlsZUFQSSAqL1xuXG4oZnVuY3Rpb24gKGFwaSwgd2luZG93KXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyXG5cdFx0ICBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudFxuXHRcdCwgRm9ybURhdGEgPSB3aW5kb3cuRm9ybURhdGFcblx0XHQsIEZvcm0gPSBmdW5jdGlvbiAoKXsgdGhpcy5pdGVtcyA9IFtdOyB9XG5cdFx0LCBlbmNvZGVVUklDb21wb25lbnQgPSB3aW5kb3cuZW5jb2RlVVJJQ29tcG9uZW50XG5cdDtcblxuXG5cdEZvcm0ucHJvdG90eXBlID0ge1xuXG5cdFx0YXBwZW5kOiBmdW5jdGlvbiAobmFtZSwgYmxvYiwgZmlsZSwgdHlwZSl7XG5cdFx0XHR0aGlzLml0ZW1zLnB1c2goe1xuXHRcdFx0XHQgIG5hbWU6IG5hbWVcblx0XHRcdFx0LCBibG9iOiBibG9iICYmIGJsb2IuYmxvYiB8fCAoYmxvYiA9PSB2b2lkIDAgPyAnJyA6IGJsb2IpXG5cdFx0XHRcdCwgZmlsZTogYmxvYiAmJiAoZmlsZSB8fCBibG9iLm5hbWUpXG5cdFx0XHRcdCwgdHlwZTpcdGJsb2IgJiYgKHR5cGUgfHwgYmxvYi50eXBlKVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGVhY2g6IGZ1bmN0aW9uIChmbil7XG5cdFx0XHR2YXIgaSA9IDAsIG4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcblx0XHRcdGZvciggOyBpIDwgbjsgaSsrICl7XG5cdFx0XHRcdGZuLmNhbGwodGhpcywgdGhpcy5pdGVtc1tpXSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHRvRGF0YTogZnVuY3Rpb24gKGZuLCBvcHRpb25zKXtcblx0XHQgICAgLy8gYWxsb3cgY2h1bmtlZCB0cmFuc2ZlciBpZiB3ZSBoYXZlIG9ubHkgb25lIGZpbGUgdG8gc2VuZFxuXHRcdCAgICAvLyBmbGFnIGlzIHVzZWQgYmVsb3cgYW5kIGluIFhIUi5fc2VuZFxuXHRcdCAgICBvcHRpb25zLl9jaHVua2VkID0gYXBpLnN1cHBvcnQuY2h1bmtlZCAmJiBvcHRpb25zLmNodW5rU2l6ZSA+IDAgJiYgYXBpLmZpbHRlcih0aGlzLml0ZW1zLCBmdW5jdGlvbiAoaXRlbSl7IHJldHVybiBpdGVtLmZpbGU7IH0pLmxlbmd0aCA9PSAxO1xuXG5cdFx0XHRpZiggIWFwaS5zdXBwb3J0Lmh0bWw1ICl7XG5cdFx0XHRcdGFwaS5sb2coJ0ZpbGVBUEkuRm9ybS50b0h0bWxEYXRhJyk7XG5cdFx0XHRcdHRoaXMudG9IdG1sRGF0YShmbik7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKCAhYXBpLmZvcm1EYXRhIHx8IHRoaXMubXVsdGlwYXJ0IHx8ICFGb3JtRGF0YSApe1xuXHRcdFx0XHRhcGkubG9nKCdGaWxlQVBJLkZvcm0udG9NdWx0aXBhcnREYXRhJyk7XG5cdFx0XHRcdHRoaXMudG9NdWx0aXBhcnREYXRhKGZuKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoIG9wdGlvbnMuX2NodW5rZWQgKXtcblx0XHRcdFx0YXBpLmxvZygnRmlsZUFQSS5Gb3JtLnRvUGxhaW5EYXRhJyk7XG5cdFx0XHRcdHRoaXMudG9QbGFpbkRhdGEoZm4pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGFwaS5sb2coJ0ZpbGVBUEkuRm9ybS50b0Zvcm1EYXRhJyk7XG5cdFx0XHRcdHRoaXMudG9Gb3JtRGF0YShmbik7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF90bzogZnVuY3Rpb24gKGRhdGEsIGNvbXBsZXRlLCBuZXh0LCBhcmcpe1xuXHRcdFx0dmFyIHF1ZXVlID0gYXBpLnF1ZXVlKGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRjb21wbGV0ZShkYXRhKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24gKGZpbGUpe1xuXHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0bmV4dChmaWxlLCBkYXRhLCBxdWV1ZSwgYXJnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCggZXJyICl7XG5cdFx0XHRcdFx0YXBpLmxvZygnRmlsZUFQSS5Gb3JtLl90bzogJyArIGVyci5tZXNzYWdlKTtcblx0XHRcdFx0XHRjb21wbGV0ZShlcnIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cXVldWUuY2hlY2soKTtcblx0XHR9LFxuXG5cblx0XHR0b0h0bWxEYXRhOiBmdW5jdGlvbiAoZm4pe1xuXHRcdFx0dGhpcy5fdG8oZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBmbiwgZnVuY3Rpb24gKGZpbGUsIGRhdGEvKipEb2N1bWVudEZyYWdtZW50Ki8pe1xuXHRcdFx0XHR2YXIgYmxvYiA9IGZpbGUuYmxvYiwgaGlkZGVuO1xuXG5cdFx0XHRcdGlmKCBmaWxlLmZpbGUgKXtcblx0XHRcdFx0XHRhcGkucmVzZXQoYmxvYiwgdHJ1ZSk7XG5cdFx0XHRcdFx0Ly8gc2V0IG5ldyBuYW1lXG5cdFx0XHRcdFx0YmxvYi5uYW1lID0gZmlsZS5uYW1lO1xuXHRcdFx0XHRcdGJsb2IuZGlzYWJsZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRkYXRhLmFwcGVuZENoaWxkKGJsb2IpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG5cdFx0XHRcdFx0aGlkZGVuLm5hbWUgID0gZmlsZS5uYW1lO1xuXHRcdFx0XHRcdGhpZGRlbi50eXBlICA9ICdoaWRkZW4nO1xuXHRcdFx0XHRcdGhpZGRlbi52YWx1ZSA9IGJsb2I7XG5cdFx0XHRcdFx0ZGF0YS5hcHBlbmRDaGlsZChoaWRkZW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0dG9QbGFpbkRhdGE6IGZ1bmN0aW9uIChmbil7XG5cdFx0XHR0aGlzLl90byh7fSwgZm4sIGZ1bmN0aW9uIChmaWxlLCBkYXRhLCBxdWV1ZSl7XG5cdFx0XHRcdGlmKCBmaWxlLmZpbGUgKXtcblx0XHRcdFx0XHRkYXRhLnR5cGUgPSBmaWxlLmZpbGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiggZmlsZS5ibG9iLnRvQmxvYiApe1xuXHRcdFx0XHQgICAgLy8gY2FudmFzXG5cdFx0XHRcdFx0cXVldWUuaW5jKCk7XG5cdFx0XHRcdFx0X2NvbnZlcnRGaWxlKGZpbGUsIGZ1bmN0aW9uIChmaWxlLCBibG9iKXtcblx0XHRcdFx0XHRcdGRhdGEubmFtZSA9IGZpbGUubmFtZTtcblx0XHRcdFx0XHRcdGRhdGEuZmlsZSA9IGJsb2I7XG5cdFx0XHRcdFx0XHRkYXRhLnNpemUgPSBibG9iLmxlbmd0aDtcblx0XHRcdFx0XHRcdGRhdGEudHlwZSA9IGZpbGUudHlwZTtcblx0XHRcdFx0XHRcdHF1ZXVlLm5leHQoKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKCBmaWxlLmZpbGUgKXtcblx0XHRcdFx0ICAgIC8vIGZpbGVcblx0XHRcdFx0XHRkYXRhLm5hbWUgPSBmaWxlLmJsb2IubmFtZTtcblx0XHRcdFx0XHRkYXRhLmZpbGUgPSBmaWxlLmJsb2I7XG5cdFx0XHRcdFx0ZGF0YS5zaXplID0gZmlsZS5ibG9iLnNpemU7XG5cdFx0XHRcdFx0ZGF0YS50eXBlID0gZmlsZS50eXBlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHQgICAgLy8gYWRkaXRpb25hbCBkYXRhXG5cdFx0XHRcdCAgICBpZiggIWRhdGEucGFyYW1zICl7XG5cdFx0XHRcdCAgICAgICAgZGF0YS5wYXJhbXMgPSBbXTtcblx0XHRcdFx0ICAgIH1cblx0XHRcdFx0ICAgIGRhdGEucGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGZpbGUubmFtZSkgK1wiPVwiKyBlbmNvZGVVUklDb21wb25lbnQoZmlsZS5ibG9iKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkYXRhLnN0YXJ0ID0gLTE7XG5cdFx0XHRcdGRhdGEuZW5kID0gZGF0YS5maWxlICYmIGRhdGEuZmlsZS5GaWxlQVBJUmVhZFBvc2l0aW9uIHx8IC0xO1xuXHRcdFx0XHRkYXRhLnJldHJ5ID0gMDtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHR0b0Zvcm1EYXRhOiBmdW5jdGlvbiAoZm4pe1xuXHRcdFx0dGhpcy5fdG8obmV3IEZvcm1EYXRhLCBmbiwgZnVuY3Rpb24gKGZpbGUsIGRhdGEsIHF1ZXVlKXtcblx0XHRcdFx0aWYoIGZpbGUuYmxvYiAmJiBmaWxlLmJsb2IudG9CbG9iICl7XG5cdFx0XHRcdFx0cXVldWUuaW5jKCk7XG5cdFx0XHRcdFx0X2NvbnZlcnRGaWxlKGZpbGUsIGZ1bmN0aW9uIChmaWxlLCBibG9iKXtcblx0XHRcdFx0XHRcdGRhdGEuYXBwZW5kKGZpbGUubmFtZSwgYmxvYiwgZmlsZS5maWxlKTtcblx0XHRcdFx0XHRcdHF1ZXVlLm5leHQoKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKCBmaWxlLmZpbGUgKXtcblx0XHRcdFx0XHRkYXRhLmFwcGVuZChmaWxlLm5hbWUsIGZpbGUuYmxvYiwgZmlsZS5maWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRkYXRhLmFwcGVuZChmaWxlLm5hbWUsIGZpbGUuYmxvYik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiggZmlsZS5maWxlICl7XG5cdFx0XHRcdFx0ZGF0YS5hcHBlbmQoJ18nK2ZpbGUubmFtZSwgZmlsZS5maWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXG5cdFx0dG9NdWx0aXBhcnREYXRhOiBmdW5jdGlvbiAoZm4pe1xuXHRcdFx0dGhpcy5fdG8oW10sIGZuLCBmdW5jdGlvbiAoZmlsZSwgZGF0YSwgcXVldWUsIGJvdW5kYXJ5KXtcblx0XHRcdFx0cXVldWUuaW5jKCk7XG5cdFx0XHRcdF9jb252ZXJ0RmlsZShmaWxlLCBmdW5jdGlvbiAoZmlsZSwgYmxvYil7XG5cdFx0XHRcdFx0ZGF0YS5wdXNoKFxuXHRcdFx0XHRcdFx0ICAnLS1fJyArIGJvdW5kYXJ5ICsgKCdcXHJcXG5Db250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGE7IG5hbWU9XCInKyBmaWxlLm5hbWUgKydcIicrIChmaWxlLmZpbGUgPyAnOyBmaWxlbmFtZT1cIicrIGVuY29kZVVSSUNvbXBvbmVudChmaWxlLmZpbGUpICsnXCInIDogJycpXG5cdFx0XHRcdFx0XHQrIChmaWxlLmZpbGUgPyAnXFxyXFxuQ29udGVudC1UeXBlOiAnKyAoZmlsZS50eXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSA6ICcnKVxuXHRcdFx0XHRcdFx0KyAnXFxyXFxuJ1xuXHRcdFx0XHRcdFx0KyAnXFxyXFxuJysgKGZpbGUuZmlsZSA/IGJsb2IgOiBlbmNvZGVVUklDb21wb25lbnQoYmxvYikpXG5cdFx0XHRcdFx0XHQrICdcXHJcXG4nKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cXVldWUubmV4dCgpO1xuXHRcdFx0XHR9LCB0cnVlKTtcblx0XHRcdH0sIGFwaS5leHBhbmRvKTtcblx0XHR9XG5cdH07XG5cblxuXHRmdW5jdGlvbiBfY29udmVydEZpbGUoZmlsZSwgZm4sIHVzZUJpbmFyeVN0cmluZyl7XG5cdFx0dmFyIGJsb2IgPSBmaWxlLmJsb2IsIGZpbGVuYW1lID0gZmlsZS5maWxlO1xuXG5cdFx0aWYoIGZpbGVuYW1lICl7XG5cdFx0XHRpZiggIWJsb2IudG9EYXRhVVJMICl7XG5cdFx0XHRcdC8vIFRoZSBCbG9iIGlzIG5vdCBhbiBpbWFnZS5cblx0XHRcdFx0YXBpLnJlYWRBc0JpbmFyeVN0cmluZyhibG9iLCBmdW5jdGlvbiAoZXZ0KXtcblx0XHRcdFx0XHRpZiggZXZ0LnR5cGUgPT0gJ2xvYWQnICl7XG5cdFx0XHRcdFx0XHRmbihmaWxlLCBldnQucmVzdWx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhclxuXHRcdFx0XHQgIG1pbWUgPSB7ICdpbWFnZS9qcGVnJzogJy5qcGU/ZycsICdpbWFnZS9wbmcnOiAnLnBuZycgfVxuXHRcdFx0XHQsIHR5cGUgPSBtaW1lW2ZpbGUudHlwZV0gPyBmaWxlLnR5cGUgOiAnaW1hZ2UvcG5nJ1xuXHRcdFx0XHQsIGV4dCAgPSBtaW1lW3R5cGVdIHx8ICcucG5nJ1xuXHRcdFx0XHQsIHF1YWxpdHkgPSBibG9iLnF1YWxpdHkgfHwgMVxuXHRcdFx0O1xuXG5cdFx0XHRpZiggIWZpbGVuYW1lLm1hdGNoKG5ldyBSZWdFeHAoZXh0KyckJywgJ2knKSkgKXtcblx0XHRcdFx0Ly8gRG9lcyBub3QgY2hhbmdlIHRoZSBjdXJyZW50IGV4dGVuc2lvbiwgYnV0IGFkZCBhIG5ldyBvbmUuXG5cdFx0XHRcdGZpbGVuYW1lICs9IGV4dC5yZXBsYWNlKCc/JywgJycpO1xuXHRcdFx0fVxuXG5cdFx0XHRmaWxlLmZpbGUgPSBmaWxlbmFtZTtcblx0XHRcdGZpbGUudHlwZSA9IHR5cGU7XG5cblx0XHRcdGlmKCAhdXNlQmluYXJ5U3RyaW5nICYmIGJsb2IudG9CbG9iICl7XG5cdFx0XHRcdGJsb2IudG9CbG9iKGZ1bmN0aW9uIChibG9iKXtcblx0XHRcdFx0XHRmbihmaWxlLCBibG9iKTtcblx0XHRcdFx0fSwgdHlwZSwgcXVhbGl0eSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Zm4oZmlsZSwgYXBpLnRvQmluYXJ5U3RyaW5nKGJsb2IudG9EYXRhVVJMKHR5cGUsIHF1YWxpdHkpKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Zm4oZmlsZSwgYmxvYik7XG5cdFx0fVxuXHR9XG5cblxuXHQvLyBAZXhwb3J0XG5cdGFwaS5Gb3JtID0gRm9ybTtcbn0pKEZpbGVBUEksIHdpbmRvdyk7XG5cbi8qZ2xvYmFsIHdpbmRvdywgRmlsZUFQSSwgVWludDhBcnJheSAqL1xuXG4oZnVuY3Rpb24gKHdpbmRvdywgYXBpKXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyXG5cdFx0ICBub29wID0gZnVuY3Rpb24gKCl7fVxuXHRcdCwgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnRcblxuXHRcdCwgWEhSID0gZnVuY3Rpb24gKG9wdGlvbnMpe1xuXHRcdFx0dGhpcy51aWQgPSBhcGkudWlkKCk7XG5cdFx0XHR0aGlzLnhociA9IHtcblx0XHRcdFx0ICBhYm9ydDogbm9vcFxuXHRcdFx0XHQsIGdldFJlc3BvbnNlSGVhZGVyOiBub29wXG5cdFx0XHRcdCwgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBub29wXG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR9LFxuXG5cdFx0X3hoclJlc3BvbnNlUG9zdGZpeCA9IHsgJyc6IDEsIFhNTDogMSwgVGV4dDogMSwgQm9keTogMSB9XG5cdDtcblxuXG5cdFhIUi5wcm90b3R5cGUgPSB7XG5cdFx0c3RhdHVzOiAwLFxuXHRcdHN0YXR1c1RleHQ6ICcnLFxuXHRcdGNvbnN0cnVjdG9yOiBYSFIsXG5cblx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24gKG5hbWUpe1xuXHRcdFx0cmV0dXJuIHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKG5hbWUpO1xuXHRcdH0sXG5cblx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuIHRoaXMueGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8IHt9O1xuXHRcdH0sXG5cblx0XHRlbmQ6IGZ1bmN0aW9uIChzdGF0dXMsIHN0YXR1c1RleHQpe1xuXHRcdFx0dmFyIF90aGlzID0gdGhpcywgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XG5cblx0XHRcdF90aGlzLmVuZFx0XHQ9XG5cdFx0XHRfdGhpcy5hYm9ydFx0XHQ9IG5vb3A7XG5cdFx0XHRfdGhpcy5zdGF0dXNcdD0gc3RhdHVzO1xuXG5cdFx0XHRpZiggc3RhdHVzVGV4dCApe1xuXHRcdFx0XHRfdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dDtcblx0XHRcdH1cblxuXHRcdFx0YXBpLmxvZygneGhyLmVuZDonLCBzdGF0dXMsIHN0YXR1c1RleHQpO1xuXHRcdFx0b3B0aW9ucy5jb21wbGV0ZShzdGF0dXMgPT0gMjAwIHx8IHN0YXR1cyA9PSAyMDEgPyBmYWxzZSA6IF90aGlzLnN0YXR1c1RleHQgfHwgJ3Vua25vd24nLCBfdGhpcyk7XG5cblx0XHRcdGlmKCBfdGhpcy54aHIgJiYgX3RoaXMueGhyLm5vZGUgKXtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKXtcblx0XHRcdFx0XHR2YXIgbm9kZSA9IF90aGlzLnhoci5ub2RlO1xuXHRcdFx0XHRcdHRyeSB7IG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTsgfSBjYXRjaCAoZSl7fVxuXHRcdFx0XHRcdHRyeSB7IGRlbGV0ZSB3aW5kb3dbX3RoaXMudWlkXTsgfSBjYXRjaCAoZSl7fVxuXHRcdFx0XHRcdHdpbmRvd1tfdGhpcy51aWRdID0gX3RoaXMueGhyLm5vZGUgPSBudWxsO1xuXHRcdFx0XHR9LCA5KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YWJvcnQ6IGZ1bmN0aW9uICgpe1xuXHRcdFx0dGhpcy5lbmQoMCwgJ2Fib3J0Jyk7XG5cblx0XHRcdGlmKCB0aGlzLnhociApe1xuXHRcdFx0XHR0aGlzLnhoci5hYm9ydGVkID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy54aHIuYWJvcnQoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2VuZDogZnVuY3Rpb24gKEZvcm1EYXRhKXtcblx0XHRcdHZhciBfdGhpcyA9IHRoaXMsIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRcdEZvcm1EYXRhLnRvRGF0YShmdW5jdGlvbiAoZGF0YSl7XG5cdFx0XHRcdGlmKCBkYXRhIGluc3RhbmNlb2YgRXJyb3IgKXtcblx0XHRcdFx0XHRfdGhpcy5lbmQoMCwgZGF0YS5tZXNzYWdlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNle1xuXHRcdFx0XHRcdC8vIFN0YXJ0IHVwbG9hZGluZ1xuXHRcdFx0XHRcdG9wdGlvbnMudXBsb2FkKG9wdGlvbnMsIF90aGlzKTtcblx0XHRcdFx0XHRfdGhpcy5fc2VuZC5jYWxsKF90aGlzLCBvcHRpb25zLCBkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgb3B0aW9ucyk7XG5cdFx0fSxcblxuXHRcdF9zZW5kOiBmdW5jdGlvbiAob3B0aW9ucywgZGF0YSl7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzLCB4aHIsIHVpZCA9IF90aGlzLnVpZCwgb25Mb2FkRm5OYW1lID0gX3RoaXMudWlkICsgXCJMb2FkXCIsIHVybCA9IG9wdGlvbnMudXJsO1xuXG5cdFx0XHRhcGkubG9nKCdYSFIuX3NlbmQ6JywgZGF0YSk7XG5cblx0XHRcdGlmKCAhb3B0aW9ucy5jYWNoZSApe1xuXHRcdFx0XHQvLyBObyBjYWNoZVxuXHRcdFx0XHR1cmwgKz0gKH51cmwuaW5kZXhPZignPycpID8gJyYnIDogJz8nKSArIGFwaS51aWQoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIGRhdGEubm9kZU5hbWUgKXtcblx0XHRcdFx0dmFyIGpzb25wID0gb3B0aW9ucy5qc29ucDtcblxuXHRcdFx0XHQvLyBwcmVwYXJlIGNhbGxiYWNrIGluIEdFVFxuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZSgvKFthLXpdKyk9KFxcPykvaSwgJyQxPScrdWlkKTtcblxuXHRcdFx0XHQvLyBsZWdhY3lcblx0XHRcdFx0b3B0aW9ucy51cGxvYWQob3B0aW9ucywgX3RoaXMpO1xuXG5cdFx0XHRcdHZhclxuXHRcdFx0XHRcdG9uUG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZ0KXtcblx0XHRcdFx0XHRcdGlmKCB+dXJsLmluZGV4T2YoZXZ0Lm9yaWdpbikgKXtcblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gYXBpLnBhcnNlSlNPTihldnQuZGF0YSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYoIHJlc3VsdC5pZCA9PSB1aWQgKXtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKHJlc3VsdC5zdGF0dXMsIHJlc3VsdC5zdGF0dXNUZXh0LCByZXN1bHQucmVzcG9uc2UpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBjYXRjaCggZXJyICl7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoMCwgZXJyLm1lc3NhZ2UpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIGpzb25wLWNhbGxhY2tcblx0XHRcdFx0XHRjb21wbGV0ZSA9IHdpbmRvd1t1aWRdID0gZnVuY3Rpb24gKHN0YXR1cywgc3RhdHVzVGV4dCwgcmVzcG9uc2Upe1xuXHRcdFx0XHRcdFx0X3RoaXMucmVhZHlTdGF0ZVx0PSA0O1xuXHRcdFx0XHRcdFx0X3RoaXMucmVzcG9uc2VUZXh0XHQ9IHJlc3BvbnNlO1xuXHRcdFx0XHRcdFx0X3RoaXMuZW5kKHN0YXR1cywgc3RhdHVzVGV4dCk7XG5cblx0XHRcdFx0XHRcdGFwaS5ldmVudC5vZmYod2luZG93LCAnbWVzc2FnZScsIG9uUG9zdE1lc3NhZ2UpO1xuXHRcdFx0XHRcdFx0d2luZG93W3VpZF0gPSB4aHIgPSB0cmFuc3BvcnQgPSB3aW5kb3dbb25Mb2FkRm5OYW1lXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQ7XG5cblx0XHRcdFx0X3RoaXMueGhyLmFib3J0ID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGlmKCB0cmFuc3BvcnQuc3RvcCApeyB0cmFuc3BvcnQuc3RvcCgpOyB9XG5cdFx0XHRcdFx0XHRlbHNlIGlmKCB0cmFuc3BvcnQuY29udGVudFdpbmRvdy5zdG9wICl7IHRyYW5zcG9ydC5jb250ZW50V2luZG93LnN0b3AoKTsgfVxuXHRcdFx0XHRcdFx0ZWxzZSB7IHRyYW5zcG9ydC5jb250ZW50V2luZG93LmRvY3VtZW50LmV4ZWNDb21tYW5kKCdTdG9wJyk7IH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGVyKSB7fVxuXHRcdFx0XHRcdGNvbXBsZXRlKDAsIFwiYWJvcnRcIik7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0YXBpLmV2ZW50Lm9uKHdpbmRvdywgJ21lc3NhZ2UnLCBvblBvc3RNZXNzYWdlKTtcblxuXHRcdFx0XHR3aW5kb3dbb25Mb2FkRm5OYW1lXSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRcdFx0ICB3aW4gPSB0cmFuc3BvcnQuY29udGVudFdpbmRvd1xuXHRcdFx0XHRcdFx0XHQsIGRvYyA9IHdpbi5kb2N1bWVudFxuXHRcdFx0XHRcdFx0XHQsIHJlc3VsdCA9IHdpbi5yZXN1bHQgfHwgYXBpLnBhcnNlSlNPTihkb2MuYm9keS5pbm5lckhUTUwpXG5cdFx0XHRcdFx0XHQ7XG5cdFx0XHRcdFx0XHRjb21wbGV0ZShyZXN1bHQuc3RhdHVzLCByZXN1bHQuc3RhdHVzVGV4dCwgcmVzdWx0LnJlc3BvbnNlKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlKXtcblx0XHRcdFx0XHRcdGFwaS5sb2coJ1t0cmFuc3BvcnQub25sb2FkXScsIGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR4aHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdFx0eGhyLmlubmVySFRNTCA9ICc8Zm9ybSB0YXJnZXQ9XCInKyB1aWQgKydcIiBhY3Rpb249XCInKyB1cmwgKydcIiBtZXRob2Q9XCJQT1NUXCIgZW5jdHlwZT1cIm11bHRpcGFydC9mb3JtLWRhdGFcIiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAtMTAwMHB4OyBvdmVyZmxvdzogaGlkZGVuOyB3aWR0aDogMXB4OyBoZWlnaHQ6IDFweDtcIj4nXG5cdFx0XHRcdFx0XHRcdCsgJzxpZnJhbWUgbmFtZT1cIicrIHVpZCArJ1wiIHNyYz1cImphdmFzY3JpcHQ6ZmFsc2U7XCIgb25sb2FkPVwid2luZG93LicgKyBvbkxvYWRGbk5hbWUgKyAnICYmICcgKyBvbkxvYWRGbk5hbWUgKyAnKCk7XCI+PC9pZnJhbWU+J1xuXHRcdFx0XHRcdFx0XHQrIChqc29ucCAmJiAob3B0aW9ucy51cmwuaW5kZXhPZignPT8nKSA8IDApID8gJzxpbnB1dCB2YWx1ZT1cIicrIHVpZCArJ1wiIG5hbWU9XCInK2pzb25wKydcIiB0eXBlPVwiaGlkZGVuXCIvPicgOiAnJylcblx0XHRcdFx0XHRcdFx0KyAnPC9mb3JtPidcblx0XHRcdFx0O1xuXG5cdFx0XHRcdC8vIGdldCBmb3JtLWRhdGEgJiB0cmFuc3BvcnRcblx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0ICBmb3JtID0geGhyLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdmb3JtJylbMF1cblx0XHRcdFx0XHQsIHRyYW5zcG9ydCA9IHhoci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaWZyYW1lJylbMF1cblx0XHRcdFx0O1xuXG5cdFx0XHRcdGZvcm0uYXBwZW5kQ2hpbGQoZGF0YSk7XG5cblx0XHRcdFx0YXBpLmxvZyhmb3JtLnBhcmVudE5vZGUuaW5uZXJIVE1MKTtcblxuXHRcdFx0XHQvLyBhcHBlbmQgdG8gRE9NXG5cdFx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoeGhyKTtcblxuXHRcdFx0XHQvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIG5vZGUtdHJhbnNwb3J0XG5cdFx0XHRcdF90aGlzLnhoci5ub2RlID0geGhyO1xuXG5cdFx0XHRcdC8vIHNlbmRcblx0XHRcdFx0X3RoaXMucmVhZHlTdGF0ZSA9IDI7IC8vIGxvYWRlZFxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvcm0uc3VibWl0KCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdGFwaS5sb2coJ2lmcmFtZS5lcnJvcjogJyArIGVycik7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9ybSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gQ2xlYW4gdXJsXG5cdFx0XHRcdHVybCA9IHVybC5yZXBsYWNlKC8oW2Etel0rKT0oXFw/KSY/L2ksICcnKTtcblxuXHRcdFx0XHQvLyBodG1sNVxuXHRcdFx0XHRpZiAodGhpcy54aHIgJiYgdGhpcy54aHIuYWJvcnRlZCkge1xuXHRcdFx0XHRcdGFwaS5sb2coXCJFcnJvcjogYWxyZWFkeSBhYm9ydGVkXCIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR4aHIgPSBfdGhpcy54aHIgPSBhcGkuZ2V0WEhSKCk7XG5cblx0XHRcdFx0aWYgKGRhdGEucGFyYW1zKSB7XG5cdFx0XHRcdFx0dXJsICs9ICh1cmwuaW5kZXhPZignPycpIDwgMCA/IFwiP1wiIDogXCImXCIpICsgZGF0YS5wYXJhbXMuam9pbihcIiZcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR4aHIub3BlbihvcHRpb25zLnVwbG9hZE1ldGhvZCB8fCAnUE9TVCcsIHVybCwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKHR5cGVvZiBvcHRpb25zLnVwbG9hZENyZWRlbnRpYWxzID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0XHR4aHIud2l0aENyZWRlbnRpYWxzID0gb3B0aW9ucy51cGxvYWRDcmVkZW50aWFscyA/ICd0cnVlJyA6IG51bGw7XG5cdFx0XHRcdH0gZWxzZSBpZiggYXBpLndpdGhDcmVkZW50aWFscyApe1xuXHRcdFx0XHRcdHhoci53aXRoQ3JlZGVudGlhbHMgPSBcInRydWVcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKCAhb3B0aW9ucy5oZWFkZXJzIHx8ICFvcHRpb25zLmhlYWRlcnNbJ1gtUmVxdWVzdGVkLVdpdGgnXSApe1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLVJlcXVlc3RlZC1XaXRoJywgJ1hNTEh0dHBSZXF1ZXN0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhcGkuZWFjaChvcHRpb25zLmhlYWRlcnMsIGZ1bmN0aW9uICh2YWwsIGtleSl7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuXHRcdFx0XHR9KTtcblxuXG5cdFx0XHRcdGlmICggb3B0aW9ucy5fY2h1bmtlZCApIHtcblx0XHRcdFx0XHQvLyBjaHVua2VkIHVwbG9hZFxuXHRcdFx0XHRcdGlmKCB4aHIudXBsb2FkICl7XG5cdFx0XHRcdFx0XHR4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgYXBpLnRocm90dGxlKGZ1bmN0aW9uICgvKipFdmVudCovZXZ0KXtcblx0XHRcdFx0XHRcdFx0aWYgKCFkYXRhLnJldHJ5KSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2hvdyBwcm9ncmVzcyBvbmx5IGZvciBjb3JyZWN0IGNodW5rIHVwbG9hZHNcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLnByb2dyZXNzKHtcblx0XHRcdFx0XHRcdFx0XHRcdCAgdHlwZTpcdFx0XHRldnQudHlwZVxuXHRcdFx0XHRcdFx0XHRcdFx0LCB0b3RhbDpcdFx0ZGF0YS5zaXplXG5cdFx0XHRcdFx0XHRcdFx0XHQsIGxvYWRlZDpcdFx0ZGF0YS5zdGFydCArIGV2dC5sb2FkZWRcblx0XHRcdFx0XHRcdFx0XHRcdCwgdG90YWxTaXplOlx0ZGF0YS5zaXplXG5cdFx0XHRcdFx0XHRcdFx0fSwgX3RoaXMsIG9wdGlvbnMpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCAxMDApLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRcdFx0dmFyIGxrYiA9IHBhcnNlSW50KHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1MYXN0LUtub3duLUJ5dGUnKSwgMTApO1xuXG5cdFx0XHRcdFx0XHRfdGhpcy5zdGF0dXMgICAgID0geGhyLnN0YXR1cztcblx0XHRcdFx0XHRcdF90aGlzLnN0YXR1c1RleHQgPSB4aHIuc3RhdHVzVGV4dDtcblx0XHRcdFx0XHRcdF90aGlzLnJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZTtcblxuXHRcdFx0XHRcdFx0aWYoIHhoci5yZWFkeVN0YXRlID09IDQgKXtcblx0XHRcdFx0XHRcdFx0Zm9yKCB2YXIgayBpbiBfeGhyUmVzcG9uc2VQb3N0Zml4ICl7XG5cdFx0XHRcdFx0XHRcdFx0X3RoaXNbJ3Jlc3BvbnNlJytrXSAgPSB4aHJbJ3Jlc3BvbnNlJytrXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIXhoci5zdGF0dXMgfHwgeGhyLnN0YXR1cyAtIDIwMSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHRhcGkubG9nKFwiRXJyb3I6IFwiICsgeGhyLnN0YXR1cyk7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gc29tZSBraW5kIG9mIGVycm9yXG5cdFx0XHRcdFx0XHRcdFx0Ly8gMCAtIGNvbm5lY3Rpb24gZmFpbCBvciB0aW1lb3V0LCBpZiB4aHIuYWJvcnRlZCBpcyB0cnVlLCB0aGVuIGl0J3Mgbm90IHJlY292ZXJhYmxlIHVzZXIgYWN0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gdXAgLSBzZXJ2ZXIgZXJyb3Jcblx0XHRcdFx0XHRcdFx0XHRpZiAoKCgheGhyLnN0YXR1cyAmJiAheGhyLmFib3J0ZWQpIHx8IDUwMCA9PSB4aHIuc3RhdHVzIHx8IDQxNiA9PSB4aHIuc3RhdHVzKSAmJiArK2RhdGEucmV0cnkgPD0gb3B0aW9ucy5jaHVua1VwbG9hZFJldHJ5KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBsZXQncyB0cnkgYWdhaW4gdGhlIHNhbWUgY2h1bmtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIG9ubHkgYXBwbGljYWJsZSBmb3IgcmVjb3ZlcmFibGUgZXJyb3IgY29kZXMgNTAwICYmIDQxNlxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGRlbGF5ID0geGhyLnN0YXR1cyA/IDAgOiBhcGkuY2h1bmtOZXR3b3JrRG93blJldHJ5VGltZW91dDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaW5mb3JtIGFib3V0IHJlY292ZXJhYmxlIHByb2JsZW1zXG5cdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLnBhdXNlKGRhdGEuZmlsZSwgb3B0aW9ucyk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIHNtYXJ0IHJlc3RhcnQgaWYgc2VydmVyIHJlcG9ydHMgYWJvdXQgdGhlIGxhc3Qga25vd24gYnl0ZVxuXHRcdFx0XHRcdFx0XHRcdFx0YXBpLmxvZyhcIlgtTGFzdC1Lbm93bi1CeXRlOiBcIiArIGxrYik7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAobGtiKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGEuZW5kID0gbGtiO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS5lbmQgPSBkYXRhLnN0YXJ0IC0gMTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKDQxNiA9PSB4aHIuc3RhdHVzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS5lbmQgPSBkYXRhLmVuZCAtIG9wdGlvbnMuY2h1bmtTaXplO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRfdGhpcy5fc2VuZChvcHRpb25zLCBkYXRhKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0sIGRlbGF5KTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gbm8gbW8gcmV0cmllc1xuXHRcdFx0XHRcdFx0XHRcdFx0X3RoaXMuZW5kKHhoci5zdGF0dXMpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBzdWNjZXNzXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5yZXRyeSA9IDA7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoZGF0YS5lbmQgPT0gZGF0YS5zaXplIC0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gZmluaXNoZWRcblx0XHRcdFx0XHRcdFx0XHRcdF90aGlzLmVuZCh4aHIuc3RhdHVzKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gbmV4dCBjaHVua1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBzaGlmdCBwb3NpdGlvbiBpZiBzZXJ2ZXIgcmVwb3J0cyBhYm91dCB0aGUgbGFzdCBrbm93biBieXRlXG5cdFx0XHRcdFx0XHRcdFx0XHRhcGkubG9nKFwiWC1MYXN0LUtub3duLUJ5dGU6IFwiICsgbGtiKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChsa2IpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS5lbmQgPSBsa2I7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhLmZpbGUuRmlsZUFQSVJlYWRQb3NpdGlvbiA9IGRhdGEuZW5kO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0X3RoaXMuX3NlbmQob3B0aW9ucywgZGF0YSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9LCAwKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR4aHIgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRkYXRhLnN0YXJ0ID0gZGF0YS5lbmQgKyAxO1xuXHRcdFx0XHRcdGRhdGEuZW5kID0gTWF0aC5tYXgoTWF0aC5taW4oZGF0YS5zdGFydCArIG9wdGlvbnMuY2h1bmtTaXplLCBkYXRhLnNpemUpIC0gMSwgZGF0YS5zdGFydCk7XG5cblx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBhIHNsaWNlIG9mIGZpbGVcblx0XHRcdFx0XHR2YXJcblx0XHRcdFx0XHRcdCAgZmlsZSA9IGRhdGEuZmlsZVxuXHRcdFx0XHRcdFx0LCBzbGljZSA9IChmaWxlLnNsaWNlIHx8IGZpbGUubW96U2xpY2UgfHwgZmlsZS53ZWJraXRTbGljZSkuY2FsbChmaWxlLCBkYXRhLnN0YXJ0LCBkYXRhLmVuZCArIDEpXG5cdFx0XHRcdFx0O1xuXG5cdFx0XHRcdFx0aWYoIGRhdGEuc2l6ZSAmJiAhc2xpY2Uuc2l6ZSApe1xuXHRcdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKXtcblx0XHRcdFx0XHRcdFx0X3RoaXMuZW5kKC0xKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtUmFuZ2VcIiwgXCJieXRlcyBcIiArIGRhdGEuc3RhcnQgKyBcIi1cIiArIGRhdGEuZW5kICsgXCIvXCIgKyBkYXRhLnNpemUpO1xuXHRcdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LURpc3Bvc2l0aW9uXCIsICdhdHRhY2htZW50OyBmaWxlbmFtZT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEubmFtZSkpO1xuXHRcdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgZGF0YS50eXBlIHx8IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIpO1xuXG5cdFx0XHRcdFx0XHR4aHIuc2VuZChzbGljZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZmlsZSA9IHNsaWNlID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBzaW5nbGUgcGllY2UgdXBsb2FkXG5cdFx0XHRcdFx0aWYoIHhoci51cGxvYWQgKXtcblx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL2pRdWVyeS1GaWxlLVVwbG9hZC93aWtpL0ZpeGluZy1TYWZhcmktaGFuZ2luZy1vbi12ZXJ5LWhpZ2gtc3BlZWQtY29ubmVjdGlvbnMtJTI4MUdicHMlMjlcblx0XHRcdFx0XHRcdHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBhcGkudGhyb3R0bGUoZnVuY3Rpb24gKC8qKkV2ZW50Ki9ldnQpe1xuXHRcdFx0XHRcdFx0XHRvcHRpb25zLnByb2dyZXNzKGV2dCwgX3RoaXMsIG9wdGlvbnMpO1xuXHRcdFx0XHRcdFx0fSwgMTAwKSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKXtcblx0XHRcdFx0XHRcdF90aGlzLnN0YXR1cyAgICAgPSB4aHIuc3RhdHVzO1xuXHRcdFx0XHRcdFx0X3RoaXMuc3RhdHVzVGV4dCA9IHhoci5zdGF0dXNUZXh0O1xuXHRcdFx0XHRcdFx0X3RoaXMucmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuXG5cdFx0XHRcdFx0XHRpZiggeGhyLnJlYWR5U3RhdGUgPT0gNCApe1xuXHRcdFx0XHRcdFx0XHRmb3IoIHZhciBrIGluIF94aHJSZXNwb25zZVBvc3RmaXggKXtcblx0XHRcdFx0XHRcdFx0XHRfdGhpc1sncmVzcG9uc2UnK2tdICA9IHhoclsncmVzcG9uc2UnK2tdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICgheGhyLnN0YXR1cyB8fCB4aHIuc3RhdHVzID4gMjAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0YXBpLmxvZyhcIkVycm9yOiBcIiArIHhoci5zdGF0dXMpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICgoKCF4aHIuc3RhdHVzICYmICF4aHIuYWJvcnRlZCkgfHwgNTAwID09IHhoci5zdGF0dXMpICYmIChvcHRpb25zLnJldHJ5IHx8IDApIDwgb3B0aW9ucy51cGxvYWRSZXRyeSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5yZXRyeSA9IChvcHRpb25zLnJldHJ5IHx8IDApICsgMTtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBkZWxheSA9IGFwaS5uZXR3b3JrRG93blJldHJ5VGltZW91dDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaW5mb3JtIGFib3V0IHJlY292ZXJhYmxlIHByb2JsZW1zXG5cdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLnBhdXNlKG9wdGlvbnMuZmlsZSwgb3B0aW9ucyk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRfdGhpcy5fc2VuZChvcHRpb25zLCBkYXRhKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0sIGRlbGF5KTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly9zdWNjZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRfdGhpcy5lbmQoeGhyLnN0YXR1cyk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vc3VjY2Vzc1xuXHRcdFx0XHRcdFx0XHRcdF90aGlzLmVuZCh4aHIuc3RhdHVzKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHhociA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGlmKCBhcGkuaXNBcnJheShkYXRhKSApe1xuXHRcdFx0XHRcdFx0Ly8gbXVsdGlwYXJ0XG5cdFx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ211bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PV8nK2FwaS5leHBhbmRvKTtcblx0XHRcdFx0XHRcdHZhciByYXdEYXRhID0gZGF0YS5qb2luKCcnKSArJy0tXycrIGFwaS5leHBhbmRvICsnLS0nO1xuXG5cdFx0XHRcdFx0XHQvKiogQG5hbWVzcGFjZSAgeGhyLnNlbmRBc0JpbmFyeSAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvcnUvWE1MSHR0cFJlcXVlc3QjU2VuZGluZ19iaW5hcnlfY29udGVudCAqL1xuXHRcdFx0XHRcdFx0aWYoIHhoci5zZW5kQXNCaW5hcnkgKXtcblx0XHRcdFx0XHRcdFx0eGhyLnNlbmRBc0JpbmFyeShyYXdEYXRhKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwocmF3RGF0YSwgZnVuY3Rpb24oYyl7IHJldHVybiBjLmNoYXJDb2RlQXQoMCkgJiAweGZmOyB9KTtcblx0XHRcdFx0XHRcdFx0eGhyLnNlbmQobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlcik7XG5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gRm9ybURhdGFcblx0XHRcdFx0XHRcdHhoci5zZW5kKGRhdGEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXG5cdC8vIEBleHBvcnRcblx0YXBpLlhIUiA9IFhIUjtcbn0pKHdpbmRvdywgRmlsZUFQSSk7XG5cbi8qKlxuICogQGNsYXNzXHRGaWxlQVBJLkNhbWVyYVxuICogQGF1dGhvclx0UnViYVhhXHQ8dHJhc2hAcnViYXhhLm9yZz5cbiAqIEBzdXBwb3J0XHRDaHJvbWUgMjErLCBGRiAxOCssIE9wZXJhIDEyK1xuICovXG5cbi8qZ2xvYmFsIHdpbmRvdywgRmlsZUFQSSwgalF1ZXJ5ICovXG4vKiogQG5hbWVzcGFjZSBMb2NhbE1lZGlhU3RyZWFtIC0tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViUlRDL01lZGlhU3RyZWFtX0FQSSNMb2NhbE1lZGlhU3RyZWFtICovXG4oZnVuY3Rpb24gKHdpbmRvdywgYXBpKXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyXG5cdFx0VVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMLFxuXG5cdFx0ZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdFx0bmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcixcblxuXHRcdGdldE1lZGlhID0gbmF2aWdhdG9yLmdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLm1zR2V0VXNlck1lZGlhLFxuXG5cdFx0aHRtbDUgPSAhIWdldE1lZGlhXG5cdDtcblxuXG5cdC8vIFN1cHBvcnQgXCJtZWRpYVwiXG5cdGFwaS5zdXBwb3J0Lm1lZGlhID0gaHRtbDU7XG5cblxuXHR2YXIgQ2FtZXJhID0gZnVuY3Rpb24gKHZpZGVvKXtcblx0XHR0aGlzLnZpZGVvID0gdmlkZW87XG5cdH07XG5cblxuXHRDYW1lcmEucHJvdG90eXBlID0ge1xuXHRcdGlzQWN0aXZlOiBmdW5jdGlvbiAoKXtcblx0XHRcdHJldHVyblx0ISF0aGlzLl9hY3RpdmU7XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogU3RhcnQgY2FtZXJhIHN0cmVhbWluZ1xuXHRcdCAqIEBwYXJhbVx0e0Z1bmN0aW9ufVx0Y2FsbGJhY2tcblx0XHQgKi9cblx0XHRzdGFydDogZnVuY3Rpb24gKGNhbGxiYWNrKXtcblx0XHRcdHZhclxuXHRcdFx0XHQgIF90aGlzID0gdGhpc1xuXHRcdFx0XHQsIHZpZGVvID0gX3RoaXMudmlkZW9cblx0XHRcdFx0LCBfc3VjY2Vzc0lkXG5cdFx0XHRcdCwgX2ZhaWxJZFxuXHRcdFx0XHQsIF9jb21wbGV0ZSA9IGZ1bmN0aW9uIChlcnIpe1xuXHRcdFx0XHRcdF90aGlzLl9hY3RpdmUgPSAhZXJyO1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dChfZmFpbElkKTtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoX3N1Y2Nlc3NJZCk7XG4vL1x0XHRcdFx0XHRhcGkuZXZlbnQub2ZmKHZpZGVvLCAnbG9hZGVkbWV0YWRhdGEnLCBfY29tcGxldGUpO1xuXHRcdFx0XHRcdGNhbGxiYWNrICYmIGNhbGxiYWNrKGVyciwgX3RoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHQ7XG5cblx0XHRcdGdldE1lZGlhLmNhbGwobmF2aWdhdG9yLCB7IHZpZGVvOiB0cnVlIH0sIGZ1bmN0aW9uIChzdHJlYW0vKipMb2NhbE1lZGlhU3RyZWFtKi8pe1xuXHRcdFx0XHQvLyBTdWNjZXNzXG5cdFx0XHRcdF90aGlzLnN0cmVhbSA9IHN0cmVhbTtcblxuLy9cdFx0XHRcdGFwaS5ldmVudC5vbih2aWRlbywgJ2xvYWRlZG1ldGFkYXRhJywgZnVuY3Rpb24gKCl7XG4vL1x0XHRcdFx0XHRfY29tcGxldGUobnVsbCk7XG4vL1x0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gU2V0IGNhbWVyYSBzdHJlYW1cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2aWRlby5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHN0cmVhbSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE5vdGU6IG9ubG9hZGVkbWV0YWRhdGEgZG9lc24ndCBmaXJlIGluIENocm9tZSB3aGVuIHVzaW5nIGl0IHdpdGggZ2V0VXNlck1lZGlhLlxuXHRcdFx0XHQvLyBTZWUgY3JidWcuY29tLzExMDkzOC5cblx0XHRcdFx0X3N1Y2Nlc3NJZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRcdGlmKCBfZGV0ZWN0VmlkZW9TaWduYWwodmlkZW8pICl7XG5cdFx0XHRcdFx0XHRfY29tcGxldGUobnVsbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCAxMDAwKTtcblxuXHRcdFx0XHRfZmFpbElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKXtcblx0XHRcdFx0XHRfY29tcGxldGUoJ3RpbWVvdXQnKTtcblx0XHRcdFx0fSwgNTAwMCk7XG5cblx0XHRcdFx0Ly8gR28tZ28tZ28hXG5cdFx0XHRcdHZpZGVvLnBsYXkoKTtcblx0XHRcdH0sIF9jb21wbGV0ZS8qZXJyb3IqLyk7XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogU3RvcCBjYW1lcmEgc3RyZWFtaW5nXG5cdFx0ICovXG5cdFx0c3RvcDogZnVuY3Rpb24gKCl7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy52aWRlby5wYXVzZSgpO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dGhpcy5zdHJlYW0uc3RvcCgpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRhcGkuZWFjaCh0aGlzLnN0cmVhbS5nZXRUcmFja3MoKSwgZnVuY3Rpb24gKHRyYWNrKSB7XG5cdFx0XHRcdFx0XHR0cmFjay5zdG9wKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnN0cmVhbSA9IG51bGw7XG5cdFx0XHR9IGNhdGNoKCBlcnIgKXtcblx0XHRcdFx0YXBpLmxvZygnW0ZpbGVBUEkuQ2FtZXJhXSBzdG9wOicsIGVycik7XG5cdFx0XHR9XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIHNjcmVlbnNob3Rcblx0XHQgKiBAcmV0dXJuIHtGaWxlQVBJLkNhbWVyYS5TaG90fVxuXHRcdCAqL1xuXHRcdHNob3Q6IGZ1bmN0aW9uICgpe1xuXHRcdFx0cmV0dXJuXHRuZXcgU2hvdCh0aGlzLnZpZGVvKTtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0ICogR2V0IGNhbWVyYSBlbGVtZW50IGZyb20gY29udGFpbmVyXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtXHR7SFRNTEVsZW1lbnR9XHRlbFxuXHQgKiBAcmV0dXJuXHR7Q2FtZXJhfVxuXHQgKi9cblx0Q2FtZXJhLmdldCA9IGZ1bmN0aW9uIChlbCl7XG5cdFx0cmV0dXJuXHRuZXcgQ2FtZXJhKGVsLmZpcnN0Q2hpbGQpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFB1Ymxpc2ggY2FtZXJhIGVsZW1lbnQgaW50byBjb250YWluZXJcblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW1cdHtIVE1MRWxlbWVudH1cdGVsXG5cdCAqIEBwYXJhbVx0e09iamVjdH1cdFx0b3B0aW9uc1xuXHQgKiBAcGFyYW1cdHtGdW5jdGlvbn1cdFx0W2NhbGxiYWNrXVxuXHQgKi9cblx0Q2FtZXJhLnB1Ymxpc2ggPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMsIGNhbGxiYWNrKXtcblx0XHRpZiggdHlwZW9mIG9wdGlvbnMgPT0gJ2Z1bmN0aW9uJyApe1xuXHRcdFx0Y2FsbGJhY2sgPSBvcHRpb25zO1xuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdH1cblxuXHRcdC8vIERpbWVuc2lvbnMgb2YgXCJjYW1lcmFcIlxuXHRcdG9wdGlvbnMgPSBhcGkuZXh0ZW5kKHt9LCB7XG5cdFx0XHQgIHdpZHRoOlx0JzEwMCUnXG5cdFx0XHQsIGhlaWdodDpcdCcxMDAlJ1xuXHRcdFx0LCBzdGFydDpcdHRydWVcblx0XHR9LCBvcHRpb25zKTtcblxuXG5cdFx0aWYoIGVsLmpxdWVyeSApe1xuXHRcdFx0Ly8gRXh0cmFjdCBmaXJzdCBlbGVtZW50LCBmcm9tIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRlbCA9IGVsWzBdO1xuXHRcdH1cblxuXG5cdFx0dmFyIGRvbmVGbiA9IGZ1bmN0aW9uIChlcnIpe1xuXHRcdFx0aWYoIGVyciApe1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIEdldCBjYW1lcmFcblx0XHRcdFx0dmFyIGNhbSA9IENhbWVyYS5nZXQoZWwpO1xuXHRcdFx0XHRpZiggb3B0aW9ucy5zdGFydCApe1xuXHRcdFx0XHRcdGNhbS5zdGFydChjYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgY2FtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblxuXHRcdGVsLnN0eWxlLndpZHRoXHQ9IF9weChvcHRpb25zLndpZHRoKTtcblx0XHRlbC5zdHlsZS5oZWlnaHRcdD0gX3B4KG9wdGlvbnMuaGVpZ2h0KTtcblxuXG5cdFx0aWYoIGFwaS5odG1sNSAmJiBodG1sNSAmJiAhYXBpLmluc2VjdXJlQ2hyb21lICl7XG5cdFx0XHQvLyBDcmVhdGUgdmlkZW8gZWxlbWVudFxuXHRcdFx0dmFyIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcblxuXHRcdFx0Ly8gU2V0IGRpbWVuc2lvbnNcblx0XHRcdHZpZGVvLnN0eWxlLndpZHRoXHQ9IF9weChvcHRpb25zLndpZHRoKTtcblx0XHRcdHZpZGVvLnN0eWxlLmhlaWdodFx0PSBfcHgob3B0aW9ucy5oZWlnaHQpO1xuXG5cdFx0XHQvLyBDbGVhbiBjb250YWluZXJcblx0XHRcdGlmKCB3aW5kb3cualF1ZXJ5ICl7XG5cdFx0XHRcdGpRdWVyeShlbCkuZW1wdHkoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsLmlubmVySFRNTCA9ICcnO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgXCJjYW1lcmFcIiB0byBjb250YWluZXJcblx0XHRcdGVsLmFwcGVuZENoaWxkKHZpZGVvKTtcblxuXHRcdFx0Ly8gZW5kXG5cdFx0XHRkb25lRm4oKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRDYW1lcmEuZmFsbGJhY2soZWwsIG9wdGlvbnMsIGRvbmVGbik7XG5cdFx0fVxuXHR9O1xuXG5cblx0Q2FtZXJhLmZhbGxiYWNrID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zLCBjYWxsYmFjayl7XG5cdFx0Y2FsbGJhY2soJ25vdF9zdXBwb3J0X2NhbWVyYScpO1xuXHR9O1xuXG5cdENhbWVyYS5jaGVja0FscmVhZHlDYXB0dXJlZCA9IChmdW5jdGlvbiAoKSB7XG5cdFx0dmFyXHRtZWRpYURldmljZXMgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLFxuXHRcdFx0TWVkaWFTdHJlYW1UcmFjayA9IHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrLFxuXHRcdFx0bmF2aWdhdG9yRW51bWVyYXRlRGV2aWNlcyA9IG5hdmlnYXRvci5lbnVtZXJhdGVEZXZpY2VzLFxuXHRcdFx0ZW51bWVyYXRlRGV2aWNlcztcblxuXHRcdGlmIChtZWRpYURldmljZXMgJiYgbWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMpIHtcblx0XHRcdGVudW1lcmF0ZURldmljZXMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdFx0bWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKS50aGVuKGNhbGxiYWNrKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmIChNZWRpYVN0cmVhbVRyYWNrICYmIE1lZGlhU3RyZWFtVHJhY2suZ2V0U291cmNlcykge1xuXHRcdFx0ZW51bWVyYXRlRGV2aWNlcyA9IE1lZGlhU3RyZWFtVHJhY2suZ2V0U291cmNlcy5iaW5kKE1lZGlhU3RyZWFtVHJhY2spO1xuXHRcdH0gZWxzZSBpZiAobmF2aWdhdG9yRW51bWVyYXRlRGV2aWNlcykge1xuXHRcdFx0ZW51bWVyYXRlRGV2aWNlcyA9IG5hdmlnYXRvckVudW1lcmF0ZURldmljZXMuYmluZChuYXZpZ2F0b3IpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbnVtZXJhdGVEZXZpY2VzID0gZnVuY3Rpb24gKGZuKSB7XG5cdFx0XHRcdGZuKFtdKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0ZW51bWVyYXRlRGV2aWNlcyhmdW5jdGlvbiAoZGV2aWNlcykge1xuXHRcdFx0XHR2YXIgZGV2aWNlRXhpc3RzID0gZGV2aWNlcy5zb21lKGZ1bmN0aW9uIChkZXZpY2UpIHtcblx0XHRcdFx0XHRyZXR1cm4gKGRldmljZS5raW5kID09PSAndmlkZW9pbnB1dCcgfHwgZGV2aWNlLmtpbmQgPT09ICd2aWRlbycpICYmIGRldmljZS5sYWJlbDtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Y2FsbGJhY2soZGV2aWNlRXhpc3RzKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0fSkoKTtcblxuXG5cdC8qKlxuXHQgKiBAY2xhc3NcdEZpbGVBUEkuQ2FtZXJhLlNob3Rcblx0ICovXG5cdHZhciBTaG90ID0gZnVuY3Rpb24gKHZpZGVvKXtcblx0XHR2YXIgY2FudmFzXHQ9IHZpZGVvLm5vZGVOYW1lID8gYXBpLkltYWdlLnRvQ2FudmFzKHZpZGVvKSA6IHZpZGVvO1xuXHRcdHZhciBzaG90XHQ9IGFwaS5JbWFnZShjYW52YXMpO1xuXHRcdHNob3QudHlwZVx0PSAnaW1hZ2UvcG5nJztcblx0XHRzaG90LndpZHRoXHQ9IGNhbnZhcy53aWR0aDtcblx0XHRzaG90LmhlaWdodFx0PSBjYW52YXMuaGVpZ2h0O1xuXHRcdHNob3Quc2l6ZVx0PSBjYW52YXMud2lkdGggKiBjYW52YXMuaGVpZ2h0ICogNDtcblx0XHRyZXR1cm5cdHNob3Q7XG5cdH07XG5cblxuXHQvKipcblx0ICogQWRkIFwicHhcIiBwb3N0Zml4LCBpZiB2YWx1ZSBpcyBhIG51bWJlclxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW1cdHsqfSAgdmFsXG5cdCAqIEByZXR1cm5cdHtTdHJpbmd9XG5cdCAqL1xuXHRmdW5jdGlvbiBfcHgodmFsKXtcblx0XHRyZXR1cm5cdHZhbCA+PSAwID8gdmFsICsgJ3B4JyA6IHZhbDtcblx0fVxuXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbVx0e0hUTUxWaWRlb0VsZW1lbnR9IHZpZGVvXG5cdCAqIEByZXR1cm5cdHtCb29sZWFufVxuXHQgKi9cblx0ZnVuY3Rpb24gX2RldGVjdFZpZGVvU2lnbmFsKHZpZGVvKXtcblx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyksIGN0eCwgcmVzID0gZmFsc2U7XG5cdFx0dHJ5IHtcblx0XHRcdGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdFx0Y3R4LmRyYXdJbWFnZSh2aWRlbywgMCwgMCwgMSwgMSk7XG5cdFx0XHRyZXMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGFbNF0gIT0gMjU1O1xuXHRcdH1cblx0XHRjYXRjaCggZXJyICl7XG5cdFx0XHRhcGkubG9nKCdbRmlsZUFQSS5DYW1lcmFdIGRldGVjdFZpZGVvU2lnbmFsOicsIGVycik7XG5cdFx0fVxuXHRcdHJldHVyblx0cmVzO1xuXHR9XG5cblxuXHQvLyBAZXhwb3J0XG5cdENhbWVyYS5TaG90XHQ9IFNob3Q7XG5cdGFwaS5DYW1lcmFcdD0gQ2FtZXJhO1xufSkod2luZG93LCBGaWxlQVBJKTtcblxuLyoqXG4gKiBGaWxlQVBJIGZhbGxiYWNrIHRvIEZsYXNoXG4gKlxuICogQGZsYXNoLWRldmVsb3BlciAgXCJWbGFkaW1pciBEZW1pZG92XCIgPHYuZGVtaWRvdkBjb3JwLm1haWwucnU+XG4gKi9cblxuLypnbG9iYWwgd2luZG93LCBBY3RpdmVYT2JqZWN0LCBGaWxlQVBJICovXG4oZnVuY3Rpb24gKHdpbmRvdywgalF1ZXJ5LCBhcGkpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyXG5cdFx0ICBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudFxuXHRcdCwgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb25cblx0XHQsIG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3Jcblx0XHQsIF9lYWNoID0gYXBpLmVhY2hcblx0O1xuXG5cblx0YXBpLnN1cHBvcnQuZmxhc2ggPSAoZnVuY3Rpb24gKCl7XG5cdFx0dmFyIG1pbWUgPSBuYXZpZ2F0b3IubWltZVR5cGVzLCBoYXMgPSBmYWxzZTtcblxuXHRcdGlmKCBuYXZpZ2F0b3IucGx1Z2lucyAmJiB0eXBlb2YgbmF2aWdhdG9yLnBsdWdpbnNbJ1Nob2Nrd2F2ZSBGbGFzaCddID09ICdvYmplY3QnICl7XG5cdFx0XHRoYXNcdD0gbmF2aWdhdG9yLnBsdWdpbnNbJ1Nob2Nrd2F2ZSBGbGFzaCddLmRlc2NyaXB0aW9uICYmICEobWltZSAmJiBtaW1lWydhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCddICYmICFtaW1lWydhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCddLmVuYWJsZWRQbHVnaW4pO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGhhc1x0PSAhISh3aW5kb3cuQWN0aXZlWE9iamVjdCAmJiBuZXcgQWN0aXZlWE9iamVjdCgnU2hvY2t3YXZlRmxhc2guU2hvY2t3YXZlRmxhc2gnKSk7XG5cdFx0XHR9XG5cdFx0XHRjYXRjaChlcil7XG5cdFx0XHRcdGFwaS5sb2coJ0ZsYXNoIC0tIGRvZXMgbm90IHN1cHBvcnRlZC4nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiggaGFzICYmIC9eZmlsZTovaS50ZXN0KGxvY2F0aW9uKSApe1xuXHRcdFx0YXBpLmxvZygnW3dhcm5dIEZsYXNoIGRvZXMgbm90IHdvcmsgb24gYGZpbGU6YCBwcm90b2NvbC4nKTtcblx0XHR9XG5cblx0XHRyZXR1cm5cdGhhcztcblx0fSkoKTtcblxuXG5cdCAgIGFwaS5zdXBwb3J0LmZsYXNoXG5cdCYmICgwXG5cdFx0fHwgIWFwaS5odG1sNSB8fCAhYXBpLnN1cHBvcnQuaHRtbDVcblx0XHR8fCAoYXBpLmNvcnMgJiYgIWFwaS5zdXBwb3J0LmNvcnMpXG5cdFx0fHwgKGFwaS5tZWRpYSAmJiAhYXBpLnN1cHBvcnQubWVkaWEpXG5cdFx0fHwgYXBpLmluc2VjdXJlQ2hyb21lXG5cdClcblx0JiYgKGZ1bmN0aW9uICgpe1xuXHRcdHZhclxuXHRcdFx0ICBfYXR0ciAgPSBhcGkudWlkKClcblx0XHRcdCwgX3JldHJ5ID0gMFxuXHRcdFx0LCBfZmlsZXMgPSB7fVxuXHRcdFx0LCBfcmh0dHAgPSAvXmh0dHBzPzovaVxuXG5cdFx0XHQsIGZsYXNoID0ge1xuXHRcdFx0XHRfZm46IHt9LFxuXG5cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEluaXRpYWxpemF0aW9uICYgcHJlbG9hZCBmbGFzaCBvYmplY3Rcblx0XHRcdFx0ICovXG5cdFx0XHRcdGluaXQ6IGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRcdHZhciBjaGlsZCA9IGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5maXJzdENoaWxkO1xuXG5cdFx0XHRcdFx0aWYoIGNoaWxkICl7XG5cdFx0XHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0XHRcdGlmKCBjaGlsZC5ub2RlVHlwZSA9PSAxICl7XG5cdFx0XHRcdFx0XHRcdFx0YXBpLmxvZygnRmxhc2hBUEkuc3RhdGU6IGF3YWl0aW5nJyk7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuXHRcdFx0XHRcdFx0XHRcdGR1bW15LmlkID0gJ18nICsgX2F0dHI7XG5cblx0XHRcdFx0XHRcdFx0XHRfY3NzKGR1bW15LCB7XG5cdFx0XHRcdFx0XHRcdFx0XHQgIHRvcDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0LCByaWdodDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0LCB3aWR0aDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0LCBoZWlnaHQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdCwgcG9zaXRpb246ICdhYnNvbHV0ZSdcblx0XHRcdFx0XHRcdFx0XHRcdCwgekluZGV4OiAyMTQ3NDgzNjQ3KycnIC8vIHNldCBtYXggekluZGV4XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjaGlsZC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkdW1teSwgY2hpbGQpO1xuXHRcdFx0XHRcdFx0XHRcdGZsYXNoLnB1Ymxpc2goZHVtbXksIF9hdHRyKTtcblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0d2hpbGUoIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiggX3JldHJ5IDwgMTAgKXtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZmxhc2guaW5pdCwgKytfcmV0cnkqNTApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBQdWJsaXNoIGZsYXNoLW9iamVjdFxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuXHRcdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gaWRcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuXHRcdFx0XHQgKi9cblx0XHRcdFx0cHVibGlzaDogZnVuY3Rpb24gKGVsLCBpZCwgb3B0cyl7XG5cdFx0XHRcdFx0b3B0cyA9IG9wdHMgfHwge307XG5cdFx0XHRcdFx0ZWwuaW5uZXJIVE1MID0gX21ha2VGbGFzaEhUTUwoe1xuXHRcdFx0XHRcdFx0ICBpZDogaWRcblx0XHRcdFx0XHRcdCwgc3JjOiBfZ2V0VXJsKGFwaS5mbGFzaFVybCwgJ3I9JyArIGFwaS52ZXJzaW9uKVxuLy9cdFx0XHRcdFx0XHQsIHNyYzogX2dldFVybCgnaHR0cDovL3YuZGVtaWRvdi5ib29tLmNvcnAubWFpbC5ydS91cGxvYWRlcmZpbGVhcGkvRmxhc2hGaWxlQVBJLnN3Zj8xJylcblx0XHRcdFx0XHRcdCwgd21vZGU6IG9wdHMuY2FtZXJhID8gJycgOiAndHJhbnNwYXJlbnQnXG5cdFx0XHRcdFx0XHQsIGZsYXNodmFyczogJ2NhbGxiYWNrPScgKyAob3B0cy5vbkV2ZW50IHx8ICdGaWxlQVBJLkZsYXNoLm9uRXZlbnQnKVxuXHRcdFx0XHRcdFx0XHQrICcmZmxhc2hJZD0nKyBpZFxuXHRcdFx0XHRcdFx0XHQrICcmc3RvcmVLZXk9JysgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvXFxkL2lnKS5qb2luKCcnKSArJ18nKyBhcGkudmVyc2lvblxuXHRcdFx0XHRcdFx0XHQrIChmbGFzaC5pc1JlYWR5IHx8IChhcGkucGluZ1VybCA/ICcmcGluZz0nK2FwaS5waW5nVXJsIDogJycpKVxuXHRcdFx0XHRcdFx0XHQrICcmdGltZW91dD0nK2FwaS5mbGFzaEFib3J0VGltZW91dFxuXHRcdFx0XHRcdFx0XHQrIChvcHRzLmNhbWVyYSA/ICcmdXNlQ2FtZXJhPScgKyBfZ2V0VXJsKGFwaS5mbGFzaFdlYmNhbVVybCkgOiAnJylcblx0XHRcdFx0XHRcdFx0KyAnJmRlYnVnPScrKGFwaS5kZWJ1Zz9cIjFcIjpcIlwiKVxuXHRcdFx0XHRcdH0sIG9wdHMpO1xuXHRcdFx0XHR9LFxuXG5cblx0XHRcdFx0cmVhZHk6IGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRcdGFwaS5sb2coJ0ZsYXNoQVBJLnN0YXRlOiByZWFkeScpO1xuXG5cdFx0XHRcdFx0Zmxhc2gucmVhZHkgPSBhcGkuRjtcblx0XHRcdFx0XHRmbGFzaC5pc1JlYWR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRmbGFzaC5wYXRjaCgpO1xuXHRcdFx0XHRcdGZsYXNoLnBhdGNoQ2FtZXJhICYmIGZsYXNoLnBhdGNoQ2FtZXJhKCk7XG5cdFx0XHRcdFx0YXBpLmV2ZW50Lm9uKGRvY3VtZW50LCAnbW91c2VvdmVyJywgZmxhc2gubW91c2VvdmVyKTtcblx0XHRcdFx0XHRhcGkuZXZlbnQub24oZG9jdW1lbnQsICdjbGljaycsIGZ1bmN0aW9uIChldnQpe1xuXHRcdFx0XHRcdFx0aWYoIGZsYXNoLm1vdXNlb3ZlcihldnQpICl7XG5cdFx0XHRcdFx0XHRcdGV2dC5wcmV2ZW50RGVmYXVsdFxuXHRcdFx0XHRcdFx0XHRcdD8gZXZ0LnByZXZlbnREZWZhdWx0KClcblx0XHRcdFx0XHRcdFx0XHQ6IChldnQucmV0dXJuVmFsdWUgPSB0cnVlKVxuXHRcdFx0XHRcdFx0XHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0sXG5cblxuXHRcdFx0XHRnZXRFbDogZnVuY3Rpb24gKCl7XG5cdFx0XHRcdFx0cmV0dXJuXHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnXycrX2F0dHIpO1xuXHRcdFx0XHR9LFxuXG5cblx0XHRcdFx0Z2V0V3JhcHBlcjogZnVuY3Rpb24gKG5vZGUpe1xuXHRcdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRcdGlmKCAvanMtZmlsZWFwaS13cmFwcGVyLy50ZXN0KG5vZGUuY2xhc3NOYW1lKSApe1xuXHRcdFx0XHRcdFx0XHRyZXR1cm5cdG5vZGU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlKCAobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkgJiYgKG5vZGUgIT09IGRvY3VtZW50LmJvZHkpICk7XG5cdFx0XHRcdH0sXG5cblxuXHRcdFx0XHRtb3VzZW92ZXI6IGZ1bmN0aW9uIChldnQpe1xuXHRcdFx0XHRcdHZhciB0YXJnZXQgPSBhcGkuZXZlbnQuZml4KGV2dCkudGFyZ2V0O1xuXG5cdFx0XHRcdFx0aWYoIC9pbnB1dC9pLnRlc3QodGFyZ2V0Lm5vZGVOYW1lKSAmJiB0YXJnZXQudHlwZSA9PSAnZmlsZScgJiYgIXRhcmdldC5kaXNhYmxlZCApe1xuXHRcdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0XHRcdCAgc3RhdGUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKF9hdHRyKVxuXHRcdFx0XHRcdFx0XHQsIHdyYXBwZXIgPSBmbGFzaC5nZXRXcmFwcGVyKHRhcmdldClcblx0XHRcdFx0XHRcdDtcblxuXHRcdFx0XHRcdFx0aWYoIGFwaS5tdWx0aUZsYXNoICl7XG5cdFx0XHRcdFx0XHRcdC8vIGNoZWNrIHN0YXRlOlxuXHRcdFx0XHRcdFx0XHQvLyAgIHAg4oCUIHB1Ymxpc2hlZFxuXHRcdFx0XHRcdFx0XHQvLyAgIGkg4oCUIGluaXRpYWxpemF0aW9uXG5cdFx0XHRcdFx0XHRcdC8vICAgciDigJQgcmVhZHlcblx0XHRcdFx0XHRcdFx0aWYoIHN0YXRlID09ICdpJyB8fCBzdGF0ZSA9PSAncicgKXtcblx0XHRcdFx0XHRcdFx0XHQvLyBwdWJsaXNoIGZhaWxcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm5cdGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYoIHN0YXRlICE9ICdwJyApe1xuXHRcdFx0XHRcdFx0XHRcdC8vIHNldCBcImluaXRcIiBzdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoX2F0dHIsICdpJyk7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmKCAhd3JhcHBlciApe1xuXHRcdFx0XHRcdFx0XHRcdFx0YXBpLmxvZygnW2Vycl0gRmxhc2hBUEkubW91c2VvdmVyOiBqcy1maWxlYXBpLXdyYXBwZXIgbm90IGZvdW5kJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0X2NzcyhkdW1teSwge1xuXHRcdFx0XHRcdFx0XHRcdFx0ICB0b3A6ICAgIDBcblx0XHRcdFx0XHRcdFx0XHRcdCwgbGVmdDogICAwXG5cdFx0XHRcdFx0XHRcdFx0XHQsIHdpZHRoOiAgdGFyZ2V0Lm9mZnNldFdpZHRoXG5cdFx0XHRcdFx0XHRcdFx0XHQsIGhlaWdodDogdGFyZ2V0Lm9mZnNldEhlaWdodFxuXHRcdFx0XHRcdFx0XHRcdFx0LCB6SW5kZXg6IDIxNDc0ODM2NDcrJycgLy8gc2V0IG1heCB6SW5kZXhcblx0XHRcdFx0XHRcdFx0XHRcdCwgcG9zaXRpb246ICdhYnNvbHV0ZSdcblx0XHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHRcdHdyYXBwZXIuYXBwZW5kQ2hpbGQoZHVtbXkpO1xuXHRcdFx0XHRcdFx0XHRcdGZsYXNoLnB1Ymxpc2goZHVtbXksIGFwaS51aWQoKSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBzZXQgXCJwdWJsaXNoXCIgc3RhdGVcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXQuc2V0QXR0cmlidXRlKF9hdHRyLCAncCcpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuXHR0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiggd3JhcHBlciApe1xuXHRcdFx0XHRcdFx0XHQvLyBVc2Ugb25lIGZsYXNoIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0dmFyIGJveCA9IF9nZXREaW1lbnNpb25zKHdyYXBwZXIpO1xuXG5cdFx0XHRcdFx0XHRcdF9jc3MoZmxhc2guZ2V0RWwoKSwgYm94KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZXQgY3VycmVudCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRmbGFzaC5jdXJJbnAgPSB0YXJnZXQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYoICEvb2JqZWN0fGVtYmVkL2kudGVzdCh0YXJnZXQubm9kZU5hbWUpICl7XG5cdFx0XHRcdFx0XHRfY3NzKGZsYXNoLmdldEVsKCksIHsgdG9wOiAxLCBsZWZ0OiAxLCB3aWR0aDogNSwgaGVpZ2h0OiA1IH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRvbkV2ZW50OiBmdW5jdGlvbiAoZXZ0KXtcblx0XHRcdFx0XHR2YXIgdHlwZSA9IGV2dC50eXBlO1xuXG5cdFx0XHRcdFx0aWYoIHR5cGUgPT0gJ3JlYWR5JyApe1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0Ly8gc2V0IFwicmVhZHlcIiBzdGF0ZVxuXHRcdFx0XHRcdFx0XHRmbGFzaC5nZXRJbnB1dChldnQuZmxhc2hJZCkuc2V0QXR0cmlidXRlKF9hdHRyLCAncicpO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZSl7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGZsYXNoLnJlYWR5KCk7XG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpeyBmbGFzaC5tb3VzZWVudGVyKGV2dCk7IH0sIDUwKTtcblx0XHRcdFx0XHRcdHJldHVyblx0dHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiggdHlwZSA9PT0gJ3BpbmcnICl7XG5cdFx0XHRcdFx0XHRhcGkubG9nKCcoZmxhc2ggLT4ganMpLnBpbmc6JywgW2V2dC5zdGF0dXMsIGV2dC5zYXZlZFN0YXR1c10sIGV2dC5lcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYoIHR5cGUgPT09ICdsb2cnICl7XG5cdFx0XHRcdFx0XHRhcGkubG9nKCcoZmxhc2ggLT4ganMpLmxvZzonLCBldnQudGFyZ2V0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiggdHlwZSBpbiBmbGFzaCApe1xuXHRcdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKXtcblx0XHRcdFx0XHRcdFx0YXBpLmxvZygnRmxhc2hBUEkuZXZlbnQuJytldnQudHlwZSsnOicsIGV2dCk7XG5cdFx0XHRcdFx0XHRcdGZsYXNoW3R5cGVdKGV2dCk7XG5cdFx0XHRcdFx0XHR9LCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblxuXHRcdFx0XHRtb3VzZWVudGVyOiBmdW5jdGlvbiAoZXZ0KXtcblx0XHRcdFx0XHR2YXIgbm9kZSA9IGZsYXNoLmdldElucHV0KGV2dC5mbGFzaElkKTtcblxuXHRcdFx0XHRcdGlmKCBub2RlICl7XG5cdFx0XHRcdFx0XHQvLyBTZXQgbXVsdGlwbGUgbW9kZVxuXHRcdFx0XHRcdFx0Zmxhc2guY21kKGV2dCwgJ211bHRpcGxlJywgbm9kZS5nZXRBdHRyaWJ1dGUoJ211bHRpcGxlJykgIT0gbnVsbCk7XG5cblxuXHRcdFx0XHRcdFx0Ly8gU2V0IGZpbGVzIGZpbHRlclxuXHRcdFx0XHRcdFx0dmFyIGFjY2VwdCA9IFtdLCBleHRzID0ge307XG5cblx0XHRcdFx0XHRcdF9lYWNoKChub2RlLmdldEF0dHJpYnV0ZSgnYWNjZXB0JykgfHwgJycpLnNwbGl0KC8sXFxzKi8pLCBmdW5jdGlvbiAobWltZSl7XG5cdFx0XHRcdFx0XHRcdGFwaS5hY2NlcHRbbWltZV0gJiYgX2VhY2goYXBpLmFjY2VwdFttaW1lXS5zcGxpdCgnICcpLCBmdW5jdGlvbiAoZXh0KXtcblx0XHRcdFx0XHRcdFx0XHRleHRzW2V4dF0gPSAxO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRfZWFjaChleHRzLCBmdW5jdGlvbiAoaSwgZXh0KXtcblx0XHRcdFx0XHRcdFx0YWNjZXB0LnB1c2goIGV4dCApO1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdGZsYXNoLmNtZChldnQsICdhY2NlcHQnLCBhY2NlcHQubGVuZ3RoID8gYWNjZXB0LmpvaW4oJywnKSsnLCcrYWNjZXB0LmpvaW4oJywnKS50b1VwcGVyQ2FzZSgpIDogJyonKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblxuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uIChpZCl7XG5cdFx0XHRcdFx0cmV0dXJuXHRkb2N1bWVudFtpZF0gfHwgd2luZG93W2lkXSB8fCBkb2N1bWVudC5lbWJlZHNbaWRdO1xuXHRcdFx0XHR9LFxuXG5cblx0XHRcdFx0Z2V0SW5wdXQ6IGZ1bmN0aW9uIChpZCl7XG5cdFx0XHRcdFx0aWYoIGFwaS5tdWx0aUZsYXNoICl7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbm9kZSA9IGZsYXNoLmdldFdyYXBwZXIoZmxhc2guZ2V0KGlkKSk7XG5cdFx0XHRcdFx0XHRcdGlmKCBub2RlICl7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0JylbMF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGUpe1xuXHRcdFx0XHRcdFx0XHRhcGkubG9nKCdbZXJyXSBDYW4gbm90IGZpbmQgXCJpbnB1dFwiIGJ5IGZsYXNoSWQ6JywgaWQsIGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm5cdGZsYXNoLmN1cklucDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblxuXHRcdFx0XHRzZWxlY3Q6IGZ1bmN0aW9uIChldnQpe1xuXHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdFx0ICBpbnAgPSBmbGFzaC5nZXRJbnB1dChldnQuZmxhc2hJZClcblx0XHRcdFx0XHRcdCwgdWlkID0gYXBpLnVpZChpbnApXG5cdFx0XHRcdFx0XHQsIGZpbGVzID0gZXZ0LnRhcmdldC5maWxlc1xuXHRcdFx0XHRcdFx0LCBldmVudFxuXHRcdFx0XHRcdDtcblxuXHRcdFx0XHRcdF9lYWNoKGZpbGVzLCBmdW5jdGlvbiAoZmlsZSl7XG5cdFx0XHRcdFx0XHRhcGkuY2hlY2tGaWxlT2JqKGZpbGUpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0X2ZpbGVzW3VpZF0gPSBmaWxlcztcblxuXHRcdFx0XHRcdGlmKCBkb2N1bWVudC5jcmVhdGVFdmVudCApe1xuXHRcdFx0XHRcdFx0ZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcblx0XHRcdFx0XHRcdGV2ZW50LmZpbGVzID0gZmlsZXM7XG5cdFx0XHRcdFx0XHRldmVudC5pbml0RXZlbnQoJ2NoYW5nZScsIHRydWUsIHRydWUpO1xuXHRcdFx0XHRcdFx0aW5wLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmKCBqUXVlcnkgKXtcblx0XHRcdFx0XHRcdGpRdWVyeShpbnApLnRyaWdnZXIoeyB0eXBlOiAnY2hhbmdlJywgZmlsZXM6IGZpbGVzIH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTtcblx0XHRcdFx0XHRcdGV2ZW50LmZpbGVzID0gZmlsZXM7XG5cdFx0XHRcdFx0XHRpbnAuZmlyZUV2ZW50KCdvbmNoYW5nZScsIGV2ZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblxuXHRcdFx0XHRjbWQ6IGZ1bmN0aW9uIChpZCwgbmFtZSwgZGF0YSwgbGFzdCl7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGFwaS5sb2coJyhqcyAtPiBmbGFzaCkuJytuYW1lKyc6JywgZGF0YSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmxhc2guZ2V0KGlkLmZsYXNoSWQgfHwgaWQpLmNtZChuYW1lLCBkYXRhKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlcnIpe1xuXHRcdFx0XHRcdFx0YXBpLmxvZygnKGpzIC0+IGZsYXNoKS5vbkVycm9yOicsIGVyci50b1N0cmluZygpKTtcblx0XHRcdFx0XHRcdGlmKCAhbGFzdCApe1xuXHRcdFx0XHRcdFx0XHQvLyB0cnkgYWdhaW5cblx0XHRcdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKXsgZmxhc2guY21kKGlkLCBuYW1lLCBkYXRhLCB0cnVlKTsgfSwgNTApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXG5cdFx0XHRcdHBhdGNoOiBmdW5jdGlvbiAoKXtcblx0XHRcdFx0XHRhcGkuZmxhc2hFbmdpbmUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Ly8gRmlsZUFQSVxuXHRcdFx0XHRcdF9pbmhlcml0KGFwaSwge1xuXHRcdFx0XHRcdFx0Z2V0RmlsZXM6IGZ1bmN0aW9uIChpbnB1dCwgZmlsdGVyLCBjYWxsYmFjayl7XG5cdFx0XHRcdFx0XHRcdGlmKCBjYWxsYmFjayApe1xuXHRcdFx0XHRcdFx0XHRcdGFwaS5maWx0ZXJGaWxlcyhhcGkuZ2V0RmlsZXMoaW5wdXQpLCBmaWx0ZXIsIGNhbGxiYWNrKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHZhciBmaWxlcyA9IGFwaS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogX2ZpbGVzW2FwaS51aWQoaW5wdXQudGFyZ2V0IHx8IGlucHV0LnNyY0VsZW1lbnQgfHwgaW5wdXQpXTtcblxuXG5cdFx0XHRcdFx0XHRcdGlmKCAhZmlsZXMgKXtcblx0XHRcdFx0XHRcdFx0XHQvLyDQpNCw0LnQu9C+0LIg0L3QtdGC0YMsINCy0YvQt9GL0LLQsNC10Lwg0YDQvtC00LjRgtC10LvRjNGB0LrQuNC5INC80LXRgtC+0LRcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm5cdHRoaXMucGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdFx0XHRcdGlmKCBmaWx0ZXIgKXtcblx0XHRcdFx0XHRcdFx0XHRmaWx0ZXJcdD0gYXBpLmdldEZpbGVzRmlsdGVyKGZpbHRlcik7XG5cdFx0XHRcdFx0XHRcdFx0ZmlsZXNcdD0gYXBpLmZpbHRlcihmaWxlcywgZnVuY3Rpb24gKGZpbGUpeyByZXR1cm4gZmlsdGVyLnRlc3QoZmlsZS5uYW1lKTsgfSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRyZXR1cm5cdGZpbGVzO1xuXHRcdFx0XHRcdFx0fSxcblxuXG5cdFx0XHRcdFx0XHRnZXRJbmZvOiBmdW5jdGlvbiAoZmlsZSwgZm4pe1xuXHRcdFx0XHRcdFx0XHRpZiggX2lzSHRtbEZpbGUoZmlsZSkgKXtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnBhcmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYoIGZpbGUuaXNTaG90ICl7XG5cdFx0XHRcdFx0XHRcdFx0Zm4obnVsbCwgZmlsZS5pbmZvID0ge1xuXHRcdFx0XHRcdFx0XHRcdFx0d2lkdGg6IGZpbGUud2lkdGgsXG5cdFx0XHRcdFx0XHRcdFx0XHRoZWlnaHQ6IGZpbGUuaGVpZ2h0XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYoICFmaWxlLl9faW5mbyApe1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGRlZmVyID0gZmlsZS5fX2luZm8gPSBhcGkuZGVmZXIoKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Zmxhc2guY21kKGZpbGUsICdnZXRGaWxlSW5mbycsIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ICBpZDogZmlsZS5pZFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQsIGNhbGxiYWNrOiBfd3JhcChmdW5jdGlvbiBfKGVyciwgaW5mbyl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0X3Vud3JhcChfKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlci5yZXNvbHZlKGVyciwgZmlsZS5pbmZvID0gaW5mbyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRmaWxlLl9faW5mby50aGVuKGZuKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXG5cblx0XHRcdFx0XHQvLyBGaWxlQVBJLkltYWdlXG5cdFx0XHRcdFx0YXBpLnN1cHBvcnQudHJhbnNmb3JtID0gdHJ1ZTtcblx0XHRcdFx0XHRhcGkuSW1hZ2UgJiYgX2luaGVyaXQoYXBpLkltYWdlLnByb3RvdHlwZSwge1xuXHRcdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoZm4sIHNjYWxlTW9kZSl7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0KHsgc2NhbGVNb2RlOiBzY2FsZU1vZGUgfHwgJ25vU2NhbGUnIH0pOyAvLyBub1NjYWxlLCBleGFjdEZpdFxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoZm4pO1xuXHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0X2xvYWQ6IGZ1bmN0aW9uIChmaWxlLCBmbil7XG5cdFx0XHRcdFx0XHRcdGFwaS5sb2coJ0ZsYXNoQVBJLkltYWdlLl9sb2FkOicsIGZpbGUpO1xuXG5cdFx0XHRcdFx0XHRcdGlmKCBfaXNIdG1sRmlsZShmaWxlKSApe1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRcdFx0XHRcdFx0XHRhcGkuZ2V0SW5mbyhmaWxlLCBmdW5jdGlvbiAoZXJyKXtcblx0XHRcdFx0XHRcdFx0XHRcdGZuLmNhbGwoX3RoaXMsIGVyciwgZmlsZSk7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdF9hcHBseTogZnVuY3Rpb24gKGZpbGUsIGZuKXtcblx0XHRcdFx0XHRcdFx0YXBpLmxvZygnRmxhc2hBUEkuSW1hZ2UuX2FwcGx5OicsIGZpbGUpO1xuXG5cdFx0XHRcdFx0XHRcdGlmKCBfaXNIdG1sRmlsZShmaWxlKSApe1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIG0gPSB0aGlzLmdldE1hdHJpeChmaWxlLmluZm8pLCBkb25lRm4gPSBmbjtcblxuXHRcdFx0XHRcdFx0XHRcdGZsYXNoLmNtZChmaWxlLCAnaW1hZ2VUcmFuc2Zvcm0nLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHQgIGlkOiBmaWxlLmlkXG5cdFx0XHRcdFx0XHRcdFx0XHQsIG1hdHJpeDogbVxuXHRcdFx0XHRcdFx0XHRcdFx0LCBjYWxsYmFjazogX3dyYXAoZnVuY3Rpb24gXyhlcnIsIGJhc2U2NCl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFwaS5sb2coJ0ZsYXNoQVBJLkltYWdlLl9hcHBseS5jYWxsYmFjazonLCBlcnIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRfdW53cmFwKF8pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKCBlcnIgKXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkb25lRm4oZXJyKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbHNlIGlmKCAhYXBpLnN1cHBvcnQuaHRtbDUgJiYgKCFhcGkuc3VwcG9ydC5kYXRhVVJJIHx8IGJhc2U2NC5sZW5ndGggPiAzZTQpICl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0X21ha2VGbGFzaEltYWdlKHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgd2lkdGg6XHQobS5kZWcgJSAxODApID8gbS5kaCA6IG0uZHdcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCwgaGVpZ2h0Olx0KG0uZGVnICUgMTgwKSA/IG0uZHcgOiBtLmRoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQsIHNjYWxlOlx0bS5zY2FsZU1vZGVcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LCBiYXNlNjQsIGRvbmVGbik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoIG0uZmlsdGVyICl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkb25lRm4gPSBmdW5jdGlvbiAoZXJyLCBpbWcpe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiggZXJyICl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4oZXJyKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcGkuSW1hZ2UuYXBwbHlGaWx0ZXIoaW1nLCBtLmZpbHRlciwgZnVuY3Rpb24gKCl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmbihlcnIsIHRoaXMuY2FudmFzKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcGkubmV3SW1hZ2UoJ2RhdGE6JysgZmlsZS50eXBlICsnO2Jhc2U2NCwnKyBiYXNlNjQsIGRvbmVGbik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdHRvRGF0YTogZnVuY3Rpb24gKGZuKXtcblx0XHRcdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0XHRcdFx0ICBmaWxlID0gdGhpcy5maWxlXG5cdFx0XHRcdFx0XHRcdFx0LCBpbmZvID0gZmlsZS5pbmZvXG5cdFx0XHRcdFx0XHRcdFx0LCBtYXRyaXggPSB0aGlzLmdldE1hdHJpeChpbmZvKVxuXHRcdFx0XHRcdFx0XHQ7XG5cdFx0XHRcdFx0XHRcdGFwaS5sb2coJ0ZsYXNoQVBJLkltYWdlLnRvRGF0YScpO1xuXG5cdFx0XHRcdFx0XHRcdGlmKCBfaXNIdG1sRmlsZShmaWxlKSApe1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYoIG1hdHJpeC5kZWcgPT0gJ2F1dG8nICl7XG5cdFx0XHRcdFx0XHRcdFx0XHRtYXRyaXguZGVnID0gYXBpLkltYWdlLmV4aWZPcmllbnRhdGlvbltpbmZvICYmIGluZm8uZXhpZiAmJiBpbmZvLmV4aWYuT3JpZW50YXRpb25dIHx8IDA7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Zm4uY2FsbCh0aGlzLCAhZmlsZS5pbmZvLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHQgIGlkOlx0XHRmaWxlLmlkXG5cdFx0XHRcdFx0XHRcdFx0XHQsIGZsYXNoSWQ6XHRmaWxlLmZsYXNoSWRcblx0XHRcdFx0XHRcdFx0XHRcdCwgbmFtZTpcdFx0ZmlsZS5uYW1lXG5cdFx0XHRcdFx0XHRcdFx0XHQsIHR5cGU6XHRcdGZpbGUudHlwZVxuXHRcdFx0XHRcdFx0XHRcdFx0LCBtYXRyaXg6XHRtYXRyaXhcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXG5cblx0XHRcdFx0XHRhcGkuSW1hZ2UgJiYgX2luaGVyaXQoYXBpLkltYWdlLCB7XG5cdFx0XHRcdFx0XHRmcm9tRGF0YVVSTDogZnVuY3Rpb24gKGRhdGFVUkwsIHNpemUsIGNhbGxiYWNrKXtcblx0XHRcdFx0XHRcdFx0aWYoICFhcGkuc3VwcG9ydC5kYXRhVVJJIHx8IGRhdGFVUkwubGVuZ3RoID4gM2U0ICl7XG5cdFx0XHRcdFx0XHRcdFx0X21ha2VGbGFzaEltYWdlKFxuXHRcdFx0XHRcdFx0XHRcdFx0ICBhcGkuZXh0ZW5kKHsgc2NhbGU6ICdleGFjdEZpdCcgfSwgc2l6ZSlcblx0XHRcdFx0XHRcdFx0XHRcdCwgZGF0YVVSTC5yZXBsYWNlKC9eZGF0YTpbXixdKywvLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdCwgZnVuY3Rpb24gKGVyciwgZWwpeyBjYWxsYmFjayhlbCk7IH1cblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucGFyZW50KGRhdGFVUkwsIHNpemUsIGNhbGxiYWNrKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Ly8gRmlsZUFQSS5Gb3JtXG5cdFx0XHRcdFx0X2luaGVyaXQoYXBpLkZvcm0ucHJvdG90eXBlLCB7XG5cdFx0XHRcdFx0XHR0b0RhdGE6IGZ1bmN0aW9uIChmbil7XG5cdFx0XHRcdFx0XHRcdHZhciBpdGVtcyA9IHRoaXMuaXRlbXMsIGkgPSBpdGVtcy5sZW5ndGg7XG5cblx0XHRcdFx0XHRcdFx0Zm9yKCA7IGktLTsgKXtcblx0XHRcdFx0XHRcdFx0XHRpZiggaXRlbXNbaV0uZmlsZSAmJiBfaXNIdG1sRmlsZShpdGVtc1tpXS5ibG9iKSApe1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMucGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YXBpLmxvZygnRmxhc2hBUEkuRm9ybS50b0RhdGEnKTtcblx0XHRcdFx0XHRcdFx0Zm4oaXRlbXMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXG5cblx0XHRcdFx0XHQvLyBGaWxlQVBJLlhIUlxuXHRcdFx0XHRcdF9pbmhlcml0KGFwaS5YSFIucHJvdG90eXBlLCB7XG5cdFx0XHRcdFx0XHRfc2VuZDogZnVuY3Rpb24gKG9wdGlvbnMsIGZvcm1EYXRhKXtcblx0XHRcdFx0XHRcdFx0aWYoXG5cdFx0XHRcdFx0XHRcdFx0ICAgZm9ybURhdGEubm9kZU5hbWVcblx0XHRcdFx0XHRcdFx0XHR8fCBmb3JtRGF0YS5hcHBlbmQgJiYgYXBpLnN1cHBvcnQuaHRtbDVcblx0XHRcdFx0XHRcdFx0XHR8fCBhcGkuaXNBcnJheShmb3JtRGF0YSkgJiYgKHR5cGVvZiBmb3JtRGF0YVswXSA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdFx0XHRcdCl7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSFRNTDUsIE11bHRpcGFydCBvciBJRnJhbWVcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm5cdHRoaXMucGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdFx0XHRcdCAgZGF0YSA9IHt9XG5cdFx0XHRcdFx0XHRcdFx0LCBmaWxlcyA9IHt9XG5cdFx0XHRcdFx0XHRcdFx0LCBfdGhpcyA9IHRoaXNcblx0XHRcdFx0XHRcdFx0XHQsIGZsYXNoSWRcblx0XHRcdFx0XHRcdFx0XHQsIGZpbGVJZFxuXHRcdFx0XHRcdFx0XHQ7XG5cblx0XHRcdFx0XHRcdFx0X2VhY2goZm9ybURhdGEsIGZ1bmN0aW9uIChpdGVtKXtcblx0XHRcdFx0XHRcdFx0XHRpZiggaXRlbS5maWxlICl7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaWxlc1tpdGVtLm5hbWVdID0gaXRlbSA9IF9nZXRGaWxlRGVzY3IoaXRlbS5ibG9iKTtcblx0XHRcdFx0XHRcdFx0XHRcdGZpbGVJZCAgPSBpdGVtLmlkO1xuXHRcdFx0XHRcdFx0XHRcdFx0Zmxhc2hJZCA9IGl0ZW0uZmxhc2hJZDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhW2l0ZW0ubmFtZV0gPSBpdGVtLmJsb2I7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHRpZiggIWZpbGVJZCApe1xuXHRcdFx0XHRcdFx0XHRcdGZsYXNoSWQgPSBfYXR0cjtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmKCAhZmxhc2hJZCApe1xuXHRcdFx0XHRcdFx0XHRcdGFwaS5sb2coJ1tlcnJdIEZsYXNoQVBJLl9zZW5kOiBmbGFzaElkIC0tIHVuZGVmaW5lZCcpO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnBhcmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGFwaS5sb2coJ0ZsYXNoQVBJLlhIUi5fc2VuZDogJysgZmxhc2hJZCArJyAtPiAnKyBmaWxlSWQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0X3RoaXMueGhyID0ge1xuXHRcdFx0XHRcdFx0XHRcdGhlYWRlcnM6IHt9LFxuXHRcdFx0XHRcdFx0XHRcdGFib3J0OiBmdW5jdGlvbiAoKXsgZmxhc2guY21kKGZsYXNoSWQsICdhYm9ydCcsIHsgaWQ6IGZpbGVJZCB9KTsgfSxcblx0XHRcdFx0XHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24gKG5hbWUpeyByZXR1cm4gdGhpcy5oZWFkZXJzW25hbWVdOyB9LFxuXHRcdFx0XHRcdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24gKCl7IHJldHVybiB0aGlzLmhlYWRlcnM7IH1cblx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHR2YXIgcXVldWUgPSBhcGkucXVldWUoZnVuY3Rpb24gKCl7XG5cdFx0XHRcdFx0XHRcdFx0Zmxhc2guY21kKGZsYXNoSWQsICd1cGxvYWQnLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHQgIHVybDogX2dldFVybChvcHRpb25zLnVybC5yZXBsYWNlKC8oW2Etel0rKT0oXFw/KSY/L2ksICcnKSlcblx0XHRcdFx0XHRcdFx0XHRcdCwgZGF0YTogZGF0YVxuXHRcdFx0XHRcdFx0XHRcdFx0LCBmaWxlczogZmlsZUlkID8gZmlsZXMgOiBudWxsXG5cdFx0XHRcdFx0XHRcdFx0XHQsIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyB8fCB7fVxuXHRcdFx0XHRcdFx0XHRcdFx0LCBjYWxsYmFjazogX3dyYXAoZnVuY3Rpb24gdXBsb2FkKGV2dCl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciB0eXBlID0gZXZ0LnR5cGUsIHJlc3VsdCA9IGV2dC5yZXN1bHQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YXBpLmxvZygnRmxhc2hBUEkudXBsb2FkLicrdHlwZSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoIHR5cGUgPT0gJ3Byb2dyZXNzJyApe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGV2dC5sb2FkZWQgPSBNYXRoLm1pbihldnQubG9hZGVkLCBldnQudG90YWwpOyAvLyBAdG9kbyBmaXhtZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGV2dC5sZW5ndGhDb21wdXRhYmxlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLnByb2dyZXNzKGV2dCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSBpZiggdHlwZSA9PSAnY29tcGxldGUnICl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0X3Vud3JhcCh1cGxvYWQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoIHR5cGVvZiByZXN1bHQgPT0gJ3N0cmluZycgKXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF90aGlzLnJlc3BvbnNlVGV4dFx0PSByZXN1bHQucmVwbGFjZSgvJTIyL2csIFwiXFxcIlwiKS5yZXBsYWNlKC8lNWMvZywgXCJcXFxcXCIpLnJlcGxhY2UoLyUyNi9nLCBcIiZcIikucmVwbGFjZSgvJTI1L2csIFwiJVwiKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfdGhpcy5lbmQoZXZ0LnN0YXR1cyB8fCAyMDApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVsc2UgaWYoIHR5cGUgPT0gJ2Fib3J0JyB8fCB0eXBlID09ICdlcnJvcicgKXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfdGhpcy5lbmQoZXZ0LnN0YXR1cyB8fCAwLCBldnQubWVzc2FnZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0X3Vud3JhcCh1cGxvYWQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9KTtcblxuXG5cdFx0XHRcdFx0XHRcdC8vICMyMTc0OiBGaWxlUmVmZXJlbmNlLmxvYWQoKSBjYWxsIHdoaWxlIEZpbGVSZWZlcmVuY2UudXBsb2FkKCkgb3IgdmljZSB2ZXJzYVxuXHRcdFx0XHRcdFx0XHRfZWFjaChmaWxlcywgZnVuY3Rpb24gKGZpbGUpe1xuXHRcdFx0XHRcdFx0XHRcdHF1ZXVlLmluYygpO1xuXHRcdFx0XHRcdFx0XHRcdGFwaS5nZXRJbmZvKGZpbGUsIHF1ZXVlLm5leHQpO1xuXHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHRxdWV1ZS5jaGVjaygpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0O1xuXG5cblx0XHRmdW5jdGlvbiBfbWFrZUZsYXNoSFRNTChvcHRzKXtcblx0XHRcdHJldHVybiAoJzxvYmplY3QgaWQ9XCIjaWQjXCIgY2xhc3NpZD1cImNsc2lkOkQyN0NEQjZFLUFFNkQtMTFjZi05NkI4LTQ0NDU1MzU0MDAwMFwiIHdpZHRoPVwiJysob3B0cy53aWR0aCB8fCAnMTAwJScpKydcIiBoZWlnaHQ9XCInKyhvcHRzLmhlaWdodCB8fCAnMTAwJScpKydcIj4nXG5cdFx0XHRcdCsgJzxwYXJhbSBuYW1lPVwibW92aWVcIiB2YWx1ZT1cIiNzcmMjXCIgLz4nXG5cdFx0XHRcdCsgJzxwYXJhbSBuYW1lPVwiZmxhc2h2YXJzXCIgdmFsdWU9XCIjZmxhc2h2YXJzI1wiIC8+J1xuXHRcdFx0XHQrICc8cGFyYW0gbmFtZT1cInN3bGl2ZWNvbm5lY3RcIiB2YWx1ZT1cInRydWVcIiAvPidcblx0XHRcdFx0KyAnPHBhcmFtIG5hbWU9XCJhbGxvd3NjcmlwdGFjY2Vzc1wiIHZhbHVlPVwiYWx3YXlzXCIgLz4nXG5cdFx0XHRcdCsgJzxwYXJhbSBuYW1lPVwiYWxsb3duZXR3b3JraW5nXCIgdmFsdWU9XCJhbGxcIiAvPidcblx0XHRcdFx0KyAnPHBhcmFtIG5hbWU9XCJtZW51XCIgdmFsdWU9XCJmYWxzZVwiIC8+J1xuXHRcdFx0XHQrICc8cGFyYW0gbmFtZT1cIndtb2RlXCIgdmFsdWU9XCIjd21vZGUjXCIgLz4nXG5cdFx0XHRcdCsgJzxlbWJlZCBmbGFzaHZhcnM9XCIjZmxhc2h2YXJzI1wiIHN3bGl2ZWNvbm5lY3Q9XCJ0cnVlXCIgYWxsb3duZXR3b3JraW5nPVwiYWxsXCIgYWxsb3dzY3JpcHRhY2Nlc3M9XCJhbHdheXNcIiBuYW1lPVwiI2lkI1wiIHNyYz1cIiNzcmMjXCIgd2lkdGg9XCInKyhvcHRzLndpZHRoIHx8ICcxMDAlJykrJ1wiIGhlaWdodD1cIicrKG9wdHMuaGVpZ2h0IHx8ICcxMDAlJykrJ1wiIG1lbnU9XCJmYWxzZVwiIHdtb2RlPVwidHJhbnNwYXJlbnRcIiB0eXBlPVwiYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2hcIj48L2VtYmVkPidcblx0XHRcdFx0KyAnPC9vYmplY3Q+JykucmVwbGFjZSgvIyhcXHcrKSMvaWcsIGZ1bmN0aW9uIChhLCBuYW1lKXsgcmV0dXJuIG9wdHNbbmFtZV07IH0pXG5cdFx0XHQ7XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBfY3NzKGVsLCBjc3Mpe1xuXHRcdFx0aWYoIGVsICYmIGVsLnN0eWxlICl7XG5cdFx0XHRcdHZhciBrZXksIHZhbDtcblx0XHRcdFx0Zm9yKCBrZXkgaW4gY3NzICl7XG5cdFx0XHRcdFx0dmFsID0gY3NzW2tleV07XG5cdFx0XHRcdFx0aWYoIHR5cGVvZiB2YWwgPT0gJ251bWJlcicgKXtcblx0XHRcdFx0XHRcdHZhbCArPSAncHgnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0cnkgeyBlbC5zdHlsZVtrZXldID0gdmFsOyB9IGNhdGNoIChlKSB7fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBfaW5oZXJpdChvYmosIG1ldGhvZHMpe1xuXHRcdFx0X2VhY2gobWV0aG9kcywgZnVuY3Rpb24gKGZuLCBuYW1lKXtcblx0XHRcdFx0dmFyIHByZXYgPSBvYmpbbmFtZV07XG5cdFx0XHRcdG9ialtuYW1lXSA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRcdHRoaXMucGFyZW50ID0gcHJldjtcblx0XHRcdFx0XHRyZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIF9pc0h0bWxGaWxlKGZpbGUpe1xuXHRcdFx0cmV0dXJuXHRmaWxlICYmICFmaWxlLmZsYXNoSWQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gX3dyYXAoZm4pe1xuXHRcdFx0dmFyIGlkID0gZm4ud2lkID0gYXBpLnVpZCgpO1xuXHRcdFx0Zmxhc2guX2ZuW2lkXSA9IGZuO1xuXHRcdFx0cmV0dXJuXHQnRmlsZUFQSS5GbGFzaC5fZm4uJytpZDtcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIF91bndyYXAoZm4pe1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zmxhc2guX2ZuW2ZuLndpZF0gPSBudWxsO1xuXHRcdFx0XHRkZWxldGVcdGZsYXNoLl9mbltmbi53aWRdO1xuXHRcdFx0fVxuXHRcdFx0Y2F0Y2goZSl7fVxuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gX2dldFVybCh1cmwsIHBhcmFtcyl7XG5cdFx0XHRpZiggIV9yaHR0cC50ZXN0KHVybCkgKXtcblx0XHRcdFx0aWYoIC9eXFwuXFwvLy50ZXN0KHVybCkgfHwgJy8nICE9IHVybC5jaGFyQXQoMCkgKXtcblx0XHRcdFx0XHR2YXIgcGF0aCA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuXHRcdFx0XHRcdHBhdGggPSBwYXRoLnN1YnN0cigwLCBwYXRoLmxhc3RJbmRleE9mKCcvJykpO1xuXHRcdFx0XHRcdHVybCA9IChwYXRoICsnLycrIHVybCkucmVwbGFjZSgnLy4vJywgJy8nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKCAnLy8nICE9IHVybC5zdWJzdHIoMCwgMikgKXtcblx0XHRcdFx0XHR1cmwgPSAnLy8nICsgbG9jYXRpb24uaG9zdCArIHVybDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKCAhX3JodHRwLnRlc3QodXJsKSApe1xuXHRcdFx0XHRcdHVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgdXJsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKCBwYXJhbXMgKXtcblx0XHRcdFx0dXJsICs9ICgvXFw/Ly50ZXN0KHVybCkgPyAnJicgOiAnPycpICsgcGFyYW1zO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm5cdHVybDtcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIF9tYWtlRmxhc2hJbWFnZShvcHRzLCBiYXNlNjQsIGZuKXtcblx0XHRcdHZhclxuXHRcdFx0XHQgIGtleVxuXHRcdFx0XHQsIGZsYXNoSWQgPSBhcGkudWlkKClcblx0XHRcdFx0LCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cdFx0XHRcdCwgYXR0ZW1wdHMgPSAxMFxuXHRcdFx0O1xuXG5cdFx0XHRmb3IoIGtleSBpbiBvcHRzICl7XG5cdFx0XHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIG9wdHNba2V5XSk7XG5cdFx0XHRcdGVsW2tleV0gPSBvcHRzW2tleV07XG5cdFx0XHR9XG5cblx0XHRcdF9jc3MoZWwsIG9wdHMpO1xuXG5cdFx0XHRvcHRzLndpZHRoXHQ9ICcxMDAlJztcblx0XHRcdG9wdHMuaGVpZ2h0XHQ9ICcxMDAlJztcblxuXHRcdFx0ZWwuaW5uZXJIVE1MID0gX21ha2VGbGFzaEhUTUwoYXBpLmV4dGVuZCh7XG5cdFx0XHRcdCAgaWQ6IGZsYXNoSWRcblx0XHRcdFx0LCBzcmM6IF9nZXRVcmwoYXBpLmZsYXNoSW1hZ2VVcmwsICdyPScrIGFwaS51aWQoKSlcblx0XHRcdFx0LCB3bW9kZTogJ29wYXF1ZSdcblx0XHRcdFx0LCBmbGFzaHZhcnM6ICdzY2FsZT0nKyBvcHRzLnNjYWxlICsnJmNhbGxiYWNrPScrX3dyYXAoZnVuY3Rpb24gXygpe1xuXHRcdFx0XHRcdF91bndyYXAoXyk7XG5cdFx0XHRcdFx0aWYoIC0tYXR0ZW1wdHMgPiAwICl7XG5cdFx0XHRcdFx0XHRfc2V0SW1hZ2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH0pXG5cdFx0XHR9LCBvcHRzKSk7XG5cblx0XHRcdGZ1bmN0aW9uIF9zZXRJbWFnZSgpe1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIEdldCBmbGFzaC1vYmplY3QgYnkgaWRcblx0XHRcdFx0XHR2YXIgaW1nID0gZmxhc2guZ2V0KGZsYXNoSWQpO1xuXHRcdFx0XHRcdGltZy5zZXRJbWFnZShiYXNlNjQpO1xuXHRcdFx0XHR9IGNhdGNoIChlKXtcblx0XHRcdFx0XHRhcGkubG9nKCdbZXJyXSBGbGFzaEFQSS5QcmV2aWV3LnNldEltYWdlIC0tIGNhbiBub3Qgc2V0IFwiYmFzZTY0XCI6JywgZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm4oZmFsc2UsIGVsKTtcblx0XHRcdGVsID0gbnVsbDtcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIF9nZXRGaWxlRGVzY3IoZmlsZSl7XG5cdFx0XHRyZXR1cm5cdHtcblx0XHRcdFx0ICBpZDogZmlsZS5pZFxuXHRcdFx0XHQsIG5hbWU6IGZpbGUubmFtZVxuXHRcdFx0XHQsIG1hdHJpeDogZmlsZS5tYXRyaXhcblx0XHRcdFx0LCBmbGFzaElkOiBmaWxlLmZsYXNoSWRcblx0XHRcdH07XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBfZ2V0RGltZW5zaW9ucyhlbCl7XG5cdFx0XHR2YXJcblx0XHRcdFx0ICBib3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXHRcdFx0XHQsIGJvZHkgPSBkb2N1bWVudC5ib2R5XG5cdFx0XHRcdCwgZG9jRWwgPSAoZWwgJiYgZWwub3duZXJEb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50XG5cdFx0XHQ7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdCAgdG9wOlx0XHRib3gudG9wICsgKHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2NFbC5zY3JvbGxUb3ApICAtIChkb2NFbC5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMClcblx0XHRcdFx0LCBsZWZ0Olx0XHRib3gubGVmdCArICh3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jRWwuc2Nyb2xsTGVmdCkgLSAoZG9jRWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMClcblx0XHRcdFx0LCB3aWR0aDpcdGJveC5yaWdodCAtIGJveC5sZWZ0XG5cdFx0XHRcdCwgaGVpZ2h0Olx0Ym94LmJvdHRvbSAtIGJveC50b3Bcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gQGV4cG9ydFxuXHRcdGFwaS5GbGFzaCA9IGZsYXNoO1xuXG5cblx0XHQvLyBDaGVjayBkYXRhVVJJIHN1cHBvcnRcblx0XHRhcGkubmV3SW1hZ2UoJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veXdBQUFBQUFRQUJBQUFDQVV3QU93PT0nLCBmdW5jdGlvbiAoZXJyLCBpbWcpe1xuXHRcdFx0YXBpLnN1cHBvcnQuZGF0YVVSSSA9ICEoaW1nLndpZHRoICE9IDEgfHwgaW1nLmhlaWdodCAhPSAxKTtcblx0XHRcdGZsYXNoLmluaXQoKTtcblx0XHR9KTtcblx0fSkoKTtcbn0pKHdpbmRvdywgd2luZG93LmpRdWVyeSwgRmlsZUFQSSk7XG5cbi8qKlxuICogRmlsZUFQSSBmYWxsYmFjayB0byBGbGFzaFxuICpcbiAqIEBmbGFzaC1kZXZlbG9wZXIgIFwiVmxhZGltaXIgRGVtaWRvdlwiIDx2LmRlbWlkb3ZAY29ycC5tYWlsLnJ1PlxuICovXG5cbi8qZ2xvYmFsIHdpbmRvdywgRmlsZUFQSSAqL1xuKGZ1bmN0aW9uICh3aW5kb3csIGpRdWVyeSwgYXBpKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgX2VhY2ggPSBhcGkuZWFjaCxcbiAgICAgICAgX2NhbWVyYVF1ZXVlID0gW107XG5cbiAgICBpZiAoYXBpLnN1cHBvcnQuZmxhc2ggJiYgKGFwaS5tZWRpYSAmJiAoIWFwaS5zdXBwb3J0Lm1lZGlhIHx8ICFhcGkuaHRtbDUgfHwgYXBpLmluc2VjdXJlQ2hyb21lKSkpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF93cmFwKGZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gZm4ud2lkID0gYXBpLnVpZCgpO1xuICAgICAgICAgICAgICAgIGFwaS5GbGFzaC5fZm5baWRdID0gZm47XG4gICAgICAgICAgICAgICAgcmV0dXJuICdGaWxlQVBJLkZsYXNoLl9mbi4nICsgaWQ7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgZnVuY3Rpb24gX3Vud3JhcChmbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5GbGFzaC5fZm5bZm4ud2lkXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhcGkuRmxhc2guX2ZuW2ZuLndpZF07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZsYXNoID0gYXBpLkZsYXNoO1xuICAgICAgICAgICAgYXBpLmV4dGVuZChhcGkuRmxhc2gsIHtcblxuICAgICAgICAgICAgICAgIHBhdGNoQ2FtZXJhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5DYW1lcmEuZmFsbGJhY2sgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FtSWQgPSBhcGkudWlkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkubG9nKCdGbGFzaEFQSS5DYW1lcmEucHVibGlzaDogJyArIGNhbUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYXNoLnB1Ymxpc2goZWwsIGNhbUlkLCBhcGkuZXh0ZW5kKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW1lcmE6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FdmVudDogX3dyYXAoZnVuY3Rpb24gXyhldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2dC50eXBlID09PSAnY2FtZXJhJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Vud3JhcChfKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2dC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5sb2coJ0ZsYXNoQVBJLkNhbWVyYS5wdWJsaXNoLmVycm9yOiAnICsgZXZ0LmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhldnQuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkubG9nKCdGbGFzaEFQSS5DYW1lcmEucHVibGlzaC5zdWNjZXNzOiAnICsgY2FtSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUnVuXG4gICAgICAgICAgICAgICAgICAgIF9lYWNoKF9jYW1lcmFRdWV1ZSwgZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5DYW1lcmEuZmFsbGJhY2suYXBwbHkoYXBpLkNhbWVyYSwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBfY2FtZXJhUXVldWUgPSBbXTtcblxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbGVBUEkuQ2FtZXJhOnByb3RvXG4gICAgICAgICAgICAgICAgICAgIGFwaS5leHRlbmQoYXBpLkNhbWVyYS5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZGVvLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhc2guY21kKHRoaXMuX2lkKCksICdjYW1lcmEub24nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBfd3JhcChmdW5jdGlvbiBfKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Vud3JhcChfKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2dC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5sb2coJ0ZsYXNoQVBJLmNhbWVyYS5vbi5lcnJvcjogJyArIGV2dC5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXZ0LmVycm9yLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5sb2coJ0ZsYXNoQVBJLmNhbWVyYS5vbi5zdWNjZXNzOiAnICsgX3RoaXMuX2lkKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFzaC5jbWQodGhpcy5faWQoKSwgJ2NhbWVyYS5vZmYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkubG9nKCdGbGFzaEFQSS5DYW1lcmEuc2hvdDonLCB0aGlzLl9pZCgpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaG90ID0gYXBpLkZsYXNoLmNtZCh0aGlzLl9pZCgpLCAnc2hvdCcsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG90LnR5cGUgPSAnaW1hZ2UvcG5nJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG90LmZsYXNoSWQgPSB0aGlzLl9pZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3QuaXNTaG90ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXBpLkNhbWVyYS5TaG90KHNob3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXBpLkNhbWVyYS5mYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfY2FtZXJhUXVldWUucHVzaChhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9KCkpO1xuICAgIH1cbn0od2luZG93LCB3aW5kb3cualF1ZXJ5LCBGaWxlQVBJKSk7XG5pZiggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKXsgZGVmaW5lKFwiRmlsZUFQSVwiLCBbXSwgZnVuY3Rpb24gKCl7IHJldHVybiBGaWxlQVBJOyB9KTsgfSIsIi8qKlxuICogSUFTQ2FsbGJhY2tzIHYyLjMuMVxuICogaHR0cHM6Ly9pbmZpbml0ZWFqYXhzY3JvbGwuY29tXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEluZmluaXRlIEFKQVggU2Nyb2xsIHBhY2thZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE4IFdlYmNyZWF0ZSAoSmVyb2VuIEZpZWdlKVxuICovXG5cbnZhciBJQVNDYWxsYmFja3MgPSBmdW5jdGlvbiAoYUpxdWVyeSkge1xuICB0aGlzLmxpc3QgPSBbXTtcbiAgdGhpcy5maXJlU3RhY2sgPSBbXTtcbiAgdGhpcy5pc0ZpcmluZyA9IGZhbHNlO1xuICB0aGlzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgdGhpcy5EZWZlcnJlZCA9IGFKcXVlcnkuRGVmZXJyZWQ7XG5cbiAgLyoqXG4gICAqIENhbGxzIGFsbCBhZGRlZCBjYWxsYmFja3NcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIGFyZ3NcbiAgICovXG4gIHRoaXMuZmlyZSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgdmFyIGNvbnRleHQgPSBhcmdzWzBdLFxuICAgICAgICBkZWZlcnJlZCA9IGFyZ3NbMV0sXG4gICAgICAgIGNhbGxiYWNrQXJndW1lbnRzID0gYXJnc1syXTtcblxuICAgIHRoaXMuaXNGaXJpbmcgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5saXN0W2ldICE9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZmFsc2UgPT09IHRoaXMubGlzdFtpXS5mbi5hcHBseShjb250ZXh0LCBjYWxsYmFja0FyZ3VtZW50cykpIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pc0ZpcmluZyA9IGZhbHNlO1xuXG4gICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuXG4gICAgaWYgKHRoaXMuZmlyZVN0YWNrLmxlbmd0aCkge1xuICAgICAgdGhpcy5maXJlKHRoaXMuZmlyZVN0YWNrLnNoaWZ0KCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBpbmRleCBvZiB0aGUgY2FsbGJhY2sgaW4gdGhlIGxpc3QgaW4gYSBzaW1pbGFyIHdheSBhc1xuICAgKiB0aGUgaW5kZXhPZiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoIGZyb21cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHRoaXMuaW5MaXN0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBpbmRleCkge1xuICAgIGluZGV4ID0gaW5kZXggfHwgMDtcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCwgbGVuZ3RoID0gdGhpcy5saXN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5saXN0W2ldLmZuID09PSBjYWxsYmFjayB8fCAoY2FsbGJhY2suZ3VpZCAmJiB0aGlzLmxpc3RbaV0uZm4uZ3VpZCAmJiBjYWxsYmFjay5ndWlkID09PSB0aGlzLmxpc3RbaV0uZm4uZ3VpZCkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuSUFTQ2FsbGJhY2tzLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge0lBU0NhbGxiYWNrc31cbiAgICogQHBhcmFtIHByaW9yaXR5XG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uIChjYWxsYmFjaywgcHJpb3JpdHkpIHtcbiAgICB2YXIgY2FsbGJhY2tPYmplY3QgPSB7Zm46IGNhbGxiYWNrLCBwcmlvcml0eTogcHJpb3JpdHl9O1xuXG4gICAgcHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMubGlzdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHByaW9yaXR5ID4gdGhpcy5saXN0W2ldLnByaW9yaXR5KSB7XG4gICAgICAgIHRoaXMubGlzdC5zcGxpY2UoaSwgMCwgY2FsbGJhY2tPYmplY3QpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGlzdC5wdXNoKGNhbGxiYWNrT2JqZWN0KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtJQVNDYWxsYmFja3N9XG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICB3aGlsZSAoKCBpbmRleCA9IHRoaXMuaW5MaXN0KGNhbGxiYWNrLCBpbmRleCkgKSA+IC0xKSB7XG4gICAgICB0aGlzLmxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGNhbGxiYWNrIGlzIGFkZGVkXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGhhczogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuICh0aGlzLmluTGlzdChjYWxsYmFjaykgPiAtMSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQ2FsbHMgY2FsbGJhY2tzIHdpdGggYSBjb250ZXh0XG4gICAqXG4gICAqIEBwYXJhbSBjb250ZXh0XG4gICAqIEBwYXJhbSBhcmdzXG4gICAqIEByZXR1cm5zIHtvYmplY3R8dm9pZH1cbiAgICovXG4gIGZpcmVXaXRoOiBmdW5jdGlvbiAoY29udGV4dCwgYXJncykge1xuICAgIHZhciBkZWZlcnJlZCA9IHRoaXMuRGVmZXJyZWQoKTtcblxuICAgIGlmICh0aGlzLmlzRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICB9XG5cbiAgICBhcmdzID0gYXJncyB8fCBbXTtcbiAgICBhcmdzID0gWyBjb250ZXh0LCBkZWZlcnJlZCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblxuICAgIGlmICh0aGlzLmlzRmlyaW5nKSB7XG4gICAgICB0aGlzLmZpcmVTdGFjay5wdXNoKGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpcmUoYXJncyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNhYmxlIGZpcmluZyBvZiBuZXcgZXZlbnRzXG4gICAqL1xuICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0Rpc2FibGVkID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogRW5hYmxlIGZpcmluZyBvZiBuZXcgZXZlbnRzXG4gICAqL1xuICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgfVxufTtcbiIsIi8qKlxuICogSW5maW5pdGUgQWpheCBTY3JvbGwgdjIuMy4xXG4gKiBBIGpRdWVyeSBwbHVnaW4gZm9yIGluZmluaXRlIHNjcm9sbGluZ1xuICogaHR0cHM6Ly9pbmZpbml0ZWFqYXhzY3JvbGwuY29tXG4gKlxuICogQ29tbWVyY2lhbCB1c2UgcmVxdWlyZXMgb25lLXRpbWUgcHVyY2hhc2Ugb2YgYSBjb21tZXJjaWFsIGxpY2Vuc2VcbiAqIGh0dHBzOi8vaW5maW5pdGVhamF4c2Nyb2xsLmNvbS9kb2NzL2xpY2Vuc2UuaHRtbFxuICpcbiAqIE5vbi1jb21tZXJjaWFsIHVzZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE4IFdlYmNyZWF0ZSAoSmVyb2VuIEZpZWdlKVxuICovXG5cbihmdW5jdGlvbigkKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBVTkRFVEVSTUlORURfU0NST0xMT0ZGU0VUID0gLTE7XG5cbiAgdmFyIElBUyA9IGZ1bmN0aW9uKCRlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5pdGVtc0NvbnRhaW5lclNlbGVjdG9yID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgdGhpcy5pdGVtU2VsZWN0b3IgPSBvcHRpb25zLml0ZW07XG4gICAgdGhpcy5uZXh0U2VsZWN0b3IgPSBvcHRpb25zLm5leHQ7XG4gICAgdGhpcy5wYWdpbmF0aW9uU2VsZWN0b3IgPSBvcHRpb25zLnBhZ2luYXRpb247XG4gICAgdGhpcy4kc2Nyb2xsQ29udGFpbmVyID0gJGVsZW1lbnQ7XG4gICAgdGhpcy4kY29udGFpbmVyID0gKHdpbmRvdyA9PT0gJGVsZW1lbnQuZ2V0KDApID8gJChkb2N1bWVudCkgOiAkZWxlbWVudCk7XG4gICAgdGhpcy5kZWZhdWx0RGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuICAgIHRoaXMubmVnYXRpdmVNYXJnaW4gPSBvcHRpb25zLm5lZ2F0aXZlTWFyZ2luO1xuICAgIHRoaXMubmV4dFVybCA9IG51bGw7XG4gICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuanNYaHIgPSBmYWxzZTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHtcbiAgICAgIG5leHQ6ICAgICBuZXcgSUFTQ2FsbGJhY2tzKCQpLFxuICAgICAgbG9hZDogICAgIG5ldyBJQVNDYWxsYmFja3MoJCksXG4gICAgICBsb2FkZWQ6ICAgbmV3IElBU0NhbGxiYWNrcygkKSxcbiAgICAgIHJlbmRlcjogICBuZXcgSUFTQ2FsbGJhY2tzKCQpLFxuICAgICAgcmVuZGVyZWQ6IG5ldyBJQVNDYWxsYmFja3MoJCksXG4gICAgICBzY3JvbGw6ICAgbmV3IElBU0NhbGxiYWNrcygkKSxcbiAgICAgIG5vbmVMZWZ0OiBuZXcgSUFTQ2FsbGJhY2tzKCQpLFxuICAgICAgcmVhZHk6ICAgIG5ldyBJQVNDYWxsYmFja3MoJClcbiAgICB9O1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogU2Nyb2xsIGV2ZW50IGhhbmRsZXJcbiAgICAgKlxuICAgICAqIE5vdGU6IGNhbGxzIHRvIHRoaXMgZnVuY3Rpb25zIHNob3VsZCBiZSB0aHJvdHRsZWRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zY3JvbGxIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyB0aGUgdGhyb3R0bGUgbWV0aG9kIGNhbiBjYWxsIHRoZSBzY3JvbGxIYW5kbGVyIGV2ZW4gdGhvdWdodCB3ZSBoYXZlIGNhbGxlZCB1bmJpbmQoKVxuICAgICAgaWYgKCF0aGlzLmlzQm91bmQgfHwgdGhpcy5pc1BhdXNlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50U2Nyb2xsT2Zmc2V0ID0gdGhpcy5nZXRDdXJyZW50U2Nyb2xsT2Zmc2V0KHRoaXMuJHNjcm9sbENvbnRhaW5lciksXG4gICAgICAgICAgc2Nyb2xsVGhyZXNob2xkID0gdGhpcy5nZXRTY3JvbGxUaHJlc2hvbGQoKVxuICAgICAgO1xuXG4gICAgICAvLyBpbnZhbGlkIHNjcm9sbFRocmVzaG9sZC4gVGhlIERPTSBtaWdodCBub3QgaGF2ZSBsb2FkZWQgeWV0Li4uXG4gICAgICBpZiAoVU5ERVRFUk1JTkVEX1NDUk9MTE9GRlNFVCA9PSBzY3JvbGxUaHJlc2hvbGQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpcmUoJ3Njcm9sbCcsIFtjdXJyZW50U2Nyb2xsT2Zmc2V0LCBzY3JvbGxUaHJlc2hvbGRdKTtcblxuICAgICAgaWYgKGN1cnJlbnRTY3JvbGxPZmZzZXQgPj0gc2Nyb2xsVGhyZXNob2xkKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpdGVtcyBjb250YWluZXIgY3VycmVudGx5IGluIHRoZSBET01cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmdldEl0ZW1zQ29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJCh0aGlzLml0ZW1zQ29udGFpbmVyU2VsZWN0b3IsIHRoaXMuJGNvbnRhaW5lcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhc3QgaXRlbSBjdXJyZW50bHkgaW4gdGhlIERPTVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuZ2V0TGFzdEl0ZW0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAkKHRoaXMuaXRlbVNlbGVjdG9yLCB0aGlzLmdldEl0ZW1zQ29udGFpbmVyKCkuZ2V0KDApKS5sYXN0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGl0ZW0gY3VycmVudGx5IGluIHRoZSBET01cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmdldEZpcnN0SXRlbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICQodGhpcy5pdGVtU2VsZWN0b3IsIHRoaXMuZ2V0SXRlbXNDb250YWluZXIoKS5nZXQoMCkpLmZpcnN0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2Nyb2xsIHRocmVzaG9sZC4gVGhpcyB0aHJlc2hvbGQgbWFya3MgdGhlIGxpbmUgZnJvbSB3aGVyZVxuICAgICAqIElBUyBzaG91bGQgc3RhcnQgbG9hZGluZyB0aGUgbmV4dCBwYWdlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gbmVnYXRpdmVNYXJnaW4gZGVmYXVsdHMgdG8ge3RoaXMubmVnYXRpdmVNYXJnaW59XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0U2Nyb2xsVGhyZXNob2xkID0gZnVuY3Rpb24obmVnYXRpdmVNYXJnaW4pIHtcbiAgICAgIHZhciAkbGFzdEVsZW1lbnQ7XG5cbiAgICAgIG5lZ2F0aXZlTWFyZ2luID0gbmVnYXRpdmVNYXJnaW4gfHwgdGhpcy5uZWdhdGl2ZU1hcmdpbjtcbiAgICAgIG5lZ2F0aXZlTWFyZ2luID0gKG5lZ2F0aXZlTWFyZ2luID49IDAgPyBuZWdhdGl2ZU1hcmdpbiAqIC0xIDogbmVnYXRpdmVNYXJnaW4pO1xuXG4gICAgICAkbGFzdEVsZW1lbnQgPSB0aGlzLmdldExhc3RJdGVtKCk7XG5cbiAgICAgIC8vIGlmIHRoZSBkb24ndCBoYXZlIGEgbGFzdCBlbGVtZW50LCB0aGUgRE9NIG1pZ2h0IG5vdCBoYXZlIGJlZW4gbG9hZGVkLFxuICAgICAgLy8gb3IgdGhlIHNlbGVjdG9yIGlzIGludmFsaWRcbiAgICAgIGlmICgwID09PSAkbGFzdEVsZW1lbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBVTkRFVEVSTUlORURfU0NST0xMT0ZGU0VUO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKCRsYXN0RWxlbWVudC5vZmZzZXQoKS50b3AgKyAkbGFzdEVsZW1lbnQuaGVpZ2h0KCkgKyBuZWdhdGl2ZU1hcmdpbik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VycmVudCBzY3JvbGwgb2Zmc2V0IGZvciB0aGUgZ2l2ZW4gc2Nyb2xsIGNvbnRhaW5lclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gJGNvbnRhaW5lclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5nZXRDdXJyZW50U2Nyb2xsT2Zmc2V0ID0gZnVuY3Rpb24oJGNvbnRhaW5lcikge1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IDAsXG4gICAgICAgICAgY29udGFpbmVySGVpZ2h0ID0gJGNvbnRhaW5lci5oZWlnaHQoKTtcblxuICAgICAgaWYgKHdpbmRvdyA9PT0gJGNvbnRhaW5lci5nZXQoMCkpICB7XG4gICAgICAgIHNjcm9sbFRvcCA9ICRjb250YWluZXIuc2Nyb2xsVG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY3JvbGxUb3AgPSAkY29udGFpbmVyLm9mZnNldCgpLnRvcDtcbiAgICAgIH1cblxuICAgICAgLy8gY29tcGVuc2F0ZSBmb3IgaVBob25lXG4gICAgICBpZiAobmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoXCJpUGhvbmVcIikgIT0gLTEgfHwgbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoXCJpUG9kXCIpICE9IC0xKSB7XG4gICAgICAgIGNvbnRhaW5lckhlaWdodCArPSA4MDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChzY3JvbGxUb3AgKyBjb250YWluZXJIZWlnaHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1cmwgZm9yIHRoZSBuZXh0IHBhZ2VcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5nZXROZXh0VXJsID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgdGhpcy4kY29udGFpbmVyO1xuXG4gICAgICAvLyBhbHdheXMgdGFrZSB0aGUgbGFzdCBtYXRjaGluZyBpdGVtXG4gICAgICByZXR1cm4gJCh0aGlzLm5leHRTZWxlY3RvciwgY29udGFpbmVyKS5sYXN0KCkuYXR0cignaHJlZicpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIHBhZ2UgdXJsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIGRlbGF5XG4gICAgICogQHJldHVybnMge29iamVjdH0gICAgICAgIGpzWGhyIG9iamVjdFxuICAgICAqL1xuICAgIHRoaXMubG9hZCA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIGRlbGF5KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgJGl0ZW1Db250YWluZXIsXG4gICAgICAgICAgaXRlbXMgPSBbXSxcbiAgICAgICAgICB0aW1lU3RhcnQgPSArbmV3IERhdGUoKSxcbiAgICAgICAgICB0aW1lRGlmZjtcblxuICAgICAgZGVsYXkgPSBkZWxheSB8fCB0aGlzLmRlZmF1bHREZWxheTtcblxuICAgICAgdmFyIGxvYWRFdmVudCA9IHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGFqYXhPcHRpb25zOiB7XG4gICAgICAgICAgZGF0YVR5cGU6ICdodG1sJ1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmZpcmUoJ2xvYWQnLCBbbG9hZEV2ZW50XSk7XG5cbiAgICAgIGZ1bmN0aW9uIHhockRvbmVDYWxsYmFjayhkYXRhKSB7XG4gICAgICAgICRpdGVtQ29udGFpbmVyID0gJCh0aGlzLml0ZW1zQ29udGFpbmVyU2VsZWN0b3IsIGRhdGEpLmVxKDApO1xuICAgICAgICBpZiAoMCA9PT0gJGl0ZW1Db250YWluZXIubGVuZ3RoKSB7XG4gICAgICAgICAgJGl0ZW1Db250YWluZXIgPSAkKGRhdGEpLmZpbHRlcih0aGlzLml0ZW1zQ29udGFpbmVyU2VsZWN0b3IpLmVxKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRpdGVtQ29udGFpbmVyKSB7XG4gICAgICAgICAgJGl0ZW1Db250YWluZXIuZmluZCh0aGlzLml0ZW1TZWxlY3RvcikuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2godGhpcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmZpcmUoJ2xvYWRlZCcsIFtkYXRhLCBpdGVtc10pO1xuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIHRpbWVEaWZmID0gK25ldyBEYXRlKCkgLSB0aW1lU3RhcnQ7XG4gICAgICAgICAgaWYgKHRpbWVEaWZmIDwgZGVsYXkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc2VsZiwgZGF0YSwgaXRlbXMpO1xuICAgICAgICAgICAgfSwgZGVsYXkgLSB0aW1lRGlmZik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc2VsZiwgZGF0YSwgaXRlbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmpzWGhyID0gJC5hamF4KGxvYWRFdmVudC51cmwsIGxvYWRFdmVudC5hamF4T3B0aW9ucylcbiAgICAgICAgLmRvbmUoJC5wcm94eSh4aHJEb25lQ2FsbGJhY2ssIHNlbGYpKTtcblxuICAgICAgcmV0dXJuIHRoaXMuanNYaHI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgaXRlbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSBpdGVtc1xuICAgICAqL1xuICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oaXRlbXMsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgJGxhc3RJdGVtID0gdGhpcy5nZXRMYXN0SXRlbSgpLFxuICAgICAgICAgIGNvdW50ID0gMDtcblxuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLmZpcmUoJ3JlbmRlcicsIFtpdGVtc10pO1xuXG4gICAgICBwcm9taXNlLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICQoaXRlbXMpLmhpZGUoKTsgLy8gYXQgZmlyc3QsIGhpZGUgaXQgc28gd2UgY2FuIGZhZGUgaXQgaW4gbGF0ZXJcblxuICAgICAgICAkbGFzdEl0ZW0uYWZ0ZXIoaXRlbXMpO1xuXG4gICAgICAgICQoaXRlbXMpLmZhZGVJbig0MDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIGNvbXBsZXRlIGNhbGxiYWNrIGdldCBmaXJlZCBmb3IgZWFjaCBpdGVtLFxuICAgICAgICAgIC8vIG9ubHkgYWN0IG9uIHRoZSBsYXN0IGl0ZW1cbiAgICAgICAgICBpZiAoKytjb3VudCA8IGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuZmlyZSgncmVuZGVyZWQnLCBbaXRlbXNdKTtcblxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHByb21pc2UuZmFpbChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhpZGVzIHRoZSBwYWdpbmF0aW9uXG4gICAgICovXG4gICAgdGhpcy5oaWRlUGFnaW5hdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucGFnaW5hdGlvblNlbGVjdG9yKSB7XG4gICAgICAgICQodGhpcy5wYWdpbmF0aW9uU2VsZWN0b3IsIHRoaXMuJGNvbnRhaW5lcikuaGlkZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyB0aGUgcGFnaW5hdGlvblxuICAgICAqL1xuICAgIHRoaXMucmVzdG9yZVBhZ2luYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBhZ2luYXRpb25TZWxlY3Rvcikge1xuICAgICAgICAkKHRoaXMucGFnaW5hdGlvblNlbGVjdG9yLCB0aGlzLiRjb250YWluZXIpLnNob3coKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhyb3R0bGVzIGEgbWV0aG9kXG4gICAgICpcbiAgICAgKiBBZG9wdGVkIGZyb20gQmVuIEFsbWFuJ3MgalF1ZXJ5IHRocm90dGxlIC8gZGVib3VuY2UgcGx1Z2luXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0gZGVsYXlcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy50aHJvdHRsZSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSkge1xuICAgICAgdmFyIGxhc3RFeGVjdXRpb25UaW1lID0gMCxcbiAgICAgICAgICB3cmFwcGVyLFxuICAgICAgICAgIHRpbWVySWRcbiAgICAgIDtcblxuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgZGlmZiA9ICtuZXcgRGF0ZSgpIC0gbGFzdEV4ZWN1dGlvblRpbWU7XG5cbiAgICAgICAgZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAgICAgICAgICBsYXN0RXhlY3V0aW9uVGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aW1lcklkKSB7XG4gICAgICAgICAgZXhlY3V0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaWZmID4gZGVsYXkpIHtcbiAgICAgICAgICBleGVjdXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQoZXhlY3V0ZSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoJC5ndWlkKSB7XG4gICAgICAgIHdyYXBwZXIuZ3VpZCA9IGNhbGxiYWNrLmd1aWQgPSBjYWxsYmFjay5ndWlkIHx8ICQuZ3VpZCsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZXMgYW4gZXZlbnQgd2l0aCB0aGUgYWJpbGl0eSB0byBjYW5jZWwgZnVydGhlciBwcm9jZXNzaW5nLiBUaGlzXG4gICAgICogY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBmYWxzZSBpbiBhIGxpc3RlbmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLmZpcmUgPSBmdW5jdGlvbihldmVudCwgYXJncykge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzW2V2ZW50XS5maXJlV2l0aCh0aGlzLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGF1c2VzIHRoZSBzY3JvbGwgaGFuZGxlclxuICAgICAqXG4gICAgICogTm90ZTogaW50ZXJuYWwgdXNlIG9ubHksIGlmIHlvdSBuZWVkIHRvIHBhdXNlIElBUyB1c2UgYHVuYmluZGAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzdW1lcyB0aGUgc2Nyb2xsIGhhbmRsZXJcbiAgICAgKlxuICAgICAqIE5vdGU6IGludGVybmFsIHVzZSBvbmx5LCBpZiB5b3UgbmVlZCB0byByZXN1bWUgSUFTIHVzZSBgYmluZGAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBJQVNcbiAgICpcbiAgICogTm90ZTogU2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBkb2N1bWVudCBpcyByZWFkeVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBJQVMucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHN1cHBvcnRzT25TY3JvbGwgPSAoISEoJ29uc2Nyb2xsJyBpbiB0aGlzLiRzY3JvbGxDb250YWluZXIuZ2V0KDApKSksXG4gICAgICAgIGN1cnJlbnRTY3JvbGxPZmZzZXQgPSB0aGlzLmdldEN1cnJlbnRTY3JvbGxPZmZzZXQodGhpcy4kc2Nyb2xsQ29udGFpbmVyKSxcbiAgICAgICAgc2Nyb2xsVGhyZXNob2xkID0gdGhpcy5nZXRTY3JvbGxUaHJlc2hvbGQoKTtcblxuICAgIC8vIGJhaWwgb3V0IHdoZW4gdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBzY3JvbGwgZXZlbnRcbiAgICBpZiAoIXN1cHBvcnRzT25TY3JvbGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmhpZGVQYWdpbmF0aW9uKCk7XG4gICAgdGhpcy5iaW5kKCk7XG5cbiAgICB0aGlzLm5leHRVcmwgPSB0aGlzLmdldE5leHRVcmwoKTtcblxuICAgIGlmICghdGhpcy5uZXh0VXJsKSB7XG4gICAgICB0aGlzLmZpcmUoJ25vbmVMZWZ0JywgW3RoaXMuZ2V0TGFzdEl0ZW0oKV0pO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0IGxvYWRpbmcgbmV4dCBwYWdlIGlmIGNvbnRlbnQgaXMgc2hvcnRlciB0aGFuIHBhZ2UgZm9sZFxuICAgIGlmICh0aGlzLm5leHRVcmwgJiYgY3VycmVudFNjcm9sbE9mZnNldCA+PSBzY3JvbGxUaHJlc2hvbGQpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAvLyBmbGFnIGFzIGluaXRpYWxpemVkIHdoZW4gcmVuZGVyaW5nIGlzIGNvbXBsZXRlZFxuICAgICAgdGhpcy5vbmUoJ3JlbmRlcmVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5maXJlKCdyZWFkeScpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuZmlyZSgncmVhZHknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVpbml0aWFsaXplcyBJQVMsIGZvciBleGFtcGxlIGFmdGVyIGFuIGFqYXggcGFnZSB1cGRhdGVcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgSUFTLnByb3RvdHlwZS5yZWluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICB0aGlzLnVuYmluZCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCaW5kcyBJQVMgdG8gRE9NIGV2ZW50c1xuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBJQVMucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc0JvdW5kKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy4kc2Nyb2xsQ29udGFpbmVyLm9uKCdzY3JvbGwnLCAkLnByb3h5KHRoaXMudGhyb3R0bGUodGhpcy5zY3JvbGxIYW5kbGVyLCAxNTApLCB0aGlzKSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuZXh0ZW5zaW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuZXh0ZW5zaW9uc1tpXS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuaXNCb3VuZCA9IHRydWU7XG4gICAgdGhpcy5yZXN1bWUoKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5iaW5kcyBJQVMgdG8gZXZlbnRzXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIElBUy5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmlzQm91bmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLiRzY3JvbGxDb250YWluZXIub2ZmKCdzY3JvbGwnLCB0aGlzLnNjcm9sbEhhbmRsZXIpO1xuXG4gICAgLy8gbm90aWZ5IGV4dGVuc2lvbnMgYWJvdXQgdW5iaW5kaW5nXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmV4dGVuc2lvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuZXh0ZW5zaW9uc1tpXVsndW5iaW5kJ10gIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zW2ldLnVuYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmlzQm91bmQgPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveXMgSUFTIGluc3RhbmNlXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIElBUy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmpzWGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIHRoaXMudW5iaW5kKCk7XG5cbiAgICB0aGlzLiRzY3JvbGxDb250YWluZXIuZGF0YSgnaWFzJywgbnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudExpc3RlbmVyXG4gICAqXG4gICAqIE5vdGU6IGNoYWluYWJsZVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIElBU1xuICAgKi9cbiAgSUFTLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjaywgcHJpb3JpdHkpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMubGlzdGVuZXJzW2V2ZW50XSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBubyBldmVudCBjYWxsZWQgXCInICsgZXZlbnQgKyAnXCInKTtcbiAgICB9XG5cbiAgICBwcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG5cbiAgICB0aGlzLmxpc3RlbmVyc1tldmVudF0uYWRkKCQucHJveHkoY2FsbGJhY2ssIHRoaXMpLCBwcmlvcml0eSk7XG5cbiAgICAvLyByZWFkeSBpcyBhbHJlYWR5IGZpcmVkLCBiZWZvcmUgb24oKSBjb3VsZCBldmVuIGJlIGNhbGxlZCwgc29cbiAgICAvLyBsZXQncyBjYWxsIHRoZSBjYWxsYmFjayByaWdodCBhd2F5XG4gICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgaWYgKGV2ZW50ID09PSAncmVhZHknKSB7XG4gICAgICAgICQucHJveHkoY2FsbGJhY2ssIHRoaXMpKCk7XG4gICAgICB9XG4gICAgICAvLyBzYW1lIGFwcGxpZXMgdG8gbm9uZUxlZnRcbiAgICAgIGVsc2UgaWYgKGV2ZW50ID09PSAnbm9uZUxlZnQnICYmICF0aGlzLm5leHRVcmwpIHtcbiAgICAgICAgJC5wcm94eShjYWxsYmFjaywgdGhpcykoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50TGlzdGVuZXIgd2hpY2ggb25seSBnZXRzXG4gICAqIGZpcmVkIG9uY2UuXG4gICAqXG4gICAqIE5vdGU6IGNoYWluYWJsZVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIElBU1xuICAgKi9cbiAgSUFTLnByb3RvdHlwZS5vbmUgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcmVtb3ZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgIHNlbGYub2ZmKGV2ZW50LCByZW1vdmVyKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vbihldmVudCwgY2FsbGJhY2spO1xuICAgIHRoaXMub24oZXZlbnQsIHJlbW92ZXIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gZXZlbnRMaXN0ZW5lclxuICAgKlxuICAgKiBOb3RlOiBjaGFpbmFibGVcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyBJQVNcbiAgICovXG4gIElBUy5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmxpc3RlbmVyc1tldmVudF0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgbm8gZXZlbnQgY2FsbGVkIFwiJyArIGV2ZW50ICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRdLnJlbW92ZShjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTG9hZCB0aGUgbmV4dCBwYWdlXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIElBUy5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB1cmwgPSB0aGlzLm5leHRVcmwsXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnBhdXNlKCk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuZmlyZSgnbmV4dCcsIFt1cmxdKTtcblxuICAgIHByb21pc2UuZG9uZShmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYubG9hZCh1cmwsIGZ1bmN0aW9uKGRhdGEsIGl0ZW1zKSB7XG4gICAgICAgIHNlbGYucmVuZGVyKGl0ZW1zLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLm5leHRVcmwgPSBzZWxmLmdldE5leHRVcmwoZGF0YSk7XG5cbiAgICAgICAgICBpZiAoIXNlbGYubmV4dFVybCkge1xuICAgICAgICAgICAgc2VsZi5maXJlKCdub25lTGVmdCcsIFtzZWxmLmdldExhc3RJdGVtKCldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLnJlc3VtZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcHJvbWlzZS5mYWlsKGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5yZXN1bWUoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGV4dGVuc2lvblxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBJQVMucHJvdG90eXBlLmV4dGVuc2lvbiA9IGZ1bmN0aW9uKGV4dGVuc2lvbikge1xuICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uWydiaW5kJ10gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXh0ZW5zaW9uIGRvZXNuXFwndCBoYXZlIHJlcXVpcmVkIG1ldGhvZCBcImJpbmRcIicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uWydpbml0aWFsaXplJ10gIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGV4dGVuc2lvbi5pbml0aWFsaXplKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuZXh0ZW5zaW9ucy5wdXNoKGV4dGVuc2lvbik7XG5cbiAgICBpZiAodGhpcy5pc0JvdW5kKSB7XG4gICAgICB0aGlzLnJlaW5pdGlhbGl6ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG9ydGN1dC4gU2V0cyB0aGUgd2luZG93IGFzIHNjcm9sbCBjb250YWluZXIuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIG9wdGlvblxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gICQuaWFzID0gZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgdmFyICR3aW5kb3cgPSAkKHdpbmRvdyk7XG5cbiAgICByZXR1cm4gJHdpbmRvdy5pYXMuYXBwbHkoJHdpbmRvdywgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvKipcbiAgICogalF1ZXJ5IHBsdWdpbiBpbml0aWFsaXphdGlvblxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSBvcHRpb25cbiAgICogQHJldHVybnMgeyp9IHRoZSBsYXN0IElBUyBpbnN0YW5jZSB3aWxsIGJlIHJldHVybmVkXG4gICAqL1xuICAkLmZuLmlhcyA9IGZ1bmN0aW9uKG9wdGlvbikge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgcmV0dmFsID0gdGhpcztcblxuICAgIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXG4gICAgICAgICAgaW5zdGFuY2UgPSAkdGhpcy5kYXRhKCdpYXMnKSxcbiAgICAgICAgICBvcHRpb25zID0gJC5leHRlbmQoe30sICQuZm4uaWFzLmRlZmF1bHRzLCAkdGhpcy5kYXRhKCksIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKVxuICAgICAgICAgIDtcblxuICAgICAgLy8gc2V0IGEgbmV3IGluc3RhbmNlIGFzIGRhdGFcbiAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgJHRoaXMuZGF0YSgnaWFzJywgKGluc3RhbmNlID0gbmV3IElBUygkdGhpcywgb3B0aW9ucykpKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5pbml0aWFsaXplKSB7XG4gICAgICAgICAgJChkb2N1bWVudCkucmVhZHkoJC5wcm94eShpbnN0YW5jZS5pbml0aWFsaXplLCBpbnN0YW5jZSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHdoZW4gdGhlIHBsdWdpbiBpcyBjYWxsZWQgd2l0aCBhIG1ldGhvZFxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2Vbb3B0aW9uXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgbm8gbWV0aG9kIGNhbGxlZCBcIicgKyBvcHRpb24gKyAnXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ3Muc2hpZnQoKTsgLy8gcmVtb3ZlIGZpcnN0IGFyZ3VtZW50ICgnb3B0aW9uJylcbiAgICAgICAgaW5zdGFuY2Vbb3B0aW9uXS5hcHBseShpbnN0YW5jZSwgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIHJldHZhbCA9IGluc3RhbmNlO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldHZhbDtcbiAgfTtcblxuICAvKipcbiAgICogUGx1Z2luIGRlZmF1bHRzXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQHR5cGUge29iamVjdH1cbiAgICovXG4gICQuZm4uaWFzLmRlZmF1bHRzID0ge1xuICAgIGl0ZW06ICcuaXRlbScsXG4gICAgY29udGFpbmVyOiAnLmxpc3RpbmcnLFxuICAgIG5leHQ6ICcubmV4dCcsXG4gICAgcGFnaW5hdGlvbjogZmFsc2UsXG4gICAgZGVsYXk6IDYwMCxcbiAgICBuZWdhdGl2ZU1hcmdpbjogMTAsXG4gICAgaW5pdGlhbGl6ZTogdHJ1ZVxuICB9O1xufSkoalF1ZXJ5KTtcbiIsIi8qKlxuICogSUFTIEhpc3RvcnkgRXh0ZW5zaW9uXG4gKiBBbiBJQVMgZXh0ZW5zaW9uIHRvIGVuYWJsZSBicm93c2VyIGhpc3RvcnlcbiAqIGh0dHBzOi8vaW5maW5pdGVhamF4c2Nyb2xsLmNvbVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBJbmZpbml0ZSBBSkFYIFNjcm9sbCBwYWNrYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxOCBXZWJjcmVhdGUgKEplcm9lbiBGaWVnZSlcbiAqL1xuXG52YXIgSUFTSGlzdG9yeUV4dGVuc2lvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBqUXVlcnkuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zKTtcblxuICB0aGlzLmlhcyA9IG51bGw7XG4gIHRoaXMucHJldlNlbGVjdG9yID0gb3B0aW9ucy5wcmV2O1xuICB0aGlzLnByZXZVcmwgPSBudWxsO1xuICB0aGlzLmxpc3RlbmVycyA9IHtcbiAgICBwcmV2OiBuZXcgSUFTQ2FsbGJhY2tzKGpRdWVyeSlcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHBhZ2VOdW1cbiAgICogQHBhcmFtIHNjcm9sbE9mZnNldFxuICAgKiBAcGFyYW0gdXJsXG4gICAqL1xuICB0aGlzLm9uUGFnZUNoYW5nZSA9IGZ1bmN0aW9uIChwYWdlTnVtLCBzY3JvbGxPZmZzZXQsIHVybCkge1xuICAgIGlmICghd2luZG93Lmhpc3RvcnkgfHwgIXdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB2YXIgc3RhdGUgPSBoaXN0b3J5LnN0YXRlO1xuXG4gICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIGRvY3VtZW50LnRpdGxlLCB1cmwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gY3VycmVudFNjcm9sbE9mZnNldFxuICAgKiBAcGFyYW0gc2Nyb2xsVGhyZXNob2xkXG4gICAqL1xuICB0aGlzLm9uU2Nyb2xsID0gZnVuY3Rpb24gKGN1cnJlbnRTY3JvbGxPZmZzZXQsIHNjcm9sbFRocmVzaG9sZCkge1xuICAgIHZhciBmaXJzdEl0ZW1TY3JvbGxUaHJlc2hvbGQgPSB0aGlzLmdldFNjcm9sbFRocmVzaG9sZEZpcnN0SXRlbSgpO1xuXG4gICAgaWYgKCF0aGlzLnByZXZVcmwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50U2Nyb2xsT2Zmc2V0IC09IHRoaXMuaWFzLiRzY3JvbGxDb250YWluZXIuaGVpZ2h0KCk7XG5cbiAgICBpZiAoY3VycmVudFNjcm9sbE9mZnNldCA8PSBmaXJzdEl0ZW1TY3JvbGxUaHJlc2hvbGQpIHtcbiAgICAgIHRoaXMucHJldigpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLm9uUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnRTY3JvbGxPZmZzZXQgPSB0aGlzLmlhcy5nZXRDdXJyZW50U2Nyb2xsT2Zmc2V0KHRoaXMuaWFzLiRzY3JvbGxDb250YWluZXIpLFxuICAgICAgICBmaXJzdEl0ZW1TY3JvbGxUaHJlc2hvbGQgPSB0aGlzLmdldFNjcm9sbFRocmVzaG9sZEZpcnN0SXRlbSgpO1xuXG4gICAgY3VycmVudFNjcm9sbE9mZnNldCAtPSB0aGlzLmlhcy4kc2Nyb2xsQ29udGFpbmVyLmhlaWdodCgpO1xuXG4gICAgaWYgKGN1cnJlbnRTY3JvbGxPZmZzZXQgPD0gZmlyc3RJdGVtU2Nyb2xsVGhyZXNob2xkKSB7XG4gICAgICB0aGlzLnByZXYoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVybCBmb3IgdGhlIG5leHQgcGFnZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5nZXRQcmV2VXJsID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXIgPSB0aGlzLmlhcy4kY29udGFpbmVyO1xuICAgIH1cblxuICAgIC8vIGFsd2F5cyB0YWtlIHRoZSBsYXN0IG1hdGNoaW5nIGl0ZW1cbiAgICByZXR1cm4galF1ZXJ5KHRoaXMucHJldlNlbGVjdG9yLCBjb250YWluZXIpLmxhc3QoKS5hdHRyKCdocmVmJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc2Nyb2xsIHRocmVzaG9sZC4gVGhpcyB0aHJlc2hvbGQgbWFya3MgdGhlIGxpbmUgZnJvbSB3aGVyZVxuICAgKiBJQVMgc2hvdWxkIHN0YXJ0IGxvYWRpbmcgdGhlIG5leHQgcGFnZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5nZXRTY3JvbGxUaHJlc2hvbGRGaXJzdEl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRmaXJzdEVsZW1lbnQ7XG5cbiAgICAkZmlyc3RFbGVtZW50ID0gdGhpcy5pYXMuZ2V0Rmlyc3RJdGVtKCk7XG5cbiAgICAvLyBpZiB0aGUgZG9uJ3QgaGF2ZSBhIGZpcnN0IGVsZW1lbnQsIHRoZSBET00gbWlnaHQgbm90IGhhdmUgYmVlbiBsb2FkZWQsXG4gICAgLy8gb3IgdGhlIHNlbGVjdG9yIGlzIGludmFsaWRcbiAgICBpZiAoMCA9PT0gJGZpcnN0RWxlbWVudC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCRmaXJzdEVsZW1lbnQub2Zmc2V0KCkudG9wKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVycyBpdGVtc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gaXRlbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICB0aGlzLnJlbmRlckJlZm9yZSA9IGZ1bmN0aW9uIChpdGVtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgaWFzID0gdGhpcy5pYXMsXG4gICAgICAgICRmaXJzdEl0ZW0gPSBpYXMuZ2V0Rmlyc3RJdGVtKCksXG4gICAgICAgIGNvdW50ID0gMDtcblxuICAgIGlhcy5maXJlKCdyZW5kZXInLCBbaXRlbXNdKTtcblxuICAgIGpRdWVyeShpdGVtcykuaGlkZSgpOyAvLyBhdCBmaXJzdCwgaGlkZSBpdCBzbyB3ZSBjYW4gZmFkZSBpdCBpbiBsYXRlclxuXG4gICAgJGZpcnN0SXRlbS5iZWZvcmUoaXRlbXMpO1xuXG4gICAgalF1ZXJ5KGl0ZW1zKS5mYWRlSW4oNDAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoKytjb3VudCA8IGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlhcy5maXJlKCdyZW5kZXJlZCcsIFtpdGVtc10pO1xuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5JQVNIaXN0b3J5RXh0ZW5zaW9uLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGlhcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5pYXMgPSBpYXM7XG5cbiAgLy8gZXhwb3NlIHRoZSBleHRlbnNpb25zIGxpc3RlbmVyc1xuICBqUXVlcnkuZXh0ZW5kKGlhcy5saXN0ZW5lcnMsIHRoaXMubGlzdGVuZXJzKTtcblxuICAvLyBleHBvc2UgcHJldiBtZXRob2RcbiAgaWFzLnByZXYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5wcmV2KCk7XG4gIH07XG5cbiAgdGhpcy5wcmV2VXJsID0gdGhpcy5nZXRQcmV2VXJsKCk7XG59O1xuXG4vKipcbiAqIEJpbmQgdG8gZXZlbnRzXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIGlhc1xuICovXG5JQVNIaXN0b3J5RXh0ZW5zaW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGlhcykge1xuICBpYXMub24oJ3BhZ2VDaGFuZ2UnLCBqUXVlcnkucHJveHkodGhpcy5vblBhZ2VDaGFuZ2UsIHRoaXMpKTtcbiAgaWFzLm9uKCdzY3JvbGwnLCBqUXVlcnkucHJveHkodGhpcy5vblNjcm9sbCwgdGhpcykpO1xuICBpYXMub24oJ3JlYWR5JywgalF1ZXJ5LnByb3h5KHRoaXMub25SZWFkeSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge29iamVjdH0gaWFzXG4gKi9cbklBU0hpc3RvcnlFeHRlbnNpb24ucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKGlhcykge1xuICBpYXMub2ZmKCdwYWdlQ2hhbmdlJywgdGhpcy5vblBhZ2VDaGFuZ2UpO1xuICBpYXMub2ZmKCdzY3JvbGwnLCB0aGlzLm9uU2Nyb2xsKTtcbiAgaWFzLm9mZigncmVhZHknLCB0aGlzLm9uUmVhZHkpO1xufTtcblxuLyoqXG4gKiBMb2FkIHRoZSBwcmV2IHBhZ2VcbiAqXG4gKiBAcHVibGljXG4gKi9cbklBU0hpc3RvcnlFeHRlbnNpb24ucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB1cmwgPSB0aGlzLnByZXZVcmwsXG4gICAgICBzZWxmID0gdGhpcyxcbiAgICAgIGlhcyA9IHRoaXMuaWFzO1xuXG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWFzLnBhdXNlKCk7XG5cbiAgdmFyIHByb21pc2UgPSBpYXMuZmlyZSgncHJldicsIFt1cmxdKTtcblxuICBwcm9taXNlLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgIGlhcy5sb2FkKHVybCwgZnVuY3Rpb24gKGRhdGEsIGl0ZW1zKSB7XG4gICAgICBzZWxmLnJlbmRlckJlZm9yZShpdGVtcywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnByZXZVcmwgPSBzZWxmLmdldFByZXZVcmwoZGF0YSk7XG5cbiAgICAgICAgaWFzLnJlc3VtZSgpO1xuXG4gICAgICAgIGlmIChzZWxmLnByZXZVcmwpIHtcbiAgICAgICAgICBzZWxmLnByZXYoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHByb21pc2UuZmFpbChmdW5jdGlvbiAoKSB7XG4gICAgaWFzLnJlc3VtZSgpO1xuICB9KTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5JQVNIaXN0b3J5RXh0ZW5zaW9uLnByb3RvdHlwZS5kZWZhdWx0cyA9IHtcbiAgcHJldjogXCIucHJldlwiXG59O1xuIiwiLyoqXG4gKiBJQVMgTm9uZSBMZWZ0IEV4dGVuc2lvblxuICogQW4gSUFTIGV4dGVuc2lvbiB0byBzaG93IGEgbWVzc2FnZSB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIHBhZ2VzIHRlIGxvYWRcbiAqIGh0dHBzOi8vaW5maW5pdGVhamF4c2Nyb2xsLmNvbVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBJbmZpbml0ZSBBSkFYIFNjcm9sbCBwYWNrYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxOCBXZWJjcmVhdGUgKEplcm9lbiBGaWVnZSlcbiAqL1xuXG52YXIgSUFTTm9uZUxlZnRFeHRlbnNpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBqUXVlcnkuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zKTtcblxuICB0aGlzLmlhcyA9IG51bGw7XG4gIHRoaXMudWlkID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgdGhpcy5odG1sID0gKG9wdGlvbnMuaHRtbCkucmVwbGFjZSgne3RleHR9Jywgb3B0aW9ucy50ZXh0KTtcblxuICAvKipcbiAgICogU2hvd3Mgbm9uZSBsZWZ0IG1lc3NhZ2VcbiAgICovXG4gIHRoaXMuc2hvd05vbmVMZWZ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyICRlbGVtZW50ID0galF1ZXJ5KHRoaXMuaHRtbCkuYXR0cignaWQnLCAnaWFzX25vbmVsZWZ0XycgKyB0aGlzLnVpZCksXG4gICAgICAgICRsYXN0SXRlbSA9IHRoaXMuaWFzLmdldExhc3RJdGVtKCk7XG5cbiAgICAkbGFzdEl0ZW0uYWZ0ZXIoJGVsZW1lbnQpO1xuICAgICRlbGVtZW50LmZhZGVJbigpO1xuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbklBU05vbmVMZWZ0RXh0ZW5zaW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oaWFzKSB7XG4gIHRoaXMuaWFzID0gaWFzO1xuXG4gIGlhcy5vbignbm9uZUxlZnQnLCBqUXVlcnkucHJveHkodGhpcy5zaG93Tm9uZUxlZnQsIHRoaXMpKTtcbn07XG5cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtvYmplY3R9IGlhc1xuICovXG5JQVNOb25lTGVmdEV4dGVuc2lvbi5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oaWFzKSB7XG4gIGlhcy5vZmYoJ25vbmVMZWZ0JywgdGhpcy5zaG93Tm9uZUxlZnQpO1xufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbklBU05vbmVMZWZ0RXh0ZW5zaW9uLnByb3RvdHlwZS5kZWZhdWx0cyA9IHtcbiAgdGV4dDogJ1lvdSByZWFjaGVkIHRoZSBlbmQuJyxcbiAgaHRtbDogJzxkaXYgY2xhc3M9XCJpYXMtbm9uZWxlZnRcIiBzdHlsZT1cInRleHQtYWxpZ246IGNlbnRlcjtcIj57dGV4dH08L2Rpdj4nXG59O1xuIiwiLyoqXG4gKiBJQVMgUGFnaW5nIEV4dGVuc2lvblxuICogQW4gSUFTIGV4dGVuc2lvbiBwcm92aWRpbmcgYWRkaXRpb25hbCBldmVudHNcbiAqIGh0dHBzOi8vaW5maW5pdGVhamF4c2Nyb2xsLmNvbVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBJbmZpbml0ZSBBSkFYIFNjcm9sbCBwYWNrYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxOCBXZWJjcmVhdGUgKEplcm9lbiBGaWVnZSlcbiAqL1xuXG52YXIgSUFTUGFnaW5nRXh0ZW5zaW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaWFzID0gbnVsbDtcbiAgdGhpcy5wYWdlYnJlYWtzID0gW1swLCBkb2N1bWVudC5sb2NhdGlvbi50b1N0cmluZygpXV07XG4gIHRoaXMubGFzdFBhZ2VOdW0gPSAxO1xuICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB0aGlzLmxpc3RlbmVycyA9IHtcbiAgICBwYWdlQ2hhbmdlOiBuZXcgSUFTQ2FsbGJhY2tzKGpRdWVyeSlcbiAgfTtcblxuICAvKipcbiAgICogRmlyZXMgcGFnZUNoYW5nZSBldmVudFxuICAgKlxuICAgKiBAcGFyYW0gY3VycmVudFNjcm9sbE9mZnNldFxuICAgKiBAcGFyYW0gc2Nyb2xsVGhyZXNob2xkXG4gICAqL1xuICB0aGlzLm9uU2Nyb2xsID0gZnVuY3Rpb24oY3VycmVudFNjcm9sbE9mZnNldCwgc2Nyb2xsVGhyZXNob2xkKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaWFzID0gdGhpcy5pYXMsXG4gICAgICAgIGN1cnJlbnRQYWdlTnVtID0gdGhpcy5nZXRDdXJyZW50UGFnZU51bShjdXJyZW50U2Nyb2xsT2Zmc2V0KSxcbiAgICAgICAgY3VycmVudFBhZ2VicmVhayA9IHRoaXMuZ2V0Q3VycmVudFBhZ2VicmVhayhjdXJyZW50U2Nyb2xsT2Zmc2V0KSxcbiAgICAgICAgdXJsUGFnZTtcblxuICAgIGlmICh0aGlzLmxhc3RQYWdlTnVtICE9PSBjdXJyZW50UGFnZU51bSkge1xuICAgICAgdXJsUGFnZSA9IGN1cnJlbnRQYWdlYnJlYWtbMV07XG5cbiAgICAgIGlhcy5maXJlKCdwYWdlQ2hhbmdlJywgW2N1cnJlbnRQYWdlTnVtLCBjdXJyZW50U2Nyb2xsT2Zmc2V0LCB1cmxQYWdlXSk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0UGFnZU51bSA9IGN1cnJlbnRQYWdlTnVtO1xuICB9O1xuXG4gIC8qKlxuICAgKiBLZWVwcyB0cmFjayBvZiBwYWdlYnJlYWtzXG4gICAqXG4gICAqIEBwYXJhbSB1cmxcbiAgICovXG4gIHRoaXMub25OZXh0ID0gZnVuY3Rpb24odXJsKSB7XG4gICAgdmFyIGN1cnJlbnRTY3JvbGxPZmZzZXQgPSB0aGlzLmlhcy5nZXRDdXJyZW50U2Nyb2xsT2Zmc2V0KHRoaXMuaWFzLiRzY3JvbGxDb250YWluZXIpO1xuXG4gICAgdGhpcy5wYWdlYnJlYWtzLnB1c2goW2N1cnJlbnRTY3JvbGxPZmZzZXQsIHVybF0pO1xuXG4gICAgLy8gdHJpZ2dlciBwYWdlQ2hhbmdlIGFuZCB1cGRhdGUgbGFzdFBhZ2VOdW1cbiAgICB2YXIgY3VycmVudFBhZ2VOdW0gPSB0aGlzLmdldEN1cnJlbnRQYWdlTnVtKGN1cnJlbnRTY3JvbGxPZmZzZXQpICsgMTtcblxuICAgIHRoaXMuaWFzLmZpcmUoJ3BhZ2VDaGFuZ2UnLCBbY3VycmVudFBhZ2VOdW0sIGN1cnJlbnRTY3JvbGxPZmZzZXQsIHVybF0pO1xuXG4gICAgdGhpcy5sYXN0UGFnZU51bSA9IGN1cnJlbnRQYWdlTnVtO1xuICB9O1xuXG4gIC8qKlxuICAgKiBLZWVwcyB0cmFjayBvZiBwYWdlYnJlYWtzXG4gICAqXG4gICAqIEBwYXJhbSB1cmxcbiAgICovXG4gIHRoaXMub25QcmV2ID0gZnVuY3Rpb24odXJsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBpYXMgPSBzZWxmLmlhcyxcbiAgICAgICAgY3VycmVudFNjcm9sbE9mZnNldCA9IGlhcy5nZXRDdXJyZW50U2Nyb2xsT2Zmc2V0KGlhcy4kc2Nyb2xsQ29udGFpbmVyKSxcbiAgICAgICAgcHJldkN1cnJlbnRTY3JvbGxPZmZzZXQgPSBjdXJyZW50U2Nyb2xsT2Zmc2V0IC0gaWFzLiRzY3JvbGxDb250YWluZXIuaGVpZ2h0KCksXG4gICAgICAgICRmaXJzdEl0ZW0gPSBpYXMuZ2V0Rmlyc3RJdGVtKCk7XG5cbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgIHRoaXMucGFnZWJyZWFrcy51bnNoaWZ0KFswLCB1cmxdKTtcblxuICAgIGlhcy5vbmUoJ3JlbmRlcmVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAvLyB1cGRhdGUgcGFnZWJyZWFrc1xuICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBzZWxmLnBhZ2VicmVha3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHNlbGYucGFnZWJyZWFrc1tpXVswXSA9IHNlbGYucGFnZWJyZWFrc1tpXVswXSArICRmaXJzdEl0ZW0ub2Zmc2V0KCkudG9wO1xuICAgICAgfVxuXG4gICAgICAvLyB0cmlnZ2VyIHBhZ2VDaGFuZ2UgYW5kIHVwZGF0ZSBsYXN0UGFnZU51bVxuICAgICAgdmFyIGN1cnJlbnRQYWdlTnVtID0gc2VsZi5nZXRDdXJyZW50UGFnZU51bShwcmV2Q3VycmVudFNjcm9sbE9mZnNldCkgKyAxO1xuXG4gICAgICBpYXMuZmlyZSgncGFnZUNoYW5nZScsIFtjdXJyZW50UGFnZU51bSwgcHJldkN1cnJlbnRTY3JvbGxPZmZzZXQsIHVybF0pO1xuXG4gICAgICBzZWxmLmxhc3RQYWdlTnVtID0gY3VycmVudFBhZ2VOdW07XG5cbiAgICAgIHNlbGYuZW5hYmxlZCA9IHRydWU7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuSUFTUGFnaW5nRXh0ZW5zaW9uLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oaWFzKSB7XG4gIHRoaXMuaWFzID0gaWFzO1xuXG4gIC8vIGV4cG9zZSB0aGUgZXh0ZW5zaW9ucyBsaXN0ZW5lcnNcbiAgalF1ZXJ5LmV4dGVuZChpYXMubGlzdGVuZXJzLCB0aGlzLmxpc3RlbmVycyk7XG59O1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuSUFTUGFnaW5nRXh0ZW5zaW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oaWFzKSB7XG4gIHRyeSB7XG4gICAgaWFzLm9uKCdwcmV2JywgalF1ZXJ5LnByb3h5KHRoaXMub25QcmV2LCB0aGlzKSwgdGhpcy5wcmlvcml0eSk7XG4gIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICBpYXMub24oJ25leHQnLCBqUXVlcnkucHJveHkodGhpcy5vbk5leHQsIHRoaXMpLCB0aGlzLnByaW9yaXR5KTtcbiAgaWFzLm9uKCdzY3JvbGwnLCBqUXVlcnkucHJveHkodGhpcy5vblNjcm9sbCwgdGhpcyksIHRoaXMucHJpb3JpdHkpO1xufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge29iamVjdH0gaWFzXG4gKi9cbklBU1BhZ2luZ0V4dGVuc2lvbi5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oaWFzKSB7XG4gIHRyeSB7XG4gICAgaWFzLm9mZigncHJldicsIHRoaXMub25QcmV2KTtcbiAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gIGlhcy5vZmYoJ25leHQnLCB0aGlzLm9uTmV4dCk7XG4gIGlhcy5vZmYoJ3Njcm9sbCcsIHRoaXMub25TY3JvbGwpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGN1cnJlbnQgcGFnZSBudW1iZXIgYmFzZWQgb24gc2Nyb2xsIG9mZnNldFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxPZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbklBU1BhZ2luZ0V4dGVuc2lvbi5wcm90b3R5cGUuZ2V0Q3VycmVudFBhZ2VOdW0gPSBmdW5jdGlvbihzY3JvbGxPZmZzZXQpIHtcbiAgZm9yICh2YXIgaSA9ICh0aGlzLnBhZ2VicmVha3MubGVuZ3RoIC0gMSk7IGkgPiAwOyBpLS0pIHtcbiAgICBpZiAoc2Nyb2xsT2Zmc2V0ID4gdGhpcy5wYWdlYnJlYWtzW2ldWzBdKSB7XG4gICAgICByZXR1cm4gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgY3VycmVudCBwYWdlYnJlYWsgaW5mb3JtYXRpb24gYmFzZWQgb24gc2Nyb2xsIG9mZnNldFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxPZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9fG51bGxcbiAqL1xuSUFTUGFnaW5nRXh0ZW5zaW9uLnByb3RvdHlwZS5nZXRDdXJyZW50UGFnZWJyZWFrID0gZnVuY3Rpb24oc2Nyb2xsT2Zmc2V0KSB7XG4gIGZvciAodmFyIGkgPSAodGhpcy5wYWdlYnJlYWtzLmxlbmd0aCAtIDEpOyBpID49IDA7IGktLSkge1xuICAgIGlmIChzY3JvbGxPZmZzZXQgPiB0aGlzLnBhZ2VicmVha3NbaV1bMF0pIHtcbiAgICAgIHJldHVybiB0aGlzLnBhZ2VicmVha3NbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbklBU1BhZ2luZ0V4dGVuc2lvbi5wcm90b3R5cGUucHJpb3JpdHkgPSA1MDA7XG4iLCIvKipcbiAqIElBUyBTcGlubmVyIEV4dGVuc2lvblxuICogQW4gSUFTIGV4dGVuc2lvbiB0byBzaG93IGEgc3Bpbm5lciB3aGVuIGxvYWRpbmdcbiAqIGh0dHBzOi8vaW5maW5pdGVhamF4c2Nyb2xsLmNvbVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBJbmZpbml0ZSBBSkFYIFNjcm9sbCBwYWNrYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxOCBXZWJjcmVhdGUgKEplcm9lbiBGaWVnZSlcbiAqL1xuXG52YXIgSUFTU3Bpbm5lckV4dGVuc2lvbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGpRdWVyeS5leHRlbmQoe30sIHRoaXMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuaWFzID0gbnVsbDtcbiAgdGhpcy51aWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgdGhpcy5zcmMgPSBvcHRpb25zLnNyYztcbiAgdGhpcy5odG1sID0gKG9wdGlvbnMuaHRtbCkucmVwbGFjZSgne3NyY30nLCB0aGlzLnNyYyk7XG5cbiAgLyoqXG4gICAqIFNob3dzIHNwaW5uZXJcbiAgICovXG4gIHRoaXMuc2hvd1NwaW5uZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgJHNwaW5uZXIgPSB0aGlzLmdldFNwaW5uZXIoKSB8fCB0aGlzLmNyZWF0ZVNwaW5uZXIoKSxcbiAgICAgICAgJGxhc3RJdGVtID0gdGhpcy5pYXMuZ2V0TGFzdEl0ZW0oKTtcblxuICAgICRsYXN0SXRlbS5hZnRlcigkc3Bpbm5lcik7XG4gICAgJHNwaW5uZXIuZmFkZUluKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3dzIHNwaW5uZXJcbiAgICovXG4gIHRoaXMuc2hvd1NwaW5uZXJCZWZvcmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgJHNwaW5uZXIgPSB0aGlzLmdldFNwaW5uZXIoKSB8fCB0aGlzLmNyZWF0ZVNwaW5uZXIoKSxcbiAgICAgICAgJGZpcnN0SXRlbSA9IHRoaXMuaWFzLmdldEZpcnN0SXRlbSgpO1xuXG4gICAgJGZpcnN0SXRlbS5iZWZvcmUoJHNwaW5uZXIpO1xuICAgICRzcGlubmVyLmZhZGVJbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHNwaW5uZXJcbiAgICovXG4gIHRoaXMucmVtb3ZlU3Bpbm5lciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmhhc1NwaW5uZXIoKSkge1xuICAgICAgdGhpcy5nZXRTcGlubmVyKCkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7alF1ZXJ5fGJvb2xlYW59XG4gICAqL1xuICB0aGlzLmdldFNwaW5uZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgJHNwaW5uZXIgPSBqUXVlcnkoJyNpYXNfc3Bpbm5lcl8nICsgdGhpcy51aWQpO1xuXG4gICAgaWYgKCRzcGlubmVyLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiAkc3Bpbm5lcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5oYXNTcGlubmVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyICRzcGlubmVyID0galF1ZXJ5KCcjaWFzX3NwaW5uZXJfJyArIHRoaXMudWlkKTtcblxuICAgIHJldHVybiAoJHNwaW5uZXIubGVuZ3RoID4gMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtqUXVlcnl9XG4gICAqL1xuICB0aGlzLmNyZWF0ZVNwaW5uZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgJHNwaW5uZXIgPSBqUXVlcnkodGhpcy5odG1sKS5hdHRyKCdpZCcsICdpYXNfc3Bpbm5lcl8nICsgdGhpcy51aWQpO1xuXG4gICAgJHNwaW5uZXIuaGlkZSgpO1xuXG4gICAgcmV0dXJuICRzcGlubmVyO1xuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbklBU1NwaW5uZXJFeHRlbnNpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihpYXMpIHtcbiAgdGhpcy5pYXMgPSBpYXM7XG5cbiAgaWFzLm9uKCduZXh0JywgalF1ZXJ5LnByb3h5KHRoaXMuc2hvd1NwaW5uZXIsIHRoaXMpKTtcbiAgaWFzLm9uKCdyZW5kZXInLCBqUXVlcnkucHJveHkodGhpcy5yZW1vdmVTcGlubmVyLCB0aGlzKSk7XG5cbiAgdHJ5IHtcbiAgICBpYXMub24oJ3ByZXYnLCBqUXVlcnkucHJveHkodGhpcy5zaG93U3Bpbm5lckJlZm9yZSwgdGhpcykpO1xuICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG59O1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7b2JqZWN0fSBpYXNcbiAqL1xuSUFTU3Bpbm5lckV4dGVuc2lvbi5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oaWFzKSB7XG4gIGlhcy5vZmYoJ25leHQnLCB0aGlzLnNob3dTcGlubmVyKTtcbiAgaWFzLm9mZigncmVuZGVyJywgdGhpcy5yZW1vdmVTcGlubmVyKTtcblxuICB0cnkge1xuICAgIGlhcy5vZmYoJ3ByZXYnLCB0aGlzLnNob3dTcGlubmVyQmVmb3JlKTtcbiAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbklBU1NwaW5uZXJFeHRlbnNpb24ucHJvdG90eXBlLmRlZmF1bHRzID0ge1xuICBzcmM6ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhFQUFRQVBRQUFQLy8vd0FBQVBEdzhJcUtpdURnNEVaR1JucDZlZ0FBQUZoWVdDUWtKS3lzckw2K3ZoUVVGSnljbkFRRUJEWTJObWhvYUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNIL0MwNUZWRk5EUVZCRk1pNHdBd0VBQUFBaC9ocERjbVZoZEdWa0lIZHBkR2dnWVdwaGVHeHZZV1F1YVc1bWJ3QWgrUVFKQ2dBQUFDd0FBQUFBRUFBUUFBQUZkeUFnQWdJSkllV29Ba1JDQ01kQmtLdElISW5neU1Lc0VyUEJZYkFEcGtTQ3doRG1RQ0JldGhSQjZWajRrRkNrUVBHNElsV0Rnck5SSXduTzRVS0JYRHVmelF2RE1hb1NEQmdGYjg4Nk1pUWFkZ05BQkFva2ZDd3pCQThMQ2cwRWdsOGpBZ2dHQUExa0JJQTFCQVl6bHlJTGN6VUxDMlVoQUNINUJBa0tBQUFBTEFBQUFBQVFBQkFBQUFWMklDQUNBbWxBWlRtT1JFRUl5VUVRakxLS3hQSEFEaEV2cXhsZ2NHZ2tHSTFEWVNWQUlBV014K2x3U0trSUNKMFFzSGk5UmdLQnduVlRpUlFRZ3dGNEk0VUZEUVFFd2k2LzNZU0dXUlJtamhFRVRBSmZJZ01GQ25BS00wS0RWNEVFRUFRTGlGMThUQVlOWERhU2UzeDZtamlkTjFzM0lRQWgrUVFKQ2dBQUFDd0FBQUFBRUFBUUFBQUZlQ0FnQWdMWkRHVTVqZ1JFQ0VVaUNJK3lpb1NEd0RKeUxLc1hvSEZReEJTSEFvQUFGQmhxdE1KZzhEZ1FCZ2ZyRXNKQUVBZzRZaFpJRWl3Z0t0SGlNQmd0cGczd2JVWlhHTzdrT2IxTVVLUkZNeXNDQ2hBb2dnSkNJZzBHQzJhTmU0Z3FRbGRmTDRsL0FnMUFYeVNKZ241TGNvRTNRWEkzSVFBaCtRUUpDZ0FBQUN3QUFBQUFFQUFRQUFBRmRpQWdBZ0xaTkdVNWpvUWhDRWp4SXNzcUVvOGJDOUJSank5QWc3R0lMUTRRRW9FMGdCQUVCY09wY0JBMERveFNLL2U4TFJJSG4raTFjSzBJeUtkZzBWQW9sallJZytHZ25ScndWUy84SUFrSUN5b3NCSVFwQkFNb0t5OWRJbXhQaFMrR0trRnJrWCtUaWd0TGxJeUtYVUYrTmphZ05pRUFJZmtFQ1FvQUFBQXNBQUFBQUJBQUVBQUFCV3dnSUFJQ2FSaGxPWTRFSWdqSDhSN0xLaEtIR3dzTXZiNEFBeTNXT0RCSUJCS0NzWUE5VGp1aEROREtFVlNFUmV6UUVMMFdyaFh1Y1JVUUd1aWs3YkZsbmd6cVZXOUxNbDlYV3ZMZGpGYUp0REZxWjFjRVpVQjBkVWd2TDNkZ1A0V0pabjRqa29tV05wU1RJeUVBSWZrRUNRb0FBQUFzQUFBQUFCQUFFQUFBQlg0Z0lBSUN1U3hsT1k2Q0lnaUQ4UnJFS2dxR093eHdVck1sQW9Td0l6QUdwSnBnb1NEQUdpZkRZNWtvcEJZRGxFcEFRQndldnhmQnRSSVVHaTh4d1drRE5CQ0l3bUM5VnEwYWlRUURRdUsrVmdRUERYVjloQ0pqQndjRllVNXBMd3dIWFFjTUtTbU5MUWNJQUV4bGJIOEpCd3R0YVgwQUJBY05iV1ZiS3lFQUlma0VDUW9BQUFBc0FBQUFBQkFBRUFBQUJYa2dJQUlDU1JCbE9ZN0NJZ2hOOHpiRUtzS29JamRGelphRWdVQkhLQ2hNSnRSd2NXcEFXb1duaWZtNkVTQU1oTzhsUUswRUVBVjNyRm9wSUJDRWNHd0RLQXFQaDRIVXJZNElDSEgxZFNvVEZnY0hVaVpqQmhBSkIyQUhEeWtwS0F3SEF3ZHpmMTlLa0FTSVBsOWNEZ2NuRGtkdE53aU1KQ3NoQUNINUJBa0tBQUFBTEFBQUFBQVFBQkFBQUFWM0lDQUNBa2tRWlRtT0Fpb3NpeUFveENxK0tQeENOVnNTTVJnQnNpQ2xXckxUU1dGb0lRWkhsNnBsZUJoNnN1eEtNSWhsdnpiQXdrQldmRldyQlFUeE5McTJSRzJ5aFNVa0RzMmI2M0FZREFvSlhBY0ZSd0FEZUFrSkRYMEFRQ3NFZkFRTURBSVBCejByQ2djeGt5MEpSV0UxQW13cEt5RUFJZmtFQ1FvQUFBQXNBQUFBQUJBQUVBQUFCWGtnSUFJQ0taemtxSjRuUVp4THFaS3Y0TnFOTEtLMi9RNEVrNGxGWENoc2c1eXBKanMxSUkzZ0VEVVNSSW5FR1lBdzZCNnpNNEpockRBdEVvc1ZrTFV0SEE3UkhhSEFHSlFFanNPRGNFZzBGQkFGVmdrUUpRMXBBd2NERHc4S2NGdFNJbndKQW93Q0NBNlJJd3FaQWdrUE5nVnBXbmRqZHlvaEFDSDVCQWtLQUFBQUxBQUFBQUFRQUJBQUFBVjVJQ0FDQWltYzVLaWVMRXVVS3ZtMnhBS0xxRENmQzJHYU85ZUwwTEFCV1RpQlltQTA2VzZrSGd2Q3FFSmlBSUppdTNnY3ZnVXNzY0hVRVJtK2thQ3h5eGErelJQazBTZ0pFZ2ZJdmJBZElBUUxDQVlsQ2o0REJ3MElCUXNNQ2pJcUJBY1BBb29DQmc5cEtnc0pMd1VGT2hDWkt5UURBM1lxSVFBaCtRUUpDZ0FBQUN3QUFBQUFFQUFRQUFBRmRTQWdBZ0lwbk9Tb25teGJxaVRoQ3JKS0VIRmJvOEp4RERPWllGRmIrQTQxRTRINE9oa09pcFh3QkVsWUlUREFja0ZFT0JnTVEzYXJrTWtVQmR4SVVHWnBFYjdrYVFCUmxBU1BnMEZRUUhBYkVFTUdEU1ZFQUExUUJoQUVEMUUwTmd3RkFvb0NEV2xqYVFJUUNFNXFNSGNOaENraklRQWgrUVFKQ2dBQUFDd0FBQUFBRUFBUUFBQUZlU0FnQWdJcG5PU29MZ3h4dnFnS0xFY0NDNjVLRUFCeUtLOGNTcEE0REFpSFEvRGtLaEdLaDRaQ3RDeVpHbzZGNmlZWVBBcUZnWXkwMnhrU2FMRU1WMzR0RUx5UllORXNDUXlIbHZXa0dDenNQZ01DRUFZN0NnMDRVazQ4TEFzRGhSQThNVlFQRUYwR0FncVlZd1NSbHljTmNXc2tDa0FwSXlFQU93QUFBQUFBQUFBQUFBPT0nLFxuICBodG1sOiAnPGRpdiBjbGFzcz1cImlhcy1zcGlubmVyXCIgc3R5bGU9XCJ0ZXh0LWFsaWduOiBjZW50ZXI7XCI+PGltZyBzcmM9XCJ7c3JjfVwiLz48L2Rpdj4nXG59O1xuIiwiLyoqXG4gKiBJQVMgVHJpZ2dlciBFeHRlbnNpb25cbiAqIEFuIElBUyBleHRlbnNpb24gdG8gc2hvdyBhIHRyaWdnZXIgbGluayB0byBsb2FkIHRoZSBuZXh0IHBhZ2VcbiAqIGh0dHBzOi8vaW5maW5pdGVhamF4c2Nyb2xsLmNvbVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBJbmZpbml0ZSBBSkFYIFNjcm9sbCBwYWNrYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxOCBXZWJjcmVhdGUgKEplcm9lbiBGaWVnZSlcbiAqL1xuXG52YXIgSUFTVHJpZ2dlckV4dGVuc2lvbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGpRdWVyeS5leHRlbmQoe30sIHRoaXMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuaWFzID0gbnVsbDtcbiAgdGhpcy5odG1sID0gKG9wdGlvbnMuaHRtbCkucmVwbGFjZSgne3RleHR9Jywgb3B0aW9ucy50ZXh0KTtcbiAgdGhpcy5odG1sUHJldiA9IChvcHRpb25zLmh0bWxQcmV2KS5yZXBsYWNlKCd7dGV4dH0nLCBvcHRpb25zLnRleHRQcmV2KTtcbiAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgdGhpcy5jb3VudCA9IDA7XG4gIHRoaXMub2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XG4gIHRoaXMuJHRyaWdnZXJOZXh0ID0gbnVsbDtcbiAgdGhpcy4kdHJpZ2dlclByZXYgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTaG93cyB0cmlnZ2VyIGZvciBuZXh0IHBhZ2VcbiAgICovXG4gIHRoaXMuc2hvd1RyaWdnZXJOZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChmYWxzZSA9PT0gdGhpcy5vZmZzZXQgfHwgKyt0aGlzLmNvdW50IDwgdGhpcy5vZmZzZXQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciAkdHJpZ2dlciA9IHRoaXMuJHRyaWdnZXJOZXh0IHx8ICh0aGlzLiR0cmlnZ2VyTmV4dCA9IHRoaXMuY3JlYXRlVHJpZ2dlcih0aGlzLm5leHQsIHRoaXMuaHRtbCkpO1xuICAgIHZhciAkbGFzdEl0ZW0gPSB0aGlzLmlhcy5nZXRMYXN0SXRlbSgpO1xuXG4gICAgJGxhc3RJdGVtLmFmdGVyKCR0cmlnZ2VyKTtcbiAgICAkdHJpZ2dlci5mYWRlSW4oKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogU2hvd3MgdHJpZ2dlciBmb3IgcHJldmlvdXMgcGFnZVxuICAgKi9cbiAgdGhpcy5zaG93VHJpZ2dlclByZXYgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyICR0cmlnZ2VyID0gdGhpcy4kdHJpZ2dlclByZXYgfHwgKHRoaXMuJHRyaWdnZXJQcmV2ID0gdGhpcy5jcmVhdGVUcmlnZ2VyKHRoaXMucHJldiwgdGhpcy5odG1sUHJldikpO1xuICAgIHZhciAkZmlyc3RJdGVtID0gdGhpcy5pYXMuZ2V0Rmlyc3RJdGVtKCk7XG5cbiAgICAkZmlyc3RJdGVtLmJlZm9yZSgkdHJpZ2dlcik7XG4gICAgJHRyaWdnZXIuZmFkZUluKCk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgdGhpcy5vblJlbmRlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIGNsaWNrQ2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgKi9cbiAgdGhpcy5jcmVhdGVUcmlnZ2VyID0gZnVuY3Rpb24oY2xpY2tDYWxsYmFjaywgaHRtbCkge1xuICAgIHZhciB1aWQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuICAgICAgICAkdHJpZ2dlcjtcblxuICAgIGh0bWwgPSBodG1sIHx8IHRoaXMuaHRtbDtcbiAgICAkdHJpZ2dlciA9IGpRdWVyeShodG1sKS5hdHRyKCdpZCcsICdpYXNfdHJpZ2dlcl8nICsgdWlkKTtcblxuICAgICR0cmlnZ2VyLmhpZGUoKTtcbiAgICAkdHJpZ2dlci5vbignY2xpY2snLCBqUXVlcnkucHJveHkoY2xpY2tDYWxsYmFjaywgdGhpcykpO1xuXG4gICAgcmV0dXJuICR0cmlnZ2VyO1xuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge29iamVjdH0gaWFzXG4gKi9cbklBU1RyaWdnZXJFeHRlbnNpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihpYXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuaWFzID0gaWFzO1xuXG4gIGlhcy5vbignbmV4dCcsIGpRdWVyeS5wcm94eSh0aGlzLnNob3dUcmlnZ2VyTmV4dCwgdGhpcyksIHRoaXMucHJpb3JpdHkpO1xuICBpYXMub24oJ3JlbmRlcmVkJywgalF1ZXJ5LnByb3h5KHRoaXMub25SZW5kZXJlZCwgdGhpcyksIHRoaXMucHJpb3JpdHkpO1xuXG4gIHRyeSB7XG4gICAgaWFzLm9uKCdwcmV2JywgalF1ZXJ5LnByb3h5KHRoaXMuc2hvd1RyaWdnZXJQcmV2LCB0aGlzKSwgdGhpcy5wcmlvcml0eSk7XG4gIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbn07XG5cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtvYmplY3R9IGlhc1xuICovXG5JQVNUcmlnZ2VyRXh0ZW5zaW9uLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbihpYXMpIHtcbiAgaWFzLm9mZignbmV4dCcsIHRoaXMuc2hvd1RyaWdnZXJOZXh0KTtcbiAgaWFzLm9mZigncmVuZGVyZWQnLCB0aGlzLm9uUmVuZGVyZWQpO1xuXG4gIHRyeSB7XG4gICAgaWFzLm9mZigncHJldicsIHRoaXMuc2hvd1RyaWdnZXJQcmV2KTtcbiAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbklBU1RyaWdnZXJFeHRlbnNpb24ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gIHRoaXMuaWFzLnBhdXNlKCk7XG5cbiAgaWYgKHRoaXMuJHRyaWdnZXJOZXh0KSB7XG4gICAgdGhpcy4kdHJpZ2dlck5leHQucmVtb3ZlKCk7XG4gICAgdGhpcy4kdHJpZ2dlck5leHQgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5pYXMubmV4dCgpO1xufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbklBU1RyaWdnZXJFeHRlbnNpb24ucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gIHRoaXMuaWFzLnBhdXNlKCk7XG5cbiAgaWYgKHRoaXMuJHRyaWdnZXJQcmV2KSB7XG4gICAgdGhpcy4kdHJpZ2dlclByZXYucmVtb3ZlKCk7XG4gICAgdGhpcy4kdHJpZ2dlclByZXYgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5pYXMucHJldigpO1xufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbklBU1RyaWdnZXJFeHRlbnNpb24ucHJvdG90eXBlLmRlZmF1bHRzID0ge1xuICB0ZXh0OiAnTG9hZCBtb3JlIGl0ZW1zJyxcbiAgaHRtbDogJzxkaXYgY2xhc3M9XCJpYXMtdHJpZ2dlciBpYXMtdHJpZ2dlci1uZXh0XCIgc3R5bGU9XCJ0ZXh0LWFsaWduOiBjZW50ZXI7IGN1cnNvcjogcG9pbnRlcjtcIj48YT57dGV4dH08L2E+PC9kaXY+JyxcbiAgdGV4dFByZXY6ICdMb2FkIHByZXZpb3VzIGl0ZW1zJyxcbiAgaHRtbFByZXY6ICc8ZGl2IGNsYXNzPVwiaWFzLXRyaWdnZXIgaWFzLXRyaWdnZXItcHJldlwiIHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyOyBjdXJzb3I6IHBvaW50ZXI7XCI+PGE+e3RleHR9PC9hPjwvZGl2PicsXG4gIG9mZnNldDogMFxufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5JQVNUcmlnZ2VyRXh0ZW5zaW9uLnByb3RvdHlwZS5wcmlvcml0eSA9IDEwMDA7XG4iLCIvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gZmFuY3lCb3ggdjMuNS43XG4vL1xuLy8gTGljZW5zZWQgR1BMdjMgZm9yIG9wZW4gc291cmNlIHVzZVxuLy8gb3IgZmFuY3lCb3ggQ29tbWVyY2lhbCBMaWNlbnNlIGZvciBjb21tZXJjaWFsIHVzZVxuLy9cbi8vIGh0dHA6Ly9mYW5jeWFwcHMuY29tL2ZhbmN5Ym94L1xuLy8gQ29weXJpZ2h0IDIwMTkgZmFuY3lBcHBzXG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgJCwgdW5kZWZpbmVkKSB7XHJcbiAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gIHdpbmRvdy5jb25zb2xlID0gd2luZG93LmNvbnNvbGUgfHwge1xyXG4gICAgaW5mbzogZnVuY3Rpb24gKHN0dWZmKSB7fVxyXG4gIH07XHJcblxyXG4gIC8vIElmIHRoZXJlJ3Mgbm8galF1ZXJ5LCBmYW5jeUJveCBjYW4ndCB3b3JrXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgaWYgKCEkKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBpZiBmYW5jeUJveCBpcyBhbHJlYWR5IGluaXRpYWxpemVkXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICBpZiAoJC5mbi5mYW5jeWJveCkge1xyXG4gICAgY29uc29sZS5pbmZvKFwiZmFuY3lCb3ggYWxyZWFkeSBpbml0aWFsaXplZFwiKTtcclxuXHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBQcml2YXRlIGRlZmF1bHQgc2V0dGluZ3NcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgdmFyIGRlZmF1bHRzID0ge1xyXG4gICAgLy8gQ2xvc2UgZXhpc3RpbmcgbW9kYWxzXHJcbiAgICAvLyBTZXQgdGhpcyB0byBmYWxzZSBpZiB5b3UgZG8gbm90IG5lZWQgdG8gc3RhY2sgbXVsdGlwbGUgaW5zdGFuY2VzXHJcbiAgICBjbG9zZUV4aXN0aW5nOiBmYWxzZSxcclxuXHJcbiAgICAvLyBFbmFibGUgaW5maW5pdGUgZ2FsbGVyeSBuYXZpZ2F0aW9uXHJcbiAgICBsb29wOiBmYWxzZSxcclxuXHJcbiAgICAvLyBIb3Jpem9udGFsIHNwYWNlIGJldHdlZW4gc2xpZGVzXHJcbiAgICBndXR0ZXI6IDUwLFxyXG5cclxuICAgIC8vIEVuYWJsZSBrZXlib2FyZCBuYXZpZ2F0aW9uXHJcbiAgICBrZXlib2FyZDogdHJ1ZSxcclxuXHJcbiAgICAvLyBTaG91bGQgYWxsb3cgY2FwdGlvbiB0byBvdmVybGFwIHRoZSBjb250ZW50XHJcbiAgICBwcmV2ZW50Q2FwdGlvbk92ZXJsYXA6IHRydWUsXHJcblxyXG4gICAgLy8gU2hvdWxkIGRpc3BsYXkgbmF2aWdhdGlvbiBhcnJvd3MgYXQgdGhlIHNjcmVlbiBlZGdlc1xyXG4gICAgYXJyb3dzOiB0cnVlLFxyXG5cclxuICAgIC8vIFNob3VsZCBkaXNwbGF5IGNvdW50ZXIgYXQgdGhlIHRvcCBsZWZ0IGNvcm5lclxyXG4gICAgaW5mb2JhcjogdHJ1ZSxcclxuXHJcbiAgICAvLyBTaG91bGQgZGlzcGxheSBjbG9zZSBidXR0b24gKHVzaW5nIGBidG5UcGwuc21hbGxCdG5gIHRlbXBsYXRlKSBvdmVyIHRoZSBjb250ZW50XHJcbiAgICAvLyBDYW4gYmUgdHJ1ZSwgZmFsc2UsIFwiYXV0b1wiXHJcbiAgICAvLyBJZiBcImF1dG9cIiAtIHdpbGwgYmUgYXV0b21hdGljYWxseSBlbmFibGVkIGZvciBcImh0bWxcIiwgXCJpbmxpbmVcIiBvciBcImFqYXhcIiBpdGVtc1xyXG4gICAgc21hbGxCdG46IFwiYXV0b1wiLFxyXG5cclxuICAgIC8vIFNob3VsZCBkaXNwbGF5IHRvb2xiYXIgKGJ1dHRvbnMgYXQgdGhlIHRvcClcclxuICAgIC8vIENhbiBiZSB0cnVlLCBmYWxzZSwgXCJhdXRvXCJcclxuICAgIC8vIElmIFwiYXV0b1wiIC0gd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGhpZGRlbiBpZiBcInNtYWxsQnRuXCIgaXMgZW5hYmxlZFxyXG4gICAgdG9vbGJhcjogXCJhdXRvXCIsXHJcblxyXG4gICAgLy8gV2hhdCBidXR0b25zIHNob3VsZCBhcHBlYXIgaW4gdGhlIHRvcCByaWdodCBjb3JuZXIuXHJcbiAgICAvLyBCdXR0b25zIHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0ZW1wbGF0ZXMgZnJvbSBgYnRuVHBsYCBvcHRpb25cclxuICAgIC8vIGFuZCB0aGV5IHdpbGwgYmUgcGxhY2VkIGludG8gdG9vbGJhciAoY2xhc3M9XCJmYW5jeWJveC10b29sYmFyXCJgIGVsZW1lbnQpXHJcbiAgICBidXR0b25zOiBbXHJcbiAgICAgIFwiem9vbVwiLFxyXG4gICAgICAvL1wic2hhcmVcIixcclxuICAgICAgXCJzbGlkZVNob3dcIixcclxuICAgICAgLy9cImZ1bGxTY3JlZW5cIixcclxuICAgICAgLy9cImRvd25sb2FkXCIsXHJcbiAgICAgIFwidGh1bWJzXCIsXHJcbiAgICAgIFwiY2xvc2VcIlxyXG4gICAgXSxcclxuXHJcbiAgICAvLyBEZXRlY3QgXCJpZGxlXCIgdGltZSBpbiBzZWNvbmRzXHJcbiAgICBpZGxlVGltZTogMyxcclxuXHJcbiAgICAvLyBEaXNhYmxlIHJpZ2h0LWNsaWNrIGFuZCB1c2Ugc2ltcGxlIGltYWdlIHByb3RlY3Rpb24gZm9yIGltYWdlc1xyXG4gICAgcHJvdGVjdDogZmFsc2UsXHJcblxyXG4gICAgLy8gU2hvcnRjdXQgdG8gbWFrZSBjb250ZW50IFwibW9kYWxcIiAtIGRpc2FibGUga2V5Ym9hcmQgbmF2aWd0aW9uLCBoaWRlIGJ1dHRvbnMsIGV0Y1xyXG4gICAgbW9kYWw6IGZhbHNlLFxyXG5cclxuICAgIGltYWdlOiB7XHJcbiAgICAgIC8vIFdhaXQgZm9yIGltYWdlcyB0byBsb2FkIGJlZm9yZSBkaXNwbGF5aW5nXHJcbiAgICAgIC8vICAgdHJ1ZSAgLSB3YWl0IGZvciBpbWFnZSB0byBsb2FkIGFuZCB0aGVuIGRpc3BsYXk7XHJcbiAgICAgIC8vICAgZmFsc2UgLSBkaXNwbGF5IHRodW1ibmFpbCBhbmQgbG9hZCB0aGUgZnVsbC1zaXplZCBpbWFnZSBvdmVyIHRvcCxcclxuICAgICAgLy8gICAgICAgICAgIHJlcXVpcmVzIHByZWRlZmluZWQgaW1hZ2UgZGltZW5zaW9ucyAoYGRhdGEtd2lkdGhgIGFuZCBgZGF0YS1oZWlnaHRgIGF0dHJpYnV0ZXMpXHJcbiAgICAgIHByZWxvYWQ6IGZhbHNlXHJcbiAgICB9LFxyXG5cclxuICAgIGFqYXg6IHtcclxuICAgICAgLy8gT2JqZWN0IGNvbnRhaW5pbmcgc2V0dGluZ3MgZm9yIGFqYXggcmVxdWVzdFxyXG4gICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgIC8vIFRoaXMgaGVscHMgdG8gaW5kaWNhdGUgdGhhdCByZXF1ZXN0IGNvbWVzIGZyb20gdGhlIG1vZGFsXHJcbiAgICAgICAgLy8gRmVlbCBmcmVlIHRvIGNoYW5nZSBuYW1pbmdcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICBmYW5jeWJveDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBpZnJhbWU6IHtcclxuICAgICAgLy8gSWZyYW1lIHRlbXBsYXRlXHJcbiAgICAgIHRwbDogJzxpZnJhbWUgaWQ9XCJmYW5jeWJveC1mcmFtZXtybmR9XCIgbmFtZT1cImZhbmN5Ym94LWZyYW1le3JuZH1cIiBjbGFzcz1cImZhbmN5Ym94LWlmcmFtZVwiIGFsbG93ZnVsbHNjcmVlbj1cImFsbG93ZnVsbHNjcmVlblwiIGFsbG93PVwiYXV0b3BsYXk7IGZ1bGxzY3JlZW5cIiBzcmM9XCJcIj48L2lmcmFtZT4nLFxyXG5cclxuICAgICAgLy8gUHJlbG9hZCBpZnJhbWUgYmVmb3JlIGRpc3BsYXlpbmcgaXRcclxuICAgICAgLy8gVGhpcyBhbGxvd3MgdG8gY2FsY3VsYXRlIGlmcmFtZSBjb250ZW50IHdpZHRoIGFuZCBoZWlnaHRcclxuICAgICAgLy8gKG5vdGU6IER1ZSB0byBcIlNhbWUgT3JpZ2luIFBvbGljeVwiLCB5b3UgY2FuJ3QgZ2V0IGNyb3NzIGRvbWFpbiBkYXRhKS5cclxuICAgICAgcHJlbG9hZDogdHJ1ZSxcclxuXHJcbiAgICAgIC8vIEN1c3RvbSBDU1Mgc3R5bGluZyBmb3IgaWZyYW1lIHdyYXBwaW5nIGVsZW1lbnRcclxuICAgICAgLy8gWW91IGNhbiB1c2UgdGhpcyB0byBzZXQgY3VzdG9tIGlmcmFtZSBkaW1lbnNpb25zXHJcbiAgICAgIGNzczoge30sXHJcblxyXG4gICAgICAvLyBJZnJhbWUgdGFnIGF0dHJpYnV0ZXNcclxuICAgICAgYXR0cjoge1xyXG4gICAgICAgIHNjcm9sbGluZzogXCJhdXRvXCJcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBGb3IgSFRNTDUgdmlkZW8gb25seVxyXG4gICAgdmlkZW86IHtcclxuICAgICAgdHBsOiAnPHZpZGVvIGNsYXNzPVwiZmFuY3lib3gtdmlkZW9cIiBjb250cm9scyBjb250cm9sc0xpc3Q9XCJub2Rvd25sb2FkXCIgcG9zdGVyPVwie3twb3N0ZXJ9fVwiPicgK1xyXG4gICAgICAgICc8c291cmNlIHNyYz1cInt7c3JjfX1cIiB0eXBlPVwie3tmb3JtYXR9fVwiIC8+JyArXHJcbiAgICAgICAgJ1NvcnJ5LCB5b3VyIGJyb3dzZXIgZG9lc25cXCd0IHN1cHBvcnQgZW1iZWRkZWQgdmlkZW9zLCA8YSBocmVmPVwie3tzcmN9fVwiPmRvd25sb2FkPC9hPiBhbmQgd2F0Y2ggd2l0aCB5b3VyIGZhdm9yaXRlIHZpZGVvIHBsYXllciEnICtcclxuICAgICAgICBcIjwvdmlkZW8+XCIsXHJcbiAgICAgIGZvcm1hdDogXCJcIiwgLy8gY3VzdG9tIHZpZGVvIGZvcm1hdFxyXG4gICAgICBhdXRvU3RhcnQ6IHRydWVcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRGVmYXVsdCBjb250ZW50IHR5cGUgaWYgY2Fubm90IGJlIGRldGVjdGVkIGF1dG9tYXRpY2FsbHlcclxuICAgIGRlZmF1bHRUeXBlOiBcImltYWdlXCIsXHJcblxyXG4gICAgLy8gT3Blbi9jbG9zZSBhbmltYXRpb24gdHlwZVxyXG4gICAgLy8gUG9zc2libGUgdmFsdWVzOlxyXG4gICAgLy8gICBmYWxzZSAgICAgICAgICAgIC0gZGlzYWJsZVxyXG4gICAgLy8gICBcInpvb21cIiAgICAgICAgICAgLSB6b29tIGltYWdlcyBmcm9tL3RvIHRodW1ibmFpbFxyXG4gICAgLy8gICBcImZhZGVcIlxyXG4gICAgLy8gICBcInpvb20taW4tb3V0XCJcclxuICAgIC8vXHJcbiAgICBhbmltYXRpb25FZmZlY3Q6IFwiem9vbVwiLFxyXG5cclxuICAgIC8vIER1cmF0aW9uIGluIG1zIGZvciBvcGVuL2Nsb3NlIGFuaW1hdGlvblxyXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDM2NixcclxuXHJcbiAgICAvLyBTaG91bGQgaW1hZ2UgY2hhbmdlIG9wYWNpdHkgd2hpbGUgem9vbWluZ1xyXG4gICAgLy8gSWYgb3BhY2l0eSBpcyBcImF1dG9cIiwgdGhlbiBvcGFjaXR5IHdpbGwgYmUgY2hhbmdlZCBpZiBpbWFnZSBhbmQgdGh1bWJuYWlsIGhhdmUgZGlmZmVyZW50IGFzcGVjdCByYXRpb3NcclxuICAgIHpvb21PcGFjaXR5OiBcImF1dG9cIixcclxuXHJcbiAgICAvLyBUcmFuc2l0aW9uIGVmZmVjdCBiZXR3ZWVuIHNsaWRlc1xyXG4gICAgLy9cclxuICAgIC8vIFBvc3NpYmxlIHZhbHVlczpcclxuICAgIC8vICAgZmFsc2UgICAgICAgICAgICAtIGRpc2FibGVcclxuICAgIC8vICAgXCJmYWRlJ1xyXG4gICAgLy8gICBcInNsaWRlJ1xyXG4gICAgLy8gICBcImNpcmN1bGFyJ1xyXG4gICAgLy8gICBcInR1YmUnXHJcbiAgICAvLyAgIFwiem9vbS1pbi1vdXQnXHJcbiAgICAvLyAgIFwicm90YXRlJ1xyXG4gICAgLy9cclxuICAgIHRyYW5zaXRpb25FZmZlY3Q6IFwiZmFkZVwiLFxyXG5cclxuICAgIC8vIER1cmF0aW9uIGluIG1zIGZvciB0cmFuc2l0aW9uIGFuaW1hdGlvblxyXG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAzNjYsXHJcblxyXG4gICAgLy8gQ3VzdG9tIENTUyBjbGFzcyBmb3Igc2xpZGUgZWxlbWVudFxyXG4gICAgc2xpZGVDbGFzczogXCJcIixcclxuXHJcbiAgICAvLyBDdXN0b20gQ1NTIGNsYXNzIGZvciBsYXlvdXRcclxuICAgIGJhc2VDbGFzczogXCJcIixcclxuXHJcbiAgICAvLyBCYXNlIHRlbXBsYXRlIGZvciBsYXlvdXRcclxuICAgIGJhc2VUcGw6ICc8ZGl2IGNsYXNzPVwiZmFuY3lib3gtY29udGFpbmVyXCIgcm9sZT1cImRpYWxvZ1wiIHRhYmluZGV4PVwiLTFcIj4nICtcclxuICAgICAgJzxkaXYgY2xhc3M9XCJmYW5jeWJveC1iZ1wiPjwvZGl2PicgK1xyXG4gICAgICAnPGRpdiBjbGFzcz1cImZhbmN5Ym94LWlubmVyXCI+JyArXHJcbiAgICAgICc8ZGl2IGNsYXNzPVwiZmFuY3lib3gtaW5mb2JhclwiPjxzcGFuIGRhdGEtZmFuY3lib3gtaW5kZXg+PC9zcGFuPiZuYnNwOy8mbmJzcDs8c3BhbiBkYXRhLWZhbmN5Ym94LWNvdW50Pjwvc3Bhbj48L2Rpdj4nICtcclxuICAgICAgJzxkaXYgY2xhc3M9XCJmYW5jeWJveC10b29sYmFyXCI+e3tidXR0b25zfX08L2Rpdj4nICtcclxuICAgICAgJzxkaXYgY2xhc3M9XCJmYW5jeWJveC1uYXZpZ2F0aW9uXCI+e3thcnJvd3N9fTwvZGl2PicgK1xyXG4gICAgICAnPGRpdiBjbGFzcz1cImZhbmN5Ym94LXN0YWdlXCI+PC9kaXY+JyArXHJcbiAgICAgICc8ZGl2IGNsYXNzPVwiZmFuY3lib3gtY2FwdGlvblwiPjxkaXYgY2xhc3M9XCJmYW5jeWJveC1jYXB0aW9uX19ib2R5XCI+PC9kaXY+PC9kaXY+JyArXHJcbiAgICAgIFwiPC9kaXY+XCIgK1xyXG4gICAgICBcIjwvZGl2PlwiLFxyXG5cclxuICAgIC8vIExvYWRpbmcgaW5kaWNhdG9yIHRlbXBsYXRlXHJcbiAgICBzcGlubmVyVHBsOiAnPGRpdiBjbGFzcz1cImZhbmN5Ym94LWxvYWRpbmdcIj48L2Rpdj4nLFxyXG5cclxuICAgIC8vIEVycm9yIG1lc3NhZ2UgdGVtcGxhdGVcclxuICAgIGVycm9yVHBsOiAnPGRpdiBjbGFzcz1cImZhbmN5Ym94LWVycm9yXCI+PHA+e3tFUlJPUn19PC9wPjwvZGl2PicsXHJcblxyXG4gICAgYnRuVHBsOiB7XHJcbiAgICAgIGRvd25sb2FkOiAnPGEgZG93bmxvYWQgZGF0YS1mYW5jeWJveC1kb3dubG9hZCBjbGFzcz1cImZhbmN5Ym94LWJ1dHRvbiBmYW5jeWJveC1idXR0b24tLWRvd25sb2FkXCIgdGl0bGU9XCJ7e0RPV05MT0FEfX1cIiBocmVmPVwiamF2YXNjcmlwdDo7XCI+JyArXHJcbiAgICAgICAgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTE4LjYyIDE3LjA5VjE5SDUuMzh2LTEuOTF6bS0yLjk3LTYuOTZMMTcgMTEuNDVsLTUgNC44Ny01LTQuODcgMS4zNi0xLjMyIDIuNjggMi42NFY1aDEuOTJ2Ny43N3pcIi8+PC9zdmc+JyArXHJcbiAgICAgICAgXCI8L2E+XCIsXHJcblxyXG4gICAgICB6b29tOiAnPGJ1dHRvbiBkYXRhLWZhbmN5Ym94LXpvb20gY2xhc3M9XCJmYW5jeWJveC1idXR0b24gZmFuY3lib3gtYnV0dG9uLS16b29tXCIgdGl0bGU9XCJ7e1pPT019fVwiPicgK1xyXG4gICAgICAgICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggZD1cIk0xOC43IDE3LjNsLTMtM2E1LjkgNS45IDAgMCAwLS42LTcuNiA1LjkgNS45IDAgMCAwLTguNCAwIDUuOSA1LjkgMCAwIDAgMCA4LjQgNS45IDUuOSAwIDAgMCA3LjcuN2wzIDNhMSAxIDAgMCAwIDEuMyAwYy40LS41LjQtMSAwLTEuNXpNOC4xIDEzLjhhNCA0IDAgMCAxIDAtNS43IDQgNCAwIDAgMSA1LjcgMCA0IDQgMCAwIDEgMCA1LjcgNCA0IDAgMCAxLTUuNyAwelwiLz48L3N2Zz4nICtcclxuICAgICAgICBcIjwvYnV0dG9uPlwiLFxyXG5cclxuICAgICAgY2xvc2U6ICc8YnV0dG9uIGRhdGEtZmFuY3lib3gtY2xvc2UgY2xhc3M9XCJmYW5jeWJveC1idXR0b24gZmFuY3lib3gtYnV0dG9uLS1jbG9zZVwiIHRpdGxlPVwie3tDTE9TRX19XCI+JyArXHJcbiAgICAgICAgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTEyIDEwLjZMNi42IDUuMiA1LjIgNi42bDUuNCA1LjQtNS40IDUuNCAxLjQgMS40IDUuNC01LjQgNS40IDUuNCAxLjQtMS40LTUuNC01LjQgNS40LTUuNC0xLjQtMS40LTUuNCA1LjR6XCIvPjwvc3ZnPicgK1xyXG4gICAgICAgIFwiPC9idXR0b24+XCIsXHJcblxyXG4gICAgICAvLyBBcnJvd3NcclxuICAgICAgYXJyb3dMZWZ0OiAnPGJ1dHRvbiBkYXRhLWZhbmN5Ym94LXByZXYgY2xhc3M9XCJmYW5jeWJveC1idXR0b24gZmFuY3lib3gtYnV0dG9uLS1hcnJvd19sZWZ0XCIgdGl0bGU9XCJ7e1BSRVZ9fVwiPicgK1xyXG4gICAgICAgICc8ZGl2PjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTExLjI4IDE1LjdsLTEuMzQgMS4zN0w1IDEybDQuOTQtNS4wNyAxLjM0IDEuMzgtMi42OCAyLjcySDE5djEuOTRIOC42elwiLz48L3N2Zz48L2Rpdj4nICtcclxuICAgICAgICBcIjwvYnV0dG9uPlwiLFxyXG5cclxuICAgICAgYXJyb3dSaWdodDogJzxidXR0b24gZGF0YS1mYW5jeWJveC1uZXh0IGNsYXNzPVwiZmFuY3lib3gtYnV0dG9uIGZhbmN5Ym94LWJ1dHRvbi0tYXJyb3dfcmlnaHRcIiB0aXRsZT1cInt7TkVYVH19XCI+JyArXHJcbiAgICAgICAgJzxkaXY+PHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNMTUuNCAxMi45N2wtMi42OCAyLjcyIDEuMzQgMS4zOEwxOSAxMmwtNC45NC01LjA3LTEuMzQgMS4zOCAyLjY4IDIuNzJINXYxLjk0elwiLz48L3N2Zz48L2Rpdj4nICtcclxuICAgICAgICBcIjwvYnV0dG9uPlwiLFxyXG5cclxuICAgICAgLy8gVGhpcyBzbWFsbCBjbG9zZSBidXR0b24gd2lsbCBiZSBhcHBlbmRlZCB0byB5b3VyIGh0bWwvaW5saW5lL2FqYXggY29udGVudCBieSBkZWZhdWx0LFxyXG4gICAgICAvLyBpZiBcInNtYWxsQnRuXCIgb3B0aW9uIGlzIG5vdCBzZXQgdG8gZmFsc2VcclxuICAgICAgc21hbGxCdG46ICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBkYXRhLWZhbmN5Ym94LWNsb3NlIGNsYXNzPVwiZmFuY3lib3gtYnV0dG9uIGZhbmN5Ym94LWNsb3NlLXNtYWxsXCIgdGl0bGU9XCJ7e0NMT1NFfX1cIj4nICtcclxuICAgICAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmVyc2lvbj1cIjFcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggZD1cIk0xMyAxMmw1LTUtMS0xLTUgNS01LTUtMSAxIDUgNS01IDUgMSAxIDUtNSA1IDUgMS0xelwiLz48L3N2Zz4nICtcclxuICAgICAgICBcIjwvYnV0dG9uPlwiXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIENvbnRhaW5lciBpcyBpbmplY3RlZCBpbnRvIHRoaXMgZWxlbWVudFxyXG4gICAgcGFyZW50RWw6IFwiYm9keVwiLFxyXG5cclxuICAgIC8vIEhpZGUgYnJvd3NlciB2ZXJ0aWNhbCBzY3JvbGxiYXJzOyB1c2UgYXQgeW91ciBvd24gcmlza1xyXG4gICAgaGlkZVNjcm9sbGJhcjogdHJ1ZSxcclxuXHJcbiAgICAvLyBGb2N1cyBoYW5kbGluZ1xyXG4gICAgLy8gPT09PT09PT09PT09PT1cclxuXHJcbiAgICAvLyBUcnkgdG8gZm9jdXMgb24gdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IGFmdGVyIG9wZW5pbmdcclxuICAgIGF1dG9Gb2N1czogdHJ1ZSxcclxuXHJcbiAgICAvLyBQdXQgZm9jdXMgYmFjayB0byBhY3RpdmUgZWxlbWVudCBhZnRlciBjbG9zaW5nXHJcbiAgICBiYWNrRm9jdXM6IHRydWUsXHJcblxyXG4gICAgLy8gRG8gbm90IGxldCB1c2VyIHRvIGZvY3VzIG9uIGVsZW1lbnQgb3V0c2lkZSBtb2RhbCBjb250ZW50XHJcbiAgICB0cmFwRm9jdXM6IHRydWUsXHJcblxyXG4gICAgLy8gTW9kdWxlIHNwZWNpZmljIG9wdGlvbnNcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgZnVsbFNjcmVlbjoge1xyXG4gICAgICBhdXRvU3RhcnQ6IGZhbHNlXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFNldCBgdG91Y2g6IGZhbHNlYCB0byBkaXNhYmxlIHBhbm5pbmcvc3dpcGluZ1xyXG4gICAgdG91Y2g6IHtcclxuICAgICAgdmVydGljYWw6IHRydWUsIC8vIEFsbG93IHRvIGRyYWcgY29udGVudCB2ZXJ0aWNhbGx5XHJcbiAgICAgIG1vbWVudHVtOiB0cnVlIC8vIENvbnRpbnVlIG1vdmVtZW50IGFmdGVyIHJlbGVhc2luZyBtb3VzZS90b3VjaCB3aGVuIHBhbm5pbmdcclxuICAgIH0sXHJcblxyXG4gICAgLy8gSGFzaCB2YWx1ZSB3aGVuIGluaXRpYWxpemluZyBtYW51YWxseSxcclxuICAgIC8vIHNldCBgZmFsc2VgIHRvIGRpc2FibGUgaGFzaCBjaGFuZ2VcclxuICAgIGhhc2g6IG51bGwsXHJcblxyXG4gICAgLy8gQ3VzdG9taXplIG9yIGFkZCBuZXcgbWVkaWEgdHlwZXNcclxuICAgIC8vIEV4YW1wbGU6XHJcbiAgICAvKlxyXG4gICAgICBtZWRpYSA6IHtcclxuICAgICAgICB5b3V0dWJlIDoge1xyXG4gICAgICAgICAgcGFyYW1zIDoge1xyXG4gICAgICAgICAgICBhdXRvcGxheSA6IDBcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICovXHJcbiAgICBtZWRpYToge30sXHJcblxyXG4gICAgc2xpZGVTaG93OiB7XHJcbiAgICAgIGF1dG9TdGFydDogZmFsc2UsXHJcbiAgICAgIHNwZWVkOiAzMDAwXHJcbiAgICB9LFxyXG5cclxuICAgIHRodW1iczoge1xyXG4gICAgICBhdXRvU3RhcnQ6IGZhbHNlLCAvLyBEaXNwbGF5IHRodW1ibmFpbHMgb24gb3BlbmluZ1xyXG4gICAgICBoaWRlT25DbG9zZTogdHJ1ZSwgLy8gSGlkZSB0aHVtYm5haWwgZ3JpZCB3aGVuIGNsb3NpbmcgYW5pbWF0aW9uIHN0YXJ0c1xyXG4gICAgICBwYXJlbnRFbDogXCIuZmFuY3lib3gtY29udGFpbmVyXCIsIC8vIENvbnRhaW5lciBpcyBpbmplY3RlZCBpbnRvIHRoaXMgZWxlbWVudFxyXG4gICAgICBheGlzOiBcInlcIiAvLyBWZXJ0aWNhbCAoeSkgb3IgaG9yaXpvbnRhbCAoeCkgc2Nyb2xsaW5nXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFVzZSBtb3VzZXdoZWVsIHRvIG5hdmlnYXRlIGdhbGxlcnlcclxuICAgIC8vIElmICdhdXRvJyAtIGVuYWJsZWQgZm9yIGltYWdlcyBvbmx5XHJcbiAgICB3aGVlbDogXCJhdXRvXCIsXHJcblxyXG4gICAgLy8gQ2FsbGJhY2tzXHJcbiAgICAvLz09PT09PT09PT1cclxuXHJcbiAgICAvLyBTZWUgRG9jdW1lbnRhdGlvbi9BUEkvRXZlbnRzIGZvciBtb3JlIGluZm9ybWF0aW9uXHJcbiAgICAvLyBFeGFtcGxlOlxyXG4gICAgLypcclxuICAgICAgYWZ0ZXJTaG93OiBmdW5jdGlvbiggaW5zdGFuY2UsIGN1cnJlbnQgKSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKCAnQ2xpY2tlZCBlbGVtZW50OicgKTtcclxuICAgICAgICBjb25zb2xlLmluZm8oIGN1cnJlbnQub3B0cy4kb3JpZyApO1xyXG4gICAgICB9XHJcbiAgICAqL1xyXG5cclxuICAgIG9uSW5pdDogJC5ub29wLCAvLyBXaGVuIGluc3RhbmNlIGhhcyBiZWVuIGluaXRpYWxpemVkXHJcblxyXG4gICAgYmVmb3JlTG9hZDogJC5ub29wLCAvLyBCZWZvcmUgdGhlIGNvbnRlbnQgb2YgYSBzbGlkZSBpcyBiZWluZyBsb2FkZWRcclxuICAgIGFmdGVyTG9hZDogJC5ub29wLCAvLyBXaGVuIHRoZSBjb250ZW50IG9mIGEgc2xpZGUgaXMgZG9uZSBsb2FkaW5nXHJcblxyXG4gICAgYmVmb3JlU2hvdzogJC5ub29wLCAvLyBCZWZvcmUgb3BlbiBhbmltYXRpb24gc3RhcnRzXHJcbiAgICBhZnRlclNob3c6ICQubm9vcCwgLy8gV2hlbiBjb250ZW50IGlzIGRvbmUgbG9hZGluZyBhbmQgYW5pbWF0aW5nXHJcblxyXG4gICAgYmVmb3JlQ2xvc2U6ICQubm9vcCwgLy8gQmVmb3JlIHRoZSBpbnN0YW5jZSBhdHRlbXB0cyB0byBjbG9zZS4gUmV0dXJuIGZhbHNlIHRvIGNhbmNlbCB0aGUgY2xvc2UuXHJcbiAgICBhZnRlckNsb3NlOiAkLm5vb3AsIC8vIEFmdGVyIGluc3RhbmNlIGhhcyBiZWVuIGNsb3NlZFxyXG5cclxuICAgIG9uQWN0aXZhdGU6ICQubm9vcCwgLy8gV2hlbiBpbnN0YW5jZSBpcyBicm91Z2h0IHRvIGZyb250XHJcbiAgICBvbkRlYWN0aXZhdGU6ICQubm9vcCwgLy8gV2hlbiBvdGhlciBpbnN0YW5jZSBoYXMgYmVlbiBhY3RpdmF0ZWRcclxuXHJcbiAgICAvLyBJbnRlcmFjdGlvblxyXG4gICAgLy8gPT09PT09PT09PT1cclxuXHJcbiAgICAvLyBVc2Ugb3B0aW9ucyBiZWxvdyB0byBjdXN0b21pemUgdGFrZW4gYWN0aW9uIHdoZW4gdXNlciBjbGlja3Mgb3IgZG91YmxlIGNsaWNrcyBvbiB0aGUgZmFuY3lCb3ggYXJlYSxcclxuICAgIC8vIGVhY2ggb3B0aW9uIGNhbiBiZSBzdHJpbmcgb3IgbWV0aG9kIHRoYXQgcmV0dXJucyB2YWx1ZS5cclxuICAgIC8vXHJcbiAgICAvLyBQb3NzaWJsZSB2YWx1ZXM6XHJcbiAgICAvLyAgIFwiY2xvc2VcIiAgICAgICAgICAgLSBjbG9zZSBpbnN0YW5jZVxyXG4gICAgLy8gICBcIm5leHRcIiAgICAgICAgICAgIC0gbW92ZSB0byBuZXh0IGdhbGxlcnkgaXRlbVxyXG4gICAgLy8gICBcIm5leHRPckNsb3NlXCIgICAgIC0gbW92ZSB0byBuZXh0IGdhbGxlcnkgaXRlbSBvciBjbG9zZSBpZiBnYWxsZXJ5IGhhcyBvbmx5IG9uZSBpdGVtXHJcbiAgICAvLyAgIFwidG9nZ2xlQ29udHJvbHNcIiAgLSBzaG93L2hpZGUgY29udHJvbHNcclxuICAgIC8vICAgXCJ6b29tXCIgICAgICAgICAgICAtIHpvb20gaW1hZ2UgKGlmIGxvYWRlZClcclxuICAgIC8vICAgZmFsc2UgICAgICAgICAgICAgLSBkbyBub3RoaW5nXHJcblxyXG4gICAgLy8gQ2xpY2tlZCBvbiB0aGUgY29udGVudFxyXG4gICAgY2xpY2tDb250ZW50OiBmdW5jdGlvbiAoY3VycmVudCwgZXZlbnQpIHtcclxuICAgICAgcmV0dXJuIGN1cnJlbnQudHlwZSA9PT0gXCJpbWFnZVwiID8gXCJ6b29tXCIgOiBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2xpY2tlZCBvbiB0aGUgc2xpZGVcclxuICAgIGNsaWNrU2xpZGU6IFwiY2xvc2VcIixcclxuXHJcbiAgICAvLyBDbGlja2VkIG9uIHRoZSBiYWNrZ3JvdW5kIChiYWNrZHJvcCkgZWxlbWVudDtcclxuICAgIC8vIGlmIHlvdSBoYXZlIG5vdCBjaGFuZ2VkIHRoZSBsYXlvdXQsIHRoZW4gbW9zdCBsaWtlbHkgeW91IG5lZWQgdG8gdXNlIGBjbGlja1NsaWRlYCBvcHRpb25cclxuICAgIGNsaWNrT3V0c2lkZTogXCJjbG9zZVwiLFxyXG5cclxuICAgIC8vIFNhbWUgYXMgcHJldmlvdXMgdHdvLCBidXQgZm9yIGRvdWJsZSBjbGlja1xyXG4gICAgZGJsY2xpY2tDb250ZW50OiBmYWxzZSxcclxuICAgIGRibGNsaWNrU2xpZGU6IGZhbHNlLFxyXG4gICAgZGJsY2xpY2tPdXRzaWRlOiBmYWxzZSxcclxuXHJcbiAgICAvLyBDdXN0b20gb3B0aW9ucyB3aGVuIG1vYmlsZSBkZXZpY2UgaXMgZGV0ZWN0ZWRcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIG1vYmlsZToge1xyXG4gICAgICBwcmV2ZW50Q2FwdGlvbk92ZXJsYXA6IGZhbHNlLFxyXG4gICAgICBpZGxlVGltZTogZmFsc2UsXHJcbiAgICAgIGNsaWNrQ29udGVudDogZnVuY3Rpb24gKGN1cnJlbnQsIGV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQudHlwZSA9PT0gXCJpbWFnZVwiID8gXCJ0b2dnbGVDb250cm9sc1wiIDogZmFsc2U7XHJcbiAgICAgIH0sXHJcbiAgICAgIGNsaWNrU2xpZGU6IGZ1bmN0aW9uIChjdXJyZW50LCBldmVudCkge1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50LnR5cGUgPT09IFwiaW1hZ2VcIiA/IFwidG9nZ2xlQ29udHJvbHNcIiA6IFwiY2xvc2VcIjtcclxuICAgICAgfSxcclxuICAgICAgZGJsY2xpY2tDb250ZW50OiBmdW5jdGlvbiAoY3VycmVudCwgZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gY3VycmVudC50eXBlID09PSBcImltYWdlXCIgPyBcInpvb21cIiA6IGZhbHNlO1xyXG4gICAgICB9LFxyXG4gICAgICBkYmxjbGlja1NsaWRlOiBmdW5jdGlvbiAoY3VycmVudCwgZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gY3VycmVudC50eXBlID09PSBcImltYWdlXCIgPyBcInpvb21cIiA6IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEludGVybmF0aW9uYWxpemF0aW9uXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGxhbmc6IFwiZW5cIixcclxuICAgIGkxOG46IHtcclxuICAgICAgZW46IHtcclxuICAgICAgICBDTE9TRTogXCJDbG9zZVwiLFxyXG4gICAgICAgIE5FWFQ6IFwiTmV4dFwiLFxyXG4gICAgICAgIFBSRVY6IFwiUHJldmlvdXNcIixcclxuICAgICAgICBFUlJPUjogXCJUaGUgcmVxdWVzdGVkIGNvbnRlbnQgY2Fubm90IGJlIGxvYWRlZC4gPGJyLz4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci5cIixcclxuICAgICAgICBQTEFZX1NUQVJUOiBcIlN0YXJ0IHNsaWRlc2hvd1wiLFxyXG4gICAgICAgIFBMQVlfU1RPUDogXCJQYXVzZSBzbGlkZXNob3dcIixcclxuICAgICAgICBGVUxMX1NDUkVFTjogXCJGdWxsIHNjcmVlblwiLFxyXG4gICAgICAgIFRIVU1CUzogXCJUaHVtYm5haWxzXCIsXHJcbiAgICAgICAgRE9XTkxPQUQ6IFwiRG93bmxvYWRcIixcclxuICAgICAgICBTSEFSRTogXCJTaGFyZVwiLFxyXG4gICAgICAgIFpPT006IFwiWm9vbVwiXHJcbiAgICAgIH0sXHJcbiAgICAgIGRlOiB7XHJcbiAgICAgICAgQ0xPU0U6IFwiU2NobGllJnN6bGlnO2VuXCIsXHJcbiAgICAgICAgTkVYVDogXCJXZWl0ZXJcIixcclxuICAgICAgICBQUkVWOiBcIlp1ciZ1dW1sO2NrXCIsXHJcbiAgICAgICAgRVJST1I6IFwiRGllIGFuZ2Vmb3JkZXJ0ZW4gRGF0ZW4ga29ubnRlbiBuaWNodCBnZWxhZGVuIHdlcmRlbi4gPGJyLz4gQml0dGUgdmVyc3VjaGVuIFNpZSBlcyBzcCZhdW1sO3RlciBub2NobWFsLlwiLFxyXG4gICAgICAgIFBMQVlfU1RBUlQ6IFwiRGlhc2NoYXUgc3RhcnRlblwiLFxyXG4gICAgICAgIFBMQVlfU1RPUDogXCJEaWFzY2hhdSBiZWVuZGVuXCIsXHJcbiAgICAgICAgRlVMTF9TQ1JFRU46IFwiVm9sbGJpbGRcIixcclxuICAgICAgICBUSFVNQlM6IFwiVm9yc2NoYXViaWxkZXJcIixcclxuICAgICAgICBET1dOTE9BRDogXCJIZXJ1bnRlcmxhZGVuXCIsXHJcbiAgICAgICAgU0hBUkU6IFwiVGVpbGVuXCIsXHJcbiAgICAgICAgWk9PTTogXCJWZXJnciZvdW1sOyZzemxpZztlcm5cIlxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gRmV3IHVzZWZ1bCB2YXJpYWJsZXMgYW5kIG1ldGhvZHNcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICB2YXIgJFcgPSAkKHdpbmRvdyk7XHJcbiAgdmFyICREID0gJChkb2N1bWVudCk7XHJcblxyXG4gIHZhciBjYWxsZWQgPSAwO1xyXG5cclxuICAvLyBDaGVjayBpZiBhbiBvYmplY3QgaXMgYSBqUXVlcnkgb2JqZWN0IGFuZCBub3QgYSBuYXRpdmUgSmF2YVNjcmlwdCBvYmplY3RcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICB2YXIgaXNRdWVyeSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgIHJldHVybiBvYmogJiYgb2JqLmhhc093blByb3BlcnR5ICYmIG9iaiBpbnN0YW5jZW9mICQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gSGFuZGxlIG11bHRpcGxlIGJyb3dzZXJzIGZvciBcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiIGFuZCBcImNhbmNlbEFuaW1hdGlvbkZyYW1lXCJcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgdmFyIHJlcXVlc3RBRnJhbWUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgLy8gaWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBzZXRUaW1lb3V0XHJcbiAgICAgIGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcclxuICAgICAgfVxyXG4gICAgKTtcclxuICB9KSgpO1xyXG5cclxuICB2YXIgY2FuY2VsQUZyYW1lID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgIHdpbmRvdy5vQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChpZCk7XHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgfSkoKTtcclxuXHJcbiAgLy8gRGV0ZWN0IHRoZSBzdXBwb3J0ZWQgdHJhbnNpdGlvbi1lbmQgZXZlbnQgcHJvcGVydHkgbmFtZVxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICB2YXIgdHJhbnNpdGlvbkVuZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmFrZWVsZW1lbnRcIiksXHJcbiAgICAgIHQ7XHJcblxyXG4gICAgdmFyIHRyYW5zaXRpb25zID0ge1xyXG4gICAgICB0cmFuc2l0aW9uOiBcInRyYW5zaXRpb25lbmRcIixcclxuICAgICAgT1RyYW5zaXRpb246IFwib1RyYW5zaXRpb25FbmRcIixcclxuICAgICAgTW96VHJhbnNpdGlvbjogXCJ0cmFuc2l0aW9uZW5kXCIsXHJcbiAgICAgIFdlYmtpdFRyYW5zaXRpb246IFwid2Via2l0VHJhbnNpdGlvbkVuZFwiXHJcbiAgICB9O1xyXG5cclxuICAgIGZvciAodCBpbiB0cmFuc2l0aW9ucykge1xyXG4gICAgICBpZiAoZWwuc3R5bGVbdF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB0cmFuc2l0aW9uc1t0XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBcInRyYW5zaXRpb25lbmRcIjtcclxuICB9KSgpO1xyXG5cclxuICAvLyBGb3JjZSByZWRyYXcgb24gYW4gZWxlbWVudC5cclxuICAvLyBUaGlzIGhlbHBzIGluIGNhc2VzIHdoZXJlIHRoZSBicm93c2VyIGRvZXNuJ3QgcmVkcmF3IGFuIHVwZGF0ZWQgZWxlbWVudCBwcm9wZXJseVxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgdmFyIGZvcmNlUmVkcmF3ID0gZnVuY3Rpb24gKCRlbCkge1xyXG4gICAgcmV0dXJuICRlbCAmJiAkZWwubGVuZ3RoICYmICRlbFswXS5vZmZzZXRIZWlnaHQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gRXhjbHVkZSBhcnJheSAoYGJ1dHRvbnNgKSBvcHRpb25zIGZyb20gZGVlcCBtZXJnaW5nXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgdmFyIG1lcmdlT3B0cyA9IGZ1bmN0aW9uIChvcHRzMSwgb3B0czIpIHtcclxuICAgIHZhciByZXogPSAkLmV4dGVuZCh0cnVlLCB7fSwgb3B0czEsIG9wdHMyKTtcclxuXHJcbiAgICAkLmVhY2gob3B0czIsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgIGlmICgkLmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV6W2tleV0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlejtcclxuICB9O1xyXG5cclxuICAvLyBIb3cgbXVjaCBvZiBhbiBlbGVtZW50IGlzIHZpc2libGUgaW4gdmlld3BvcnRcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgdmFyIGluVmlld3BvcnQgPSBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgdmFyIGVsZW1DZW50ZXIsIHJlejtcclxuXHJcbiAgICBpZiAoIWVsZW0gfHwgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgJChcIi5mYW5jeWJveC1jb250YWluZXJcIikuY3NzKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xyXG5cclxuICAgIGVsZW1DZW50ZXIgPSB7XHJcbiAgICAgIHg6IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIGVsZW0ub2Zmc2V0V2lkdGggLyAyLFxyXG4gICAgICB5OiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIGVsZW0ub2Zmc2V0SGVpZ2h0IC8gMlxyXG4gICAgfTtcclxuXHJcbiAgICByZXogPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGVsZW1DZW50ZXIueCwgZWxlbUNlbnRlci55KSA9PT0gZWxlbTtcclxuXHJcbiAgICAkKFwiLmZhbmN5Ym94LWNvbnRhaW5lclwiKS5jc3MoXCJwb2ludGVyLWV2ZW50c1wiLCBcIlwiKTtcclxuXHJcbiAgICByZXR1cm4gcmV6O1xyXG4gIH07XHJcblxyXG4gIC8vIENsYXNzIGRlZmluaXRpb25cclxuICAvLyA9PT09PT09PT09PT09PT09XHJcblxyXG4gIHZhciBGYW5jeUJveCA9IGZ1bmN0aW9uIChjb250ZW50LCBvcHRzLCBpbmRleCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHNlbGYub3B0cyA9IG1lcmdlT3B0cyh7XHJcbiAgICAgIGluZGV4OiBpbmRleFxyXG4gICAgfSwgJC5mYW5jeWJveC5kZWZhdWx0cyk7XHJcblxyXG4gICAgaWYgKCQuaXNQbGFpbk9iamVjdChvcHRzKSkge1xyXG4gICAgICBzZWxmLm9wdHMgPSBtZXJnZU9wdHMoc2VsZi5vcHRzLCBvcHRzKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoJC5mYW5jeWJveC5pc01vYmlsZSkge1xyXG4gICAgICBzZWxmLm9wdHMgPSBtZXJnZU9wdHMoc2VsZi5vcHRzLCBzZWxmLm9wdHMubW9iaWxlKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmLmlkID0gc2VsZi5vcHRzLmlkIHx8ICsrY2FsbGVkO1xyXG5cclxuICAgIHNlbGYuY3VyckluZGV4ID0gcGFyc2VJbnQoc2VsZi5vcHRzLmluZGV4LCAxMCkgfHwgMDtcclxuICAgIHNlbGYucHJldkluZGV4ID0gbnVsbDtcclxuXHJcbiAgICBzZWxmLnByZXZQb3MgPSBudWxsO1xyXG4gICAgc2VsZi5jdXJyUG9zID0gMDtcclxuXHJcbiAgICBzZWxmLmZpcnN0UnVuID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBBbGwgZ3JvdXAgaXRlbXNcclxuICAgIHNlbGYuZ3JvdXAgPSBbXTtcclxuXHJcbiAgICAvLyBFeGlzdGluZyBzbGlkZXMgKGZvciBjdXJyZW50LCBuZXh0IGFuZCBwcmV2aW91cyBnYWxsZXJ5IGl0ZW1zKVxyXG4gICAgc2VsZi5zbGlkZXMgPSB7fTtcclxuXHJcbiAgICAvLyBDcmVhdGUgZ3JvdXAgZWxlbWVudHNcclxuICAgIHNlbGYuYWRkQ29udGVudChjb250ZW50KTtcclxuXHJcbiAgICBpZiAoIXNlbGYuZ3JvdXAubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmLmluaXQoKTtcclxuICB9O1xyXG5cclxuICAkLmV4dGVuZChGYW5jeUJveC5wcm90b3R5cGUsIHtcclxuICAgIC8vIENyZWF0ZSBET00gc3RydWN0dXJlXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIGZpcnN0SXRlbSA9IHNlbGYuZ3JvdXBbc2VsZi5jdXJySW5kZXhdLFxyXG4gICAgICAgIGZpcnN0SXRlbU9wdHMgPSBmaXJzdEl0ZW0ub3B0cyxcclxuICAgICAgICAkY29udGFpbmVyLFxyXG4gICAgICAgIGJ1dHRvblN0cjtcclxuXHJcbiAgICAgIGlmIChmaXJzdEl0ZW1PcHRzLmNsb3NlRXhpc3RpbmcpIHtcclxuICAgICAgICAkLmZhbmN5Ym94LmNsb3NlKHRydWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBIaWRlIHNjcm9sbGJhcnNcclxuICAgICAgLy8gPT09PT09PT09PT09PT09XHJcblxyXG4gICAgICAkKFwiYm9keVwiKS5hZGRDbGFzcyhcImZhbmN5Ym94LWFjdGl2ZVwiKTtcclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICAhJC5mYW5jeWJveC5nZXRJbnN0YW5jZSgpICYmXHJcbiAgICAgICAgZmlyc3RJdGVtT3B0cy5oaWRlU2Nyb2xsYmFyICE9PSBmYWxzZSAmJlxyXG4gICAgICAgICEkLmZhbmN5Ym94LmlzTW9iaWxlICYmXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgPiB3aW5kb3cuaW5uZXJIZWlnaHRcclxuICAgICAgKSB7XHJcbiAgICAgICAgJChcImhlYWRcIikuYXBwZW5kKFxyXG4gICAgICAgICAgJzxzdHlsZSBpZD1cImZhbmN5Ym94LXN0eWxlLW5vc2Nyb2xsXCIgdHlwZT1cInRleHQvY3NzXCI+LmNvbXBlbnNhdGUtZm9yLXNjcm9sbGJhcnttYXJnaW4tcmlnaHQ6JyArXHJcbiAgICAgICAgICAod2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpICtcclxuICAgICAgICAgIFwicHg7fTwvc3R5bGU+XCJcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAkKFwiYm9keVwiKS5hZGRDbGFzcyhcImNvbXBlbnNhdGUtZm9yLXNjcm9sbGJhclwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQnVpbGQgaHRtbCBtYXJrdXAgYW5kIHNldCByZWZlcmVuY2VzXHJcbiAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgICAgLy8gQnVpbGQgaHRtbCBjb2RlIGZvciBidXR0b25zIGFuZCBpbnNlcnQgaW50byBtYWluIHRlbXBsYXRlXHJcbiAgICAgIGJ1dHRvblN0ciA9IFwiXCI7XHJcblxyXG4gICAgICAkLmVhY2goZmlyc3RJdGVtT3B0cy5idXR0b25zLCBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgYnV0dG9uU3RyICs9IGZpcnN0SXRlbU9wdHMuYnRuVHBsW3ZhbHVlXSB8fCBcIlwiO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSBtYXJrdXAgZnJvbSBiYXNlIHRlbXBsYXRlLCBpdCB3aWxsIGJlIGluaXRpYWxseSBoaWRkZW4gdG9cclxuICAgICAgLy8gYXZvaWQgdW5uZWNlc3Nhcnkgd29yayBsaWtlIHBhaW50aW5nIHdoaWxlIGluaXRpYWxpemluZyBpcyBub3QgY29tcGxldGVcclxuICAgICAgJGNvbnRhaW5lciA9ICQoXHJcbiAgICAgICAgICBzZWxmLnRyYW5zbGF0ZShcclxuICAgICAgICAgICAgc2VsZixcclxuICAgICAgICAgICAgZmlyc3RJdGVtT3B0cy5iYXNlVHBsXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKFwie3tidXR0b25zfX1cIiwgYnV0dG9uU3RyKVxyXG4gICAgICAgICAgICAucmVwbGFjZShcInt7YXJyb3dzfX1cIiwgZmlyc3RJdGVtT3B0cy5idG5UcGwuYXJyb3dMZWZ0ICsgZmlyc3RJdGVtT3B0cy5idG5UcGwuYXJyb3dSaWdodClcclxuICAgICAgICAgIClcclxuICAgICAgICApXHJcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcImZhbmN5Ym94LWNvbnRhaW5lci1cIiArIHNlbGYuaWQpXHJcbiAgICAgICAgLmFkZENsYXNzKGZpcnN0SXRlbU9wdHMuYmFzZUNsYXNzKVxyXG4gICAgICAgIC5kYXRhKFwiRmFuY3lCb3hcIiwgc2VsZilcclxuICAgICAgICAuYXBwZW5kVG8oZmlyc3RJdGVtT3B0cy5wYXJlbnRFbCk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgb2JqZWN0IGhvbGRpbmcgcmVmZXJlbmNlcyB0byBqUXVlcnkgd3JhcHBlZCBub2Rlc1xyXG4gICAgICBzZWxmLiRyZWZzID0ge1xyXG4gICAgICAgIGNvbnRhaW5lcjogJGNvbnRhaW5lclxyXG4gICAgICB9O1xyXG5cclxuICAgICAgW1wiYmdcIiwgXCJpbm5lclwiLCBcImluZm9iYXJcIiwgXCJ0b29sYmFyXCIsIFwic3RhZ2VcIiwgXCJjYXB0aW9uXCIsIFwibmF2aWdhdGlvblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgc2VsZi4kcmVmc1tpdGVtXSA9ICRjb250YWluZXIuZmluZChcIi5mYW5jeWJveC1cIiArIGl0ZW0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHNlbGYudHJpZ2dlcihcIm9uSW5pdFwiKTtcclxuXHJcbiAgICAgIC8vIEVuYWJsZSBldmVudHMsIGRlYWN0aXZlIHByZXZpb3VzIGluc3RhbmNlc1xyXG4gICAgICBzZWxmLmFjdGl2YXRlKCk7XHJcblxyXG4gICAgICAvLyBCdWlsZCBzbGlkZXMsIGxvYWQgYW5kIHJldmVhbCBjb250ZW50XHJcbiAgICAgIHNlbGYuanVtcFRvKHNlbGYuY3VyckluZGV4KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gU2ltcGxlIGkxOG4gc3VwcG9ydCAtIHJlcGxhY2VzIG9iamVjdCBrZXlzIGZvdW5kIGluIHRlbXBsYXRlXHJcbiAgICAvLyB3aXRoIGNvcnJlc3BvbmRpbmcgdmFsdWVzXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIChvYmosIHN0cikge1xyXG4gICAgICB2YXIgYXJyID0gb2JqLm9wdHMuaTE4bltvYmoub3B0cy5sYW5nXSB8fCBvYmoub3B0cy5pMThuLmVuO1xyXG5cclxuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHtcXHsoXFx3KylcXH1cXH0vZywgZnVuY3Rpb24gKG1hdGNoLCBuKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycltuXSA9PT0gdW5kZWZpbmVkID8gbWF0Y2ggOiBhcnJbbl07XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBQb3B1bGF0ZSBjdXJyZW50IGdyb3VwIHdpdGggZnJlc2ggY29udGVudFxyXG4gICAgLy8gQ2hlY2sgaWYgZWFjaCBvYmplY3QgaGFzIHZhbGlkIHR5cGUgYW5kIGNvbnRlbnRcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgYWRkQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIGl0ZW1zID0gJC5tYWtlQXJyYXkoY29udGVudCksXHJcbiAgICAgICAgdGh1bWJzO1xyXG5cclxuICAgICAgJC5lYWNoKGl0ZW1zLCBmdW5jdGlvbiAoaSwgaXRlbSkge1xyXG4gICAgICAgIHZhciBvYmogPSB7fSxcclxuICAgICAgICAgIG9wdHMgPSB7fSxcclxuICAgICAgICAgICRpdGVtLFxyXG4gICAgICAgICAgdHlwZSxcclxuICAgICAgICAgIGZvdW5kLFxyXG4gICAgICAgICAgc3JjLFxyXG4gICAgICAgICAgc3JjUGFydHM7XHJcblxyXG4gICAgICAgIC8vIFN0ZXAgMSAtIE1ha2Ugc3VyZSB3ZSBoYXZlIGFuIG9iamVjdFxyXG4gICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KGl0ZW0pKSB7XHJcbiAgICAgICAgICAvLyBXZSBwcm9iYWJseSBoYXZlIG1hbnVhbCB1c2FnZSBoZXJlLCBzb21ldGhpbmcgbGlrZVxyXG4gICAgICAgICAgLy8gJC5mYW5jeWJveC5vcGVuKCBbIHsgc3JjIDogXCJpbWFnZS5qcGdcIiwgdHlwZSA6IFwiaW1hZ2VcIiB9IF0gKVxyXG5cclxuICAgICAgICAgIG9iaiA9IGl0ZW07XHJcbiAgICAgICAgICBvcHRzID0gaXRlbS5vcHRzIHx8IGl0ZW07XHJcbiAgICAgICAgfSBlbHNlIGlmICgkLnR5cGUoaXRlbSkgPT09IFwib2JqZWN0XCIgJiYgJChpdGVtKS5sZW5ndGgpIHtcclxuICAgICAgICAgIC8vIEhlcmUgd2UgcHJvYmFibHkgaGF2ZSBqUXVlcnkgY29sbGVjdGlvbiByZXR1cm5lZCBieSBzb21lIHNlbGVjdG9yXHJcbiAgICAgICAgICAkaXRlbSA9ICQoaXRlbSk7XHJcblxyXG4gICAgICAgICAgLy8gU3VwcG9ydCBhdHRyaWJ1dGVzIGxpa2UgYGRhdGEtb3B0aW9ucz0ne1widG91Y2hcIiA6IGZhbHNlfSdgIGFuZCBgZGF0YS10b3VjaD0nZmFsc2UnYFxyXG4gICAgICAgICAgb3B0cyA9ICRpdGVtLmRhdGEoKSB8fCB7fTtcclxuICAgICAgICAgIG9wdHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgb3B0cywgb3B0cy5vcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAvLyBIZXJlIHdlIHN0b3JlIGNsaWNrZWQgZWxlbWVudFxyXG4gICAgICAgICAgb3B0cy4kb3JpZyA9ICRpdGVtO1xyXG5cclxuICAgICAgICAgIG9iai5zcmMgPSBzZWxmLm9wdHMuc3JjIHx8IG9wdHMuc3JjIHx8ICRpdGVtLmF0dHIoXCJocmVmXCIpO1xyXG5cclxuICAgICAgICAgIC8vIEFzc3VtZSB0aGF0IHNpbXBsZSBzeW50YXggaXMgdXNlZCwgZm9yIGV4YW1wbGU6XHJcbiAgICAgICAgICAvLyAgIGAkLmZhbmN5Ym94Lm9wZW4oICQoXCIjdGVzdFwiKSwge30gKTtgXHJcbiAgICAgICAgICBpZiAoIW9iai50eXBlICYmICFvYmouc3JjKSB7XHJcbiAgICAgICAgICAgIG9iai50eXBlID0gXCJpbmxpbmVcIjtcclxuICAgICAgICAgICAgb2JqLnNyYyA9IGl0ZW07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIEFzc3VtZSB3ZSBoYXZlIGEgc2ltcGxlIGh0bWwgY29kZSwgZm9yIGV4YW1wbGU6XHJcbiAgICAgICAgICAvLyAgICQuZmFuY3lib3gub3BlbiggJzxkaXY+PGgxPkhpITwvaDE+PC9kaXY+JyApO1xyXG4gICAgICAgICAgb2JqID0ge1xyXG4gICAgICAgICAgICB0eXBlOiBcImh0bWxcIixcclxuICAgICAgICAgICAgc3JjOiBpdGVtICsgXCJcIlxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVhY2ggZ2FsbGVyeSBvYmplY3QgaGFzIGZ1bGwgY29sbGVjdGlvbiBvZiBvcHRpb25zXHJcbiAgICAgICAgb2JqLm9wdHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgc2VsZi5vcHRzLCBvcHRzKTtcclxuXHJcbiAgICAgICAgLy8gRG8gbm90IG1lcmdlIGJ1dHRvbnMgYXJyYXlcclxuICAgICAgICBpZiAoJC5pc0FycmF5KG9wdHMuYnV0dG9ucykpIHtcclxuICAgICAgICAgIG9iai5vcHRzLmJ1dHRvbnMgPSBvcHRzLmJ1dHRvbnM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoJC5mYW5jeWJveC5pc01vYmlsZSAmJiBvYmoub3B0cy5tb2JpbGUpIHtcclxuICAgICAgICAgIG9iai5vcHRzID0gbWVyZ2VPcHRzKG9iai5vcHRzLCBvYmoub3B0cy5tb2JpbGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RlcCAyIC0gTWFrZSBzdXJlIHdlIGhhdmUgY29udGVudCB0eXBlLCBpZiBub3QgLSB0cnkgdG8gZ3Vlc3NcclxuICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgICAgICB0eXBlID0gb2JqLnR5cGUgfHwgb2JqLm9wdHMudHlwZTtcclxuICAgICAgICBzcmMgPSBvYmouc3JjIHx8IFwiXCI7XHJcblxyXG4gICAgICAgIGlmICghdHlwZSAmJiBzcmMpIHtcclxuICAgICAgICAgIGlmICgoZm91bmQgPSBzcmMubWF0Y2goL1xcLihtcDR8bW92fG9ndnx3ZWJtKSgoXFw/fCMpLiopPyQvaSkpKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBcInZpZGVvXCI7XHJcblxyXG4gICAgICAgICAgICBpZiAoIW9iai5vcHRzLnZpZGVvLmZvcm1hdCkge1xyXG4gICAgICAgICAgICAgIG9iai5vcHRzLnZpZGVvLmZvcm1hdCA9IFwidmlkZW8vXCIgKyAoZm91bmRbMV0gPT09IFwib2d2XCIgPyBcIm9nZ1wiIDogZm91bmRbMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHNyYy5tYXRjaCgvKF5kYXRhOmltYWdlXFwvW2EtejAtOStcXC89XSosKXwoXFwuKGpwKGV8Z3xlZyl8Z2lmfHBuZ3xibXB8d2VicHxzdmd8aWNvKSgoXFw/fCMpLiopPyQpL2kpKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBcImltYWdlXCI7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHNyYy5tYXRjaCgvXFwuKHBkZikoKFxcP3wjKS4qKT8kL2kpKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBcImlmcmFtZVwiO1xyXG4gICAgICAgICAgICBvYmogPSAkLmV4dGVuZCh0cnVlLCBvYmosIHtcclxuICAgICAgICAgICAgICBjb250ZW50VHlwZTogXCJwZGZcIixcclxuICAgICAgICAgICAgICBvcHRzOiB7XHJcbiAgICAgICAgICAgICAgICBpZnJhbWU6IHtcclxuICAgICAgICAgICAgICAgICAgcHJlbG9hZDogZmFsc2VcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChzcmMuY2hhckF0KDApID09PSBcIiNcIikge1xyXG4gICAgICAgICAgICB0eXBlID0gXCJpbmxpbmVcIjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICBvYmoudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNlbGYudHJpZ2dlcihcIm9iamVjdE5lZWRzVHlwZVwiLCBvYmopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFvYmouY29udGVudFR5cGUpIHtcclxuICAgICAgICAgIG9iai5jb250ZW50VHlwZSA9ICQuaW5BcnJheShvYmoudHlwZSwgW1wiaHRtbFwiLCBcImlubGluZVwiLCBcImFqYXhcIl0pID4gLTEgPyBcImh0bWxcIiA6IG9iai50eXBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RlcCAzIC0gU29tZSBhZGp1c3RtZW50c1xyXG4gICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAgICAgb2JqLmluZGV4ID0gc2VsZi5ncm91cC5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChvYmoub3B0cy5zbWFsbEJ0biA9PSBcImF1dG9cIikge1xyXG4gICAgICAgICAgb2JqLm9wdHMuc21hbGxCdG4gPSAkLmluQXJyYXkob2JqLnR5cGUsIFtcImh0bWxcIiwgXCJpbmxpbmVcIiwgXCJhamF4XCJdKSA+IC0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9iai5vcHRzLnRvb2xiYXIgPT09IFwiYXV0b1wiKSB7XHJcbiAgICAgICAgICBvYmoub3B0cy50b29sYmFyID0gIW9iai5vcHRzLnNtYWxsQnRuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRmluZCB0aHVtYm5haWwgaW1hZ2UsIGNoZWNrIGlmIGV4aXN0cyBhbmQgaWYgaXMgaW4gdGhlIHZpZXdwb3J0XHJcbiAgICAgICAgb2JqLiR0aHVtYiA9IG9iai5vcHRzLiR0aHVtYiB8fCBudWxsO1xyXG5cclxuICAgICAgICBpZiAob2JqLm9wdHMuJHRyaWdnZXIgJiYgb2JqLmluZGV4ID09PSBzZWxmLm9wdHMuaW5kZXgpIHtcclxuICAgICAgICAgIG9iai4kdGh1bWIgPSBvYmoub3B0cy4kdHJpZ2dlci5maW5kKFwiaW1nOmZpcnN0XCIpO1xyXG5cclxuICAgICAgICAgIGlmIChvYmouJHRodW1iLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBvYmoub3B0cy4kb3JpZyA9IG9iai5vcHRzLiR0cmlnZ2VyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCEob2JqLiR0aHVtYiAmJiBvYmouJHRodW1iLmxlbmd0aCkgJiYgb2JqLm9wdHMuJG9yaWcpIHtcclxuICAgICAgICAgIG9iai4kdGh1bWIgPSBvYmoub3B0cy4kb3JpZy5maW5kKFwiaW1nOmZpcnN0XCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9iai4kdGh1bWIgJiYgIW9iai4kdGh1bWIubGVuZ3RoKSB7XHJcbiAgICAgICAgICBvYmouJHRodW1iID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9iai50aHVtYiA9IG9iai5vcHRzLnRodW1iIHx8IChvYmouJHRodW1iID8gb2JqLiR0aHVtYlswXS5zcmMgOiBudWxsKTtcclxuXHJcbiAgICAgICAgLy8gXCJjYXB0aW9uXCIgaXMgYSBcInNwZWNpYWxcIiBvcHRpb24sIGl0IGNhbiBiZSB1c2VkIHRvIGN1c3RvbWl6ZSBjYXB0aW9uIHBlciBnYWxsZXJ5IGl0ZW1cclxuICAgICAgICBpZiAoJC50eXBlKG9iai5vcHRzLmNhcHRpb24pID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgIG9iai5vcHRzLmNhcHRpb24gPSBvYmoub3B0cy5jYXB0aW9uLmFwcGx5KGl0ZW0sIFtzZWxmLCBvYmpdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgkLnR5cGUoc2VsZi5vcHRzLmNhcHRpb24pID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgIG9iai5vcHRzLmNhcHRpb24gPSBzZWxmLm9wdHMuY2FwdGlvbi5hcHBseShpdGVtLCBbc2VsZiwgb2JqXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBjYXB0aW9uIGFzIGEgc3RyaW5nIG9yIGpRdWVyeSBvYmplY3RcclxuICAgICAgICBpZiAoIShvYmoub3B0cy5jYXB0aW9uIGluc3RhbmNlb2YgJCkpIHtcclxuICAgICAgICAgIG9iai5vcHRzLmNhcHRpb24gPSBvYmoub3B0cy5jYXB0aW9uID09PSB1bmRlZmluZWQgPyBcIlwiIDogb2JqLm9wdHMuY2FwdGlvbiArIFwiXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB1cmwgY29udGFpbnMgXCJmaWx0ZXJcIiB1c2VkIHRvIGZpbHRlciB0aGUgY29udGVudFxyXG4gICAgICAgIC8vIEV4YW1wbGU6IFwiYWpheC5odG1sICNzb21ldGhpbmdcIlxyXG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJhamF4XCIpIHtcclxuICAgICAgICAgIHNyY1BhcnRzID0gc3JjLnNwbGl0KC9cXHMrLywgMik7XHJcblxyXG4gICAgICAgICAgaWYgKHNyY1BhcnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgb2JqLnNyYyA9IHNyY1BhcnRzLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgICAgICBvYmoub3B0cy5maWx0ZXIgPSBzcmNQYXJ0cy5zaGlmdCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSGlkZSBhbGwgYnV0dG9ucyBhbmQgZGlzYWJsZSBpbnRlcmFjdGl2aXR5IGZvciBtb2RhbCBpdGVtc1xyXG4gICAgICAgIGlmIChvYmoub3B0cy5tb2RhbCkge1xyXG4gICAgICAgICAgb2JqLm9wdHMgPSAkLmV4dGVuZCh0cnVlLCBvYmoub3B0cywge1xyXG4gICAgICAgICAgICB0cmFwRm9jdXM6IHRydWUsXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBidXR0b25zXHJcbiAgICAgICAgICAgIGluZm9iYXI6IDAsXHJcbiAgICAgICAgICAgIHRvb2xiYXI6IDAsXHJcblxyXG4gICAgICAgICAgICBzbWFsbEJ0bjogMCxcclxuXHJcbiAgICAgICAgICAgIC8vIERpc2FibGUga2V5Ym9hcmQgbmF2aWdhdGlvblxyXG4gICAgICAgICAgICBrZXlib2FyZDogMCxcclxuXHJcbiAgICAgICAgICAgIC8vIERpc2FibGUgc29tZSBtb2R1bGVzXHJcbiAgICAgICAgICAgIHNsaWRlU2hvdzogMCxcclxuICAgICAgICAgICAgZnVsbFNjcmVlbjogMCxcclxuICAgICAgICAgICAgdGh1bWJzOiAwLFxyXG4gICAgICAgICAgICB0b3VjaDogMCxcclxuXHJcbiAgICAgICAgICAgIC8vIERpc2FibGUgY2xpY2sgZXZlbnQgaGFuZGxlcnNcclxuICAgICAgICAgICAgY2xpY2tDb250ZW50OiBmYWxzZSxcclxuICAgICAgICAgICAgY2xpY2tTbGlkZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGNsaWNrT3V0c2lkZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGRibGNsaWNrQ29udGVudDogZmFsc2UsXHJcbiAgICAgICAgICAgIGRibGNsaWNrU2xpZGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBkYmxjbGlja091dHNpZGU6IGZhbHNlXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFN0ZXAgNCAtIEFkZCBwcm9jZXNzZWQgb2JqZWN0IHRvIGdyb3VwXHJcbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAgICAgc2VsZi5ncm91cC5wdXNoKG9iaik7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIGNvbnRyb2xzIGlmIGdhbGxlcnkgaXMgYWxyZWFkeSBvcGVuZWRcclxuICAgICAgaWYgKE9iamVjdC5rZXlzKHNlbGYuc2xpZGVzKS5sZW5ndGgpIHtcclxuICAgICAgICBzZWxmLnVwZGF0ZUNvbnRyb2xzKCk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aHVtYm5haWxzLCBpZiBuZWVkZWRcclxuICAgICAgICB0aHVtYnMgPSBzZWxmLlRodW1icztcclxuXHJcbiAgICAgICAgaWYgKHRodW1icyAmJiB0aHVtYnMuaXNBY3RpdmUpIHtcclxuICAgICAgICAgIHRodW1icy5jcmVhdGUoKTtcclxuXHJcbiAgICAgICAgICB0aHVtYnMuZm9jdXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gQXR0YWNoIGFuIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25zIGZvcjpcclxuICAgIC8vICAgLSBuYXZpZ2F0aW9uIGJ1dHRvbnNcclxuICAgIC8vICAgLSBicm93c2VyIHNjcm9sbGluZywgcmVzaXppbmc7XHJcbiAgICAvLyAgIC0gZm9jdXNpbmdcclxuICAgIC8vICAgLSBrZXlib2FyZFxyXG4gICAgLy8gICAtIGRldGVjdGluZyBpbmFjdGl2aXR5XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGFkZEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICBzZWxmLnJlbW92ZUV2ZW50cygpO1xyXG5cclxuICAgICAgLy8gTWFrZSBuYXZpZ2F0aW9uIGVsZW1lbnRzIGNsaWNrYWJsZVxyXG4gICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgICBzZWxmLiRyZWZzLmNvbnRhaW5lclxyXG4gICAgICAgIC5vbihcImNsaWNrLmZiLWNsb3NlXCIsIFwiW2RhdGEtZmFuY3lib3gtY2xvc2VdXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgIHNlbGYuY2xvc2UoZSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oXCJ0b3VjaHN0YXJ0LmZiLXByZXYgY2xpY2suZmItcHJldlwiLCBcIltkYXRhLWZhbmN5Ym94LXByZXZdXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgIHNlbGYucHJldmlvdXMoKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbihcInRvdWNoc3RhcnQuZmItbmV4dCBjbGljay5mYi1uZXh0XCIsIFwiW2RhdGEtZmFuY3lib3gtbmV4dF1cIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgc2VsZi5uZXh0KCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oXCJjbGljay5mYlwiLCBcIltkYXRhLWZhbmN5Ym94LXpvb21dXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAvLyBDbGljayBoYW5kbGVyIGZvciB6b29tIGJ1dHRvblxyXG4gICAgICAgICAgc2VsZltzZWxmLmlzU2NhbGVkRG93bigpID8gXCJzY2FsZVRvQWN0dWFsXCIgOiBcInNjYWxlVG9GaXRcIl0oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEhhbmRsZSBwYWdlIHNjcm9sbGluZyBhbmQgYnJvd3NlciByZXNpemluZ1xyXG4gICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAgICRXLm9uKFwib3JpZW50YXRpb25jaGFuZ2UuZmIgcmVzaXplLmZiXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKGUgJiYgZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC50eXBlID09PSBcInJlc2l6ZVwiKSB7XHJcbiAgICAgICAgICBpZiAoc2VsZi5yZXF1ZXN0SWQpIHtcclxuICAgICAgICAgICAgY2FuY2VsQUZyYW1lKHNlbGYucmVxdWVzdElkKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzZWxmLnJlcXVlc3RJZCA9IHJlcXVlc3RBRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZWxmLnVwZGF0ZShlKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoc2VsZi5jdXJyZW50ICYmIHNlbGYuY3VycmVudC50eXBlID09PSBcImlmcmFtZVwiKSB7XHJcbiAgICAgICAgICAgIHNlbGYuJHJlZnMuc3RhZ2UuaGlkZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHNldFRpbWVvdXQoXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBzZWxmLiRyZWZzLnN0YWdlLnNob3coKTtcclxuXHJcbiAgICAgICAgICAgICAgc2VsZi51cGRhdGUoZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICQuZmFuY3lib3guaXNNb2JpbGUgPyA2MDAgOiAyNTBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgICRELm9uKFwia2V5ZG93bi5mYlwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHZhciBpbnN0YW5jZSA9ICQuZmFuY3lib3ggPyAkLmZhbmN5Ym94LmdldEluc3RhbmNlKCkgOiBudWxsLFxyXG4gICAgICAgICAgY3VycmVudCA9IGluc3RhbmNlLmN1cnJlbnQsXHJcbiAgICAgICAgICBrZXljb2RlID0gZS5rZXlDb2RlIHx8IGUud2hpY2g7XHJcblxyXG4gICAgICAgIC8vIFRyYXAga2V5Ym9hcmQgZm9jdXMgaW5zaWRlIG9mIHRoZSBtb2RhbFxyXG4gICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgICAgICBpZiAoa2V5Y29kZSA9PSA5KSB7XHJcbiAgICAgICAgICBpZiAoY3VycmVudC5vcHRzLnRyYXBGb2N1cykge1xyXG4gICAgICAgICAgICBzZWxmLmZvY3VzKGUpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVuYWJsZSBrZXlib2FyZCBuYXZpZ2F0aW9uXHJcbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAgICAgaWYgKCFjdXJyZW50Lm9wdHMua2V5Ym9hcmQgfHwgZS5jdHJsS2V5IHx8IGUuYWx0S2V5IHx8IGUuc2hpZnRLZXkgfHwgJChlLnRhcmdldCkuaXMoXCJpbnB1dCx0ZXh0YXJlYSx2aWRlbyxhdWRpbyxzZWxlY3RcIikpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEJhY2tzcGFjZSBhbmQgRXNjIGtleXNcclxuICAgICAgICBpZiAoa2V5Y29kZSA9PT0gOCB8fCBrZXljb2RlID09PSAyNykge1xyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgIHNlbGYuY2xvc2UoZSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTGVmdCBhcnJvdyBhbmQgVXAgYXJyb3dcclxuICAgICAgICBpZiAoa2V5Y29kZSA9PT0gMzcgfHwga2V5Y29kZSA9PT0gMzgpIHtcclxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICBzZWxmLnByZXZpb3VzKCk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmlnaCBhcnJvdyBhbmQgRG93biBhcnJvd1xyXG4gICAgICAgIGlmIChrZXljb2RlID09PSAzOSB8fCBrZXljb2RlID09PSA0MCkge1xyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgIHNlbGYubmV4dCgpO1xyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGYudHJpZ2dlcihcImFmdGVyS2V5ZG93blwiLCBlLCBrZXljb2RlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBIaWRlIGNvbnRyb2xzIGFmdGVyIHNvbWUgaW5hY3Rpdml0eSBwZXJpb2RcclxuICAgICAgaWYgKHNlbGYuZ3JvdXBbc2VsZi5jdXJySW5kZXhdLm9wdHMuaWRsZVRpbWUpIHtcclxuICAgICAgICBzZWxmLmlkbGVTZWNvbmRzQ291bnRlciA9IDA7XHJcblxyXG4gICAgICAgICRELm9uKFxyXG4gICAgICAgICAgXCJtb3VzZW1vdmUuZmItaWRsZSBtb3VzZWxlYXZlLmZiLWlkbGUgbW91c2Vkb3duLmZiLWlkbGUgdG91Y2hzdGFydC5mYi1pZGxlIHRvdWNobW92ZS5mYi1pZGxlIHNjcm9sbC5mYi1pZGxlIGtleWRvd24uZmItaWRsZVwiLFxyXG4gICAgICAgICAgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgc2VsZi5pZGxlU2Vjb25kc0NvdW50ZXIgPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGYuaXNJZGxlKSB7XHJcbiAgICAgICAgICAgICAgc2VsZi5zaG93Q29udHJvbHMoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2VsZi5pc0lkbGUgPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBzZWxmLmlkbGVJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBzZWxmLmlkbGVTZWNvbmRzQ291bnRlcisrO1xyXG5cclxuICAgICAgICAgIGlmIChzZWxmLmlkbGVTZWNvbmRzQ291bnRlciA+PSBzZWxmLmdyb3VwW3NlbGYuY3VyckluZGV4XS5vcHRzLmlkbGVUaW1lICYmICFzZWxmLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgc2VsZi5pc0lkbGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBzZWxmLmlkbGVTZWNvbmRzQ291bnRlciA9IDA7XHJcblxyXG4gICAgICAgICAgICBzZWxmLmhpZGVDb250cm9scygpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIDEwMDApO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFJlbW92ZSBldmVudHMgYWRkZWQgYnkgdGhlIGNvcmVcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICByZW1vdmVFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgJFcub2ZmKFwib3JpZW50YXRpb25jaGFuZ2UuZmIgcmVzaXplLmZiXCIpO1xyXG4gICAgICAkRC5vZmYoXCJrZXlkb3duLmZiIC5mYi1pZGxlXCIpO1xyXG5cclxuICAgICAgdGhpcy4kcmVmcy5jb250YWluZXIub2ZmKFwiLmZiLWNsb3NlIC5mYi1wcmV2IC5mYi1uZXh0XCIpO1xyXG5cclxuICAgICAgaWYgKHNlbGYuaWRsZUludGVydmFsKSB7XHJcbiAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwoc2VsZi5pZGxlSW50ZXJ2YWwpO1xyXG5cclxuICAgICAgICBzZWxmLmlkbGVJbnRlcnZhbCA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2hhbmdlIHRvIHByZXZpb3VzIGdhbGxlcnkgaXRlbVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIHByZXZpb3VzOiBmdW5jdGlvbiAoZHVyYXRpb24pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuanVtcFRvKHRoaXMuY3VyclBvcyAtIDEsIGR1cmF0aW9uKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2hhbmdlIHRvIG5leHQgZ2FsbGVyeSBpdGVtXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBuZXh0OiBmdW5jdGlvbiAoZHVyYXRpb24pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuanVtcFRvKHRoaXMuY3VyclBvcyArIDEsIGR1cmF0aW9uKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gU3dpdGNoIHRvIHNlbGVjdGVkIGdhbGxlcnkgaXRlbVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGp1bXBUbzogZnVuY3Rpb24gKHBvcywgZHVyYXRpb24pIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIGdyb3VwTGVuID0gc2VsZi5ncm91cC5sZW5ndGgsXHJcbiAgICAgICAgZmlyc3RSdW4sXHJcbiAgICAgICAgaXNNb3ZlZCxcclxuICAgICAgICBsb29wLFxyXG4gICAgICAgIGN1cnJlbnQsXHJcbiAgICAgICAgcHJldmlvdXMsXHJcbiAgICAgICAgc2xpZGVQb3MsXHJcbiAgICAgICAgc3RhZ2VQb3MsXHJcbiAgICAgICAgcHJvcCxcclxuICAgICAgICBkaWZmO1xyXG5cclxuICAgICAgaWYgKHNlbGYuaXNEcmFnZ2luZyB8fCBzZWxmLmlzQ2xvc2luZyB8fCAoc2VsZi5pc0FuaW1hdGluZyAmJiBzZWxmLmZpcnN0UnVuKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2hvdWxkIGxvb3A/XHJcbiAgICAgIHBvcyA9IHBhcnNlSW50KHBvcywgMTApO1xyXG4gICAgICBsb29wID0gc2VsZi5jdXJyZW50ID8gc2VsZi5jdXJyZW50Lm9wdHMubG9vcCA6IHNlbGYub3B0cy5sb29wO1xyXG5cclxuICAgICAgaWYgKCFsb29wICYmIChwb3MgPCAwIHx8IHBvcyA+PSBncm91cExlbikpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIG9wZW5pbmcgZm9yIHRoZSBmaXJzdCB0aW1lOyB0aGlzIGhlbHBzIHRvIHNwZWVkIHRoaW5ncyB1cFxyXG4gICAgICBmaXJzdFJ1biA9IHNlbGYuZmlyc3RSdW4gPSAhT2JqZWN0LmtleXMoc2VsZi5zbGlkZXMpLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSBzbGlkZXNcclxuICAgICAgcHJldmlvdXMgPSBzZWxmLmN1cnJlbnQ7XHJcblxyXG4gICAgICBzZWxmLnByZXZJbmRleCA9IHNlbGYuY3VyckluZGV4O1xyXG4gICAgICBzZWxmLnByZXZQb3MgPSBzZWxmLmN1cnJQb3M7XHJcblxyXG4gICAgICBjdXJyZW50ID0gc2VsZi5jcmVhdGVTbGlkZShwb3MpO1xyXG5cclxuICAgICAgaWYgKGdyb3VwTGVuID4gMSkge1xyXG4gICAgICAgIGlmIChsb29wIHx8IGN1cnJlbnQuaW5kZXggPCBncm91cExlbiAtIDEpIHtcclxuICAgICAgICAgIHNlbGYuY3JlYXRlU2xpZGUocG9zICsgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobG9vcCB8fCBjdXJyZW50LmluZGV4ID4gMCkge1xyXG4gICAgICAgICAgc2VsZi5jcmVhdGVTbGlkZShwb3MgLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGYuY3VycmVudCA9IGN1cnJlbnQ7XHJcbiAgICAgIHNlbGYuY3VyckluZGV4ID0gY3VycmVudC5pbmRleDtcclxuICAgICAgc2VsZi5jdXJyUG9zID0gY3VycmVudC5wb3M7XHJcblxyXG4gICAgICBzZWxmLnRyaWdnZXIoXCJiZWZvcmVTaG93XCIsIGZpcnN0UnVuKTtcclxuXHJcbiAgICAgIHNlbGYudXBkYXRlQ29udHJvbHMoKTtcclxuXHJcbiAgICAgIC8vIFZhbGlkYXRlIGR1cmF0aW9uIGxlbmd0aFxyXG4gICAgICBjdXJyZW50LmZvcmNlZER1cmF0aW9uID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgaWYgKCQuaXNOdW1lcmljKGR1cmF0aW9uKSkge1xyXG4gICAgICAgIGN1cnJlbnQuZm9yY2VkRHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkdXJhdGlvbiA9IGN1cnJlbnQub3B0c1tmaXJzdFJ1biA/IFwiYW5pbWF0aW9uRHVyYXRpb25cIiA6IFwidHJhbnNpdGlvbkR1cmF0aW9uXCJdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkdXJhdGlvbiA9IHBhcnNlSW50KGR1cmF0aW9uLCAxMCk7XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiB1c2VyIGhhcyBzd2lwZWQgdGhlIHNsaWRlcyBvciBpZiBzdGlsbCBhbmltYXRpbmdcclxuICAgICAgaXNNb3ZlZCA9IHNlbGYuaXNNb3ZlZChjdXJyZW50KTtcclxuXHJcbiAgICAgIC8vIE1ha2Ugc3VyZSBjdXJyZW50IHNsaWRlIGlzIHZpc2libGVcclxuICAgICAgY3VycmVudC4kc2xpZGUuYWRkQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tY3VycmVudFwiKTtcclxuXHJcbiAgICAgIC8vIEZyZXNoIHN0YXJ0IC0gcmV2ZWFsIGNvbnRhaW5lciwgY3VycmVudCBzbGlkZSBhbmQgc3RhcnQgbG9hZGluZyBjb250ZW50XHJcbiAgICAgIGlmIChmaXJzdFJ1bikge1xyXG4gICAgICAgIGlmIChjdXJyZW50Lm9wdHMuYW5pbWF0aW9uRWZmZWN0ICYmIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICBzZWxmLiRyZWZzLmNvbnRhaW5lci5jc3MoXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIsIGR1cmF0aW9uICsgXCJtc1wiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGYuJHJlZnMuY29udGFpbmVyLmFkZENsYXNzKFwiZmFuY3lib3gtaXMtb3BlblwiKS50cmlnZ2VyKFwiZm9jdXNcIik7XHJcblxyXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gbG9hZCBjb250ZW50IGludG8gc2xpZGVcclxuICAgICAgICAvLyBUaGlzIHdpbGwgbGF0ZXIgY2FsbCBgYWZ0ZXJMb2FkYCAtPiBgcmV2ZWFsQ29udGVudGBcclxuICAgICAgICBzZWxmLmxvYWRTbGlkZShjdXJyZW50KTtcclxuXHJcbiAgICAgICAgc2VsZi5wcmVsb2FkKFwiaW1hZ2VcIik7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gR2V0IGFjdHVhbCBzbGlkZS9zdGFnZSBwb3NpdGlvbnMgKGJlZm9yZSBjbGVhbmluZyB1cClcclxuICAgICAgc2xpZGVQb3MgPSAkLmZhbmN5Ym94LmdldFRyYW5zbGF0ZShwcmV2aW91cy4kc2xpZGUpO1xyXG4gICAgICBzdGFnZVBvcyA9ICQuZmFuY3lib3guZ2V0VHJhbnNsYXRlKHNlbGYuJHJlZnMuc3RhZ2UpO1xyXG5cclxuICAgICAgLy8gQ2xlYW4gdXAgYWxsIHNsaWRlc1xyXG4gICAgICAkLmVhY2goc2VsZi5zbGlkZXMsIGZ1bmN0aW9uIChpbmRleCwgc2xpZGUpIHtcclxuICAgICAgICAkLmZhbmN5Ym94LnN0b3Aoc2xpZGUuJHNsaWRlLCB0cnVlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAocHJldmlvdXMucG9zICE9PSBjdXJyZW50LnBvcykge1xyXG4gICAgICAgIHByZXZpb3VzLmlzQ29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHJldmlvdXMuJHNsaWRlLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtc2xpZGUtLWNvbXBsZXRlIGZhbmN5Ym94LXNsaWRlLS1jdXJyZW50XCIpO1xyXG5cclxuICAgICAgLy8gSWYgc2xpZGVzIGFyZSBvdXQgb2YgcGxhY2UsIHRoZW4gYW5pbWF0ZSB0aGVtIHRvIGNvcnJlY3QgcG9zaXRpb25cclxuICAgICAgaWYgKGlzTW92ZWQpIHtcclxuICAgICAgICAvLyBDYWxjdWxhdGUgaG9yaXpvbnRhbCBzd2lwZSBkaXN0YW5jZVxyXG4gICAgICAgIGRpZmYgPSBzbGlkZVBvcy5sZWZ0IC0gKHByZXZpb3VzLnBvcyAqIHNsaWRlUG9zLndpZHRoICsgcHJldmlvdXMucG9zICogcHJldmlvdXMub3B0cy5ndXR0ZXIpO1xyXG5cclxuICAgICAgICAkLmVhY2goc2VsZi5zbGlkZXMsIGZ1bmN0aW9uIChpbmRleCwgc2xpZGUpIHtcclxuICAgICAgICAgIHNsaWRlLiRzbGlkZS5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LWFuaW1hdGVkXCIpLnJlbW92ZUNsYXNzKGZ1bmN0aW9uIChpbmRleCwgY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoY2xhc3NOYW1lLm1hdGNoKC8oXnxcXHMpZmFuY3lib3gtZngtXFxTKy9nKSB8fCBbXSkuam9pbihcIiBcIik7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBlYWNoIHNsaWRlIGlzIGluIGVxdWFsIGRpc3RhbmNlXHJcbiAgICAgICAgICAvLyBUaGlzIGlzIG1vc3RseSBuZWVkZWQgZm9yIGZyZXNobHkgYWRkZWQgc2xpZGVzLCBiZWNhdXNlIHRoZXkgYXJlIG5vdCB5ZXQgcG9zaXRpb25lZFxyXG4gICAgICAgICAgdmFyIGxlZnRQb3MgPSBzbGlkZS5wb3MgKiBzbGlkZVBvcy53aWR0aCArIHNsaWRlLnBvcyAqIHNsaWRlLm9wdHMuZ3V0dGVyO1xyXG5cclxuICAgICAgICAgICQuZmFuY3lib3guc2V0VHJhbnNsYXRlKHNsaWRlLiRzbGlkZSwge1xyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIGxlZnQ6IGxlZnRQb3MgLSBzdGFnZVBvcy5sZWZ0ICsgZGlmZlxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaWYgKHNsaWRlLnBvcyAhPT0gY3VycmVudC5wb3MpIHtcclxuICAgICAgICAgICAgc2xpZGUuJHNsaWRlLmFkZENsYXNzKFwiZmFuY3lib3gtc2xpZGUtLVwiICsgKHNsaWRlLnBvcyA+IGN1cnJlbnQucG9zID8gXCJuZXh0XCIgOiBcInByZXZpb3VzXCIpKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZWRyYXcgdG8gbWFrZSBzdXJlIHRoYXQgdHJhbnNpdGlvbiB3aWxsIHN0YXJ0XHJcbiAgICAgICAgICBmb3JjZVJlZHJhdyhzbGlkZS4kc2xpZGUpO1xyXG5cclxuICAgICAgICAgIC8vIEFuaW1hdGUgdGhlIHNsaWRlXHJcbiAgICAgICAgICAkLmZhbmN5Ym94LmFuaW1hdGUoXHJcbiAgICAgICAgICAgIHNsaWRlLiRzbGlkZSwge1xyXG4gICAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgICBsZWZ0OiAoc2xpZGUucG9zIC0gY3VycmVudC5wb3MpICogc2xpZGVQb3Mud2lkdGggKyAoc2xpZGUucG9zIC0gY3VycmVudC5wb3MpICogc2xpZGUub3B0cy5ndXR0ZXJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBzbGlkZS4kc2xpZGVcclxuICAgICAgICAgICAgICAgIC5jc3Moe1xyXG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiXCJcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tbmV4dCBmYW5jeWJveC1zbGlkZS0tcHJldmlvdXNcIik7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChzbGlkZS5wb3MgPT09IHNlbGYuY3VyclBvcykge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiAmJiBjdXJyZW50Lm9wdHMudHJhbnNpdGlvbkVmZmVjdCkge1xyXG4gICAgICAgIC8vIFNldCB0cmFuc2l0aW9uIGVmZmVjdCBmb3IgcHJldmlvdXNseSBhY3RpdmUgc2xpZGVcclxuICAgICAgICBwcm9wID0gXCJmYW5jeWJveC1hbmltYXRlZCBmYW5jeWJveC1meC1cIiArIGN1cnJlbnQub3B0cy50cmFuc2l0aW9uRWZmZWN0O1xyXG5cclxuICAgICAgICBwcmV2aW91cy4kc2xpZGUuYWRkQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tXCIgKyAocHJldmlvdXMucG9zID4gY3VycmVudC5wb3MgPyBcIm5leHRcIiA6IFwicHJldmlvdXNcIikpO1xyXG5cclxuICAgICAgICAkLmZhbmN5Ym94LmFuaW1hdGUoXHJcbiAgICAgICAgICBwcmV2aW91cy4kc2xpZGUsXHJcbiAgICAgICAgICBwcm9wLFxyXG4gICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHByZXZpb3VzLiRzbGlkZS5yZW1vdmVDbGFzcyhwcm9wKS5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LXNsaWRlLS1uZXh0IGZhbmN5Ym94LXNsaWRlLS1wcmV2aW91c1wiKTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBmYWxzZVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjdXJyZW50LmlzTG9hZGVkKSB7XHJcbiAgICAgICAgc2VsZi5yZXZlYWxDb250ZW50KGN1cnJlbnQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlbGYubG9hZFNsaWRlKGN1cnJlbnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZWxmLnByZWxvYWQoXCJpbWFnZVwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ3JlYXRlIG5ldyBcInNsaWRlXCIgZWxlbWVudFxyXG4gICAgLy8gVGhlc2UgYXJlIGdhbGxlcnkgaXRlbXMgIHRoYXQgYXJlIGFjdHVhbGx5IGFkZGVkIHRvIERPTVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGNyZWF0ZVNsaWRlOiBmdW5jdGlvbiAocG9zKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAkc2xpZGUsXHJcbiAgICAgICAgaW5kZXg7XHJcblxyXG4gICAgICBpbmRleCA9IHBvcyAlIHNlbGYuZ3JvdXAubGVuZ3RoO1xyXG4gICAgICBpbmRleCA9IGluZGV4IDwgMCA/IHNlbGYuZ3JvdXAubGVuZ3RoICsgaW5kZXggOiBpbmRleDtcclxuXHJcbiAgICAgIGlmICghc2VsZi5zbGlkZXNbcG9zXSAmJiBzZWxmLmdyb3VwW2luZGV4XSkge1xyXG4gICAgICAgICRzbGlkZSA9ICQoJzxkaXYgY2xhc3M9XCJmYW5jeWJveC1zbGlkZVwiPjwvZGl2PicpLmFwcGVuZFRvKHNlbGYuJHJlZnMuc3RhZ2UpO1xyXG5cclxuICAgICAgICBzZWxmLnNsaWRlc1twb3NdID0gJC5leHRlbmQodHJ1ZSwge30sIHNlbGYuZ3JvdXBbaW5kZXhdLCB7XHJcbiAgICAgICAgICBwb3M6IHBvcyxcclxuICAgICAgICAgICRzbGlkZTogJHNsaWRlLFxyXG4gICAgICAgICAgaXNMb2FkZWQ6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNlbGYudXBkYXRlU2xpZGUoc2VsZi5zbGlkZXNbcG9zXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzZWxmLnNsaWRlc1twb3NdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBTY2FsZSBpbWFnZSB0byB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIGltYWdlO1xyXG4gICAgLy8geCBhbmQgeSB2YWx1ZXMgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBzbGlkZVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIHNjYWxlVG9BY3R1YWw6IGZ1bmN0aW9uICh4LCB5LCBkdXJhdGlvbikge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgY3VycmVudCA9IHNlbGYuY3VycmVudCxcclxuICAgICAgICAkY29udGVudCA9IGN1cnJlbnQuJGNvbnRlbnQsXHJcbiAgICAgICAgY2FudmFzV2lkdGggPSAkLmZhbmN5Ym94LmdldFRyYW5zbGF0ZShjdXJyZW50LiRzbGlkZSkud2lkdGgsXHJcbiAgICAgICAgY2FudmFzSGVpZ2h0ID0gJC5mYW5jeWJveC5nZXRUcmFuc2xhdGUoY3VycmVudC4kc2xpZGUpLmhlaWdodCxcclxuICAgICAgICBuZXdJbWdXaWR0aCA9IGN1cnJlbnQud2lkdGgsXHJcbiAgICAgICAgbmV3SW1nSGVpZ2h0ID0gY3VycmVudC5oZWlnaHQsXHJcbiAgICAgICAgaW1nUG9zLFxyXG4gICAgICAgIHBvc1gsXHJcbiAgICAgICAgcG9zWSxcclxuICAgICAgICBzY2FsZVgsXHJcbiAgICAgICAgc2NhbGVZO1xyXG5cclxuICAgICAgaWYgKHNlbGYuaXNBbmltYXRpbmcgfHwgc2VsZi5pc01vdmVkKCkgfHwgISRjb250ZW50IHx8ICEoY3VycmVudC50eXBlID09IFwiaW1hZ2VcIiAmJiBjdXJyZW50LmlzTG9hZGVkICYmICFjdXJyZW50Lmhhc0Vycm9yKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZi5pc0FuaW1hdGluZyA9IHRydWU7XHJcblxyXG4gICAgICAkLmZhbmN5Ym94LnN0b3AoJGNvbnRlbnQpO1xyXG5cclxuICAgICAgeCA9IHggPT09IHVuZGVmaW5lZCA/IGNhbnZhc1dpZHRoICogMC41IDogeDtcclxuICAgICAgeSA9IHkgPT09IHVuZGVmaW5lZCA/IGNhbnZhc0hlaWdodCAqIDAuNSA6IHk7XHJcblxyXG4gICAgICBpbWdQb3MgPSAkLmZhbmN5Ym94LmdldFRyYW5zbGF0ZSgkY29udGVudCk7XHJcblxyXG4gICAgICBpbWdQb3MudG9wIC09ICQuZmFuY3lib3guZ2V0VHJhbnNsYXRlKGN1cnJlbnQuJHNsaWRlKS50b3A7XHJcbiAgICAgIGltZ1Bvcy5sZWZ0IC09ICQuZmFuY3lib3guZ2V0VHJhbnNsYXRlKGN1cnJlbnQuJHNsaWRlKS5sZWZ0O1xyXG5cclxuICAgICAgc2NhbGVYID0gbmV3SW1nV2lkdGggLyBpbWdQb3Mud2lkdGg7XHJcbiAgICAgIHNjYWxlWSA9IG5ld0ltZ0hlaWdodCAvIGltZ1Bvcy5oZWlnaHQ7XHJcblxyXG4gICAgICAvLyBHZXQgY2VudGVyIHBvc2l0aW9uIGZvciBvcmlnaW5hbCBpbWFnZVxyXG4gICAgICBwb3NYID0gY2FudmFzV2lkdGggKiAwLjUgLSBuZXdJbWdXaWR0aCAqIDAuNTtcclxuICAgICAgcG9zWSA9IGNhbnZhc0hlaWdodCAqIDAuNSAtIG5ld0ltZ0hlaWdodCAqIDAuNTtcclxuXHJcbiAgICAgIC8vIE1ha2Ugc3VyZSBpbWFnZSBkb2VzIG5vdCBtb3ZlIGF3YXkgZnJvbSBlZGdlc1xyXG4gICAgICBpZiAobmV3SW1nV2lkdGggPiBjYW52YXNXaWR0aCkge1xyXG4gICAgICAgIHBvc1ggPSBpbWdQb3MubGVmdCAqIHNjYWxlWCAtICh4ICogc2NhbGVYIC0geCk7XHJcblxyXG4gICAgICAgIGlmIChwb3NYID4gMCkge1xyXG4gICAgICAgICAgcG9zWCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocG9zWCA8IGNhbnZhc1dpZHRoIC0gbmV3SW1nV2lkdGgpIHtcclxuICAgICAgICAgIHBvc1ggPSBjYW52YXNXaWR0aCAtIG5ld0ltZ1dpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG5ld0ltZ0hlaWdodCA+IGNhbnZhc0hlaWdodCkge1xyXG4gICAgICAgIHBvc1kgPSBpbWdQb3MudG9wICogc2NhbGVZIC0gKHkgKiBzY2FsZVkgLSB5KTtcclxuXHJcbiAgICAgICAgaWYgKHBvc1kgPiAwKSB7XHJcbiAgICAgICAgICBwb3NZID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwb3NZIDwgY2FudmFzSGVpZ2h0IC0gbmV3SW1nSGVpZ2h0KSB7XHJcbiAgICAgICAgICBwb3NZID0gY2FudmFzSGVpZ2h0IC0gbmV3SW1nSGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZi51cGRhdGVDdXJzb3IobmV3SW1nV2lkdGgsIG5ld0ltZ0hlaWdodCk7XHJcblxyXG4gICAgICAkLmZhbmN5Ym94LmFuaW1hdGUoXHJcbiAgICAgICAgJGNvbnRlbnQsIHtcclxuICAgICAgICAgIHRvcDogcG9zWSxcclxuICAgICAgICAgIGxlZnQ6IHBvc1gsXHJcbiAgICAgICAgICBzY2FsZVg6IHNjYWxlWCxcclxuICAgICAgICAgIHNjYWxlWTogc2NhbGVZXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkdXJhdGlvbiB8fCAzNjYsXHJcbiAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgc2VsZi5pc0FuaW1hdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIFN0b3Agc2xpZGVzaG93XHJcbiAgICAgIGlmIChzZWxmLlNsaWRlU2hvdyAmJiBzZWxmLlNsaWRlU2hvdy5pc0FjdGl2ZSkge1xyXG4gICAgICAgIHNlbGYuU2xpZGVTaG93LnN0b3AoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBTY2FsZSBpbWFnZSB0byBmaXQgaW5zaWRlIHBhcmVudCBlbGVtZW50XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgc2NhbGVUb0ZpdDogZnVuY3Rpb24gKGR1cmF0aW9uKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICBjdXJyZW50ID0gc2VsZi5jdXJyZW50LFxyXG4gICAgICAgICRjb250ZW50ID0gY3VycmVudC4kY29udGVudCxcclxuICAgICAgICBlbmQ7XHJcblxyXG4gICAgICBpZiAoc2VsZi5pc0FuaW1hdGluZyB8fCBzZWxmLmlzTW92ZWQoKSB8fCAhJGNvbnRlbnQgfHwgIShjdXJyZW50LnR5cGUgPT0gXCJpbWFnZVwiICYmIGN1cnJlbnQuaXNMb2FkZWQgJiYgIWN1cnJlbnQuaGFzRXJyb3IpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZWxmLmlzQW5pbWF0aW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICQuZmFuY3lib3guc3RvcCgkY29udGVudCk7XHJcblxyXG4gICAgICBlbmQgPSBzZWxmLmdldEZpdFBvcyhjdXJyZW50KTtcclxuXHJcbiAgICAgIHNlbGYudXBkYXRlQ3Vyc29yKGVuZC53aWR0aCwgZW5kLmhlaWdodCk7XHJcblxyXG4gICAgICAkLmZhbmN5Ym94LmFuaW1hdGUoXHJcbiAgICAgICAgJGNvbnRlbnQsIHtcclxuICAgICAgICAgIHRvcDogZW5kLnRvcCxcclxuICAgICAgICAgIGxlZnQ6IGVuZC5sZWZ0LFxyXG4gICAgICAgICAgc2NhbGVYOiBlbmQud2lkdGggLyAkY29udGVudC53aWR0aCgpLFxyXG4gICAgICAgICAgc2NhbGVZOiBlbmQuaGVpZ2h0IC8gJGNvbnRlbnQuaGVpZ2h0KClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGR1cmF0aW9uIHx8IDM2NixcclxuICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBzZWxmLmlzQW5pbWF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgaW1hZ2Ugc2l6ZSB0byBmaXQgaW5zaWRlIHZpZXdwb3J0XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgZ2V0Rml0UG9zOiBmdW5jdGlvbiAoc2xpZGUpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICRjb250ZW50ID0gc2xpZGUuJGNvbnRlbnQsXHJcbiAgICAgICAgJHNsaWRlID0gc2xpZGUuJHNsaWRlLFxyXG4gICAgICAgIHdpZHRoID0gc2xpZGUud2lkdGggfHwgc2xpZGUub3B0cy53aWR0aCxcclxuICAgICAgICBoZWlnaHQgPSBzbGlkZS5oZWlnaHQgfHwgc2xpZGUub3B0cy5oZWlnaHQsXHJcbiAgICAgICAgbWF4V2lkdGgsXHJcbiAgICAgICAgbWF4SGVpZ2h0LFxyXG4gICAgICAgIG1pblJhdGlvLFxyXG4gICAgICAgIGFzcGVjdFJhdGlvLFxyXG4gICAgICAgIHJleiA9IHt9O1xyXG5cclxuICAgICAgaWYgKCFzbGlkZS5pc0xvYWRlZCB8fCAhJGNvbnRlbnQgfHwgISRjb250ZW50Lmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbWF4V2lkdGggPSAkLmZhbmN5Ym94LmdldFRyYW5zbGF0ZShzZWxmLiRyZWZzLnN0YWdlKS53aWR0aDtcclxuICAgICAgbWF4SGVpZ2h0ID0gJC5mYW5jeWJveC5nZXRUcmFuc2xhdGUoc2VsZi4kcmVmcy5zdGFnZSkuaGVpZ2h0O1xyXG5cclxuICAgICAgbWF4V2lkdGggLT1cclxuICAgICAgICBwYXJzZUZsb2F0KCRzbGlkZS5jc3MoXCJwYWRkaW5nTGVmdFwiKSkgK1xyXG4gICAgICAgIHBhcnNlRmxvYXQoJHNsaWRlLmNzcyhcInBhZGRpbmdSaWdodFwiKSkgK1xyXG4gICAgICAgIHBhcnNlRmxvYXQoJGNvbnRlbnQuY3NzKFwibWFyZ2luTGVmdFwiKSkgK1xyXG4gICAgICAgIHBhcnNlRmxvYXQoJGNvbnRlbnQuY3NzKFwibWFyZ2luUmlnaHRcIikpO1xyXG5cclxuICAgICAgbWF4SGVpZ2h0IC09XHJcbiAgICAgICAgcGFyc2VGbG9hdCgkc2xpZGUuY3NzKFwicGFkZGluZ1RvcFwiKSkgK1xyXG4gICAgICAgIHBhcnNlRmxvYXQoJHNsaWRlLmNzcyhcInBhZGRpbmdCb3R0b21cIikpICtcclxuICAgICAgICBwYXJzZUZsb2F0KCRjb250ZW50LmNzcyhcIm1hcmdpblRvcFwiKSkgK1xyXG4gICAgICAgIHBhcnNlRmxvYXQoJGNvbnRlbnQuY3NzKFwibWFyZ2luQm90dG9tXCIpKTtcclxuXHJcbiAgICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xyXG4gICAgICAgIHdpZHRoID0gbWF4V2lkdGg7XHJcbiAgICAgICAgaGVpZ2h0ID0gbWF4SGVpZ2h0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBtaW5SYXRpbyA9IE1hdGgubWluKDEsIG1heFdpZHRoIC8gd2lkdGgsIG1heEhlaWdodCAvIGhlaWdodCk7XHJcblxyXG4gICAgICB3aWR0aCA9IG1pblJhdGlvICogd2lkdGg7XHJcbiAgICAgIGhlaWdodCA9IG1pblJhdGlvICogaGVpZ2h0O1xyXG5cclxuICAgICAgLy8gQWRqdXN0IHdpZHRoL2hlaWdodCB0byBwcmVjaXNlbHkgZml0IGludG8gY29udGFpbmVyXHJcbiAgICAgIGlmICh3aWR0aCA+IG1heFdpZHRoIC0gMC41KSB7XHJcbiAgICAgICAgd2lkdGggPSBtYXhXaWR0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGhlaWdodCA+IG1heEhlaWdodCAtIDAuNSkge1xyXG4gICAgICAgIGhlaWdodCA9IG1heEhlaWdodDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNsaWRlLnR5cGUgPT09IFwiaW1hZ2VcIikge1xyXG4gICAgICAgIHJlei50b3AgPSBNYXRoLmZsb29yKChtYXhIZWlnaHQgLSBoZWlnaHQpICogMC41KSArIHBhcnNlRmxvYXQoJHNsaWRlLmNzcyhcInBhZGRpbmdUb3BcIikpO1xyXG4gICAgICAgIHJlei5sZWZ0ID0gTWF0aC5mbG9vcigobWF4V2lkdGggLSB3aWR0aCkgKiAwLjUpICsgcGFyc2VGbG9hdCgkc2xpZGUuY3NzKFwicGFkZGluZ0xlZnRcIikpO1xyXG4gICAgICB9IGVsc2UgaWYgKHNsaWRlLmNvbnRlbnRUeXBlID09PSBcInZpZGVvXCIpIHtcclxuICAgICAgICAvLyBGb3JjZSBhc3BlY3QgcmF0aW8gZm9yIHRoZSB2aWRlb1xyXG4gICAgICAgIC8vIFwiSSBzYXkgdGhlIHdob2xlIHdvcmxkIG11c3QgbGVhcm4gb2Ygb3VyIHBlYWNlZnVsIHdheXPigKYgYnkgZm9yY2UhXCJcclxuICAgICAgICBhc3BlY3RSYXRpbyA9IHNsaWRlLm9wdHMud2lkdGggJiYgc2xpZGUub3B0cy5oZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IHNsaWRlLm9wdHMucmF0aW8gfHwgMTYgLyA5O1xyXG5cclxuICAgICAgICBpZiAoaGVpZ2h0ID4gd2lkdGggLyBhc3BlY3RSYXRpbykge1xyXG4gICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3RSYXRpbztcclxuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoID4gaGVpZ2h0ICogYXNwZWN0UmF0aW8pIHtcclxuICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXoud2lkdGggPSB3aWR0aDtcclxuICAgICAgcmV6LmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgIHJldHVybiByZXo7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFVwZGF0ZSBjb250ZW50IHNpemUgYW5kIHBvc2l0aW9uIGZvciBhbGwgc2xpZGVzXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAkLmVhY2goc2VsZi5zbGlkZXMsIGZ1bmN0aW9uIChrZXksIHNsaWRlKSB7XHJcbiAgICAgICAgc2VsZi51cGRhdGVTbGlkZShzbGlkZSwgZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBVcGRhdGUgc2xpZGUgY29udGVudCBwb3NpdGlvbiBhbmQgc2l6ZVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICB1cGRhdGVTbGlkZTogZnVuY3Rpb24gKHNsaWRlLCBlKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAkY29udGVudCA9IHNsaWRlICYmIHNsaWRlLiRjb250ZW50LFxyXG4gICAgICAgIHdpZHRoID0gc2xpZGUud2lkdGggfHwgc2xpZGUub3B0cy53aWR0aCxcclxuICAgICAgICBoZWlnaHQgPSBzbGlkZS5oZWlnaHQgfHwgc2xpZGUub3B0cy5oZWlnaHQsXHJcbiAgICAgICAgJHNsaWRlID0gc2xpZGUuJHNsaWRlO1xyXG5cclxuICAgICAgLy8gRmlyc3QsIHByZXZlbnQgY2FwdGlvbiBvdmVybGFwLCBpZiBuZWVkZWRcclxuICAgICAgc2VsZi5hZGp1c3RDYXB0aW9uKHNsaWRlKTtcclxuXHJcbiAgICAgIC8vIFRoZW4gcmVzaXplIGNvbnRlbnQgdG8gZml0IGluc2lkZSB0aGUgc2xpZGVcclxuICAgICAgaWYgKCRjb250ZW50ICYmICh3aWR0aCB8fCBoZWlnaHQgfHwgc2xpZGUuY29udGVudFR5cGUgPT09IFwidmlkZW9cIikgJiYgIXNsaWRlLmhhc0Vycm9yKSB7XHJcbiAgICAgICAgJC5mYW5jeWJveC5zdG9wKCRjb250ZW50KTtcclxuXHJcbiAgICAgICAgJC5mYW5jeWJveC5zZXRUcmFuc2xhdGUoJGNvbnRlbnQsIHNlbGYuZ2V0Rml0UG9zKHNsaWRlKSk7XHJcblxyXG4gICAgICAgIGlmIChzbGlkZS5wb3MgPT09IHNlbGYuY3VyclBvcykge1xyXG4gICAgICAgICAgc2VsZi5pc0FuaW1hdGluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgIHNlbGYudXBkYXRlQ3Vyc29yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUaGVuIHNvbWUgYWRqdXN0bWVudHNcclxuICAgICAgc2VsZi5hZGp1c3RMYXlvdXQoc2xpZGUpO1xyXG5cclxuICAgICAgaWYgKCRzbGlkZS5sZW5ndGgpIHtcclxuICAgICAgICAkc2xpZGUudHJpZ2dlcihcInJlZnJlc2hcIik7XHJcblxyXG4gICAgICAgIGlmIChzbGlkZS5wb3MgPT09IHNlbGYuY3VyclBvcykge1xyXG4gICAgICAgICAgc2VsZi4kcmVmcy50b29sYmFyXHJcbiAgICAgICAgICAgIC5hZGQoc2VsZi4kcmVmcy5uYXZpZ2F0aW9uLmZpbmQoXCIuZmFuY3lib3gtYnV0dG9uLS1hcnJvd19yaWdodFwiKSlcclxuICAgICAgICAgICAgLnRvZ2dsZUNsYXNzKFwiY29tcGVuc2F0ZS1mb3Itc2Nyb2xsYmFyXCIsICRzbGlkZS5nZXQoMCkuc2Nyb2xsSGVpZ2h0ID4gJHNsaWRlLmdldCgwKS5jbGllbnRIZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZi50cmlnZ2VyKFwib25VcGRhdGVcIiwgc2xpZGUsIGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBIb3Jpem9udGFsbHkgY2VudGVyIHNsaWRlXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgY2VudGVyU2xpZGU6IGZ1bmN0aW9uIChkdXJhdGlvbikge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgY3VycmVudCA9IHNlbGYuY3VycmVudCxcclxuICAgICAgICAkc2xpZGUgPSBjdXJyZW50LiRzbGlkZTtcclxuXHJcbiAgICAgIGlmIChzZWxmLmlzQ2xvc2luZyB8fCAhY3VycmVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgJHNsaWRlLnNpYmxpbmdzKCkuY3NzKHtcclxuICAgICAgICB0cmFuc2Zvcm06IFwiXCIsXHJcbiAgICAgICAgb3BhY2l0eTogXCJcIlxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgICRzbGlkZVxyXG4gICAgICAgIC5wYXJlbnQoKVxyXG4gICAgICAgIC5jaGlsZHJlbigpXHJcbiAgICAgICAgLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtc2xpZGUtLXByZXZpb3VzIGZhbmN5Ym94LXNsaWRlLS1uZXh0XCIpO1xyXG5cclxuICAgICAgJC5mYW5jeWJveC5hbmltYXRlKFxyXG4gICAgICAgICRzbGlkZSwge1xyXG4gICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgIG9wYWNpdHk6IDFcclxuICAgICAgICB9LFxyXG4gICAgICAgIGR1cmF0aW9uID09PSB1bmRlZmluZWQgPyAwIDogZHVyYXRpb24sXHJcbiAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgLy8gQ2xlYW4gdXBcclxuICAgICAgICAgICRzbGlkZS5jc3Moe1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwiXCIsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IFwiXCJcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGlmICghY3VycmVudC5pc0NvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgIHNlbGYuY29tcGxldGUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGZhbHNlXHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgc2xpZGUgaXMgbW92ZWQgKHN3aXBlZClcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBpc01vdmVkOiBmdW5jdGlvbiAoc2xpZGUpIHtcclxuICAgICAgdmFyIGN1cnJlbnQgPSBzbGlkZSB8fCB0aGlzLmN1cnJlbnQsXHJcbiAgICAgICAgc2xpZGVQb3MsXHJcbiAgICAgICAgc3RhZ2VQb3M7XHJcblxyXG4gICAgICBpZiAoIWN1cnJlbnQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0YWdlUG9zID0gJC5mYW5jeWJveC5nZXRUcmFuc2xhdGUodGhpcy4kcmVmcy5zdGFnZSk7XHJcbiAgICAgIHNsaWRlUG9zID0gJC5mYW5jeWJveC5nZXRUcmFuc2xhdGUoY3VycmVudC4kc2xpZGUpO1xyXG5cclxuICAgICAgcmV0dXJuIChcclxuICAgICAgICAhY3VycmVudC4kc2xpZGUuaGFzQ2xhc3MoXCJmYW5jeWJveC1hbmltYXRlZFwiKSAmJlxyXG4gICAgICAgIChNYXRoLmFicyhzbGlkZVBvcy50b3AgLSBzdGFnZVBvcy50b3ApID4gMC41IHx8IE1hdGguYWJzKHNsaWRlUG9zLmxlZnQgLSBzdGFnZVBvcy5sZWZ0KSA+IDAuNSlcclxuICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gVXBkYXRlIGN1cnNvciBzdHlsZSBkZXBlbmRpbmcgaWYgY29udGVudCBjYW4gYmUgem9vbWVkXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICB1cGRhdGVDdXJzb3I6IGZ1bmN0aW9uIChuZXh0V2lkdGgsIG5leHRIZWlnaHQpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIGN1cnJlbnQgPSBzZWxmLmN1cnJlbnQsXHJcbiAgICAgICAgJGNvbnRhaW5lciA9IHNlbGYuJHJlZnMuY29udGFpbmVyLFxyXG4gICAgICAgIGNhblBhbixcclxuICAgICAgICBpc1pvb21hYmxlO1xyXG5cclxuICAgICAgaWYgKCFjdXJyZW50IHx8IHNlbGYuaXNDbG9zaW5nIHx8ICFzZWxmLkd1ZXN0dXJlcykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgJGNvbnRhaW5lci5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LWlzLXpvb21hYmxlIGZhbmN5Ym94LWNhbi16b29tSW4gZmFuY3lib3gtY2FuLXpvb21PdXQgZmFuY3lib3gtY2FuLXN3aXBlIGZhbmN5Ym94LWNhbi1wYW5cIik7XHJcblxyXG4gICAgICBjYW5QYW4gPSBzZWxmLmNhblBhbihuZXh0V2lkdGgsIG5leHRIZWlnaHQpO1xyXG5cclxuICAgICAgaXNab29tYWJsZSA9IGNhblBhbiA/IHRydWUgOiBzZWxmLmlzWm9vbWFibGUoKTtcclxuXHJcbiAgICAgICRjb250YWluZXIudG9nZ2xlQ2xhc3MoXCJmYW5jeWJveC1pcy16b29tYWJsZVwiLCBpc1pvb21hYmxlKTtcclxuXHJcbiAgICAgICQoXCJbZGF0YS1mYW5jeWJveC16b29tXVwiKS5wcm9wKFwiZGlzYWJsZWRcIiwgIWlzWm9vbWFibGUpO1xyXG5cclxuICAgICAgaWYgKGNhblBhbikge1xyXG4gICAgICAgICRjb250YWluZXIuYWRkQ2xhc3MoXCJmYW5jeWJveC1jYW4tcGFuXCIpO1xyXG4gICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgIGlzWm9vbWFibGUgJiZcclxuICAgICAgICAoY3VycmVudC5vcHRzLmNsaWNrQ29udGVudCA9PT0gXCJ6b29tXCIgfHwgKCQuaXNGdW5jdGlvbihjdXJyZW50Lm9wdHMuY2xpY2tDb250ZW50KSAmJiBjdXJyZW50Lm9wdHMuY2xpY2tDb250ZW50KGN1cnJlbnQpID09IFwiem9vbVwiKSlcclxuICAgICAgKSB7XHJcbiAgICAgICAgJGNvbnRhaW5lci5hZGRDbGFzcyhcImZhbmN5Ym94LWNhbi16b29tSW5cIik7XHJcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudC5vcHRzLnRvdWNoICYmIChjdXJyZW50Lm9wdHMudG91Y2gudmVydGljYWwgfHwgc2VsZi5ncm91cC5sZW5ndGggPiAxKSAmJiBjdXJyZW50LmNvbnRlbnRUeXBlICE9PSBcInZpZGVvXCIpIHtcclxuICAgICAgICAkY29udGFpbmVyLmFkZENsYXNzKFwiZmFuY3lib3gtY2FuLXN3aXBlXCIpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgc2xpZGUgaXMgem9vbWFibGVcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBpc1pvb21hYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICBjdXJyZW50ID0gc2VsZi5jdXJyZW50LFxyXG4gICAgICAgIGZpdFBvcztcclxuXHJcbiAgICAgIC8vIEFzc3VtZSB0aGF0IHNsaWRlIGlzIHpvb21hYmxlIGlmOlxyXG4gICAgICAvLyAgIC0gaW1hZ2UgaXMgc3RpbGwgbG9hZGluZ1xyXG4gICAgICAvLyAgIC0gYWN0dWFsIHNpemUgb2YgdGhlIGltYWdlIGlzIHNtYWxsZXIgdGhhbiBhdmFpbGFibGUgYXJlYVxyXG4gICAgICBpZiAoY3VycmVudCAmJiAhc2VsZi5pc0Nsb3NpbmcgJiYgY3VycmVudC50eXBlID09PSBcImltYWdlXCIgJiYgIWN1cnJlbnQuaGFzRXJyb3IpIHtcclxuICAgICAgICBpZiAoIWN1cnJlbnQuaXNMb2FkZWQpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZml0UG9zID0gc2VsZi5nZXRGaXRQb3MoY3VycmVudCk7XHJcblxyXG4gICAgICAgIGlmIChmaXRQb3MgJiYgKGN1cnJlbnQud2lkdGggPiBmaXRQb3Mud2lkdGggfHwgY3VycmVudC5oZWlnaHQgPiBmaXRQb3MuaGVpZ2h0KSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgaW1hZ2UgZGltZW5zaW9ucyBhcmUgc21hbGxlciB0aGFuIGFjdHVhbFxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgaXNTY2FsZWREb3duOiBmdW5jdGlvbiAobmV4dFdpZHRoLCBuZXh0SGVpZ2h0KSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICByZXogPSBmYWxzZSxcclxuICAgICAgICBjdXJyZW50ID0gc2VsZi5jdXJyZW50LFxyXG4gICAgICAgICRjb250ZW50ID0gY3VycmVudC4kY29udGVudDtcclxuXHJcbiAgICAgIGlmIChuZXh0V2lkdGggIT09IHVuZGVmaW5lZCAmJiBuZXh0SGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXogPSBuZXh0V2lkdGggPCBjdXJyZW50LndpZHRoICYmIG5leHRIZWlnaHQgPCBjdXJyZW50LmhlaWdodDtcclxuICAgICAgfSBlbHNlIGlmICgkY29udGVudCkge1xyXG4gICAgICAgIHJleiA9ICQuZmFuY3lib3guZ2V0VHJhbnNsYXRlKCRjb250ZW50KTtcclxuICAgICAgICByZXogPSByZXoud2lkdGggPCBjdXJyZW50LndpZHRoICYmIHJlei5oZWlnaHQgPCBjdXJyZW50LmhlaWdodDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlejtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgaW1hZ2UgZGltZW5zaW9ucyBleGNlZWQgcGFyZW50IGVsZW1lbnRcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgY2FuUGFuOiBmdW5jdGlvbiAobmV4dFdpZHRoLCBuZXh0SGVpZ2h0KSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICBjdXJyZW50ID0gc2VsZi5jdXJyZW50LFxyXG4gICAgICAgIHBvcyA9IG51bGwsXHJcbiAgICAgICAgcmV6ID0gZmFsc2U7XHJcblxyXG4gICAgICBpZiAoY3VycmVudC50eXBlID09PSBcImltYWdlXCIgJiYgKGN1cnJlbnQuaXNDb21wbGV0ZSB8fCAobmV4dFdpZHRoICYmIG5leHRIZWlnaHQpKSAmJiAhY3VycmVudC5oYXNFcnJvcikge1xyXG4gICAgICAgIHJleiA9IHNlbGYuZ2V0Rml0UG9zKGN1cnJlbnQpO1xyXG5cclxuICAgICAgICBpZiAobmV4dFdpZHRoICE9PSB1bmRlZmluZWQgJiYgbmV4dEhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBwb3MgPSB7XHJcbiAgICAgICAgICAgIHdpZHRoOiBuZXh0V2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogbmV4dEhlaWdodFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQuaXNDb21wbGV0ZSkge1xyXG4gICAgICAgICAgcG9zID0gJC5mYW5jeWJveC5nZXRUcmFuc2xhdGUoY3VycmVudC4kY29udGVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocG9zICYmIHJleikge1xyXG4gICAgICAgICAgcmV6ID0gTWF0aC5hYnMocG9zLndpZHRoIC0gcmV6LndpZHRoKSA+IDEuNSB8fCBNYXRoLmFicyhwb3MuaGVpZ2h0IC0gcmV6LmhlaWdodCkgPiAxLjU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmV6O1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBMb2FkIGNvbnRlbnQgaW50byB0aGUgc2xpZGVcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGxvYWRTbGlkZTogZnVuY3Rpb24gKHNsaWRlKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgICRzbGlkZSxcclxuICAgICAgICBhamF4TG9hZDtcclxuXHJcbiAgICAgIGlmIChzbGlkZS5pc0xvYWRpbmcgfHwgc2xpZGUuaXNMb2FkZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNsaWRlLmlzTG9hZGluZyA9IHRydWU7XHJcblxyXG4gICAgICBpZiAoc2VsZi50cmlnZ2VyKFwiYmVmb3JlTG9hZFwiLCBzbGlkZSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgc2xpZGUuaXNMb2FkaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdHlwZSA9IHNsaWRlLnR5cGU7XHJcbiAgICAgICRzbGlkZSA9IHNsaWRlLiRzbGlkZTtcclxuXHJcbiAgICAgICRzbGlkZVxyXG4gICAgICAgIC5vZmYoXCJyZWZyZXNoXCIpXHJcbiAgICAgICAgLnRyaWdnZXIoXCJvblJlc2V0XCIpXHJcbiAgICAgICAgLmFkZENsYXNzKHNsaWRlLm9wdHMuc2xpZGVDbGFzcyk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgY29udGVudCBkZXBlbmRpbmcgb24gdGhlIHR5cGVcclxuICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSBcImltYWdlXCI6XHJcbiAgICAgICAgICBzZWxmLnNldEltYWdlKHNsaWRlKTtcclxuXHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSBcImlmcmFtZVwiOlxyXG4gICAgICAgICAgc2VsZi5zZXRJZnJhbWUoc2xpZGUpO1xyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIFwiaHRtbFwiOlxyXG4gICAgICAgICAgc2VsZi5zZXRDb250ZW50KHNsaWRlLCBzbGlkZS5zcmMgfHwgc2xpZGUuY29udGVudCk7XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgXCJ2aWRlb1wiOlxyXG4gICAgICAgICAgc2VsZi5zZXRDb250ZW50KFxyXG4gICAgICAgICAgICBzbGlkZSxcclxuICAgICAgICAgICAgc2xpZGUub3B0cy52aWRlby50cGxcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xce1xce3NyY1xcfVxcfS9naSwgc2xpZGUuc3JjKVxyXG4gICAgICAgICAgICAucmVwbGFjZShcInt7Zm9ybWF0fX1cIiwgc2xpZGUub3B0cy52aWRlb0Zvcm1hdCB8fCBzbGlkZS5vcHRzLnZpZGVvLmZvcm1hdCB8fCBcIlwiKVxyXG4gICAgICAgICAgICAucmVwbGFjZShcInt7cG9zdGVyfX1cIiwgc2xpZGUudGh1bWIgfHwgXCJcIilcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgXCJpbmxpbmVcIjpcclxuICAgICAgICAgIGlmICgkKHNsaWRlLnNyYykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0Q29udGVudChzbGlkZSwgJChzbGlkZS5zcmMpKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0RXJyb3Ioc2xpZGUpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIFwiYWpheFwiOlxyXG4gICAgICAgICAgc2VsZi5zaG93TG9hZGluZyhzbGlkZSk7XHJcblxyXG4gICAgICAgICAgYWpheExvYWQgPSAkLmFqYXgoXHJcbiAgICAgICAgICAgICQuZXh0ZW5kKHt9LCBzbGlkZS5vcHRzLmFqYXguc2V0dGluZ3MsIHtcclxuICAgICAgICAgICAgICB1cmw6IHNsaWRlLnNyYyxcclxuICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSwgdGV4dFN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRleHRTdGF0dXMgPT09IFwic3VjY2Vzc1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgIHNlbGYuc2V0Q29udGVudChzbGlkZSwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoanFYSFIgJiYgdGV4dFN0YXR1cyAhPT0gXCJhYm9ydFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgIHNlbGYuc2V0RXJyb3Ioc2xpZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgJHNsaWRlLm9uZShcIm9uUmVzZXRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBhamF4TG9hZC5hYm9ydCgpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBzZWxmLnNldEVycm9yKHNsaWRlKTtcclxuXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFVzZSB0aHVtYm5haWwgaW1hZ2UsIGlmIHBvc3NpYmxlXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIHNldEltYWdlOiBmdW5jdGlvbiAoc2xpZGUpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIGdob3N0O1xyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgbmVlZCB0byBzaG93IGxvYWRpbmcgaWNvblxyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgJGltZyA9IHNsaWRlLiRpbWFnZTtcclxuXHJcbiAgICAgICAgaWYgKCFzZWxmLmlzQ2xvc2luZyAmJiBzbGlkZS5pc0xvYWRpbmcgJiYgKCEkaW1nIHx8ICEkaW1nLmxlbmd0aCB8fCAhJGltZ1swXS5jb21wbGV0ZSkgJiYgIXNsaWRlLmhhc0Vycm9yKSB7XHJcbiAgICAgICAgICBzZWxmLnNob3dMb2FkaW5nKHNsaWRlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIDUwKTtcclxuXHJcbiAgICAgIC8vQ2hlY2sgaWYgaW1hZ2UgaGFzIHNyY3NldFxyXG4gICAgICBzZWxmLmNoZWNrU3Jjc2V0KHNsaWRlKTtcclxuXHJcbiAgICAgIC8vIFRoaXMgd2lsbCBiZSB3cmFwcGVyIGNvbnRhaW5pbmcgYm90aCBnaG9zdCBhbmQgYWN0dWFsIGltYWdlXHJcbiAgICAgIHNsaWRlLiRjb250ZW50ID0gJCgnPGRpdiBjbGFzcz1cImZhbmN5Ym94LWNvbnRlbnRcIj48L2Rpdj4nKVxyXG4gICAgICAgIC5hZGRDbGFzcyhcImZhbmN5Ym94LWlzLWhpZGRlblwiKVxyXG4gICAgICAgIC5hcHBlbmRUbyhzbGlkZS4kc2xpZGUuYWRkQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0taW1hZ2VcIikpO1xyXG5cclxuICAgICAgLy8gSWYgd2UgaGF2ZSBhIHRodW1ibmFpbCwgd2UgY2FuIGRpc3BsYXkgaXQgd2hpbGUgYWN0dWFsIGltYWdlIGlzIGxvYWRpbmdcclxuICAgICAgLy8gVXNlcnMgd2lsbCBub3Qgc3RhcmUgYXQgYmxhY2sgc2NyZWVuIGFuZCBhY3R1YWwgaW1hZ2Ugd2lsbCBhcHBlYXIgZ3JhZHVhbGx5XHJcbiAgICAgIGlmIChzbGlkZS5vcHRzLnByZWxvYWQgIT09IGZhbHNlICYmIHNsaWRlLm9wdHMud2lkdGggJiYgc2xpZGUub3B0cy5oZWlnaHQgJiYgc2xpZGUudGh1bWIpIHtcclxuICAgICAgICBzbGlkZS53aWR0aCA9IHNsaWRlLm9wdHMud2lkdGg7XHJcbiAgICAgICAgc2xpZGUuaGVpZ2h0ID0gc2xpZGUub3B0cy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIGdob3N0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcclxuXHJcbiAgICAgICAgZ2hvc3Qub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICQodGhpcykucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgICAgc2xpZGUuJGdob3N0ID0gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBnaG9zdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBzZWxmLmFmdGVyTG9hZChzbGlkZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgc2xpZGUuJGdob3N0ID0gJChnaG9zdClcclxuICAgICAgICAgIC5hZGRDbGFzcyhcImZhbmN5Ym94LWltYWdlXCIpXHJcbiAgICAgICAgICAuYXBwZW5kVG8oc2xpZGUuJGNvbnRlbnQpXHJcbiAgICAgICAgICAuYXR0cihcInNyY1wiLCBzbGlkZS50aHVtYik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFN0YXJ0IGxvYWRpbmcgYWN0dWFsIGltYWdlXHJcbiAgICAgIHNlbGYuc2V0QmlnSW1hZ2Uoc2xpZGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBDaGVjayBpZiBpbWFnZSBoYXMgc3Jjc2V0IGFuZCBnZXQgdGhlIHNvdXJjZVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIGNoZWNrU3Jjc2V0OiBmdW5jdGlvbiAoc2xpZGUpIHtcclxuICAgICAgdmFyIHNyY3NldCA9IHNsaWRlLm9wdHMuc3Jjc2V0IHx8IHNsaWRlLm9wdHMuaW1hZ2Uuc3Jjc2V0LFxyXG4gICAgICAgIGZvdW5kLFxyXG4gICAgICAgIHRlbXAsXHJcbiAgICAgICAgcHhSYXRpbyxcclxuICAgICAgICB3aW5kb3dXaWR0aDtcclxuXHJcbiAgICAgIC8vIElmIHdlIGhhdmUgXCJzcmNzZXRcIiwgdGhlbiB3ZSBuZWVkIHRvIGZpbmQgZmlyc3QgbWF0Y2hpbmcgXCJzcmNcIiB2YWx1ZS5cclxuICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnksIGJlY2F1c2Ugd2hlbiB5b3Ugc2V0IGFuIHNyYyBhdHRyaWJ1dGUsIHRoZSBicm93c2VyIHdpbGwgcHJlbG9hZCB0aGUgaW1hZ2VcclxuICAgICAgLy8gYmVmb3JlIGFueSBqYXZhc2NyaXB0IG9yIGV2ZW4gQ1NTIGlzIGFwcGxpZWQuXHJcbiAgICAgIGlmIChzcmNzZXQpIHtcclxuICAgICAgICBweFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcclxuICAgICAgICB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoICogcHhSYXRpbztcclxuXHJcbiAgICAgICAgdGVtcCA9IHNyY3NldC5zcGxpdChcIixcIikubWFwKGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgdmFyIHJldCA9IHt9O1xyXG5cclxuICAgICAgICAgIGVsLnRyaW0oKVxyXG4gICAgICAgICAgICAuc3BsaXQoL1xccysvKVxyXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGkpIHtcclxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUludChlbC5zdWJzdHJpbmcoMCwgZWwubGVuZ3RoIC0gMSksIDEwKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAocmV0LnVybCA9IGVsKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0LnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXQucG9zdGZpeCA9IGVsW2VsLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gU29ydCBieSB2YWx1ZVxyXG4gICAgICAgIHRlbXAuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgcmV0dXJuIGEudmFsdWUgLSBiLnZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBPaywgbm93IHdlIGhhdmUgYW4gYXJyYXkgb2YgYWxsIHNyY3NldCB2YWx1ZXNcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRlbXAubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgIHZhciBlbCA9IHRlbXBbal07XHJcblxyXG4gICAgICAgICAgaWYgKChlbC5wb3N0Zml4ID09PSBcIndcIiAmJiBlbC52YWx1ZSA+PSB3aW5kb3dXaWR0aCkgfHwgKGVsLnBvc3RmaXggPT09IFwieFwiICYmIGVsLnZhbHVlID49IHB4UmF0aW8pKSB7XHJcbiAgICAgICAgICAgIGZvdW5kID0gZWw7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgbm90IGZvdW5kLCB0YWtlIHRoZSBsYXN0IG9uZVxyXG4gICAgICAgIGlmICghZm91bmQgJiYgdGVtcC5sZW5ndGgpIHtcclxuICAgICAgICAgIGZvdW5kID0gdGVtcFt0ZW1wLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICBzbGlkZS5zcmMgPSBmb3VuZC51cmw7XHJcblxyXG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBkZWZhdWx0IHdpZHRoL2hlaWdodCB2YWx1ZXMsIHdlIGNhbiBjYWxjdWxhdGUgaGVpZ2h0IGZvciBtYXRjaGluZyBzb3VyY2VcclxuICAgICAgICAgIGlmIChzbGlkZS53aWR0aCAmJiBzbGlkZS5oZWlnaHQgJiYgZm91bmQucG9zdGZpeCA9PSBcIndcIikge1xyXG4gICAgICAgICAgICBzbGlkZS5oZWlnaHQgPSAoc2xpZGUud2lkdGggLyBzbGlkZS5oZWlnaHQpICogZm91bmQudmFsdWU7XHJcbiAgICAgICAgICAgIHNsaWRlLndpZHRoID0gZm91bmQudmFsdWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc2xpZGUub3B0cy5zcmNzZXQgPSBzcmNzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIENyZWF0ZSBmdWxsLXNpemUgaW1hZ2VcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBzZXRCaWdJbWFnZTogZnVuY3Rpb24gKHNsaWRlKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpLFxyXG4gICAgICAgICRpbWcgPSAkKGltZyk7XHJcblxyXG4gICAgICBzbGlkZS4kaW1hZ2UgPSAkaW1nXHJcbiAgICAgICAgLm9uZShcImVycm9yXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHNlbGYuc2V0RXJyb3Ioc2xpZGUpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uZShcImxvYWRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgdmFyIHNpemVzO1xyXG5cclxuICAgICAgICAgIGlmICghc2xpZGUuJGdob3N0KSB7XHJcbiAgICAgICAgICAgIHNlbGYucmVzb2x2ZUltYWdlU2xpZGVTaXplKHNsaWRlLCB0aGlzLm5hdHVyYWxXaWR0aCwgdGhpcy5uYXR1cmFsSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIHNlbGYuYWZ0ZXJMb2FkKHNsaWRlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoc2VsZi5pc0Nsb3NpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChzbGlkZS5vcHRzLnNyY3NldCkge1xyXG4gICAgICAgICAgICBzaXplcyA9IHNsaWRlLm9wdHMuc2l6ZXM7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXNpemVzIHx8IHNpemVzID09PSBcImF1dG9cIikge1xyXG4gICAgICAgICAgICAgIHNpemVzID1cclxuICAgICAgICAgICAgICAgIChzbGlkZS53aWR0aCAvIHNsaWRlLmhlaWdodCA+IDEgJiYgJFcud2lkdGgoKSAvICRXLmhlaWdodCgpID4gMSA/IFwiMTAwXCIgOiBNYXRoLnJvdW5kKChzbGlkZS53aWR0aCAvIHNsaWRlLmhlaWdodCkgKiAxMDApKSArXHJcbiAgICAgICAgICAgICAgICBcInZ3XCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICRpbWcuYXR0cihcInNpemVzXCIsIHNpemVzKS5hdHRyKFwic3Jjc2V0XCIsIHNsaWRlLm9wdHMuc3Jjc2V0KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBIaWRlIHRlbXBvcmFyeSBpbWFnZSBhZnRlciBzb21lIGRlbGF5XHJcbiAgICAgICAgICBpZiAoc2xpZGUuJGdob3N0KSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIGlmIChzbGlkZS4kZ2hvc3QgJiYgIXNlbGYuaXNDbG9zaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBzbGlkZS4kZ2hvc3QuaGlkZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgTWF0aC5taW4oMzAwLCBNYXRoLm1heCgxMDAwLCBzbGlkZS5oZWlnaHQgLyAxNjAwKSkpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHNlbGYuaGlkZUxvYWRpbmcoc2xpZGUpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmFkZENsYXNzKFwiZmFuY3lib3gtaW1hZ2VcIilcclxuICAgICAgICAuYXR0cihcInNyY1wiLCBzbGlkZS5zcmMpXHJcbiAgICAgICAgLmFwcGVuZFRvKHNsaWRlLiRjb250ZW50KTtcclxuXHJcbiAgICAgIGlmICgoaW1nLmNvbXBsZXRlIHx8IGltZy5yZWFkeVN0YXRlID09IFwiY29tcGxldGVcIikgJiYgJGltZy5uYXR1cmFsV2lkdGggJiYgJGltZy5uYXR1cmFsSGVpZ2h0KSB7XHJcbiAgICAgICAgJGltZy50cmlnZ2VyKFwibG9hZFwiKTtcclxuICAgICAgfSBlbHNlIGlmIChpbWcuZXJyb3IpIHtcclxuICAgICAgICAkaW1nLnRyaWdnZXIoXCJlcnJvclwiKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBDb21wdXRlcyB0aGUgc2xpZGUgc2l6ZSBmcm9tIGltYWdlIHNpemUgYW5kIG1heFdpZHRoL21heEhlaWdodFxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICByZXNvbHZlSW1hZ2VTbGlkZVNpemU6IGZ1bmN0aW9uIChzbGlkZSwgaW1nV2lkdGgsIGltZ0hlaWdodCkge1xyXG4gICAgICB2YXIgbWF4V2lkdGggPSBwYXJzZUludChzbGlkZS5vcHRzLndpZHRoLCAxMCksXHJcbiAgICAgICAgbWF4SGVpZ2h0ID0gcGFyc2VJbnQoc2xpZGUub3B0cy5oZWlnaHQsIDEwKTtcclxuXHJcbiAgICAgIC8vIFNldHMgdGhlIGRlZmF1bHQgdmFsdWVzIGZyb20gdGhlIGltYWdlXHJcbiAgICAgIHNsaWRlLndpZHRoID0gaW1nV2lkdGg7XHJcbiAgICAgIHNsaWRlLmhlaWdodCA9IGltZ0hlaWdodDtcclxuXHJcbiAgICAgIGlmIChtYXhXaWR0aCA+IDApIHtcclxuICAgICAgICBzbGlkZS53aWR0aCA9IG1heFdpZHRoO1xyXG4gICAgICAgIHNsaWRlLmhlaWdodCA9IE1hdGguZmxvb3IoKG1heFdpZHRoICogaW1nSGVpZ2h0KSAvIGltZ1dpZHRoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG1heEhlaWdodCA+IDApIHtcclxuICAgICAgICBzbGlkZS53aWR0aCA9IE1hdGguZmxvb3IoKG1heEhlaWdodCAqIGltZ1dpZHRoKSAvIGltZ0hlaWdodCk7XHJcbiAgICAgICAgc2xpZGUuaGVpZ2h0ID0gbWF4SGVpZ2h0O1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIENyZWF0ZSBpZnJhbWUgd3JhcHBlciwgaWZyYW1lIGFuZCBiaW5kaW5nc1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgc2V0SWZyYW1lOiBmdW5jdGlvbiAoc2xpZGUpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIG9wdHMgPSBzbGlkZS5vcHRzLmlmcmFtZSxcclxuICAgICAgICAkc2xpZGUgPSBzbGlkZS4kc2xpZGUsXHJcbiAgICAgICAgJGlmcmFtZTtcclxuXHJcbiAgICAgIHNsaWRlLiRjb250ZW50ID0gJCgnPGRpdiBjbGFzcz1cImZhbmN5Ym94LWNvbnRlbnQnICsgKG9wdHMucHJlbG9hZCA/IFwiIGZhbmN5Ym94LWlzLWhpZGRlblwiIDogXCJcIikgKyAnXCI+PC9kaXY+JylcclxuICAgICAgICAuY3NzKG9wdHMuY3NzKVxyXG4gICAgICAgIC5hcHBlbmRUbygkc2xpZGUpO1xyXG5cclxuICAgICAgJHNsaWRlLmFkZENsYXNzKFwiZmFuY3lib3gtc2xpZGUtLVwiICsgc2xpZGUuY29udGVudFR5cGUpO1xyXG5cclxuICAgICAgc2xpZGUuJGlmcmFtZSA9ICRpZnJhbWUgPSAkKG9wdHMudHBsLnJlcGxhY2UoL1xce3JuZFxcfS9nLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSkpXHJcbiAgICAgICAgLmF0dHIob3B0cy5hdHRyKVxyXG4gICAgICAgIC5hcHBlbmRUbyhzbGlkZS4kY29udGVudCk7XHJcblxyXG4gICAgICBpZiAob3B0cy5wcmVsb2FkKSB7XHJcbiAgICAgICAgc2VsZi5zaG93TG9hZGluZyhzbGlkZSk7XHJcblxyXG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIGl0IGlzIG5vdCBhbHdheXMgcG9zc2libGUgdG8gZGV0ZXJtaW5lIGlmIGlmcmFtZSBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkXHJcbiAgICAgICAgLy8gKGR1ZSB0byBicm93c2VyIHNlY3VyaXR5IHBvbGljeSlcclxuXHJcbiAgICAgICAgJGlmcmFtZS5vbihcImxvYWQuZmIgZXJyb3IuZmJcIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgIHRoaXMuaXNSZWFkeSA9IDE7XHJcblxyXG4gICAgICAgICAgc2xpZGUuJHNsaWRlLnRyaWdnZXIoXCJyZWZyZXNoXCIpO1xyXG5cclxuICAgICAgICAgIHNlbGYuYWZ0ZXJMb2FkKHNsaWRlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gUmVjYWxjdWxhdGUgaWZyYW1lIGNvbnRlbnQgc2l6ZVxyXG4gICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAgICAgJHNsaWRlLm9uKFwicmVmcmVzaC5mYlwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICB2YXIgJGNvbnRlbnQgPSBzbGlkZS4kY29udGVudCxcclxuICAgICAgICAgICAgZnJhbWVXaWR0aCA9IG9wdHMuY3NzLndpZHRoLFxyXG4gICAgICAgICAgICBmcmFtZUhlaWdodCA9IG9wdHMuY3NzLmhlaWdodCxcclxuICAgICAgICAgICAgJGNvbnRlbnRzLFxyXG4gICAgICAgICAgICAkYm9keTtcclxuXHJcbiAgICAgICAgICBpZiAoJGlmcmFtZVswXS5pc1JlYWR5ICE9PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAkY29udGVudHMgPSAkaWZyYW1lLmNvbnRlbnRzKCk7XHJcbiAgICAgICAgICAgICRib2R5ID0gJGNvbnRlbnRzLmZpbmQoXCJib2R5XCIpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBjb250ZW50IGRpbWVuc2lvbnMsIGlmIGl0IGlzIGFjY2Vzc2libGVcclxuICAgICAgICAgIGlmICgkYm9keSAmJiAkYm9keS5sZW5ndGggJiYgJGJvZHkuY2hpbGRyZW4oKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gQXZvaWQgc2Nyb2xsaW5nIHRvIHRvcCAoaWYgbXVsdGlwbGUgaW5zdGFuY2VzKVxyXG4gICAgICAgICAgICAkc2xpZGUuY3NzKFwib3ZlcmZsb3dcIiwgXCJ2aXNpYmxlXCIpO1xyXG5cclxuICAgICAgICAgICAgJGNvbnRlbnQuY3NzKHtcclxuICAgICAgICAgICAgICB3aWR0aDogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgXCJtYXgtd2lkdGhcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgaGVpZ2h0OiBcIjk5OTlweFwiXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZyYW1lV2lkdGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgIGZyYW1lV2lkdGggPSBNYXRoLmNlaWwoTWF0aC5tYXgoJGJvZHlbMF0uY2xpZW50V2lkdGgsICRib2R5Lm91dGVyV2lkdGgodHJ1ZSkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgJGNvbnRlbnQuY3NzKFwid2lkdGhcIiwgZnJhbWVXaWR0aCA/IGZyYW1lV2lkdGggOiBcIlwiKS5jc3MoXCJtYXgtd2lkdGhcIiwgXCJcIik7XHJcblxyXG4gICAgICAgICAgICBpZiAoZnJhbWVIZWlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgIGZyYW1lSGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubWF4KCRib2R5WzBdLmNsaWVudEhlaWdodCwgJGJvZHkub3V0ZXJIZWlnaHQodHJ1ZSkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgJGNvbnRlbnQuY3NzKFwiaGVpZ2h0XCIsIGZyYW1lSGVpZ2h0ID8gZnJhbWVIZWlnaHQgOiBcIlwiKTtcclxuXHJcbiAgICAgICAgICAgICRzbGlkZS5jc3MoXCJvdmVyZmxvd1wiLCBcImF1dG9cIik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgJGNvbnRlbnQucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1pcy1oaWRkZW5cIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2VsZi5hZnRlckxvYWQoc2xpZGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAkaWZyYW1lLmF0dHIoXCJzcmNcIiwgc2xpZGUuc3JjKTtcclxuXHJcbiAgICAgIC8vIFJlbW92ZSBpZnJhbWUgaWYgY2xvc2luZyBvciBjaGFuZ2luZyBnYWxsZXJ5IGl0ZW1cclxuICAgICAgJHNsaWRlLm9uZShcIm9uUmVzZXRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFRoaXMgaGVscHMgSUUgbm90IHRvIHRocm93IGVycm9ycyB3aGVuIGNsb3NpbmdcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgJCh0aGlzKVxyXG4gICAgICAgICAgICAuZmluZChcImlmcmFtZVwiKVxyXG4gICAgICAgICAgICAuaGlkZSgpXHJcbiAgICAgICAgICAgIC51bmJpbmQoKVxyXG4gICAgICAgICAgICAuYXR0cihcInNyY1wiLCBcIi8vYWJvdXQ6YmxhbmtcIik7XHJcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG5cclxuICAgICAgICAkKHRoaXMpXHJcbiAgICAgICAgICAub2ZmKFwicmVmcmVzaC5mYlwiKVxyXG4gICAgICAgICAgLmVtcHR5KCk7XHJcblxyXG4gICAgICAgIHNsaWRlLmlzTG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgc2xpZGUuaXNSZXZlYWxlZCA9IGZhbHNlO1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gV3JhcCBhbmQgYXBwZW5kIGNvbnRlbnQgdG8gdGhlIHNsaWRlXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIHNldENvbnRlbnQ6IGZ1bmN0aW9uIChzbGlkZSwgY29udGVudCkge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoc2VsZi5pc0Nsb3NpbmcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGYuaGlkZUxvYWRpbmcoc2xpZGUpO1xyXG5cclxuICAgICAgaWYgKHNsaWRlLiRjb250ZW50KSB7XHJcbiAgICAgICAgJC5mYW5jeWJveC5zdG9wKHNsaWRlLiRjb250ZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2xpZGUuJHNsaWRlLmVtcHR5KCk7XHJcblxyXG4gICAgICAvLyBJZiBjb250ZW50IGlzIGEgalF1ZXJ5IG9iamVjdCwgdGhlbiBpdCB3aWxsIGJlIG1vdmVkIHRvIHRoZSBzbGlkZS5cclxuICAgICAgLy8gVGhlIHBsYWNlaG9sZGVyIGlzIGNyZWF0ZWQgc28gd2Ugd2lsbCBrbm93IHdoZXJlIHRvIHB1dCBpdCBiYWNrLlxyXG4gICAgICBpZiAoaXNRdWVyeShjb250ZW50KSAmJiBjb250ZW50LnBhcmVudCgpLmxlbmd0aCkge1xyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBjb250ZW50IGlzIG5vdCBhbHJlYWR5IG1vdmVkIHRvIGZhbmN5Qm94XHJcbiAgICAgICAgaWYgKGNvbnRlbnQuaGFzQ2xhc3MoXCJmYW5jeWJveC1jb250ZW50XCIpIHx8IGNvbnRlbnQucGFyZW50KCkuaGFzQ2xhc3MoXCJmYW5jeWJveC1jb250ZW50XCIpKSB7XHJcbiAgICAgICAgICBjb250ZW50LnBhcmVudHMoXCIuZmFuY3lib3gtc2xpZGVcIikudHJpZ2dlcihcIm9uUmVzZXRcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGVtcG9yYXJ5IGVsZW1lbnQgbWFya2luZyBvcmlnaW5hbCBwbGFjZSBvZiB0aGUgY29udGVudFxyXG4gICAgICAgIHNsaWRlLiRwbGFjZWhvbGRlciA9ICQoXCI8ZGl2PlwiKVxyXG4gICAgICAgICAgLmhpZGUoKVxyXG4gICAgICAgICAgLmluc2VydEFmdGVyKGNvbnRlbnQpO1xyXG5cclxuICAgICAgICAvLyBNYWtlIHN1cmUgY29udGVudCBpcyB2aXNpYmxlXHJcbiAgICAgICAgY29udGVudC5jc3MoXCJkaXNwbGF5XCIsIFwiaW5saW5lLWJsb2NrXCIpO1xyXG4gICAgICB9IGVsc2UgaWYgKCFzbGlkZS5oYXNFcnJvcikge1xyXG4gICAgICAgIC8vIElmIGNvbnRlbnQgaXMganVzdCBhIHBsYWluIHRleHQsIHRyeSB0byBjb252ZXJ0IGl0IHRvIGh0bWxcclxuICAgICAgICBpZiAoJC50eXBlKGNvbnRlbnQpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICBjb250ZW50ID0gJChcIjxkaXY+XCIpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJC50cmltKGNvbnRlbnQpKVxyXG4gICAgICAgICAgICAuY29udGVudHMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIFwiZmlsdGVyXCIgb3B0aW9uIGlzIHByb3ZpZGVkLCB0aGVuIGZpbHRlciBjb250ZW50XHJcbiAgICAgICAgaWYgKHNsaWRlLm9wdHMuZmlsdGVyKSB7XHJcbiAgICAgICAgICBjb250ZW50ID0gJChcIjxkaXY+XCIpXHJcbiAgICAgICAgICAgIC5odG1sKGNvbnRlbnQpXHJcbiAgICAgICAgICAgIC5maW5kKHNsaWRlLm9wdHMuZmlsdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNsaWRlLiRzbGlkZS5vbmUoXCJvblJlc2V0XCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBQYXVzZSBhbGwgaHRtbDUgdmlkZW8vYXVkaW9cclxuICAgICAgICAkKHRoaXMpXHJcbiAgICAgICAgICAuZmluZChcInZpZGVvLGF1ZGlvXCIpXHJcbiAgICAgICAgICAudHJpZ2dlcihcInBhdXNlXCIpO1xyXG5cclxuICAgICAgICAvLyBQdXQgY29udGVudCBiYWNrXHJcbiAgICAgICAgaWYgKHNsaWRlLiRwbGFjZWhvbGRlcikge1xyXG4gICAgICAgICAgc2xpZGUuJHBsYWNlaG9sZGVyLmFmdGVyKGNvbnRlbnQucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1jb250ZW50XCIpLmhpZGUoKSkucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgICAgc2xpZGUuJHBsYWNlaG9sZGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBjdXN0b20gY2xvc2UgYnV0dG9uXHJcbiAgICAgICAgaWYgKHNsaWRlLiRzbWFsbEJ0bikge1xyXG4gICAgICAgICAgc2xpZGUuJHNtYWxsQnRuLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAgIHNsaWRlLiRzbWFsbEJ0biA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgY29udGVudCBhbmQgbWFyayBzbGlkZSBhcyBub3QgbG9hZGVkXHJcbiAgICAgICAgaWYgKCFzbGlkZS5oYXNFcnJvcikge1xyXG4gICAgICAgICAgJCh0aGlzKS5lbXB0eSgpO1xyXG5cclxuICAgICAgICAgIHNsaWRlLmlzTG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICBzbGlkZS5pc1JldmVhbGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgICQoY29udGVudCkuYXBwZW5kVG8oc2xpZGUuJHNsaWRlKTtcclxuXHJcbiAgICAgIGlmICgkKGNvbnRlbnQpLmlzKFwidmlkZW8sYXVkaW9cIikpIHtcclxuICAgICAgICAkKGNvbnRlbnQpLmFkZENsYXNzKFwiZmFuY3lib3gtdmlkZW9cIik7XHJcblxyXG4gICAgICAgICQoY29udGVudCkud3JhcChcIjxkaXY+PC9kaXY+XCIpO1xyXG5cclxuICAgICAgICBzbGlkZS5jb250ZW50VHlwZSA9IFwidmlkZW9cIjtcclxuXHJcbiAgICAgICAgc2xpZGUub3B0cy53aWR0aCA9IHNsaWRlLm9wdHMud2lkdGggfHwgJChjb250ZW50KS5hdHRyKFwid2lkdGhcIik7XHJcbiAgICAgICAgc2xpZGUub3B0cy5oZWlnaHQgPSBzbGlkZS5vcHRzLmhlaWdodCB8fCAkKGNvbnRlbnQpLmF0dHIoXCJoZWlnaHRcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNsaWRlLiRjb250ZW50ID0gc2xpZGUuJHNsaWRlXHJcbiAgICAgICAgLmNoaWxkcmVuKClcclxuICAgICAgICAuZmlsdGVyKFwiZGl2LGZvcm0sbWFpbix2aWRlbyxhdWRpbyxhcnRpY2xlLC5mYW5jeWJveC1jb250ZW50XCIpXHJcbiAgICAgICAgLmZpcnN0KCk7XHJcblxyXG4gICAgICBzbGlkZS4kY29udGVudC5zaWJsaW5ncygpLmhpZGUoKTtcclxuXHJcbiAgICAgIC8vIFJlLWNoZWNrIGlmIHRoZXJlIGlzIGEgdmFsaWQgY29udGVudFxyXG4gICAgICAvLyAoaW4gc29tZSBjYXNlcywgYWpheCByZXNwb25zZSBjYW4gY29udGFpbiB2YXJpb3VzIGVsZW1lbnRzIG9yIHBsYWluIHRleHQpXHJcbiAgICAgIGlmICghc2xpZGUuJGNvbnRlbnQubGVuZ3RoKSB7XHJcbiAgICAgICAgc2xpZGUuJGNvbnRlbnQgPSBzbGlkZS4kc2xpZGVcclxuICAgICAgICAgIC53cmFwSW5uZXIoXCI8ZGl2PjwvZGl2PlwiKVxyXG4gICAgICAgICAgLmNoaWxkcmVuKClcclxuICAgICAgICAgIC5maXJzdCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzbGlkZS4kY29udGVudC5hZGRDbGFzcyhcImZhbmN5Ym94LWNvbnRlbnRcIik7XHJcblxyXG4gICAgICBzbGlkZS4kc2xpZGUuYWRkQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tXCIgKyBzbGlkZS5jb250ZW50VHlwZSk7XHJcblxyXG4gICAgICBzZWxmLmFmdGVyTG9hZChzbGlkZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIERpc3BsYXkgZXJyb3IgbWVzc2FnZVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgc2V0RXJyb3I6IGZ1bmN0aW9uIChzbGlkZSkge1xyXG4gICAgICBzbGlkZS5oYXNFcnJvciA9IHRydWU7XHJcblxyXG4gICAgICBzbGlkZS4kc2xpZGVcclxuICAgICAgICAudHJpZ2dlcihcIm9uUmVzZXRcIilcclxuICAgICAgICAucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tXCIgKyBzbGlkZS5jb250ZW50VHlwZSlcclxuICAgICAgICAuYWRkQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tZXJyb3JcIik7XHJcblxyXG4gICAgICBzbGlkZS5jb250ZW50VHlwZSA9IFwiaHRtbFwiO1xyXG5cclxuICAgICAgdGhpcy5zZXRDb250ZW50KHNsaWRlLCB0aGlzLnRyYW5zbGF0ZShzbGlkZSwgc2xpZGUub3B0cy5lcnJvclRwbCkpO1xyXG5cclxuICAgICAgaWYgKHNsaWRlLnBvcyA9PT0gdGhpcy5jdXJyUG9zKSB7XHJcbiAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFNob3cgbG9hZGluZyBpY29uIGluc2lkZSB0aGUgc2xpZGVcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBzaG93TG9hZGluZzogZnVuY3Rpb24gKHNsaWRlKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgIHNsaWRlID0gc2xpZGUgfHwgc2VsZi5jdXJyZW50O1xyXG5cclxuICAgICAgaWYgKHNsaWRlICYmICFzbGlkZS4kc3Bpbm5lcikge1xyXG4gICAgICAgIHNsaWRlLiRzcGlubmVyID0gJChzZWxmLnRyYW5zbGF0ZShzZWxmLCBzZWxmLm9wdHMuc3Bpbm5lclRwbCkpXHJcbiAgICAgICAgICAuYXBwZW5kVG8oc2xpZGUuJHNsaWRlKVxyXG4gICAgICAgICAgLmhpZGUoKVxyXG4gICAgICAgICAgLmZhZGVJbihcImZhc3RcIik7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gUmVtb3ZlIGxvYWRpbmcgaWNvbiBmcm9tIHRoZSBzbGlkZVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGhpZGVMb2FkaW5nOiBmdW5jdGlvbiAoc2xpZGUpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgc2xpZGUgPSBzbGlkZSB8fCBzZWxmLmN1cnJlbnQ7XHJcblxyXG4gICAgICBpZiAoc2xpZGUgJiYgc2xpZGUuJHNwaW5uZXIpIHtcclxuICAgICAgICBzbGlkZS4kc3Bpbm5lci5zdG9wKCkucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIGRlbGV0ZSBzbGlkZS4kc3Bpbm5lcjtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBBZGp1c3RtZW50cyBhZnRlciBzbGlkZSBjb250ZW50IGhhcyBiZWVuIGxvYWRlZFxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBhZnRlckxvYWQ6IGZ1bmN0aW9uIChzbGlkZSkge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoc2VsZi5pc0Nsb3NpbmcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNsaWRlLmlzTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICBzbGlkZS5pc0xvYWRlZCA9IHRydWU7XHJcblxyXG4gICAgICBzZWxmLnRyaWdnZXIoXCJhZnRlckxvYWRcIiwgc2xpZGUpO1xyXG5cclxuICAgICAgc2VsZi5oaWRlTG9hZGluZyhzbGlkZSk7XHJcblxyXG4gICAgICAvLyBBZGQgc21hbGwgY2xvc2UgYnV0dG9uXHJcbiAgICAgIGlmIChzbGlkZS5vcHRzLnNtYWxsQnRuICYmICghc2xpZGUuJHNtYWxsQnRuIHx8ICFzbGlkZS4kc21hbGxCdG4ubGVuZ3RoKSkge1xyXG4gICAgICAgIHNsaWRlLiRzbWFsbEJ0biA9ICQoc2VsZi50cmFuc2xhdGUoc2xpZGUsIHNsaWRlLm9wdHMuYnRuVHBsLnNtYWxsQnRuKSkuYXBwZW5kVG8oc2xpZGUuJGNvbnRlbnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEaXNhYmxlIHJpZ2h0IGNsaWNrXHJcbiAgICAgIGlmIChzbGlkZS5vcHRzLnByb3RlY3QgJiYgc2xpZGUuJGNvbnRlbnQgJiYgIXNsaWRlLmhhc0Vycm9yKSB7XHJcbiAgICAgICAgc2xpZGUuJGNvbnRlbnQub24oXCJjb250ZXh0bWVudS5mYlwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgaWYgKGUuYnV0dG9uID09IDIpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBBZGQgZmFrZSBlbGVtZW50IG9uIHRvcCBvZiB0aGUgaW1hZ2VcclxuICAgICAgICAvLyBUaGlzIG1ha2VzIGEgYml0IGhhcmRlciBmb3IgdXNlciB0byBzZWxlY3QgaW1hZ2VcclxuICAgICAgICBpZiAoc2xpZGUudHlwZSA9PT0gXCJpbWFnZVwiKSB7XHJcbiAgICAgICAgICAkKCc8ZGl2IGNsYXNzPVwiZmFuY3lib3gtc3BhY2ViYWxsXCI+PC9kaXY+JykuYXBwZW5kVG8oc2xpZGUuJGNvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZi5hZGp1c3RDYXB0aW9uKHNsaWRlKTtcclxuXHJcbiAgICAgIHNlbGYuYWRqdXN0TGF5b3V0KHNsaWRlKTtcclxuXHJcbiAgICAgIGlmIChzbGlkZS5wb3MgPT09IHNlbGYuY3VyclBvcykge1xyXG4gICAgICAgIHNlbGYudXBkYXRlQ3Vyc29yKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGYucmV2ZWFsQ29udGVudChzbGlkZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFByZXZlbnQgY2FwdGlvbiBvdmVybGFwLFxyXG4gICAgLy8gZml4IGNzcyBpbmNvbnNpc3RlbmN5IGFjcm9zcyBicm93c2Vyc1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGFkanVzdENhcHRpb246IGZ1bmN0aW9uIChzbGlkZSkge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgY3VycmVudCA9IHNsaWRlIHx8IHNlbGYuY3VycmVudCxcclxuICAgICAgICBjYXB0aW9uID0gY3VycmVudC5vcHRzLmNhcHRpb24sXHJcbiAgICAgICAgcHJldmVudE92ZXJsYXAgPSBjdXJyZW50Lm9wdHMucHJldmVudENhcHRpb25PdmVybGFwLFxyXG4gICAgICAgICRjYXB0aW9uID0gc2VsZi4kcmVmcy5jYXB0aW9uLFxyXG4gICAgICAgICRjbG9uZSxcclxuICAgICAgICBjYXB0aW9uSCA9IGZhbHNlO1xyXG5cclxuICAgICAgJGNhcHRpb24udG9nZ2xlQ2xhc3MoXCJmYW5jeWJveC1jYXB0aW9uLS1zZXBhcmF0ZVwiLCBwcmV2ZW50T3ZlcmxhcCk7XHJcblxyXG4gICAgICBpZiAocHJldmVudE92ZXJsYXAgJiYgY2FwdGlvbiAmJiBjYXB0aW9uLmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChjdXJyZW50LnBvcyAhPT0gc2VsZi5jdXJyUG9zKSB7XHJcbiAgICAgICAgICAkY2xvbmUgPSAkY2FwdGlvbi5jbG9uZSgpLmFwcGVuZFRvKCRjYXB0aW9uLnBhcmVudCgpKTtcclxuXHJcbiAgICAgICAgICAkY2xvbmVcclxuICAgICAgICAgICAgLmNoaWxkcmVuKClcclxuICAgICAgICAgICAgLmVxKDApXHJcbiAgICAgICAgICAgIC5lbXB0eSgpXHJcbiAgICAgICAgICAgIC5odG1sKGNhcHRpb24pO1xyXG5cclxuICAgICAgICAgIGNhcHRpb25IID0gJGNsb25lLm91dGVySGVpZ2h0KHRydWUpO1xyXG5cclxuICAgICAgICAgICRjbG9uZS5lbXB0eSgpLnJlbW92ZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZi4kY2FwdGlvbikge1xyXG4gICAgICAgICAgY2FwdGlvbkggPSBzZWxmLiRjYXB0aW9uLm91dGVySGVpZ2h0KHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3VycmVudC4kc2xpZGUuY3NzKFwicGFkZGluZy1ib3R0b21cIiwgY2FwdGlvbkggfHwgXCJcIik7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gU2ltcGxlIGhhY2sgdG8gZml4IGluY29uc2lzdGVuY3kgYWNyb3NzIGJyb3dzZXJzLCBkZXNjcmliZWQgaGVyZSAoYWZmZWN0cyBFZGdlLCB0b28pOlxyXG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzQ4NTE4XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBhZGp1c3RMYXlvdXQ6IGZ1bmN0aW9uIChzbGlkZSkge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgY3VycmVudCA9IHNsaWRlIHx8IHNlbGYuY3VycmVudCxcclxuICAgICAgICBzY3JvbGxIZWlnaHQsXHJcbiAgICAgICAgbWFyZ2luQm90dG9tLFxyXG4gICAgICAgIGlubGluZVBhZGRpbmcsXHJcbiAgICAgICAgYWN0dWFsUGFkZGluZztcclxuXHJcbiAgICAgIGlmIChjdXJyZW50LmlzTG9hZGVkICYmIGN1cnJlbnQub3B0cy5kaXNhYmxlTGF5b3V0Rml4ICE9PSB0cnVlKSB7XHJcbiAgICAgICAgY3VycmVudC4kY29udGVudC5jc3MoXCJtYXJnaW4tYm90dG9tXCIsIFwiXCIpO1xyXG5cclxuICAgICAgICAvLyBJZiB3ZSB3b3VsZCBhbHdheXMgc2V0IG1hcmdpbi1ib3R0b20gZm9yIHRoZSBjb250ZW50LFxyXG4gICAgICAgIC8vIHRoZW4gaXQgd291bGQgcG90ZW50aWFsbHkgYnJlYWsgdmVydGljYWwgYWxpZ25cclxuICAgICAgICBpZiAoY3VycmVudC4kY29udGVudC5vdXRlckhlaWdodCgpID4gY3VycmVudC4kc2xpZGUuaGVpZ2h0KCkgKyAwLjUpIHtcclxuICAgICAgICAgIGlubGluZVBhZGRpbmcgPSBjdXJyZW50LiRzbGlkZVswXS5zdHlsZVtcInBhZGRpbmctYm90dG9tXCJdO1xyXG4gICAgICAgICAgYWN0dWFsUGFkZGluZyA9IGN1cnJlbnQuJHNsaWRlLmNzcyhcInBhZGRpbmctYm90dG9tXCIpO1xyXG5cclxuICAgICAgICAgIGlmIChwYXJzZUZsb2F0KGFjdHVhbFBhZGRpbmcpID4gMCkge1xyXG4gICAgICAgICAgICBzY3JvbGxIZWlnaHQgPSBjdXJyZW50LiRzbGlkZVswXS5zY3JvbGxIZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50LiRzbGlkZS5jc3MoXCJwYWRkaW5nLWJvdHRvbVwiLCAwKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzY3JvbGxIZWlnaHQgLSBjdXJyZW50LiRzbGlkZVswXS5zY3JvbGxIZWlnaHQpIDwgMSkge1xyXG4gICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSA9IGFjdHVhbFBhZGRpbmc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnQuJHNsaWRlLmNzcyhcInBhZGRpbmctYm90dG9tXCIsIGlubGluZVBhZGRpbmcpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3VycmVudC4kY29udGVudC5jc3MoXCJtYXJnaW4tYm90dG9tXCIsIG1hcmdpbkJvdHRvbSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gTWFrZSBjb250ZW50IHZpc2libGVcclxuICAgIC8vIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCByaWdodCBhZnRlciBjb250ZW50IGhhcyBiZWVuIGxvYWRlZCBvclxyXG4gICAgLy8gdXNlciBuYXZpZ2F0ZXMgZ2FsbGVyeSBhbmQgdHJhbnNpdGlvbiBzaG91bGQgc3RhcnRcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIHJldmVhbENvbnRlbnQ6IGZ1bmN0aW9uIChzbGlkZSkge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgJHNsaWRlID0gc2xpZGUuJHNsaWRlLFxyXG4gICAgICAgIGVuZCA9IGZhbHNlLFxyXG4gICAgICAgIHN0YXJ0ID0gZmFsc2UsXHJcbiAgICAgICAgaXNNb3ZlZCA9IHNlbGYuaXNNb3ZlZChzbGlkZSksXHJcbiAgICAgICAgaXNSZXZlYWxlZCA9IHNsaWRlLmlzUmV2ZWFsZWQsXHJcbiAgICAgICAgZWZmZWN0LFxyXG4gICAgICAgIGVmZmVjdENsYXNzTmFtZSxcclxuICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICBvcGFjaXR5O1xyXG5cclxuICAgICAgc2xpZGUuaXNSZXZlYWxlZCA9IHRydWU7XHJcblxyXG4gICAgICBlZmZlY3QgPSBzbGlkZS5vcHRzW3NlbGYuZmlyc3RSdW4gPyBcImFuaW1hdGlvbkVmZmVjdFwiIDogXCJ0cmFuc2l0aW9uRWZmZWN0XCJdO1xyXG4gICAgICBkdXJhdGlvbiA9IHNsaWRlLm9wdHNbc2VsZi5maXJzdFJ1biA/IFwiYW5pbWF0aW9uRHVyYXRpb25cIiA6IFwidHJhbnNpdGlvbkR1cmF0aW9uXCJdO1xyXG5cclxuICAgICAgZHVyYXRpb24gPSBwYXJzZUludChzbGlkZS5mb3JjZWREdXJhdGlvbiA9PT0gdW5kZWZpbmVkID8gZHVyYXRpb24gOiBzbGlkZS5mb3JjZWREdXJhdGlvbiwgMTApO1xyXG5cclxuICAgICAgaWYgKGlzTW92ZWQgfHwgc2xpZGUucG9zICE9PSBzZWxmLmN1cnJQb3MgfHwgIWR1cmF0aW9uKSB7XHJcbiAgICAgICAgZWZmZWN0ID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIGNhbiB6b29tXHJcbiAgICAgIGlmIChlZmZlY3QgPT09IFwiem9vbVwiKSB7XHJcbiAgICAgICAgaWYgKHNsaWRlLnBvcyA9PT0gc2VsZi5jdXJyUG9zICYmIGR1cmF0aW9uICYmIHNsaWRlLnR5cGUgPT09IFwiaW1hZ2VcIiAmJiAhc2xpZGUuaGFzRXJyb3IgJiYgKHN0YXJ0ID0gc2VsZi5nZXRUaHVtYlBvcyhzbGlkZSkpKSB7XHJcbiAgICAgICAgICBlbmQgPSBzZWxmLmdldEZpdFBvcyhzbGlkZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGVmZmVjdCA9IFwiZmFkZVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gWm9vbSBhbmltYXRpb25cclxuICAgICAgLy8gPT09PT09PT09PT09PT1cclxuICAgICAgaWYgKGVmZmVjdCA9PT0gXCJ6b29tXCIpIHtcclxuICAgICAgICBzZWxmLmlzQW5pbWF0aW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZW5kLnNjYWxlWCA9IGVuZC53aWR0aCAvIHN0YXJ0LndpZHRoO1xyXG4gICAgICAgIGVuZC5zY2FsZVkgPSBlbmQuaGVpZ2h0IC8gc3RhcnQuaGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIGFuaW1hdGUgb3BhY2l0eVxyXG4gICAgICAgIG9wYWNpdHkgPSBzbGlkZS5vcHRzLnpvb21PcGFjaXR5O1xyXG5cclxuICAgICAgICBpZiAob3BhY2l0eSA9PSBcImF1dG9cIikge1xyXG4gICAgICAgICAgb3BhY2l0eSA9IE1hdGguYWJzKHNsaWRlLndpZHRoIC8gc2xpZGUuaGVpZ2h0IC0gc3RhcnQud2lkdGggLyBzdGFydC5oZWlnaHQpID4gMC4xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wYWNpdHkpIHtcclxuICAgICAgICAgIHN0YXJ0Lm9wYWNpdHkgPSAwLjE7XHJcbiAgICAgICAgICBlbmQub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEcmF3IGltYWdlIGF0IHN0YXJ0IHBvc2l0aW9uXHJcbiAgICAgICAgJC5mYW5jeWJveC5zZXRUcmFuc2xhdGUoc2xpZGUuJGNvbnRlbnQucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1pcy1oaWRkZW5cIiksIHN0YXJ0KTtcclxuXHJcbiAgICAgICAgZm9yY2VSZWRyYXcoc2xpZGUuJGNvbnRlbnQpO1xyXG5cclxuICAgICAgICAvLyBTdGFydCBhbmltYXRpb25cclxuICAgICAgICAkLmZhbmN5Ym94LmFuaW1hdGUoc2xpZGUuJGNvbnRlbnQsIGVuZCwgZHVyYXRpb24sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHNlbGYuaXNBbmltYXRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICBzZWxmLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZi51cGRhdGVTbGlkZShzbGlkZSk7XHJcblxyXG4gICAgICAvLyBTaW1wbHkgc2hvdyBjb250ZW50IGlmIG5vIGVmZmVjdFxyXG4gICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICBpZiAoIWVmZmVjdCkge1xyXG4gICAgICAgIHNsaWRlLiRjb250ZW50LnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtaXMtaGlkZGVuXCIpO1xyXG5cclxuICAgICAgICBpZiAoIWlzUmV2ZWFsZWQgJiYgaXNNb3ZlZCAmJiBzbGlkZS50eXBlID09PSBcImltYWdlXCIgJiYgIXNsaWRlLmhhc0Vycm9yKSB7XHJcbiAgICAgICAgICBzbGlkZS4kY29udGVudC5oaWRlKCkuZmFkZUluKFwiZmFzdFwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzbGlkZS5wb3MgPT09IHNlbGYuY3VyclBvcykge1xyXG4gICAgICAgICAgc2VsZi5jb21wbGV0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQcmVwYXJlIGZvciBDU1MgdHJhbnNpdG9uXHJcbiAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgJC5mYW5jeWJveC5zdG9wKCRzbGlkZSk7XHJcblxyXG4gICAgICAvL2VmZmVjdENsYXNzTmFtZSA9IFwiZmFuY3lib3gtYW5pbWF0ZWQgZmFuY3lib3gtc2xpZGUtLVwiICsgKHNsaWRlLnBvcyA+PSBzZWxmLnByZXZQb3MgPyBcIm5leHRcIiA6IFwicHJldmlvdXNcIikgKyBcIiBmYW5jeWJveC1meC1cIiArIGVmZmVjdDtcclxuICAgICAgZWZmZWN0Q2xhc3NOYW1lID0gXCJmYW5jeWJveC1zbGlkZS0tXCIgKyAoc2xpZGUucG9zID49IHNlbGYucHJldlBvcyA/IFwibmV4dFwiIDogXCJwcmV2aW91c1wiKSArIFwiIGZhbmN5Ym94LWFuaW1hdGVkIGZhbmN5Ym94LWZ4LVwiICsgZWZmZWN0O1xyXG5cclxuICAgICAgJHNsaWRlLmFkZENsYXNzKGVmZmVjdENsYXNzTmFtZSkucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tY3VycmVudFwiKTsgLy8uYWRkQ2xhc3MoZWZmZWN0Q2xhc3NOYW1lKTtcclxuXHJcbiAgICAgIHNsaWRlLiRjb250ZW50LnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtaXMtaGlkZGVuXCIpO1xyXG5cclxuICAgICAgLy8gRm9yY2UgcmVmbG93XHJcbiAgICAgIGZvcmNlUmVkcmF3KCRzbGlkZSk7XHJcblxyXG4gICAgICBpZiAoc2xpZGUudHlwZSAhPT0gXCJpbWFnZVwiKSB7XHJcbiAgICAgICAgc2xpZGUuJGNvbnRlbnQuaGlkZSgpLnNob3coMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICQuZmFuY3lib3guYW5pbWF0ZShcclxuICAgICAgICAkc2xpZGUsXHJcbiAgICAgICAgXCJmYW5jeWJveC1zbGlkZS0tY3VycmVudFwiLFxyXG4gICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICRzbGlkZS5yZW1vdmVDbGFzcyhlZmZlY3RDbGFzc05hbWUpLmNzcyh7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJcIixcclxuICAgICAgICAgICAgb3BhY2l0eTogXCJcIlxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaWYgKHNsaWRlLnBvcyA9PT0gc2VsZi5jdXJyUG9zKSB7XHJcbiAgICAgICAgICAgIHNlbGYuY29tcGxldGUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHRydWVcclxuICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgd2UgY2FuIGFuZCBoYXZlIHRvIHpvb20gZnJvbSB0aHVtYm5haWxcclxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgZ2V0VGh1bWJQb3M6IGZ1bmN0aW9uIChzbGlkZSkge1xyXG4gICAgICB2YXIgcmV6ID0gZmFsc2UsXHJcbiAgICAgICAgJHRodW1iID0gc2xpZGUuJHRodW1iLFxyXG4gICAgICAgIHRodW1iUG9zLFxyXG4gICAgICAgIGJ0dyxcclxuICAgICAgICBicncsXHJcbiAgICAgICAgYmJ3LFxyXG4gICAgICAgIGJsdztcclxuXHJcbiAgICAgIGlmICghJHRodW1iIHx8ICFpblZpZXdwb3J0KCR0aHVtYlswXSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRodW1iUG9zID0gJC5mYW5jeWJveC5nZXRUcmFuc2xhdGUoJHRodW1iKTtcclxuXHJcbiAgICAgIGJ0dyA9IHBhcnNlRmxvYXQoJHRodW1iLmNzcyhcImJvcmRlci10b3Atd2lkdGhcIikgfHwgMCk7XHJcbiAgICAgIGJydyA9IHBhcnNlRmxvYXQoJHRodW1iLmNzcyhcImJvcmRlci1yaWdodC13aWR0aFwiKSB8fCAwKTtcclxuICAgICAgYmJ3ID0gcGFyc2VGbG9hdCgkdGh1bWIuY3NzKFwiYm9yZGVyLWJvdHRvbS13aWR0aFwiKSB8fCAwKTtcclxuICAgICAgYmx3ID0gcGFyc2VGbG9hdCgkdGh1bWIuY3NzKFwiYm9yZGVyLWxlZnQtd2lkdGhcIikgfHwgMCk7XHJcblxyXG4gICAgICByZXogPSB7XHJcbiAgICAgICAgdG9wOiB0aHVtYlBvcy50b3AgKyBidHcsXHJcbiAgICAgICAgbGVmdDogdGh1bWJQb3MubGVmdCArIGJsdyxcclxuICAgICAgICB3aWR0aDogdGh1bWJQb3Mud2lkdGggLSBicncgLSBibHcsXHJcbiAgICAgICAgaGVpZ2h0OiB0aHVtYlBvcy5oZWlnaHQgLSBidHcgLSBiYncsXHJcbiAgICAgICAgc2NhbGVYOiAxLFxyXG4gICAgICAgIHNjYWxlWTogMVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuIHRodW1iUG9zLndpZHRoID4gMCAmJiB0aHVtYlBvcy5oZWlnaHQgPiAwID8gcmV6IDogZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEZpbmFsIGFkanVzdG1lbnRzIGFmdGVyIGN1cnJlbnQgZ2FsbGVyeSBpdGVtIGlzIG1vdmVkIHRvIHBvc2l0aW9uXHJcbiAgICAvLyBhbmQgaXRgcyBjb250ZW50IGlzIGxvYWRlZFxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIGN1cnJlbnQgPSBzZWxmLmN1cnJlbnQsXHJcbiAgICAgICAgc2xpZGVzID0ge30sXHJcbiAgICAgICAgJGVsO1xyXG5cclxuICAgICAgaWYgKHNlbGYuaXNNb3ZlZCgpIHx8ICFjdXJyZW50LmlzTG9hZGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWN1cnJlbnQuaXNDb21wbGV0ZSkge1xyXG4gICAgICAgIGN1cnJlbnQuaXNDb21wbGV0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIGN1cnJlbnQuJHNsaWRlLnNpYmxpbmdzKCkudHJpZ2dlcihcIm9uUmVzZXRcIik7XHJcblxyXG4gICAgICAgIHNlbGYucHJlbG9hZChcImlubGluZVwiKTtcclxuXHJcbiAgICAgICAgLy8gVHJpZ2dlciBhbnkgQ1NTIHRyYW5zaXRvbiBpbnNpZGUgdGhlIHNsaWRlXHJcbiAgICAgICAgZm9yY2VSZWRyYXcoY3VycmVudC4kc2xpZGUpO1xyXG5cclxuICAgICAgICBjdXJyZW50LiRzbGlkZS5hZGRDbGFzcyhcImZhbmN5Ym94LXNsaWRlLS1jb21wbGV0ZVwiKTtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHVubmVjZXNzYXJ5IHNsaWRlc1xyXG4gICAgICAgICQuZWFjaChzZWxmLnNsaWRlcywgZnVuY3Rpb24gKGtleSwgc2xpZGUpIHtcclxuICAgICAgICAgIGlmIChzbGlkZS5wb3MgPj0gc2VsZi5jdXJyUG9zIC0gMSAmJiBzbGlkZS5wb3MgPD0gc2VsZi5jdXJyUG9zICsgMSkge1xyXG4gICAgICAgICAgICBzbGlkZXNbc2xpZGUucG9zXSA9IHNsaWRlO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChzbGlkZSkge1xyXG4gICAgICAgICAgICAkLmZhbmN5Ym94LnN0b3Aoc2xpZGUuJHNsaWRlKTtcclxuXHJcbiAgICAgICAgICAgIHNsaWRlLiRzbGlkZS5vZmYoKS5yZW1vdmUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2VsZi5zbGlkZXMgPSBzbGlkZXM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGYuaXNBbmltYXRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgIHNlbGYudXBkYXRlQ3Vyc29yKCk7XHJcblxyXG4gICAgICBzZWxmLnRyaWdnZXIoXCJhZnRlclNob3dcIik7XHJcblxyXG4gICAgICAvLyBBdXRvcGxheSBmaXJzdCBodG1sNSB2aWRlby9hdWRpb1xyXG4gICAgICBpZiAoISFjdXJyZW50Lm9wdHMudmlkZW8uYXV0b1N0YXJ0KSB7XHJcbiAgICAgICAgY3VycmVudC4kc2xpZGVcclxuICAgICAgICAgIC5maW5kKFwidmlkZW8sYXVkaW9cIilcclxuICAgICAgICAgIC5maWx0ZXIoXCI6dmlzaWJsZTpmaXJzdFwiKVxyXG4gICAgICAgICAgLnRyaWdnZXIoXCJwbGF5XCIpXHJcbiAgICAgICAgICAub25lKFwiZW5kZWRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoRG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4pIHtcclxuICAgICAgICAgICAgICBEb2N1bWVudC5leGl0RnVsbHNjcmVlbigpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMud2Via2l0RXhpdEZ1bGxzY3JlZW4pIHtcclxuICAgICAgICAgICAgICB0aGlzLndlYmtpdEV4aXRGdWxsc2NyZWVuKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNlbGYubmV4dCgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRyeSB0byBmb2N1cyBvbiB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnRcclxuICAgICAgaWYgKGN1cnJlbnQub3B0cy5hdXRvRm9jdXMgJiYgY3VycmVudC5jb250ZW50VHlwZSA9PT0gXCJodG1sXCIpIHtcclxuICAgICAgICAvLyBMb29rIGZvciB0aGUgZmlyc3QgaW5wdXQgd2l0aCBhdXRvZm9jdXMgYXR0cmlidXRlXHJcbiAgICAgICAgJGVsID0gY3VycmVudC4kY29udGVudC5maW5kKFwiaW5wdXRbYXV0b2ZvY3VzXTplbmFibGVkOnZpc2libGU6Zmlyc3RcIik7XHJcblxyXG4gICAgICAgIGlmICgkZWwubGVuZ3RoKSB7XHJcbiAgICAgICAgICAkZWwudHJpZ2dlcihcImZvY3VzXCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzZWxmLmZvY3VzKG51bGwsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQXZvaWQganVtcGluZ1xyXG4gICAgICBjdXJyZW50LiRzbGlkZS5zY3JvbGxUb3AoMCkuc2Nyb2xsTGVmdCgwKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gUHJlbG9hZCBuZXh0IGFuZCBwcmV2aW91cyBzbGlkZXNcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgcHJlbG9hZDogZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIHByZXYsXHJcbiAgICAgICAgbmV4dDtcclxuXHJcbiAgICAgIGlmIChzZWxmLmdyb3VwLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5leHQgPSBzZWxmLnNsaWRlc1tzZWxmLmN1cnJQb3MgKyAxXTtcclxuICAgICAgcHJldiA9IHNlbGYuc2xpZGVzW3NlbGYuY3VyclBvcyAtIDFdO1xyXG5cclxuICAgICAgaWYgKHByZXYgJiYgcHJldi50eXBlID09PSB0eXBlKSB7XHJcbiAgICAgICAgc2VsZi5sb2FkU2xpZGUocHJldik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChuZXh0ICYmIG5leHQudHlwZSA9PT0gdHlwZSkge1xyXG4gICAgICAgIHNlbGYubG9hZFNsaWRlKG5leHQpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFRyeSB0byBmaW5kIGFuZCBmb2N1cyBvbiB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnRcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBmb2N1czogZnVuY3Rpb24gKGUsIGZpcnN0UnVuKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICBmb2N1c2FibGVTdHIgPSBbXHJcbiAgICAgICAgICBcImFbaHJlZl1cIixcclxuICAgICAgICAgIFwiYXJlYVtocmVmXVwiLFxyXG4gICAgICAgICAgJ2lucHV0Om5vdChbZGlzYWJsZWRdKTpub3QoW3R5cGU9XCJoaWRkZW5cIl0pOm5vdChbYXJpYS1oaWRkZW5dKScsXHJcbiAgICAgICAgICBcInNlbGVjdDpub3QoW2Rpc2FibGVkXSk6bm90KFthcmlhLWhpZGRlbl0pXCIsXHJcbiAgICAgICAgICBcInRleHRhcmVhOm5vdChbZGlzYWJsZWRdKTpub3QoW2FyaWEtaGlkZGVuXSlcIixcclxuICAgICAgICAgIFwiYnV0dG9uOm5vdChbZGlzYWJsZWRdKTpub3QoW2FyaWEtaGlkZGVuXSlcIixcclxuICAgICAgICAgIFwiaWZyYW1lXCIsXHJcbiAgICAgICAgICBcIm9iamVjdFwiLFxyXG4gICAgICAgICAgXCJlbWJlZFwiLFxyXG4gICAgICAgICAgXCJ2aWRlb1wiLFxyXG4gICAgICAgICAgXCJhdWRpb1wiLFxyXG4gICAgICAgICAgXCJbY29udGVudGVkaXRhYmxlXVwiLFxyXG4gICAgICAgICAgJ1t0YWJpbmRleF06bm90KFt0YWJpbmRleF49XCItXCJdKSdcclxuICAgICAgICBdLmpvaW4oXCIsXCIpLFxyXG4gICAgICAgIGZvY3VzYWJsZUl0ZW1zLFxyXG4gICAgICAgIGZvY3VzZWRJdGVtSW5kZXg7XHJcblxyXG4gICAgICBpZiAoc2VsZi5pc0Nsb3NpbmcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChlIHx8ICFzZWxmLmN1cnJlbnQgfHwgIXNlbGYuY3VycmVudC5pc0NvbXBsZXRlKSB7XHJcbiAgICAgICAgLy8gRm9jdXMgb24gYW55IGVsZW1lbnQgaW5zaWRlIGZhbmN5Ym94XHJcbiAgICAgICAgZm9jdXNhYmxlSXRlbXMgPSBzZWxmLiRyZWZzLmNvbnRhaW5lci5maW5kKFwiKjp2aXNpYmxlXCIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEZvY3VzIGluc2lkZSBjdXJyZW50IHNsaWRlXHJcbiAgICAgICAgZm9jdXNhYmxlSXRlbXMgPSBzZWxmLmN1cnJlbnQuJHNsaWRlLmZpbmQoXCIqOnZpc2libGVcIiArIChmaXJzdFJ1biA/IFwiOm5vdCguZmFuY3lib3gtY2xvc2Utc21hbGwpXCIgOiBcIlwiKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvY3VzYWJsZUl0ZW1zID0gZm9jdXNhYmxlSXRlbXMuZmlsdGVyKGZvY3VzYWJsZVN0cikuZmlsdGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJCh0aGlzKS5jc3MoXCJ2aXNpYmlsaXR5XCIpICE9PSBcImhpZGRlblwiICYmICEkKHRoaXMpLmhhc0NsYXNzKFwiZGlzYWJsZWRcIik7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKGZvY3VzYWJsZUl0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgIGZvY3VzZWRJdGVtSW5kZXggPSBmb2N1c2FibGVJdGVtcy5pbmRleChkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcclxuXHJcbiAgICAgICAgaWYgKGUgJiYgZS5zaGlmdEtleSkge1xyXG4gICAgICAgICAgLy8gQmFjayB0YWJcclxuICAgICAgICAgIGlmIChmb2N1c2VkSXRlbUluZGV4IDwgMCB8fCBmb2N1c2VkSXRlbUluZGV4ID09IDApIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgZm9jdXNhYmxlSXRlbXMuZXEoZm9jdXNhYmxlSXRlbXMubGVuZ3RoIC0gMSkudHJpZ2dlcihcImZvY3VzXCIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBPdXRzaWRlIG9yIEZvcndhcmQgdGFiXHJcbiAgICAgICAgICBpZiAoZm9jdXNlZEl0ZW1JbmRleCA8IDAgfHwgZm9jdXNlZEl0ZW1JbmRleCA9PSBmb2N1c2FibGVJdGVtcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb2N1c2FibGVJdGVtcy5lcSgwKS50cmlnZ2VyKFwiZm9jdXNcIik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlbGYuJHJlZnMuY29udGFpbmVyLnRyaWdnZXIoXCJmb2N1c1wiKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBBY3RpdmF0ZXMgY3VycmVudCBpbnN0YW5jZSAtIGJyaW5ncyBjb250YWluZXIgdG8gdGhlIGZyb250IGFuZCBlbmFibGVzIGtleWJvYXJkLFxyXG4gICAgLy8gbm90aWZpZXMgb3RoZXIgaW5zdGFuY2VzIGFib3V0IGRlYWN0aXZhdGluZ1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgYWN0aXZhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgLy8gRGVhY3RpdmF0ZSBhbGwgaW5zdGFuY2VzXHJcbiAgICAgICQoXCIuZmFuY3lib3gtY29udGFpbmVyXCIpLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpbnN0YW5jZSA9ICQodGhpcykuZGF0YShcIkZhbmN5Qm94XCIpO1xyXG5cclxuICAgICAgICAvLyBTa2lwIHNlbGYgYW5kIGNsb3NpbmcgaW5zdGFuY2VzXHJcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLmlkICE9PSBzZWxmLmlkICYmICFpbnN0YW5jZS5pc0Nsb3NpbmcpIHtcclxuICAgICAgICAgIGluc3RhbmNlLnRyaWdnZXIoXCJvbkRlYWN0aXZhdGVcIik7XHJcblxyXG4gICAgICAgICAgaW5zdGFuY2UucmVtb3ZlRXZlbnRzKCk7XHJcblxyXG4gICAgICAgICAgaW5zdGFuY2UuaXNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHNlbGYuaXNWaXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgIGlmIChzZWxmLmN1cnJlbnQgfHwgc2VsZi5pc0lkbGUpIHtcclxuICAgICAgICBzZWxmLnVwZGF0ZSgpO1xyXG5cclxuICAgICAgICBzZWxmLnVwZGF0ZUNvbnRyb2xzKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGYudHJpZ2dlcihcIm9uQWN0aXZhdGVcIik7XHJcblxyXG4gICAgICBzZWxmLmFkZEV2ZW50cygpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBTdGFydCBjbG9zaW5nIHByb2NlZHVyZVxyXG4gICAgLy8gVGhpcyB3aWxsIHN0YXJ0IFwiem9vbS1vdXRcIiBhbmltYXRpb24gaWYgbmVlZGVkIGFuZCBjbGVhbiBldmVyeXRoaW5nIHVwIGFmdGVyd2FyZHNcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGNsb3NlOiBmdW5jdGlvbiAoZSwgZCkge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgY3VycmVudCA9IHNlbGYuY3VycmVudCxcclxuICAgICAgICBlZmZlY3QsXHJcbiAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgJGNvbnRlbnQsXHJcbiAgICAgICAgZG9tUmVjdCxcclxuICAgICAgICBvcGFjaXR5LFxyXG4gICAgICAgIHN0YXJ0LFxyXG4gICAgICAgIGVuZDtcclxuXHJcbiAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYuY2xlYW5VcChlKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmIChzZWxmLmlzQ2xvc2luZykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZi5pc0Nsb3NpbmcgPSB0cnVlO1xyXG5cclxuICAgICAgLy8gSWYgYmVmb3JlQ2xvc2UgY2FsbGJhY2sgcHJldmVudHMgY2xvc2luZywgbWFrZSBzdXJlIGNvbnRlbnQgaXMgY2VudGVyZWRcclxuICAgICAgaWYgKHNlbGYudHJpZ2dlcihcImJlZm9yZUNsb3NlXCIsIGUpID09PSBmYWxzZSkge1xyXG4gICAgICAgIHNlbGYuaXNDbG9zaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHJlcXVlc3RBRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgc2VsZi51cGRhdGUoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgYWxsIGV2ZW50c1xyXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgaW5zdGFuY2VzLCB0aGV5IHdpbGwgYmUgc2V0IGFnYWluIGJ5IFwiYWN0aXZhdGVcIiBtZXRob2RcclxuICAgICAgc2VsZi5yZW1vdmVFdmVudHMoKTtcclxuXHJcbiAgICAgICRjb250ZW50ID0gY3VycmVudC4kY29udGVudDtcclxuICAgICAgZWZmZWN0ID0gY3VycmVudC5vcHRzLmFuaW1hdGlvbkVmZmVjdDtcclxuICAgICAgZHVyYXRpb24gPSAkLmlzTnVtZXJpYyhkKSA/IGQgOiBlZmZlY3QgPyBjdXJyZW50Lm9wdHMuYW5pbWF0aW9uRHVyYXRpb24gOiAwO1xyXG5cclxuICAgICAgY3VycmVudC4kc2xpZGUucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tY29tcGxldGUgZmFuY3lib3gtc2xpZGUtLW5leHQgZmFuY3lib3gtc2xpZGUtLXByZXZpb3VzIGZhbmN5Ym94LWFuaW1hdGVkXCIpO1xyXG5cclxuICAgICAgaWYgKGUgIT09IHRydWUpIHtcclxuICAgICAgICAkLmZhbmN5Ym94LnN0b3AoY3VycmVudC4kc2xpZGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVmZmVjdCA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgb3RoZXIgc2xpZGVzXHJcbiAgICAgIGN1cnJlbnQuJHNsaWRlXHJcbiAgICAgICAgLnNpYmxpbmdzKClcclxuICAgICAgICAudHJpZ2dlcihcIm9uUmVzZXRcIilcclxuICAgICAgICAucmVtb3ZlKCk7XHJcblxyXG4gICAgICAvLyBUcmlnZ2VyIGFuaW1hdGlvbnNcclxuICAgICAgaWYgKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgc2VsZi4kcmVmcy5jb250YWluZXJcclxuICAgICAgICAgIC5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LWlzLW9wZW5cIilcclxuICAgICAgICAgIC5hZGRDbGFzcyhcImZhbmN5Ym94LWlzLWNsb3NpbmdcIilcclxuICAgICAgICAgIC5jc3MoXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIsIGR1cmF0aW9uICsgXCJtc1wiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2xlYW4gdXBcclxuICAgICAgc2VsZi5oaWRlTG9hZGluZyhjdXJyZW50KTtcclxuXHJcbiAgICAgIHNlbGYuaGlkZUNvbnRyb2xzKHRydWUpO1xyXG5cclxuICAgICAgc2VsZi51cGRhdGVDdXJzb3IoKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIHBvc3NpYmxlIHRvIHpvb20tb3V0XHJcbiAgICAgIGlmIChcclxuICAgICAgICBlZmZlY3QgPT09IFwiem9vbVwiICYmXHJcbiAgICAgICAgISgkY29udGVudCAmJiBkdXJhdGlvbiAmJiBjdXJyZW50LnR5cGUgPT09IFwiaW1hZ2VcIiAmJiAhc2VsZi5pc01vdmVkKCkgJiYgIWN1cnJlbnQuaGFzRXJyb3IgJiYgKGVuZCA9IHNlbGYuZ2V0VGh1bWJQb3MoY3VycmVudCkpKVxyXG4gICAgICApIHtcclxuICAgICAgICBlZmZlY3QgPSBcImZhZGVcIjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGVmZmVjdCA9PT0gXCJ6b29tXCIpIHtcclxuICAgICAgICAkLmZhbmN5Ym94LnN0b3AoJGNvbnRlbnQpO1xyXG5cclxuICAgICAgICBkb21SZWN0ID0gJC5mYW5jeWJveC5nZXRUcmFuc2xhdGUoJGNvbnRlbnQpO1xyXG5cclxuICAgICAgICBzdGFydCA9IHtcclxuICAgICAgICAgIHRvcDogZG9tUmVjdC50b3AsXHJcbiAgICAgICAgICBsZWZ0OiBkb21SZWN0LmxlZnQsXHJcbiAgICAgICAgICBzY2FsZVg6IGRvbVJlY3Qud2lkdGggLyBlbmQud2lkdGgsXHJcbiAgICAgICAgICBzY2FsZVk6IGRvbVJlY3QuaGVpZ2h0IC8gZW5kLmhlaWdodCxcclxuICAgICAgICAgIHdpZHRoOiBlbmQud2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IGVuZC5oZWlnaHRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIGFuaW1hdGUgb3BhY2l0eVxyXG4gICAgICAgIG9wYWNpdHkgPSBjdXJyZW50Lm9wdHMuem9vbU9wYWNpdHk7XHJcblxyXG4gICAgICAgIGlmIChvcGFjaXR5ID09IFwiYXV0b1wiKSB7XHJcbiAgICAgICAgICBvcGFjaXR5ID0gTWF0aC5hYnMoY3VycmVudC53aWR0aCAvIGN1cnJlbnQuaGVpZ2h0IC0gZW5kLndpZHRoIC8gZW5kLmhlaWdodCkgPiAwLjE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3BhY2l0eSkge1xyXG4gICAgICAgICAgZW5kLm9wYWNpdHkgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJC5mYW5jeWJveC5zZXRUcmFuc2xhdGUoJGNvbnRlbnQsIHN0YXJ0KTtcclxuXHJcbiAgICAgICAgZm9yY2VSZWRyYXcoJGNvbnRlbnQpO1xyXG5cclxuICAgICAgICAkLmZhbmN5Ym94LmFuaW1hdGUoJGNvbnRlbnQsIGVuZCwgZHVyYXRpb24sIGRvbmUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGVmZmVjdCAmJiBkdXJhdGlvbikge1xyXG4gICAgICAgICQuZmFuY3lib3guYW5pbWF0ZShcclxuICAgICAgICAgIGN1cnJlbnQuJHNsaWRlLmFkZENsYXNzKFwiZmFuY3lib3gtc2xpZGUtLXByZXZpb3VzXCIpLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtc2xpZGUtLWN1cnJlbnRcIiksXHJcbiAgICAgICAgICBcImZhbmN5Ym94LWFuaW1hdGVkIGZhbmN5Ym94LWZ4LVwiICsgZWZmZWN0LFxyXG4gICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICBkb25lXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBJZiBza2lwIGFuaW1hdGlvblxyXG4gICAgICAgIGlmIChlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KGRvbmUsIGR1cmF0aW9uKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEZpbmFsIGFkanVzdG1lbnRzIGFmdGVyIHJlbW92aW5nIHRoZSBpbnN0YW5jZVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgY2xlYW5VcDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIGluc3RhbmNlLFxyXG4gICAgICAgICRmb2N1cyA9IHNlbGYuY3VycmVudC5vcHRzLiRvcmlnLFxyXG4gICAgICAgIHgsXHJcbiAgICAgICAgeTtcclxuXHJcbiAgICAgIHNlbGYuY3VycmVudC4kc2xpZGUudHJpZ2dlcihcIm9uUmVzZXRcIik7XHJcblxyXG4gICAgICBzZWxmLiRyZWZzLmNvbnRhaW5lci5lbXB0eSgpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgc2VsZi50cmlnZ2VyKFwiYWZ0ZXJDbG9zZVwiLCBlKTtcclxuXHJcbiAgICAgIC8vIFBsYWNlIGJhY2sgZm9jdXNcclxuICAgICAgaWYgKCEhc2VsZi5jdXJyZW50Lm9wdHMuYmFja0ZvY3VzKSB7XHJcbiAgICAgICAgaWYgKCEkZm9jdXMgfHwgISRmb2N1cy5sZW5ndGggfHwgISRmb2N1cy5pcyhcIjp2aXNpYmxlXCIpKSB7XHJcbiAgICAgICAgICAkZm9jdXMgPSBzZWxmLiR0cmlnZ2VyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCRmb2N1cyAmJiAkZm9jdXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICB4ID0gd2luZG93LnNjcm9sbFg7XHJcbiAgICAgICAgICB5ID0gd2luZG93LnNjcm9sbFk7XHJcblxyXG4gICAgICAgICAgJGZvY3VzLnRyaWdnZXIoXCJmb2N1c1wiKTtcclxuXHJcbiAgICAgICAgICAkKFwiaHRtbCwgYm9keVwiKVxyXG4gICAgICAgICAgICAuc2Nyb2xsVG9wKHkpXHJcbiAgICAgICAgICAgIC5zY3JvbGxMZWZ0KHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZi5jdXJyZW50ID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGFyZSBvdGhlciBpbnN0YW5jZXNcclxuICAgICAgaW5zdGFuY2UgPSAkLmZhbmN5Ym94LmdldEluc3RhbmNlKCk7XHJcblxyXG4gICAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICBpbnN0YW5jZS5hY3RpdmF0ZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICQoXCJib2R5XCIpLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtYWN0aXZlIGNvbXBlbnNhdGUtZm9yLXNjcm9sbGJhclwiKTtcclxuXHJcbiAgICAgICAgJChcIiNmYW5jeWJveC1zdHlsZS1ub3Njcm9sbFwiKS5yZW1vdmUoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBDYWxsIGNhbGxiYWNrIGFuZCB0cmlnZ2VyIGFuIGV2ZW50XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgdHJpZ2dlcjogZnVuY3Rpb24gKG5hbWUsIHNsaWRlKSB7XHJcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuICAgICAgICBzZWxmID0gdGhpcyxcclxuICAgICAgICBvYmogPSBzbGlkZSAmJiBzbGlkZS5vcHRzID8gc2xpZGUgOiBzZWxmLmN1cnJlbnQsXHJcbiAgICAgICAgcmV6O1xyXG5cclxuICAgICAgaWYgKG9iaikge1xyXG4gICAgICAgIGFyZ3MudW5zaGlmdChvYmopO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9iaiA9IHNlbGY7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFyZ3MudW5zaGlmdChzZWxmKTtcclxuXHJcbiAgICAgIGlmICgkLmlzRnVuY3Rpb24ob2JqLm9wdHNbbmFtZV0pKSB7XHJcbiAgICAgICAgcmV6ID0gb2JqLm9wdHNbbmFtZV0uYXBwbHkob2JqLCBhcmdzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJleiA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4gcmV6O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobmFtZSA9PT0gXCJhZnRlckNsb3NlXCIgfHwgIXNlbGYuJHJlZnMpIHtcclxuICAgICAgICAkRC50cmlnZ2VyKG5hbWUgKyBcIi5mYlwiLCBhcmdzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZWxmLiRyZWZzLmNvbnRhaW5lci50cmlnZ2VyKG5hbWUgKyBcIi5mYlwiLCBhcmdzKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBVcGRhdGUgaW5mb2JhciB2YWx1ZXMsIG5hdmlnYXRpb24gYnV0dG9uIHN0YXRlcyBhbmQgcmV2ZWFsIGNhcHRpb25cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIHVwZGF0ZUNvbnRyb2xzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICBjdXJyZW50ID0gc2VsZi5jdXJyZW50LFxyXG4gICAgICAgIGluZGV4ID0gY3VycmVudC5pbmRleCxcclxuICAgICAgICAkY29udGFpbmVyID0gc2VsZi4kcmVmcy5jb250YWluZXIsXHJcbiAgICAgICAgJGNhcHRpb24gPSBzZWxmLiRyZWZzLmNhcHRpb24sXHJcbiAgICAgICAgY2FwdGlvbiA9IGN1cnJlbnQub3B0cy5jYXB0aW9uO1xyXG5cclxuICAgICAgLy8gUmVjYWxjdWxhdGUgY29udGVudCBkaW1lbnNpb25zXHJcbiAgICAgIGN1cnJlbnQuJHNsaWRlLnRyaWdnZXIoXCJyZWZyZXNoXCIpO1xyXG5cclxuICAgICAgLy8gU2V0IGNhcHRpb25cclxuICAgICAgaWYgKGNhcHRpb24gJiYgY2FwdGlvbi5sZW5ndGgpIHtcclxuICAgICAgICBzZWxmLiRjYXB0aW9uID0gJGNhcHRpb247XHJcblxyXG4gICAgICAgICRjYXB0aW9uXHJcbiAgICAgICAgICAuY2hpbGRyZW4oKVxyXG4gICAgICAgICAgLmVxKDApXHJcbiAgICAgICAgICAuaHRtbChjYXB0aW9uKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZWxmLiRjYXB0aW9uID0gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFzZWxmLmhhc0hpZGRlbkNvbnRyb2xzICYmICFzZWxmLmlzSWRsZSkge1xyXG4gICAgICAgIHNlbGYuc2hvd0NvbnRyb2xzKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBpbmZvIGFuZCBuYXZpZ2F0aW9uIGVsZW1lbnRzXHJcbiAgICAgICRjb250YWluZXIuZmluZChcIltkYXRhLWZhbmN5Ym94LWNvdW50XVwiKS5odG1sKHNlbGYuZ3JvdXAubGVuZ3RoKTtcclxuICAgICAgJGNvbnRhaW5lci5maW5kKFwiW2RhdGEtZmFuY3lib3gtaW5kZXhdXCIpLmh0bWwoaW5kZXggKyAxKTtcclxuXHJcbiAgICAgICRjb250YWluZXIuZmluZChcIltkYXRhLWZhbmN5Ym94LXByZXZdXCIpLnByb3AoXCJkaXNhYmxlZFwiLCAhY3VycmVudC5vcHRzLmxvb3AgJiYgaW5kZXggPD0gMCk7XHJcbiAgICAgICRjb250YWluZXIuZmluZChcIltkYXRhLWZhbmN5Ym94LW5leHRdXCIpLnByb3AoXCJkaXNhYmxlZFwiLCAhY3VycmVudC5vcHRzLmxvb3AgJiYgaW5kZXggPj0gc2VsZi5ncm91cC5sZW5ndGggLSAxKTtcclxuXHJcbiAgICAgIGlmIChjdXJyZW50LnR5cGUgPT09IFwiaW1hZ2VcIikge1xyXG4gICAgICAgIC8vIFJlLWVuYWJsZSBidXR0b25zOyB1cGRhdGUgZG93bmxvYWQgYnV0dG9uIHNvdXJjZVxyXG4gICAgICAgICRjb250YWluZXJcclxuICAgICAgICAgIC5maW5kKFwiW2RhdGEtZmFuY3lib3gtem9vbV1cIilcclxuICAgICAgICAgIC5zaG93KClcclxuICAgICAgICAgIC5lbmQoKVxyXG4gICAgICAgICAgLmZpbmQoXCJbZGF0YS1mYW5jeWJveC1kb3dubG9hZF1cIilcclxuICAgICAgICAgIC5hdHRyKFwiaHJlZlwiLCBjdXJyZW50Lm9wdHMuaW1hZ2Uuc3JjIHx8IGN1cnJlbnQuc3JjKVxyXG4gICAgICAgICAgLnNob3coKTtcclxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50Lm9wdHMudG9vbGJhcikge1xyXG4gICAgICAgICRjb250YWluZXIuZmluZChcIltkYXRhLWZhbmN5Ym94LWRvd25sb2FkXSxbZGF0YS1mYW5jeWJveC16b29tXVwiKS5oaWRlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE1ha2Ugc3VyZSBmb2N1cyBpcyBub3Qgb24gZGlzYWJsZWQgYnV0dG9uL2VsZW1lbnRcclxuICAgICAgaWYgKCQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuaXMoXCI6aGlkZGVuLFtkaXNhYmxlZF1cIikpIHtcclxuICAgICAgICBzZWxmLiRyZWZzLmNvbnRhaW5lci50cmlnZ2VyKFwiZm9jdXNcIik7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gSGlkZSB0b29sYmFyIGFuZCBjYXB0aW9uXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBoaWRlQ29udHJvbHM6IGZ1bmN0aW9uIChhbmRDYXB0aW9uKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICBhcnIgPSBbXCJpbmZvYmFyXCIsIFwidG9vbGJhclwiLCBcIm5hdlwiXTtcclxuXHJcbiAgICAgIGlmIChhbmRDYXB0aW9uIHx8ICFzZWxmLmN1cnJlbnQub3B0cy5wcmV2ZW50Q2FwdGlvbk92ZXJsYXApIHtcclxuICAgICAgICBhcnIucHVzaChcImNhcHRpb25cIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuJHJlZnMuY29udGFpbmVyLnJlbW92ZUNsYXNzKFxyXG4gICAgICAgIGFyclxyXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgIHJldHVybiBcImZhbmN5Ym94LXNob3ctXCIgKyBpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmpvaW4oXCIgXCIpXHJcbiAgICAgICk7XHJcblxyXG4gICAgICB0aGlzLmhhc0hpZGRlbkNvbnRyb2xzID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgc2hvd0NvbnRyb2xzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICBvcHRzID0gc2VsZi5jdXJyZW50ID8gc2VsZi5jdXJyZW50Lm9wdHMgOiBzZWxmLm9wdHMsXHJcbiAgICAgICAgJGNvbnRhaW5lciA9IHNlbGYuJHJlZnMuY29udGFpbmVyO1xyXG5cclxuICAgICAgc2VsZi5oYXNIaWRkZW5Db250cm9scyA9IGZhbHNlO1xyXG4gICAgICBzZWxmLmlkbGVTZWNvbmRzQ291bnRlciA9IDA7XHJcblxyXG4gICAgICAkY29udGFpbmVyXHJcbiAgICAgICAgLnRvZ2dsZUNsYXNzKFwiZmFuY3lib3gtc2hvdy10b29sYmFyXCIsICEhKG9wdHMudG9vbGJhciAmJiBvcHRzLmJ1dHRvbnMpKVxyXG4gICAgICAgIC50b2dnbGVDbGFzcyhcImZhbmN5Ym94LXNob3ctaW5mb2JhclwiLCAhIShvcHRzLmluZm9iYXIgJiYgc2VsZi5ncm91cC5sZW5ndGggPiAxKSlcclxuICAgICAgICAudG9nZ2xlQ2xhc3MoXCJmYW5jeWJveC1zaG93LWNhcHRpb25cIiwgISFzZWxmLiRjYXB0aW9uKVxyXG4gICAgICAgIC50b2dnbGVDbGFzcyhcImZhbmN5Ym94LXNob3ctbmF2XCIsICEhKG9wdHMuYXJyb3dzICYmIHNlbGYuZ3JvdXAubGVuZ3RoID4gMSkpXHJcbiAgICAgICAgLnRvZ2dsZUNsYXNzKFwiZmFuY3lib3gtaXMtbW9kYWxcIiwgISFvcHRzLm1vZGFsKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gVG9nZ2xlIHRvb2xiYXIgYW5kIGNhcHRpb25cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgdG9nZ2xlQ29udHJvbHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHRoaXMuaGFzSGlkZGVuQ29udHJvbHMpIHtcclxuICAgICAgICB0aGlzLnNob3dDb250cm9scygpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuaGlkZUNvbnRyb2xzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgJC5mYW5jeWJveCA9IHtcclxuICAgIHZlcnNpb246IFwiMy41LjdcIixcclxuICAgIGRlZmF1bHRzOiBkZWZhdWx0cyxcclxuXHJcbiAgICAvLyBHZXQgY3VycmVudCBpbnN0YW5jZSBhbmQgZXhlY3V0ZSBhIGNvbW1hbmQuXHJcbiAgICAvL1xyXG4gICAgLy8gRXhhbXBsZXMgb2YgdXNhZ2U6XHJcbiAgICAvL1xyXG4gICAgLy8gICAkaW5zdGFuY2UgPSAkLmZhbmN5Ym94LmdldEluc3RhbmNlKCk7XHJcbiAgICAvLyAgICQuZmFuY3lib3guZ2V0SW5zdGFuY2UoKS5qdW1wVG8oIDEgKTtcclxuICAgIC8vICAgJC5mYW5jeWJveC5nZXRJbnN0YW5jZSggJ2p1bXBUbycsIDEgKTtcclxuICAgIC8vICAgJC5mYW5jeWJveC5nZXRJbnN0YW5jZSggZnVuY3Rpb24oKSB7XHJcbiAgICAvLyAgICAgICBjb25zb2xlLmluZm8oIHRoaXMuY3VyckluZGV4ICk7XHJcbiAgICAvLyAgIH0pO1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uIChjb21tYW5kKSB7XHJcbiAgICAgIHZhciBpbnN0YW5jZSA9ICQoJy5mYW5jeWJveC1jb250YWluZXI6bm90KFwiLmZhbmN5Ym94LWlzLWNsb3NpbmdcIik6bGFzdCcpLmRhdGEoXCJGYW5jeUJveFwiKSxcclxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcbiAgICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIEZhbmN5Qm94KSB7XHJcbiAgICAgICAgaWYgKCQudHlwZShjb21tYW5kKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgaW5zdGFuY2VbY29tbWFuZF0uYXBwbHkoaW5zdGFuY2UsIGFyZ3MpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoJC50eXBlKGNvbW1hbmQpID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgIGNvbW1hbmQuYXBwbHkoaW5zdGFuY2UsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2VcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBvcGVuOiBmdW5jdGlvbiAoaXRlbXMsIG9wdHMsIGluZGV4KSB7XHJcbiAgICAgIHJldHVybiBuZXcgRmFuY3lCb3goaXRlbXMsIG9wdHMsIGluZGV4KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2xvc2UgY3VycmVudCBvciBhbGwgaW5zdGFuY2VzXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBjbG9zZTogZnVuY3Rpb24gKGFsbCkge1xyXG4gICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmdldEluc3RhbmNlKCk7XHJcblxyXG4gICAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICBpbnN0YW5jZS5jbG9zZSgpO1xyXG5cclxuICAgICAgICAvLyBUcnkgdG8gZmluZCBhbmQgY2xvc2UgbmV4dCBpbnN0YW5jZVxyXG4gICAgICAgIGlmIChhbGwgPT09IHRydWUpIHtcclxuICAgICAgICAgIHRoaXMuY2xvc2UoYWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2xvc2UgYWxsIGluc3RhbmNlcyBhbmQgdW5iaW5kIGFsbCBldmVudHNcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLmNsb3NlKHRydWUpO1xyXG5cclxuICAgICAgJEQuYWRkKFwiYm9keVwiKS5vZmYoXCJjbGljay5mYi1zdGFydFwiLCBcIioqXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBUcnkgdG8gZGV0ZWN0IG1vYmlsZSBkZXZpY2VzXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgaXNNb2JpbGU6IC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxcclxuXHJcbiAgICAvLyBEZXRlY3QgaWYgJ3RyYW5zbGF0ZTNkJyBzdXBwb3J0IGlzIGF2YWlsYWJsZVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICB1c2UzZDogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcblxyXG4gICAgICByZXR1cm4gKFxyXG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICYmXHJcbiAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZGl2KSAmJlxyXG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRpdikuZ2V0UHJvcGVydHlWYWx1ZShcInRyYW5zZm9ybVwiKSAmJlxyXG4gICAgICAgICEoZG9jdW1lbnQuZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDExKVxyXG4gICAgICApO1xyXG4gICAgfSkoKSxcclxuXHJcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGN1cnJlbnQgdmlzdWFsIHN0YXRlIG9mIGFuIGVsZW1lbnRcclxuICAgIC8vIHJldHVybnMgYXJyYXlbIHRvcCwgbGVmdCwgaG9yaXpvbnRhbC1zY2FsZSwgdmVydGljYWwtc2NhbGUsIG9wYWNpdHkgXVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgZ2V0VHJhbnNsYXRlOiBmdW5jdGlvbiAoJGVsKSB7XHJcbiAgICAgIHZhciBkb21SZWN0O1xyXG5cclxuICAgICAgaWYgKCEkZWwgfHwgISRlbC5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRvbVJlY3QgPSAkZWxbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvcDogZG9tUmVjdC50b3AgfHwgMCxcclxuICAgICAgICBsZWZ0OiBkb21SZWN0LmxlZnQgfHwgMCxcclxuICAgICAgICB3aWR0aDogZG9tUmVjdC53aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IGRvbVJlY3QuaGVpZ2h0LFxyXG4gICAgICAgIG9wYWNpdHk6IHBhcnNlRmxvYXQoJGVsLmNzcyhcIm9wYWNpdHlcIikpXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFNob3J0Y3V0IGZvciBzZXR0aW5nIFwidHJhbnNsYXRlM2RcIiBwcm9wZXJ0aWVzIGZvciBlbGVtZW50XHJcbiAgICAvLyBDYW4gc2V0IGJlIHVzZWQgdG8gc2V0IG9wYWNpdHksIHRvb1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBzZXRUcmFuc2xhdGU6IGZ1bmN0aW9uICgkZWwsIHByb3BzKSB7XHJcbiAgICAgIHZhciBzdHIgPSBcIlwiLFxyXG4gICAgICAgIGNzcyA9IHt9O1xyXG5cclxuICAgICAgaWYgKCEkZWwgfHwgIXByb3BzKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocHJvcHMubGVmdCAhPT0gdW5kZWZpbmVkIHx8IHByb3BzLnRvcCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgc3RyID1cclxuICAgICAgICAgIChwcm9wcy5sZWZ0ID09PSB1bmRlZmluZWQgPyAkZWwucG9zaXRpb24oKS5sZWZ0IDogcHJvcHMubGVmdCkgK1xyXG4gICAgICAgICAgXCJweCwgXCIgK1xyXG4gICAgICAgICAgKHByb3BzLnRvcCA9PT0gdW5kZWZpbmVkID8gJGVsLnBvc2l0aW9uKCkudG9wIDogcHJvcHMudG9wKSArXHJcbiAgICAgICAgICBcInB4XCI7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnVzZTNkKSB7XHJcbiAgICAgICAgICBzdHIgPSBcInRyYW5zbGF0ZTNkKFwiICsgc3RyICsgXCIsIDBweClcIjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3RyID0gXCJ0cmFuc2xhdGUoXCIgKyBzdHIgKyBcIilcIjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwcm9wcy5zY2FsZVggIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5zY2FsZVkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHN0ciArPSBcIiBzY2FsZShcIiArIHByb3BzLnNjYWxlWCArIFwiLCBcIiArIHByb3BzLnNjYWxlWSArIFwiKVwiO1xyXG4gICAgICB9IGVsc2UgaWYgKHByb3BzLnNjYWxlWCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgc3RyICs9IFwiIHNjYWxlWChcIiArIHByb3BzLnNjYWxlWCArIFwiKVwiO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc3RyLmxlbmd0aCkge1xyXG4gICAgICAgIGNzcy50cmFuc2Zvcm0gPSBzdHI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwcm9wcy5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBjc3Mub3BhY2l0eSA9IHByb3BzLm9wYWNpdHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwcm9wcy53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY3NzLndpZHRoID0gcHJvcHMud2lkdGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwcm9wcy5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNzcy5oZWlnaHQgPSBwcm9wcy5oZWlnaHQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAkZWwuY3NzKGNzcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFNpbXBsZSBDU1MgdHJhbnNpdGlvbiBoYW5kbGVyXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uICgkZWwsIHRvLCBkdXJhdGlvbiwgY2FsbGJhY2ssIGxlYXZlQW5pbWF0aW9uTmFtZSkge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgZnJvbTtcclxuXHJcbiAgICAgIGlmICgkLmlzRnVuY3Rpb24oZHVyYXRpb24pKSB7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBkdXJhdGlvbjtcclxuICAgICAgICBkdXJhdGlvbiA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGYuc3RvcCgkZWwpO1xyXG5cclxuICAgICAgZnJvbSA9IHNlbGYuZ2V0VHJhbnNsYXRlKCRlbCk7XHJcblxyXG4gICAgICAkZWwub24odHJhbnNpdGlvbkVuZCwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAvLyBTa2lwIGV2ZW50cyBmcm9tIGNoaWxkIGVsZW1lbnRzIGFuZCB6LWluZGV4IGNoYW5nZVxyXG4gICAgICAgIGlmIChlICYmIGUub3JpZ2luYWxFdmVudCAmJiAoISRlbC5pcyhlLm9yaWdpbmFsRXZlbnQudGFyZ2V0KSB8fCBlLm9yaWdpbmFsRXZlbnQucHJvcGVydHlOYW1lID09IFwiei1pbmRleFwiKSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2VsZi5zdG9wKCRlbCk7XHJcblxyXG4gICAgICAgIGlmICgkLmlzTnVtZXJpYyhkdXJhdGlvbikpIHtcclxuICAgICAgICAgICRlbC5jc3MoXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIsIFwiXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdCh0bykpIHtcclxuICAgICAgICAgIGlmICh0by5zY2FsZVggIT09IHVuZGVmaW5lZCAmJiB0by5zY2FsZVkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzZWxmLnNldFRyYW5zbGF0ZSgkZWwsIHtcclxuICAgICAgICAgICAgICB0b3A6IHRvLnRvcCxcclxuICAgICAgICAgICAgICBsZWZ0OiB0by5sZWZ0LFxyXG4gICAgICAgICAgICAgIHdpZHRoOiBmcm9tLndpZHRoICogdG8uc2NhbGVYLFxyXG4gICAgICAgICAgICAgIGhlaWdodDogZnJvbS5oZWlnaHQgKiB0by5zY2FsZVksXHJcbiAgICAgICAgICAgICAgc2NhbGVYOiAxLFxyXG4gICAgICAgICAgICAgIHNjYWxlWTogMVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGxlYXZlQW5pbWF0aW9uTmFtZSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgJGVsLnJlbW92ZUNsYXNzKHRvKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgkLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XHJcbiAgICAgICAgICBjYWxsYmFjayhlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCQuaXNOdW1lcmljKGR1cmF0aW9uKSkge1xyXG4gICAgICAgICRlbC5jc3MoXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIsIGR1cmF0aW9uICsgXCJtc1wiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU3RhcnQgYW5pbWF0aW9uIGJ5IGNoYW5naW5nIENTUyBwcm9wZXJ0aWVzIG9yIGNsYXNzIG5hbWVcclxuICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdCh0bykpIHtcclxuICAgICAgICBpZiAodG8uc2NhbGVYICE9PSB1bmRlZmluZWQgJiYgdG8uc2NhbGVZICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGRlbGV0ZSB0by53aWR0aDtcclxuICAgICAgICAgIGRlbGV0ZSB0by5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgaWYgKCRlbC5wYXJlbnQoKS5oYXNDbGFzcyhcImZhbmN5Ym94LXNsaWRlLS1pbWFnZVwiKSkge1xyXG4gICAgICAgICAgICAkZWwucGFyZW50KCkuYWRkQ2xhc3MoXCJmYW5jeWJveC1pcy1zY2FsaW5nXCIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJC5mYW5jeWJveC5zZXRUcmFuc2xhdGUoJGVsLCB0byk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgJGVsLmFkZENsYXNzKHRvKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgYHRyYW5zaXRpb25lbmRgIGNhbGxiYWNrIGdldHMgZmlyZWRcclxuICAgICAgJGVsLmRhdGEoXHJcbiAgICAgICAgXCJ0aW1lclwiLFxyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgJGVsLnRyaWdnZXIodHJhbnNpdGlvbkVuZCk7XHJcbiAgICAgICAgfSwgZHVyYXRpb24gKyAzMylcclxuICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RvcDogZnVuY3Rpb24gKCRlbCwgY2FsbENhbGxiYWNrKSB7XHJcbiAgICAgIGlmICgkZWwgJiYgJGVsLmxlbmd0aCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCgkZWwuZGF0YShcInRpbWVyXCIpKTtcclxuXHJcbiAgICAgICAgaWYgKGNhbGxDYWxsYmFjaykge1xyXG4gICAgICAgICAgJGVsLnRyaWdnZXIodHJhbnNpdGlvbkVuZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAkZWwub2ZmKHRyYW5zaXRpb25FbmQpLmNzcyhcInRyYW5zaXRpb24tZHVyYXRpb25cIiwgXCJcIik7XHJcblxyXG4gICAgICAgICRlbC5wYXJlbnQoKS5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LWlzLXNjYWxpbmdcIik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBEZWZhdWx0IGNsaWNrIGhhbmRsZXIgZm9yIFwiZmFuY3lib3hlZFwiIGxpbmtzXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgZnVuY3Rpb24gX3J1bihlLCBvcHRzKSB7XHJcbiAgICB2YXIgaXRlbXMgPSBbXSxcclxuICAgICAgaW5kZXggPSAwLFxyXG4gICAgICAkdGFyZ2V0LFxyXG4gICAgICB2YWx1ZSxcclxuICAgICAgaW5zdGFuY2U7XHJcblxyXG4gICAgLy8gQXZvaWQgb3BlbmluZyBtdWx0aXBsZSB0aW1lc1xyXG4gICAgaWYgKGUgJiYgZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG5cclxuICAgIGlmIChlICYmIGUuZGF0YSkge1xyXG4gICAgICBvcHRzID0gbWVyZ2VPcHRzKGUuZGF0YS5vcHRpb25zLCBvcHRzKTtcclxuICAgIH1cclxuXHJcbiAgICAkdGFyZ2V0ID0gb3B0cy4kdGFyZ2V0IHx8ICQoZS5jdXJyZW50VGFyZ2V0KS50cmlnZ2VyKFwiYmx1clwiKTtcclxuICAgIGluc3RhbmNlID0gJC5mYW5jeWJveC5nZXRJbnN0YW5jZSgpO1xyXG5cclxuICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS4kdHJpZ2dlciAmJiBpbnN0YW5jZS4kdHJpZ2dlci5pcygkdGFyZ2V0KSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdHMuc2VsZWN0b3IpIHtcclxuICAgICAgaXRlbXMgPSAkKG9wdHMuc2VsZWN0b3IpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gR2V0IGFsbCByZWxhdGVkIGl0ZW1zIGFuZCBmaW5kIGluZGV4IGZvciBjbGlja2VkIG9uZVxyXG4gICAgICB2YWx1ZSA9ICR0YXJnZXQuYXR0cihcImRhdGEtZmFuY3lib3hcIikgfHwgXCJcIjtcclxuXHJcbiAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgIGl0ZW1zID0gZS5kYXRhID8gZS5kYXRhLml0ZW1zIDogW107XHJcbiAgICAgICAgaXRlbXMgPSBpdGVtcy5sZW5ndGggPyBpdGVtcy5maWx0ZXIoJ1tkYXRhLWZhbmN5Ym94PVwiJyArIHZhbHVlICsgJ1wiXScpIDogJCgnW2RhdGEtZmFuY3lib3g9XCInICsgdmFsdWUgKyAnXCJdJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaXRlbXMgPSBbJHRhcmdldF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpbmRleCA9ICQoaXRlbXMpLmluZGV4KCR0YXJnZXQpO1xyXG5cclxuICAgIC8vIFNvbWV0aW1lcyBjdXJyZW50IGl0ZW0gY2FuIG5vdCBiZSBmb3VuZFxyXG4gICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICBpbmRleCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaW5zdGFuY2UgPSAkLmZhbmN5Ym94Lm9wZW4oaXRlbXMsIG9wdHMsIGluZGV4KTtcclxuXHJcbiAgICAvLyBTYXZlIGxhc3QgYWN0aXZlIGVsZW1lbnRcclxuICAgIGluc3RhbmNlLiR0cmlnZ2VyID0gJHRhcmdldDtcclxuICB9XHJcblxyXG4gIC8vIENyZWF0ZSBhIGpRdWVyeSBwbHVnaW5cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICQuZm4uZmFuY3lib3ggPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIHNlbGVjdG9yO1xyXG5cclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgc2VsZWN0b3IgPSBvcHRpb25zLnNlbGVjdG9yIHx8IGZhbHNlO1xyXG5cclxuICAgIGlmIChzZWxlY3Rvcikge1xyXG4gICAgICAvLyBVc2UgYm9keSBlbGVtZW50IGluc3RlYWQgb2YgZG9jdW1lbnQgc28gaXQgZXhlY3V0ZXMgZmlyc3RcclxuICAgICAgJChcImJvZHlcIilcclxuICAgICAgICAub2ZmKFwiY2xpY2suZmItc3RhcnRcIiwgc2VsZWN0b3IpXHJcbiAgICAgICAgLm9uKFwiY2xpY2suZmItc3RhcnRcIiwgc2VsZWN0b3IsIHtcclxuICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcclxuICAgICAgICB9LCBfcnVuKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMub2ZmKFwiY2xpY2suZmItc3RhcnRcIikub24oXHJcbiAgICAgICAgXCJjbGljay5mYi1zdGFydFwiLCB7XHJcbiAgICAgICAgICBpdGVtczogdGhpcyxcclxuICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9ydW5cclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvLyBTZWxmIGluaXRpYWxpemluZyBwbHVnaW4gZm9yIGFsbCBlbGVtZW50cyBoYXZpbmcgYGRhdGEtZmFuY3lib3hgIGF0dHJpYnV0ZVxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICRELm9uKFwiY2xpY2suZmItc3RhcnRcIiwgXCJbZGF0YS1mYW5jeWJveF1cIiwgX3J1bik7XHJcblxyXG4gIC8vIEVuYWJsZSBcInRyaWdnZXIgZWxlbWVudHNcIlxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgJEQub24oXCJjbGljay5mYi1zdGFydFwiLCBcIltkYXRhLWZhbmN5Ym94LXRyaWdnZXJdXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAkKCdbZGF0YS1mYW5jeWJveD1cIicgKyAkKHRoaXMpLmF0dHIoXCJkYXRhLWZhbmN5Ym94LXRyaWdnZXJcIikgKyAnXCJdJylcclxuICAgICAgLmVxKCQodGhpcykuYXR0cihcImRhdGEtZmFuY3lib3gtaW5kZXhcIikgfHwgMClcclxuICAgICAgLnRyaWdnZXIoXCJjbGljay5mYi1zdGFydFwiLCB7XHJcbiAgICAgICAgJHRyaWdnZXI6ICQodGhpcylcclxuICAgICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIFRyYWNrIGZvY3VzIGV2ZW50IGZvciBiZXR0ZXIgYWNjZXNzaWJpbGl0eSBzdHlsaW5nXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGJ1dHRvblN0ciA9IFwiLmZhbmN5Ym94LWJ1dHRvblwiLFxyXG4gICAgICBmb2N1c1N0ciA9IFwiZmFuY3lib3gtZm9jdXNcIixcclxuICAgICAgJHByZXNzZWQgPSBudWxsO1xyXG5cclxuICAgICRELm9uKFwibW91c2Vkb3duIG1vdXNldXAgZm9jdXMgYmx1clwiLCBidXR0b25TdHIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIHN3aXRjaCAoZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSBcIm1vdXNlZG93blwiOlxyXG4gICAgICAgICAgJHByZXNzZWQgPSAkKHRoaXMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIm1vdXNldXBcIjpcclxuICAgICAgICAgICRwcmVzc2VkID0gbnVsbDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJmb2N1c2luXCI6XHJcbiAgICAgICAgICAkKGJ1dHRvblN0cikucmVtb3ZlQ2xhc3MoZm9jdXNTdHIpO1xyXG5cclxuICAgICAgICAgIGlmICghJCh0aGlzKS5pcygkcHJlc3NlZCkgJiYgISQodGhpcykuaXMoXCJbZGlzYWJsZWRdXCIpKSB7XHJcbiAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoZm9jdXNTdHIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImZvY3Vzb3V0XCI6XHJcbiAgICAgICAgICAkKGJ1dHRvblN0cikucmVtb3ZlQ2xhc3MoZm9jdXNTdHIpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pKCk7XHJcbn0pKHdpbmRvdywgZG9jdW1lbnQsIGpRdWVyeSk7XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vL1xyXG4vLyBNZWRpYVxyXG4vLyBBZGRzIGFkZGl0aW9uYWwgbWVkaWEgdHlwZSBzdXBwb3J0XHJcbi8vXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbihmdW5jdGlvbiAoJCkge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAvLyBPYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGZvciBlYWNoIG1lZGlhIHR5cGVcclxuICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICB5b3V0dWJlOiB7XHJcbiAgICAgIG1hdGNoZXI6IC8oeW91dHViZVxcLmNvbXx5b3V0dVxcLmJlfHlvdXR1YmVcXC1ub2Nvb2tpZVxcLmNvbSlcXC8od2F0Y2hcXD8oLiomKT92PXx2XFwvfHVcXC98ZW1iZWRcXC8/KT8odmlkZW9zZXJpZXNcXD9saXN0PSguKil8W1xcdy1dezExfXxcXD9saXN0VHlwZT0oLiopJmxpc3Q9KC4qKSkoLiopL2ksXHJcbiAgICAgIHBhcmFtczoge1xyXG4gICAgICAgIGF1dG9wbGF5OiAxLFxyXG4gICAgICAgIGF1dG9oaWRlOiAxLFxyXG4gICAgICAgIGZzOiAxLFxyXG4gICAgICAgIHJlbDogMCxcclxuICAgICAgICBoZDogMSxcclxuICAgICAgICB3bW9kZTogXCJ0cmFuc3BhcmVudFwiLFxyXG4gICAgICAgIGVuYWJsZWpzYXBpOiAxLFxyXG4gICAgICAgIGh0bWw1OiAxXHJcbiAgICAgIH0sXHJcbiAgICAgIHBhcmFtUGxhY2U6IDgsXHJcbiAgICAgIHR5cGU6IFwiaWZyYW1lXCIsXHJcbiAgICAgIHVybDogXCJodHRwczovL3d3dy55b3V0dWJlLW5vY29va2llLmNvbS9lbWJlZC8kNFwiLFxyXG4gICAgICB0aHVtYjogXCJodHRwczovL2ltZy55b3V0dWJlLmNvbS92aS8kNC9ocWRlZmF1bHQuanBnXCJcclxuICAgIH0sXHJcblxyXG4gICAgdmltZW86IHtcclxuICAgICAgbWF0Y2hlcjogL14uK3ZpbWVvLmNvbVxcLyguKlxcLyk/KFtcXGRdKykoLiopPy8sXHJcbiAgICAgIHBhcmFtczoge1xyXG4gICAgICAgIGF1dG9wbGF5OiAxLFxyXG4gICAgICAgIGhkOiAxLFxyXG4gICAgICAgIHNob3dfdGl0bGU6IDEsXHJcbiAgICAgICAgc2hvd19ieWxpbmU6IDEsXHJcbiAgICAgICAgc2hvd19wb3J0cmFpdDogMCxcclxuICAgICAgICBmdWxsc2NyZWVuOiAxXHJcbiAgICAgIH0sXHJcbiAgICAgIHBhcmFtUGxhY2U6IDMsXHJcbiAgICAgIHR5cGU6IFwiaWZyYW1lXCIsXHJcbiAgICAgIHVybDogXCIvL3BsYXllci52aW1lby5jb20vdmlkZW8vJDJcIlxyXG4gICAgfSxcclxuXHJcbiAgICBpbnN0YWdyYW06IHtcclxuICAgICAgbWF0Y2hlcjogLyhpbnN0YWdyXFwuYW18aW5zdGFncmFtXFwuY29tKVxcL3BcXC8oW2EtekEtWjAtOV9cXC1dKylcXC8/L2ksXHJcbiAgICAgIHR5cGU6IFwiaW1hZ2VcIixcclxuICAgICAgdXJsOiBcIi8vJDEvcC8kMi9tZWRpYS8/c2l6ZT1sXCJcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRXhhbXBsZXM6XHJcbiAgICAvLyBodHRwOi8vbWFwcy5nb29nbGUuY29tLz9sbD00OC44NTc5OTUsMi4yOTQyOTcmc3BuPTAuMDA3NjY2LDAuMDIxMTM2JnQ9bSZ6PTE2XHJcbiAgICAvLyBodHRwczovL3d3dy5nb29nbGUuY29tL21hcHMvQDM3Ljc4NTIwMDYsLTEyMi40MTQ2MzU1LDE0LjY1elxyXG4gICAgLy8gaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9tYXBzL0A1Mi4yMTExMTIzLDIuOTIzNzU0Miw2LjYxej9obD1lblxyXG4gICAgLy8gaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9tYXBzL3BsYWNlL0dvb2dsZXBsZXgvQDM3LjQyMjAwNDEsLTEyMi4wODMzNDk0LDE3ei9kYXRhPSE0bTUhM200ITFzMHgwOjB4NmMyOTZjNjY2MTkzNjdlMCE4bTIhM2QzNy40MjE5OTk4ITRkLTEyMi4wODQwNTcyXHJcbiAgICBnbWFwX3BsYWNlOiB7XHJcbiAgICAgIG1hdGNoZXI6IC8obWFwc1xcLik/Z29vZ2xlXFwuKFthLXpdezIsM30oXFwuW2Etel17Mn0pPylcXC8oKChtYXBzXFwvKHBsYWNlXFwvKC4qKVxcLyk/XFxAKC4qKSwoXFxkKy4/XFxkKz8peikpfChcXD9sbD0pKSguKik/L2ksXHJcbiAgICAgIHR5cGU6IFwiaWZyYW1lXCIsXHJcbiAgICAgIHVybDogZnVuY3Rpb24gKHJleikge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICBcIi8vbWFwcy5nb29nbGUuXCIgK1xyXG4gICAgICAgICAgcmV6WzJdICtcclxuICAgICAgICAgIFwiLz9sbD1cIiArXHJcbiAgICAgICAgICAocmV6WzldID8gcmV6WzldICsgXCImej1cIiArIE1hdGguZmxvb3IocmV6WzEwXSkgKyAocmV6WzEyXSA/IHJlelsxMl0ucmVwbGFjZSgvXlxcLy8sIFwiJlwiKSA6IFwiXCIpIDogcmV6WzEyXSArIFwiXCIpLnJlcGxhY2UoL1xcPy8sIFwiJlwiKSArXHJcbiAgICAgICAgICBcIiZvdXRwdXQ9XCIgK1xyXG4gICAgICAgICAgKHJlelsxMl0gJiYgcmV6WzEyXS5pbmRleE9mKFwibGF5ZXI9Y1wiKSA+IDAgPyBcInN2ZW1iZWRcIiA6IFwiZW1iZWRcIilcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEV4YW1wbGVzOlxyXG4gICAgLy8gaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9tYXBzL3NlYXJjaC9FbXBpcmUrU3RhdGUrQnVpbGRpbmcvXHJcbiAgICAvLyBodHRwczovL3d3dy5nb29nbGUuY29tL21hcHMvc2VhcmNoLz9hcGk9MSZxdWVyeT1jZW50dXJ5bGluaytmaWVsZFxyXG4gICAgLy8gaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9tYXBzL3NlYXJjaC8/YXBpPTEmcXVlcnk9NDcuNTk1MTUxOCwtMTIyLjMzMTYzOTNcclxuICAgIGdtYXBfc2VhcmNoOiB7XHJcbiAgICAgIG1hdGNoZXI6IC8obWFwc1xcLik/Z29vZ2xlXFwuKFthLXpdezIsM30oXFwuW2Etel17Mn0pPylcXC8obWFwc1xcL3NlYXJjaFxcLykoLiopL2ksXHJcbiAgICAgIHR5cGU6IFwiaWZyYW1lXCIsXHJcbiAgICAgIHVybDogZnVuY3Rpb24gKHJleikge1xyXG4gICAgICAgIHJldHVybiBcIi8vbWFwcy5nb29nbGUuXCIgKyByZXpbMl0gKyBcIi9tYXBzP3E9XCIgKyByZXpbNV0ucmVwbGFjZShcInF1ZXJ5PVwiLCBcInE9XCIpLnJlcGxhY2UoXCJhcGk9MVwiLCBcIlwiKSArIFwiJm91dHB1dD1lbWJlZFwiO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gRm9ybWF0cyBtYXRjaGluZyB1cmwgdG8gZmluYWwgZm9ybVxyXG4gIHZhciBmb3JtYXQgPSBmdW5jdGlvbiAodXJsLCByZXosIHBhcmFtcykge1xyXG4gICAgaWYgKCF1cmwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCBcIlwiO1xyXG5cclxuICAgIGlmICgkLnR5cGUocGFyYW1zKSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICBwYXJhbXMgPSAkLnBhcmFtKHBhcmFtcywgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgJC5lYWNoKHJleiwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgdXJsID0gdXJsLnJlcGxhY2UoXCIkXCIgKyBrZXksIHZhbHVlIHx8IFwiXCIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHBhcmFtcy5sZW5ndGgpIHtcclxuICAgICAgdXJsICs9ICh1cmwuaW5kZXhPZihcIj9cIikgPiAwID8gXCImXCIgOiBcIj9cIikgKyBwYXJhbXM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVybDtcclxuICB9O1xyXG5cclxuICAkKGRvY3VtZW50KS5vbihcIm9iamVjdE5lZWRzVHlwZS5mYlwiLCBmdW5jdGlvbiAoZSwgaW5zdGFuY2UsIGl0ZW0pIHtcclxuICAgIHZhciB1cmwgPSBpdGVtLnNyYyB8fCBcIlwiLFxyXG4gICAgICB0eXBlID0gZmFsc2UsXHJcbiAgICAgIG1lZGlhLFxyXG4gICAgICB0aHVtYixcclxuICAgICAgcmV6LFxyXG4gICAgICBwYXJhbXMsXHJcbiAgICAgIHVybFBhcmFtcyxcclxuICAgICAgcGFyYW1PYmosXHJcbiAgICAgIHByb3ZpZGVyO1xyXG5cclxuICAgIG1lZGlhID0gJC5leHRlbmQodHJ1ZSwge30sIGRlZmF1bHRzLCBpdGVtLm9wdHMubWVkaWEpO1xyXG5cclxuICAgIC8vIExvb2sgZm9yIGFueSBtYXRjaGluZyBtZWRpYSB0eXBlXHJcbiAgICAkLmVhY2gobWVkaWEsIGZ1bmN0aW9uIChwcm92aWRlck5hbWUsIHByb3ZpZGVyT3B0cykge1xyXG4gICAgICByZXogPSB1cmwubWF0Y2gocHJvdmlkZXJPcHRzLm1hdGNoZXIpO1xyXG5cclxuICAgICAgaWYgKCFyZXopIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHR5cGUgPSBwcm92aWRlck9wdHMudHlwZTtcclxuICAgICAgcHJvdmlkZXIgPSBwcm92aWRlck5hbWU7XHJcbiAgICAgIHBhcmFtT2JqID0ge307XHJcblxyXG4gICAgICBpZiAocHJvdmlkZXJPcHRzLnBhcmFtUGxhY2UgJiYgcmV6W3Byb3ZpZGVyT3B0cy5wYXJhbVBsYWNlXSkge1xyXG4gICAgICAgIHVybFBhcmFtcyA9IHJleltwcm92aWRlck9wdHMucGFyYW1QbGFjZV07XHJcblxyXG4gICAgICAgIGlmICh1cmxQYXJhbXNbMF0gPT0gXCI/XCIpIHtcclxuICAgICAgICAgIHVybFBhcmFtcyA9IHVybFBhcmFtcy5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB1cmxQYXJhbXMgPSB1cmxQYXJhbXMuc3BsaXQoXCImXCIpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IHVybFBhcmFtcy5sZW5ndGg7ICsrbSkge1xyXG4gICAgICAgICAgdmFyIHAgPSB1cmxQYXJhbXNbbV0uc3BsaXQoXCI9XCIsIDIpO1xyXG5cclxuICAgICAgICAgIGlmIChwLmxlbmd0aCA9PSAyKSB7XHJcbiAgICAgICAgICAgIHBhcmFtT2JqW3BbMF1dID0gZGVjb2RlVVJJQ29tcG9uZW50KHBbMV0ucmVwbGFjZSgvXFwrL2csIFwiIFwiKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBwYXJhbXMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgcHJvdmlkZXJPcHRzLnBhcmFtcywgaXRlbS5vcHRzW3Byb3ZpZGVyTmFtZV0sIHBhcmFtT2JqKTtcclxuXHJcbiAgICAgIHVybCA9XHJcbiAgICAgICAgJC50eXBlKHByb3ZpZGVyT3B0cy51cmwpID09PSBcImZ1bmN0aW9uXCIgPyBwcm92aWRlck9wdHMudXJsLmNhbGwodGhpcywgcmV6LCBwYXJhbXMsIGl0ZW0pIDogZm9ybWF0KHByb3ZpZGVyT3B0cy51cmwsIHJleiwgcGFyYW1zKTtcclxuXHJcbiAgICAgIHRodW1iID1cclxuICAgICAgICAkLnR5cGUocHJvdmlkZXJPcHRzLnRodW1iKSA9PT0gXCJmdW5jdGlvblwiID8gcHJvdmlkZXJPcHRzLnRodW1iLmNhbGwodGhpcywgcmV6LCBwYXJhbXMsIGl0ZW0pIDogZm9ybWF0KHByb3ZpZGVyT3B0cy50aHVtYiwgcmV6KTtcclxuXHJcbiAgICAgIGlmIChwcm92aWRlck5hbWUgPT09IFwieW91dHViZVwiKSB7XHJcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoLyZ0PSgoXFxkKyltKT8oXFxkKylzLywgZnVuY3Rpb24gKG1hdGNoLCBwMSwgbSwgcykge1xyXG4gICAgICAgICAgcmV0dXJuIFwiJnN0YXJ0PVwiICsgKChtID8gcGFyc2VJbnQobSwgMTApICogNjAgOiAwKSArIHBhcnNlSW50KHMsIDEwKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocHJvdmlkZXJOYW1lID09PSBcInZpbWVvXCIpIHtcclxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcIiYlMjNcIiwgXCIjXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBJZiBpdCBpcyBmb3VuZCwgdGhlbiBjaGFuZ2UgY29udGVudCB0eXBlIGFuZCB1cGRhdGUgdGhlIHVybFxyXG5cclxuICAgIGlmICh0eXBlKSB7XHJcbiAgICAgIGlmICghaXRlbS5vcHRzLnRodW1iICYmICEoaXRlbS5vcHRzLiR0aHVtYiAmJiBpdGVtLm9wdHMuJHRodW1iLmxlbmd0aCkpIHtcclxuICAgICAgICBpdGVtLm9wdHMudGh1bWIgPSB0aHVtYjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGUgPT09IFwiaWZyYW1lXCIpIHtcclxuICAgICAgICBpdGVtLm9wdHMgPSAkLmV4dGVuZCh0cnVlLCBpdGVtLm9wdHMsIHtcclxuICAgICAgICAgIGlmcmFtZToge1xyXG4gICAgICAgICAgICBwcmVsb2FkOiBmYWxzZSxcclxuICAgICAgICAgICAgYXR0cjoge1xyXG4gICAgICAgICAgICAgIHNjcm9sbGluZzogXCJub1wiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgJC5leHRlbmQoaXRlbSwge1xyXG4gICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgc3JjOiB1cmwsXHJcbiAgICAgICAgb3JpZ1NyYzogaXRlbS5zcmMsXHJcbiAgICAgICAgY29udGVudFNvdXJjZTogcHJvdmlkZXIsXHJcbiAgICAgICAgY29udGVudFR5cGU6IHR5cGUgPT09IFwiaW1hZ2VcIiA/IFwiaW1hZ2VcIiA6IHByb3ZpZGVyID09IFwiZ21hcF9wbGFjZVwiIHx8IHByb3ZpZGVyID09IFwiZ21hcF9zZWFyY2hcIiA/IFwibWFwXCIgOiBcInZpZGVvXCJcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKHVybCkge1xyXG4gICAgICBpdGVtLnR5cGUgPSBpdGVtLm9wdHMuZGVmYXVsdFR5cGU7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIExvYWQgWW91VHViZS9WaWRlbyBBUEkgb24gcmVxdWVzdCB0byBkZXRlY3Qgd2hlbiB2aWRlbyBmaW5pc2hlZCBwbGF5aW5nXHJcbiAgdmFyIFZpZGVvQVBJTG9hZGVyID0ge1xyXG4gICAgeW91dHViZToge1xyXG4gICAgICBzcmM6IFwiaHR0cHM6Ly93d3cueW91dHViZS5jb20vaWZyYW1lX2FwaVwiLFxyXG4gICAgICBjbGFzczogXCJZVFwiLFxyXG4gICAgICBsb2FkaW5nOiBmYWxzZSxcclxuICAgICAgbG9hZGVkOiBmYWxzZVxyXG4gICAgfSxcclxuXHJcbiAgICB2aW1lbzoge1xyXG4gICAgICBzcmM6IFwiaHR0cHM6Ly9wbGF5ZXIudmltZW8uY29tL2FwaS9wbGF5ZXIuanNcIixcclxuICAgICAgY2xhc3M6IFwiVmltZW9cIixcclxuICAgICAgbG9hZGluZzogZmFsc2UsXHJcbiAgICAgIGxvYWRlZDogZmFsc2VcclxuICAgIH0sXHJcblxyXG4gICAgbG9hZDogZnVuY3Rpb24gKHZlbmRvcikge1xyXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxyXG4gICAgICAgIHNjcmlwdDtcclxuXHJcbiAgICAgIGlmICh0aGlzW3ZlbmRvcl0ubG9hZGVkKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBfdGhpcy5kb25lKHZlbmRvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpc1t2ZW5kb3JdLmxvYWRpbmcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXNbdmVuZG9yXS5sb2FkaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XHJcbiAgICAgIHNjcmlwdC50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcclxuICAgICAgc2NyaXB0LnNyYyA9IHRoaXNbdmVuZG9yXS5zcmM7XHJcblxyXG4gICAgICBpZiAodmVuZG9yID09PSBcInlvdXR1YmVcIikge1xyXG4gICAgICAgIHdpbmRvdy5vbllvdVR1YmVJZnJhbWVBUElSZWFkeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIF90aGlzW3ZlbmRvcl0ubG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgIF90aGlzLmRvbmUodmVuZG9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBfdGhpc1t2ZW5kb3JdLmxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICBfdGhpcy5kb25lKHZlbmRvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xyXG4gICAgfSxcclxuICAgIGRvbmU6IGZ1bmN0aW9uICh2ZW5kb3IpIHtcclxuICAgICAgdmFyIGluc3RhbmNlLCAkZWwsIHBsYXllcjtcclxuXHJcbiAgICAgIGlmICh2ZW5kb3IgPT09IFwieW91dHViZVwiKSB7XHJcbiAgICAgICAgZGVsZXRlIHdpbmRvdy5vbllvdVR1YmVJZnJhbWVBUElSZWFkeTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaW5zdGFuY2UgPSAkLmZhbmN5Ym94LmdldEluc3RhbmNlKCk7XHJcblxyXG4gICAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAkZWwgPSBpbnN0YW5jZS5jdXJyZW50LiRjb250ZW50LmZpbmQoXCJpZnJhbWVcIik7XHJcblxyXG4gICAgICAgIGlmICh2ZW5kb3IgPT09IFwieW91dHViZVwiICYmIFlUICE9PSB1bmRlZmluZWQgJiYgWVQpIHtcclxuICAgICAgICAgIHBsYXllciA9IG5ldyBZVC5QbGF5ZXIoJGVsLmF0dHIoXCJpZFwiKSwge1xyXG4gICAgICAgICAgICBldmVudHM6IHtcclxuICAgICAgICAgICAgICBvblN0YXRlQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuZGF0YSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodmVuZG9yID09PSBcInZpbWVvXCIgJiYgVmltZW8gIT09IHVuZGVmaW5lZCAmJiBWaW1lbykge1xyXG4gICAgICAgICAgcGxheWVyID0gbmV3IFZpbWVvLlBsYXllcigkZWwpO1xyXG5cclxuICAgICAgICAgIHBsYXllci5vbihcImVuZGVkXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UubmV4dCgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgJChkb2N1bWVudCkub24oe1xyXG4gICAgXCJhZnRlclNob3cuZmJcIjogZnVuY3Rpb24gKGUsIGluc3RhbmNlLCBjdXJyZW50KSB7XHJcbiAgICAgIGlmIChpbnN0YW5jZS5ncm91cC5sZW5ndGggPiAxICYmIChjdXJyZW50LmNvbnRlbnRTb3VyY2UgPT09IFwieW91dHViZVwiIHx8IGN1cnJlbnQuY29udGVudFNvdXJjZSA9PT0gXCJ2aW1lb1wiKSkge1xyXG4gICAgICAgIFZpZGVvQVBJTG9hZGVyLmxvYWQoY3VycmVudC5jb250ZW50U291cmNlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG59KShqUXVlcnkpO1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy9cclxuLy8gR3Vlc3R1cmVzXHJcbi8vIEFkZHMgdG91Y2ggZ3Vlc3R1cmVzLCBoYW5kbGVzIGNsaWNrIGFuZCB0YXAgZXZlbnRzXHJcbi8vXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgJCkge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICB2YXIgcmVxdWVzdEFGcmFtZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAvLyBpZiBhbGwgZWxzZSBmYWlscywgdXNlIHNldFRpbWVvdXRcclxuICAgICAgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xyXG4gICAgICB9XHJcbiAgICApO1xyXG4gIH0pKCk7XHJcblxyXG4gIHZhciBjYW5jZWxBRnJhbWUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgIHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgd2luZG93Lm9DYW5jZWxBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTtcclxuICAgICAgfVxyXG4gICAgKTtcclxuICB9KSgpO1xyXG5cclxuICB2YXIgZ2V0UG9pbnRlclhZID0gZnVuY3Rpb24gKGUpIHtcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuXHJcbiAgICBlID0gZS5vcmlnaW5hbEV2ZW50IHx8IGUgfHwgd2luZG93LmU7XHJcbiAgICBlID0gZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPyBlLnRvdWNoZXMgOiBlLmNoYW5nZWRUb3VjaGVzICYmIGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID8gZS5jaGFuZ2VkVG91Y2hlcyA6IFtlXTtcclxuXHJcbiAgICBmb3IgKHZhciBrZXkgaW4gZSkge1xyXG4gICAgICBpZiAoZVtrZXldLnBhZ2VYKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2goe1xyXG4gICAgICAgICAgeDogZVtrZXldLnBhZ2VYLFxyXG4gICAgICAgICAgeTogZVtrZXldLnBhZ2VZXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZVtrZXldLmNsaWVudFgpIHtcclxuICAgICAgICByZXN1bHQucHVzaCh7XHJcbiAgICAgICAgICB4OiBlW2tleV0uY2xpZW50WCxcclxuICAgICAgICAgIHk6IGVba2V5XS5jbGllbnRZXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIHZhciBkaXN0YW5jZSA9IGZ1bmN0aW9uIChwb2ludDIsIHBvaW50MSwgd2hhdCkge1xyXG4gICAgaWYgKCFwb2ludDEgfHwgIXBvaW50Mikge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAod2hhdCA9PT0gXCJ4XCIpIHtcclxuICAgICAgcmV0dXJuIHBvaW50Mi54IC0gcG9pbnQxLng7XHJcbiAgICB9IGVsc2UgaWYgKHdoYXQgPT09IFwieVwiKSB7XHJcbiAgICAgIHJldHVybiBwb2ludDIueSAtIHBvaW50MS55O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocG9pbnQyLnggLSBwb2ludDEueCwgMikgKyBNYXRoLnBvdyhwb2ludDIueSAtIHBvaW50MS55LCAyKSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGlzQ2xpY2thYmxlID0gZnVuY3Rpb24gKCRlbCkge1xyXG4gICAgaWYgKFxyXG4gICAgICAkZWwuaXMoJ2EsYXJlYSxidXR0b24sW3JvbGU9XCJidXR0b25cIl0saW5wdXQsbGFiZWwsc2VsZWN0LHN1bW1hcnksdGV4dGFyZWEsdmlkZW8sYXVkaW8saWZyYW1lJykgfHxcclxuICAgICAgJC5pc0Z1bmN0aW9uKCRlbC5nZXQoMCkub25jbGljaykgfHxcclxuICAgICAgJGVsLmRhdGEoXCJzZWxlY3RhYmxlXCIpXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgZm9yIGF0dHJpYnV0ZXMgbGlrZSBkYXRhLWZhbmN5Ym94LW5leHQgb3IgZGF0YS1mYW5jeWJveC1jbG9zZVxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGF0dHMgPSAkZWxbMF0uYXR0cmlidXRlcywgbiA9IGF0dHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgIGlmIChhdHRzW2ldLm5vZGVOYW1lLnN1YnN0cigwLCAxNCkgPT09IFwiZGF0YS1mYW5jeWJveC1cIikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH07XHJcblxyXG4gIHZhciBoYXNTY3JvbGxiYXJzID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICB2YXIgb3ZlcmZsb3dZID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpW1wib3ZlcmZsb3cteVwiXSxcclxuICAgICAgb3ZlcmZsb3dYID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpW1wib3ZlcmZsb3cteFwiXSxcclxuICAgICAgdmVydGljYWwgPSAob3ZlcmZsb3dZID09PSBcInNjcm9sbFwiIHx8IG92ZXJmbG93WSA9PT0gXCJhdXRvXCIpICYmIGVsLnNjcm9sbEhlaWdodCA+IGVsLmNsaWVudEhlaWdodCxcclxuICAgICAgaG9yaXpvbnRhbCA9IChvdmVyZmxvd1ggPT09IFwic2Nyb2xsXCIgfHwgb3ZlcmZsb3dYID09PSBcImF1dG9cIikgJiYgZWwuc2Nyb2xsV2lkdGggPiBlbC5jbGllbnRXaWR0aDtcclxuXHJcbiAgICByZXR1cm4gdmVydGljYWwgfHwgaG9yaXpvbnRhbDtcclxuICB9O1xyXG5cclxuICB2YXIgaXNTY3JvbGxhYmxlID0gZnVuY3Rpb24gKCRlbCkge1xyXG4gICAgdmFyIHJleiA9IGZhbHNlO1xyXG5cclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgIHJleiA9IGhhc1Njcm9sbGJhcnMoJGVsLmdldCgwKSk7XHJcblxyXG4gICAgICBpZiAocmV6KSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICRlbCA9ICRlbC5wYXJlbnQoKTtcclxuXHJcbiAgICAgIGlmICghJGVsLmxlbmd0aCB8fCAkZWwuaGFzQ2xhc3MoXCJmYW5jeWJveC1zdGFnZVwiKSB8fCAkZWwuaXMoXCJib2R5XCIpKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmV6O1xyXG4gIH07XHJcblxyXG4gIHZhciBHdWVzdHVyZXMgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICBzZWxmLmluc3RhbmNlID0gaW5zdGFuY2U7XHJcblxyXG4gICAgc2VsZi4kYmcgPSBpbnN0YW5jZS4kcmVmcy5iZztcclxuICAgIHNlbGYuJHN0YWdlID0gaW5zdGFuY2UuJHJlZnMuc3RhZ2U7XHJcbiAgICBzZWxmLiRjb250YWluZXIgPSBpbnN0YW5jZS4kcmVmcy5jb250YWluZXI7XHJcblxyXG4gICAgc2VsZi5kZXN0cm95KCk7XHJcblxyXG4gICAgc2VsZi4kY29udGFpbmVyLm9uKFwidG91Y2hzdGFydC5mYi50b3VjaCBtb3VzZWRvd24uZmIudG91Y2hcIiwgJC5wcm94eShzZWxmLCBcIm9udG91Y2hzdGFydFwiKSk7XHJcbiAgfTtcclxuXHJcbiAgR3Vlc3R1cmVzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHNlbGYuJGNvbnRhaW5lci5vZmYoXCIuZmIudG91Y2hcIik7XHJcblxyXG4gICAgJChkb2N1bWVudCkub2ZmKFwiLmZiLnRvdWNoXCIpO1xyXG5cclxuICAgIGlmIChzZWxmLnJlcXVlc3RJZCkge1xyXG4gICAgICBjYW5jZWxBRnJhbWUoc2VsZi5yZXF1ZXN0SWQpO1xyXG4gICAgICBzZWxmLnJlcXVlc3RJZCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNlbGYudGFwcGVkKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLnRhcHBlZCk7XHJcbiAgICAgIHNlbGYudGFwcGVkID0gbnVsbDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBHdWVzdHVyZXMucHJvdG90eXBlLm9udG91Y2hzdGFydCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICR0YXJnZXQgPSAkKGUudGFyZ2V0KSxcclxuICAgICAgaW5zdGFuY2UgPSBzZWxmLmluc3RhbmNlLFxyXG4gICAgICBjdXJyZW50ID0gaW5zdGFuY2UuY3VycmVudCxcclxuICAgICAgJHNsaWRlID0gY3VycmVudC4kc2xpZGUsXHJcbiAgICAgICRjb250ZW50ID0gY3VycmVudC4kY29udGVudCxcclxuICAgICAgaXNUb3VjaERldmljZSA9IGUudHlwZSA9PSBcInRvdWNoc3RhcnRcIjtcclxuXHJcbiAgICAvLyBEbyBub3QgcmVzcG9uZCB0byBib3RoICh0b3VjaCBhbmQgbW91c2UpIGV2ZW50c1xyXG4gICAgaWYgKGlzVG91Y2hEZXZpY2UpIHtcclxuICAgICAgc2VsZi4kY29udGFpbmVyLm9mZihcIm1vdXNlZG93bi5mYi50b3VjaFwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZ25vcmUgcmlnaHQgY2xpY2tcclxuICAgIGlmIChlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmJ1dHRvbiA9PSAyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZ25vcmUgdGFwaW5nIG9uIGxpbmtzLCBidXR0b25zLCBpbnB1dCBlbGVtZW50c1xyXG4gICAgaWYgKCEkc2xpZGUubGVuZ3RoIHx8ICEkdGFyZ2V0Lmxlbmd0aCB8fCBpc0NsaWNrYWJsZSgkdGFyZ2V0KSB8fCBpc0NsaWNrYWJsZSgkdGFyZ2V0LnBhcmVudCgpKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBJZ25vcmUgY2xpY2tzIG9uIHRoZSBzY3JvbGxiYXJcclxuICAgIGlmICghJHRhcmdldC5pcyhcImltZ1wiKSAmJiBlLm9yaWdpbmFsRXZlbnQuY2xpZW50WCA+ICR0YXJnZXRbMF0uY2xpZW50V2lkdGggKyAkdGFyZ2V0Lm9mZnNldCgpLmxlZnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElnbm9yZSBjbGlja3Mgd2hpbGUgem9vbWluZyBvciBjbG9zaW5nXHJcbiAgICBpZiAoIWN1cnJlbnQgfHwgaW5zdGFuY2UuaXNBbmltYXRpbmcgfHwgY3VycmVudC4kc2xpZGUuaGFzQ2xhc3MoXCJmYW5jeWJveC1hbmltYXRlZFwiKSkge1xyXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZi5yZWFsUG9pbnRzID0gc2VsZi5zdGFydFBvaW50cyA9IGdldFBvaW50ZXJYWShlKTtcclxuXHJcbiAgICBpZiAoIXNlbGYuc3RhcnRQb2ludHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBbGxvdyBvdGhlciBzY3JpcHRzIHRvIGNhdGNoIHRvdWNoIGV2ZW50IGlmIFwidG91Y2hcIiBpcyBzZXQgdG8gZmFsc2VcclxuICAgIGlmIChjdXJyZW50LnRvdWNoKSB7XHJcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZi5zdGFydEV2ZW50ID0gZTtcclxuXHJcbiAgICBzZWxmLmNhblRhcCA9IHRydWU7XHJcbiAgICBzZWxmLiR0YXJnZXQgPSAkdGFyZ2V0O1xyXG4gICAgc2VsZi4kY29udGVudCA9ICRjb250ZW50O1xyXG4gICAgc2VsZi5vcHRzID0gY3VycmVudC5vcHRzLnRvdWNoO1xyXG5cclxuICAgIHNlbGYuaXNQYW5uaW5nID0gZmFsc2U7XHJcbiAgICBzZWxmLmlzU3dpcGluZyA9IGZhbHNlO1xyXG4gICAgc2VsZi5pc1pvb21pbmcgPSBmYWxzZTtcclxuICAgIHNlbGYuaXNTY3JvbGxpbmcgPSBmYWxzZTtcclxuICAgIHNlbGYuY2FuUGFuID0gaW5zdGFuY2UuY2FuUGFuKCk7XHJcblxyXG4gICAgc2VsZi5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIHNlbGYuZGlzdGFuY2VYID0gc2VsZi5kaXN0YW5jZVkgPSBzZWxmLmRpc3RhbmNlID0gMDtcclxuXHJcbiAgICBzZWxmLmNhbnZhc1dpZHRoID0gTWF0aC5yb3VuZCgkc2xpZGVbMF0uY2xpZW50V2lkdGgpO1xyXG4gICAgc2VsZi5jYW52YXNIZWlnaHQgPSBNYXRoLnJvdW5kKCRzbGlkZVswXS5jbGllbnRIZWlnaHQpO1xyXG5cclxuICAgIHNlbGYuY29udGVudExhc3RQb3MgPSBudWxsO1xyXG4gICAgc2VsZi5jb250ZW50U3RhcnRQb3MgPSAkLmZhbmN5Ym94LmdldFRyYW5zbGF0ZShzZWxmLiRjb250ZW50KSB8fCB7XHJcbiAgICAgIHRvcDogMCxcclxuICAgICAgbGVmdDogMFxyXG4gICAgfTtcclxuICAgIHNlbGYuc2xpZGVyU3RhcnRQb3MgPSAkLmZhbmN5Ym94LmdldFRyYW5zbGF0ZSgkc2xpZGUpO1xyXG5cclxuICAgIC8vIFNpbmNlIHBvc2l0aW9uIHdpbGwgYmUgYWJzb2x1dGUsIGJ1dCB3ZSBuZWVkIHRvIG1ha2UgaXQgcmVsYXRpdmUgdG8gdGhlIHN0YWdlXHJcbiAgICBzZWxmLnN0YWdlUG9zID0gJC5mYW5jeWJveC5nZXRUcmFuc2xhdGUoaW5zdGFuY2UuJHJlZnMuc3RhZ2UpO1xyXG5cclxuICAgIHNlbGYuc2xpZGVyU3RhcnRQb3MudG9wIC09IHNlbGYuc3RhZ2VQb3MudG9wO1xyXG4gICAgc2VsZi5zbGlkZXJTdGFydFBvcy5sZWZ0IC09IHNlbGYuc3RhZ2VQb3MubGVmdDtcclxuXHJcbiAgICBzZWxmLmNvbnRlbnRTdGFydFBvcy50b3AgLT0gc2VsZi5zdGFnZVBvcy50b3A7XHJcbiAgICBzZWxmLmNvbnRlbnRTdGFydFBvcy5sZWZ0IC09IHNlbGYuc3RhZ2VQb3MubGVmdDtcclxuXHJcbiAgICAkKGRvY3VtZW50KVxyXG4gICAgICAub2ZmKFwiLmZiLnRvdWNoXCIpXHJcbiAgICAgIC5vbihpc1RvdWNoRGV2aWNlID8gXCJ0b3VjaGVuZC5mYi50b3VjaCB0b3VjaGNhbmNlbC5mYi50b3VjaFwiIDogXCJtb3VzZXVwLmZiLnRvdWNoIG1vdXNlbGVhdmUuZmIudG91Y2hcIiwgJC5wcm94eShzZWxmLCBcIm9udG91Y2hlbmRcIikpXHJcbiAgICAgIC5vbihpc1RvdWNoRGV2aWNlID8gXCJ0b3VjaG1vdmUuZmIudG91Y2hcIiA6IFwibW91c2Vtb3ZlLmZiLnRvdWNoXCIsICQucHJveHkoc2VsZiwgXCJvbnRvdWNobW92ZVwiKSk7XHJcblxyXG4gICAgaWYgKCQuZmFuY3lib3guaXNNb2JpbGUpIHtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBzZWxmLm9uc2Nyb2xsLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTa2lwIGlmIGNsaWNrZWQgb3V0c2lkZSB0aGUgc2xpZGluZyBhcmVhXHJcbiAgICBpZiAoIShzZWxmLm9wdHMgfHwgc2VsZi5jYW5QYW4pIHx8ICEoJHRhcmdldC5pcyhzZWxmLiRzdGFnZSkgfHwgc2VsZi4kc3RhZ2UuZmluZCgkdGFyZ2V0KS5sZW5ndGgpKSB7XHJcbiAgICAgIGlmICgkdGFyZ2V0LmlzKFwiLmZhbmN5Ym94LWltYWdlXCIpKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoISgkLmZhbmN5Ym94LmlzTW9iaWxlICYmICR0YXJnZXQucGFyZW50cyhcIi5mYW5jeWJveC1jYXB0aW9uXCIpLmxlbmd0aCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZWxmLmlzU2Nyb2xsYWJsZSA9IGlzU2Nyb2xsYWJsZSgkdGFyZ2V0KSB8fCBpc1Njcm9sbGFibGUoJHRhcmdldC5wYXJlbnQoKSk7XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgZWxlbWVudCBpcyBzY3JvbGxhYmxlIGFuZCB0cnkgdG8gcHJldmVudCBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcpXHJcbiAgICBpZiAoISgkLmZhbmN5Ym94LmlzTW9iaWxlICYmIHNlbGYuaXNTY3JvbGxhYmxlKSkge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT25lIGZpbmdlciBvciBtb3VzZSBjbGljayAtIHN3aXBlIG9yIHBhbiBhbiBpbWFnZVxyXG4gICAgaWYgKHNlbGYuc3RhcnRQb2ludHMubGVuZ3RoID09PSAxIHx8IGN1cnJlbnQuaGFzRXJyb3IpIHtcclxuICAgICAgaWYgKHNlbGYuY2FuUGFuKSB7XHJcbiAgICAgICAgJC5mYW5jeWJveC5zdG9wKHNlbGYuJGNvbnRlbnQpO1xyXG5cclxuICAgICAgICBzZWxmLmlzUGFubmluZyA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2VsZi5pc1N3aXBpbmcgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZWxmLiRjb250YWluZXIuYWRkQ2xhc3MoXCJmYW5jeWJveC1pcy1ncmFiYmluZ1wiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUd28gZmluZ2VycyAtIHpvb20gaW1hZ2VcclxuICAgIGlmIChzZWxmLnN0YXJ0UG9pbnRzLmxlbmd0aCA9PT0gMiAmJiBjdXJyZW50LnR5cGUgPT09IFwiaW1hZ2VcIiAmJiAoY3VycmVudC5pc0xvYWRlZCB8fCBjdXJyZW50LiRnaG9zdCkpIHtcclxuICAgICAgc2VsZi5jYW5UYXAgPSBmYWxzZTtcclxuICAgICAgc2VsZi5pc1N3aXBpbmcgPSBmYWxzZTtcclxuICAgICAgc2VsZi5pc1Bhbm5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgIHNlbGYuaXNab29taW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICQuZmFuY3lib3guc3RvcChzZWxmLiRjb250ZW50KTtcclxuXHJcbiAgICAgIHNlbGYuY2VudGVyUG9pbnRTdGFydFggPSAoc2VsZi5zdGFydFBvaW50c1swXS54ICsgc2VsZi5zdGFydFBvaW50c1sxXS54KSAqIDAuNSAtICQod2luZG93KS5zY3JvbGxMZWZ0KCk7XHJcbiAgICAgIHNlbGYuY2VudGVyUG9pbnRTdGFydFkgPSAoc2VsZi5zdGFydFBvaW50c1swXS55ICsgc2VsZi5zdGFydFBvaW50c1sxXS55KSAqIDAuNSAtICQod2luZG93KS5zY3JvbGxUb3AoKTtcclxuXHJcbiAgICAgIHNlbGYucGVyY2VudGFnZU9mSW1hZ2VBdFBpbmNoUG9pbnRYID0gKHNlbGYuY2VudGVyUG9pbnRTdGFydFggLSBzZWxmLmNvbnRlbnRTdGFydFBvcy5sZWZ0KSAvIHNlbGYuY29udGVudFN0YXJ0UG9zLndpZHRoO1xyXG4gICAgICBzZWxmLnBlcmNlbnRhZ2VPZkltYWdlQXRQaW5jaFBvaW50WSA9IChzZWxmLmNlbnRlclBvaW50U3RhcnRZIC0gc2VsZi5jb250ZW50U3RhcnRQb3MudG9wKSAvIHNlbGYuY29udGVudFN0YXJ0UG9zLmhlaWdodDtcclxuXHJcbiAgICAgIHNlbGYuc3RhcnREaXN0YW5jZUJldHdlZW5GaW5nZXJzID0gZGlzdGFuY2Uoc2VsZi5zdGFydFBvaW50c1swXSwgc2VsZi5zdGFydFBvaW50c1sxXSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgR3Vlc3R1cmVzLnByb3RvdHlwZS5vbnNjcm9sbCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgc2VsZi5pc1Njcm9sbGluZyA9IHRydWU7XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBzZWxmLm9uc2Nyb2xsLCB0cnVlKTtcclxuICB9O1xyXG5cclxuICBHdWVzdHVyZXMucHJvdG90eXBlLm9udG91Y2htb3ZlID0gZnVuY3Rpb24gKGUpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdXNlciBoYXMgbm90IHJlbGVhc2VkIG92ZXIgaWZyYW1lIG9yIGRpc2FibGVkIGVsZW1lbnRcclxuICAgIGlmIChlLm9yaWdpbmFsRXZlbnQuYnV0dG9ucyAhPT0gdW5kZWZpbmVkICYmIGUub3JpZ2luYWxFdmVudC5idXR0b25zID09PSAwKSB7XHJcbiAgICAgIHNlbGYub250b3VjaGVuZChlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZWxmLmlzU2Nyb2xsaW5nKSB7XHJcbiAgICAgIHNlbGYuY2FuVGFwID0gZmFsc2U7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmLm5ld1BvaW50cyA9IGdldFBvaW50ZXJYWShlKTtcclxuXHJcbiAgICBpZiAoIShzZWxmLm9wdHMgfHwgc2VsZi5jYW5QYW4pIHx8ICFzZWxmLm5ld1BvaW50cy5sZW5ndGggfHwgIXNlbGYubmV3UG9pbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEoc2VsZi5pc1N3aXBpbmcgJiYgc2VsZi5pc1N3aXBpbmcgPT09IHRydWUpKSB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmLmRpc3RhbmNlWCA9IGRpc3RhbmNlKHNlbGYubmV3UG9pbnRzWzBdLCBzZWxmLnN0YXJ0UG9pbnRzWzBdLCBcInhcIik7XHJcbiAgICBzZWxmLmRpc3RhbmNlWSA9IGRpc3RhbmNlKHNlbGYubmV3UG9pbnRzWzBdLCBzZWxmLnN0YXJ0UG9pbnRzWzBdLCBcInlcIik7XHJcblxyXG4gICAgc2VsZi5kaXN0YW5jZSA9IGRpc3RhbmNlKHNlbGYubmV3UG9pbnRzWzBdLCBzZWxmLnN0YXJ0UG9pbnRzWzBdKTtcclxuXHJcbiAgICAvLyBTa2lwIGZhbHNlIG9udG91Y2htb3ZlIGV2ZW50cyAoQ2hyb21lKVxyXG4gICAgaWYgKHNlbGYuZGlzdGFuY2UgPiAwKSB7XHJcbiAgICAgIGlmIChzZWxmLmlzU3dpcGluZykge1xyXG4gICAgICAgIHNlbGYub25Td2lwZShlKTtcclxuICAgICAgfSBlbHNlIGlmIChzZWxmLmlzUGFubmluZykge1xyXG4gICAgICAgIHNlbGYub25QYW4oKTtcclxuICAgICAgfSBlbHNlIGlmIChzZWxmLmlzWm9vbWluZykge1xyXG4gICAgICAgIHNlbGYub25ab29tKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICBHdWVzdHVyZXMucHJvdG90eXBlLm9uU3dpcGUgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICBpbnN0YW5jZSA9IHNlbGYuaW5zdGFuY2UsXHJcbiAgICAgIHN3aXBpbmcgPSBzZWxmLmlzU3dpcGluZyxcclxuICAgICAgbGVmdCA9IHNlbGYuc2xpZGVyU3RhcnRQb3MubGVmdCB8fCAwLFxyXG4gICAgICBhbmdsZTtcclxuXHJcbiAgICAvLyBJZiBkaXJlY3Rpb24gaXMgbm90IHlldCBkZXRlcm1pbmVkXHJcbiAgICBpZiAoc3dpcGluZyA9PT0gdHJ1ZSkge1xyXG4gICAgICAvLyBXZSBuZWVkIGF0IGxlYXN0IDEwcHggZGlzdGFuY2UgdG8gY29ycmVjdGx5IGNhbGN1bGF0ZSBhbiBhbmdsZVxyXG4gICAgICBpZiAoTWF0aC5hYnMoc2VsZi5kaXN0YW5jZSkgPiAxMCkge1xyXG4gICAgICAgIHNlbGYuY2FuVGFwID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5ncm91cC5sZW5ndGggPCAyICYmIHNlbGYub3B0cy52ZXJ0aWNhbCkge1xyXG4gICAgICAgICAgc2VsZi5pc1N3aXBpbmcgPSBcInlcIjtcclxuICAgICAgICB9IGVsc2UgaWYgKGluc3RhbmNlLmlzRHJhZ2dpbmcgfHwgc2VsZi5vcHRzLnZlcnRpY2FsID09PSBmYWxzZSB8fCAoc2VsZi5vcHRzLnZlcnRpY2FsID09PSBcImF1dG9cIiAmJiAkKHdpbmRvdykud2lkdGgoKSA+IDgwMCkpIHtcclxuICAgICAgICAgIHNlbGYuaXNTd2lwaW5nID0gXCJ4XCI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFuZ2xlID0gTWF0aC5hYnMoKE1hdGguYXRhbjIoc2VsZi5kaXN0YW5jZVksIHNlbGYuZGlzdGFuY2VYKSAqIDE4MCkgLyBNYXRoLlBJKTtcclxuXHJcbiAgICAgICAgICBzZWxmLmlzU3dpcGluZyA9IGFuZ2xlID4gNDUgJiYgYW5nbGUgPCAxMzUgPyBcInlcIiA6IFwieFwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNlbGYuaXNTd2lwaW5nID09PSBcInlcIiAmJiAkLmZhbmN5Ym94LmlzTW9iaWxlICYmIHNlbGYuaXNTY3JvbGxhYmxlKSB7XHJcbiAgICAgICAgICBzZWxmLmlzU2Nyb2xsaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnN0YW5jZS5pc0RyYWdnaW5nID0gc2VsZi5pc1N3aXBpbmc7XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IHBvaW50cyB0byBhdm9pZCBqdW1waW5nLCBiZWNhdXNlIHdlIGRyb3BwZWQgZmlyc3Qgc3dpcGVzIHRvIGNhbGN1bGF0ZSB0aGUgYW5nbGVcclxuICAgICAgICBzZWxmLnN0YXJ0UG9pbnRzID0gc2VsZi5uZXdQb2ludHM7XHJcblxyXG4gICAgICAgICQuZWFjaChpbnN0YW5jZS5zbGlkZXMsIGZ1bmN0aW9uIChpbmRleCwgc2xpZGUpIHtcclxuICAgICAgICAgIHZhciBzbGlkZVBvcywgc3RhZ2VQb3M7XHJcblxyXG4gICAgICAgICAgJC5mYW5jeWJveC5zdG9wKHNsaWRlLiRzbGlkZSk7XHJcblxyXG4gICAgICAgICAgc2xpZGVQb3MgPSAkLmZhbmN5Ym94LmdldFRyYW5zbGF0ZShzbGlkZS4kc2xpZGUpO1xyXG4gICAgICAgICAgc3RhZ2VQb3MgPSAkLmZhbmN5Ym94LmdldFRyYW5zbGF0ZShpbnN0YW5jZS4kcmVmcy5zdGFnZSk7XHJcblxyXG4gICAgICAgICAgc2xpZGUuJHNsaWRlXHJcbiAgICAgICAgICAgIC5jc3Moe1xyXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJcIixcclxuICAgICAgICAgICAgICBvcGFjaXR5OiBcIlwiLFxyXG4gICAgICAgICAgICAgIFwidHJhbnNpdGlvbi1kdXJhdGlvblwiOiBcIlwiXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LWFuaW1hdGVkXCIpXHJcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhmdW5jdGlvbiAoaW5kZXgsIGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiAoY2xhc3NOYW1lLm1hdGNoKC8oXnxcXHMpZmFuY3lib3gtZngtXFxTKy9nKSB8fCBbXSkuam9pbihcIiBcIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGlmIChzbGlkZS5wb3MgPT09IGluc3RhbmNlLmN1cnJlbnQucG9zKSB7XHJcbiAgICAgICAgICAgIHNlbGYuc2xpZGVyU3RhcnRQb3MudG9wID0gc2xpZGVQb3MudG9wIC0gc3RhZ2VQb3MudG9wO1xyXG4gICAgICAgICAgICBzZWxmLnNsaWRlclN0YXJ0UG9zLmxlZnQgPSBzbGlkZVBvcy5sZWZ0IC0gc3RhZ2VQb3MubGVmdDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAkLmZhbmN5Ym94LnNldFRyYW5zbGF0ZShzbGlkZS4kc2xpZGUsIHtcclxuICAgICAgICAgICAgdG9wOiBzbGlkZVBvcy50b3AgLSBzdGFnZVBvcy50b3AsXHJcbiAgICAgICAgICAgIGxlZnQ6IHNsaWRlUG9zLmxlZnQgLSBzdGFnZVBvcy5sZWZ0XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gU3RvcCBzbGlkZXNob3dcclxuICAgICAgICBpZiAoaW5zdGFuY2UuU2xpZGVTaG93ICYmIGluc3RhbmNlLlNsaWRlU2hvdy5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgaW5zdGFuY2UuU2xpZGVTaG93LnN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGlja3kgZWRnZXNcclxuICAgIGlmIChzd2lwaW5nID09IFwieFwiKSB7XHJcbiAgICAgIGlmIChcclxuICAgICAgICBzZWxmLmRpc3RhbmNlWCA+IDAgJiZcclxuICAgICAgICAoc2VsZi5pbnN0YW5jZS5ncm91cC5sZW5ndGggPCAyIHx8IChzZWxmLmluc3RhbmNlLmN1cnJlbnQuaW5kZXggPT09IDAgJiYgIXNlbGYuaW5zdGFuY2UuY3VycmVudC5vcHRzLmxvb3ApKVxyXG4gICAgICApIHtcclxuICAgICAgICBsZWZ0ID0gbGVmdCArIE1hdGgucG93KHNlbGYuZGlzdGFuY2VYLCAwLjgpO1xyXG4gICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgIHNlbGYuZGlzdGFuY2VYIDwgMCAmJlxyXG4gICAgICAgIChzZWxmLmluc3RhbmNlLmdyb3VwLmxlbmd0aCA8IDIgfHxcclxuICAgICAgICAgIChzZWxmLmluc3RhbmNlLmN1cnJlbnQuaW5kZXggPT09IHNlbGYuaW5zdGFuY2UuZ3JvdXAubGVuZ3RoIC0gMSAmJiAhc2VsZi5pbnN0YW5jZS5jdXJyZW50Lm9wdHMubG9vcCkpXHJcbiAgICAgICkge1xyXG4gICAgICAgIGxlZnQgPSBsZWZ0IC0gTWF0aC5wb3coLXNlbGYuZGlzdGFuY2VYLCAwLjgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxlZnQgPSBsZWZ0ICsgc2VsZi5kaXN0YW5jZVg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZWxmLnNsaWRlckxhc3RQb3MgPSB7XHJcbiAgICAgIHRvcDogc3dpcGluZyA9PSBcInhcIiA/IDAgOiBzZWxmLnNsaWRlclN0YXJ0UG9zLnRvcCArIHNlbGYuZGlzdGFuY2VZLFxyXG4gICAgICBsZWZ0OiBsZWZ0XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChzZWxmLnJlcXVlc3RJZCkge1xyXG4gICAgICBjYW5jZWxBRnJhbWUoc2VsZi5yZXF1ZXN0SWQpO1xyXG5cclxuICAgICAgc2VsZi5yZXF1ZXN0SWQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGYucmVxdWVzdElkID0gcmVxdWVzdEFGcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChzZWxmLnNsaWRlckxhc3RQb3MpIHtcclxuICAgICAgICAkLmVhY2goc2VsZi5pbnN0YW5jZS5zbGlkZXMsIGZ1bmN0aW9uIChpbmRleCwgc2xpZGUpIHtcclxuICAgICAgICAgIHZhciBwb3MgPSBzbGlkZS5wb3MgLSBzZWxmLmluc3RhbmNlLmN1cnJQb3M7XHJcblxyXG4gICAgICAgICAgJC5mYW5jeWJveC5zZXRUcmFuc2xhdGUoc2xpZGUuJHNsaWRlLCB7XHJcbiAgICAgICAgICAgIHRvcDogc2VsZi5zbGlkZXJMYXN0UG9zLnRvcCxcclxuICAgICAgICAgICAgbGVmdDogc2VsZi5zbGlkZXJMYXN0UG9zLmxlZnQgKyBwb3MgKiBzZWxmLmNhbnZhc1dpZHRoICsgcG9zICogc2xpZGUub3B0cy5ndXR0ZXJcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzZWxmLiRjb250YWluZXIuYWRkQ2xhc3MoXCJmYW5jeWJveC1pcy1zbGlkaW5nXCIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBHdWVzdHVyZXMucHJvdG90eXBlLm9uUGFuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIC8vIFByZXZlbnQgYWNjaWRlbnRhbCBtb3ZlbWVudCAoc29tZXRpbWVzLCB3aGVuIHRhcHBpbmcgY2FzdWFsbHksIGZpbmdlciBjYW4gbW92ZSBhIGJpdClcclxuICAgIGlmIChkaXN0YW5jZShzZWxmLm5ld1BvaW50c1swXSwgc2VsZi5yZWFsUG9pbnRzWzBdKSA8ICgkLmZhbmN5Ym94LmlzTW9iaWxlID8gMTAgOiA1KSkge1xyXG4gICAgICBzZWxmLnN0YXJ0UG9pbnRzID0gc2VsZi5uZXdQb2ludHM7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmLmNhblRhcCA9IGZhbHNlO1xyXG5cclxuICAgIHNlbGYuY29udGVudExhc3RQb3MgPSBzZWxmLmxpbWl0TW92ZW1lbnQoKTtcclxuXHJcbiAgICBpZiAoc2VsZi5yZXF1ZXN0SWQpIHtcclxuICAgICAgY2FuY2VsQUZyYW1lKHNlbGYucmVxdWVzdElkKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmLnJlcXVlc3RJZCA9IHJlcXVlc3RBRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAkLmZhbmN5Ym94LnNldFRyYW5zbGF0ZShzZWxmLiRjb250ZW50LCBzZWxmLmNvbnRlbnRMYXN0UG9zKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8vIE1ha2UgcGFubmluZyBzdGlja3kgdG8gdGhlIGVkZ2VzXHJcbiAgR3Vlc3R1cmVzLnByb3RvdHlwZS5saW1pdE1vdmVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHZhciBjYW52YXNXaWR0aCA9IHNlbGYuY2FudmFzV2lkdGg7XHJcbiAgICB2YXIgY2FudmFzSGVpZ2h0ID0gc2VsZi5jYW52YXNIZWlnaHQ7XHJcblxyXG4gICAgdmFyIGRpc3RhbmNlWCA9IHNlbGYuZGlzdGFuY2VYO1xyXG4gICAgdmFyIGRpc3RhbmNlWSA9IHNlbGYuZGlzdGFuY2VZO1xyXG5cclxuICAgIHZhciBjb250ZW50U3RhcnRQb3MgPSBzZWxmLmNvbnRlbnRTdGFydFBvcztcclxuXHJcbiAgICB2YXIgY3VycmVudE9mZnNldFggPSBjb250ZW50U3RhcnRQb3MubGVmdDtcclxuICAgIHZhciBjdXJyZW50T2Zmc2V0WSA9IGNvbnRlbnRTdGFydFBvcy50b3A7XHJcblxyXG4gICAgdmFyIGN1cnJlbnRXaWR0aCA9IGNvbnRlbnRTdGFydFBvcy53aWR0aDtcclxuICAgIHZhciBjdXJyZW50SGVpZ2h0ID0gY29udGVudFN0YXJ0UG9zLmhlaWdodDtcclxuXHJcbiAgICB2YXIgbWluVHJhbnNsYXRlWCwgbWluVHJhbnNsYXRlWSwgbWF4VHJhbnNsYXRlWCwgbWF4VHJhbnNsYXRlWSwgbmV3T2Zmc2V0WCwgbmV3T2Zmc2V0WTtcclxuXHJcbiAgICBpZiAoY3VycmVudFdpZHRoID4gY2FudmFzV2lkdGgpIHtcclxuICAgICAgbmV3T2Zmc2V0WCA9IGN1cnJlbnRPZmZzZXRYICsgZGlzdGFuY2VYO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbmV3T2Zmc2V0WCA9IGN1cnJlbnRPZmZzZXRYO1xyXG4gICAgfVxyXG5cclxuICAgIG5ld09mZnNldFkgPSBjdXJyZW50T2Zmc2V0WSArIGRpc3RhbmNlWTtcclxuXHJcbiAgICAvLyBTbG93IGRvd24gcHJvcG9ydGlvbmFsbHkgdG8gdHJhdmVsZWQgZGlzdGFuY2VcclxuICAgIG1pblRyYW5zbGF0ZVggPSBNYXRoLm1heCgwLCBjYW52YXNXaWR0aCAqIDAuNSAtIGN1cnJlbnRXaWR0aCAqIDAuNSk7XHJcbiAgICBtaW5UcmFuc2xhdGVZID0gTWF0aC5tYXgoMCwgY2FudmFzSGVpZ2h0ICogMC41IC0gY3VycmVudEhlaWdodCAqIDAuNSk7XHJcblxyXG4gICAgbWF4VHJhbnNsYXRlWCA9IE1hdGgubWluKGNhbnZhc1dpZHRoIC0gY3VycmVudFdpZHRoLCBjYW52YXNXaWR0aCAqIDAuNSAtIGN1cnJlbnRXaWR0aCAqIDAuNSk7XHJcbiAgICBtYXhUcmFuc2xhdGVZID0gTWF0aC5taW4oY2FudmFzSGVpZ2h0IC0gY3VycmVudEhlaWdodCwgY2FudmFzSGVpZ2h0ICogMC41IC0gY3VycmVudEhlaWdodCAqIDAuNSk7XHJcblxyXG4gICAgLy8gICAtPlxyXG4gICAgaWYgKGRpc3RhbmNlWCA+IDAgJiYgbmV3T2Zmc2V0WCA+IG1pblRyYW5zbGF0ZVgpIHtcclxuICAgICAgbmV3T2Zmc2V0WCA9IG1pblRyYW5zbGF0ZVggLSAxICsgTWF0aC5wb3coLW1pblRyYW5zbGF0ZVggKyBjdXJyZW50T2Zmc2V0WCArIGRpc3RhbmNlWCwgMC44KSB8fCAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICAgIDwtXHJcbiAgICBpZiAoZGlzdGFuY2VYIDwgMCAmJiBuZXdPZmZzZXRYIDwgbWF4VHJhbnNsYXRlWCkge1xyXG4gICAgICBuZXdPZmZzZXRYID0gbWF4VHJhbnNsYXRlWCArIDEgLSBNYXRoLnBvdyhtYXhUcmFuc2xhdGVYIC0gY3VycmVudE9mZnNldFggLSBkaXN0YW5jZVgsIDAuOCkgfHwgMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyAgIFxcL1xyXG4gICAgaWYgKGRpc3RhbmNlWSA+IDAgJiYgbmV3T2Zmc2V0WSA+IG1pblRyYW5zbGF0ZVkpIHtcclxuICAgICAgbmV3T2Zmc2V0WSA9IG1pblRyYW5zbGF0ZVkgLSAxICsgTWF0aC5wb3coLW1pblRyYW5zbGF0ZVkgKyBjdXJyZW50T2Zmc2V0WSArIGRpc3RhbmNlWSwgMC44KSB8fCAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICAgL1xcXHJcbiAgICBpZiAoZGlzdGFuY2VZIDwgMCAmJiBuZXdPZmZzZXRZIDwgbWF4VHJhbnNsYXRlWSkge1xyXG4gICAgICBuZXdPZmZzZXRZID0gbWF4VHJhbnNsYXRlWSArIDEgLSBNYXRoLnBvdyhtYXhUcmFuc2xhdGVZIC0gY3VycmVudE9mZnNldFkgLSBkaXN0YW5jZVksIDAuOCkgfHwgMDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3A6IG5ld09mZnNldFksXHJcbiAgICAgIGxlZnQ6IG5ld09mZnNldFhcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgR3Vlc3R1cmVzLnByb3RvdHlwZS5saW1pdFBvc2l0aW9uID0gZnVuY3Rpb24gKG5ld09mZnNldFgsIG5ld09mZnNldFksIG5ld1dpZHRoLCBuZXdIZWlnaHQpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICB2YXIgY2FudmFzV2lkdGggPSBzZWxmLmNhbnZhc1dpZHRoO1xyXG4gICAgdmFyIGNhbnZhc0hlaWdodCA9IHNlbGYuY2FudmFzSGVpZ2h0O1xyXG5cclxuICAgIGlmIChuZXdXaWR0aCA+IGNhbnZhc1dpZHRoKSB7XHJcbiAgICAgIG5ld09mZnNldFggPSBuZXdPZmZzZXRYID4gMCA/IDAgOiBuZXdPZmZzZXRYO1xyXG4gICAgICBuZXdPZmZzZXRYID0gbmV3T2Zmc2V0WCA8IGNhbnZhc1dpZHRoIC0gbmV3V2lkdGggPyBjYW52YXNXaWR0aCAtIG5ld1dpZHRoIDogbmV3T2Zmc2V0WDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIENlbnRlciBob3Jpem9udGFsbHlcclxuICAgICAgbmV3T2Zmc2V0WCA9IE1hdGgubWF4KDAsIGNhbnZhc1dpZHRoIC8gMiAtIG5ld1dpZHRoIC8gMik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5ld0hlaWdodCA+IGNhbnZhc0hlaWdodCkge1xyXG4gICAgICBuZXdPZmZzZXRZID0gbmV3T2Zmc2V0WSA+IDAgPyAwIDogbmV3T2Zmc2V0WTtcclxuICAgICAgbmV3T2Zmc2V0WSA9IG5ld09mZnNldFkgPCBjYW52YXNIZWlnaHQgLSBuZXdIZWlnaHQgPyBjYW52YXNIZWlnaHQgLSBuZXdIZWlnaHQgOiBuZXdPZmZzZXRZO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gQ2VudGVyIHZlcnRpY2FsbHlcclxuICAgICAgbmV3T2Zmc2V0WSA9IE1hdGgubWF4KDAsIGNhbnZhc0hlaWdodCAvIDIgLSBuZXdIZWlnaHQgLyAyKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3A6IG5ld09mZnNldFksXHJcbiAgICAgIGxlZnQ6IG5ld09mZnNldFhcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgR3Vlc3R1cmVzLnByb3RvdHlwZS5vblpvb20gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgdG8gZ2V0IHBpbmNoIHJhdGlvIGFuZCBuZXcgd2lkdGggYW5kIGhlaWdodFxyXG4gICAgdmFyIGNvbnRlbnRTdGFydFBvcyA9IHNlbGYuY29udGVudFN0YXJ0UG9zO1xyXG5cclxuICAgIHZhciBjdXJyZW50V2lkdGggPSBjb250ZW50U3RhcnRQb3Mud2lkdGg7XHJcbiAgICB2YXIgY3VycmVudEhlaWdodCA9IGNvbnRlbnRTdGFydFBvcy5oZWlnaHQ7XHJcblxyXG4gICAgdmFyIGN1cnJlbnRPZmZzZXRYID0gY29udGVudFN0YXJ0UG9zLmxlZnQ7XHJcbiAgICB2YXIgY3VycmVudE9mZnNldFkgPSBjb250ZW50U3RhcnRQb3MudG9wO1xyXG5cclxuICAgIHZhciBlbmREaXN0YW5jZUJldHdlZW5GaW5nZXJzID0gZGlzdGFuY2Uoc2VsZi5uZXdQb2ludHNbMF0sIHNlbGYubmV3UG9pbnRzWzFdKTtcclxuXHJcbiAgICB2YXIgcGluY2hSYXRpbyA9IGVuZERpc3RhbmNlQmV0d2VlbkZpbmdlcnMgLyBzZWxmLnN0YXJ0RGlzdGFuY2VCZXR3ZWVuRmluZ2VycztcclxuXHJcbiAgICB2YXIgbmV3V2lkdGggPSBNYXRoLmZsb29yKGN1cnJlbnRXaWR0aCAqIHBpbmNoUmF0aW8pO1xyXG4gICAgdmFyIG5ld0hlaWdodCA9IE1hdGguZmxvb3IoY3VycmVudEhlaWdodCAqIHBpbmNoUmF0aW8pO1xyXG5cclxuICAgIC8vIFRoaXMgaXMgdGhlIHRyYW5zbGF0aW9uIGR1ZSB0byBwaW5jaC16b29taW5nXHJcbiAgICB2YXIgdHJhbnNsYXRlRnJvbVpvb21pbmdYID0gKGN1cnJlbnRXaWR0aCAtIG5ld1dpZHRoKSAqIHNlbGYucGVyY2VudGFnZU9mSW1hZ2VBdFBpbmNoUG9pbnRYO1xyXG4gICAgdmFyIHRyYW5zbGF0ZUZyb21ab29taW5nWSA9IChjdXJyZW50SGVpZ2h0IC0gbmV3SGVpZ2h0KSAqIHNlbGYucGVyY2VudGFnZU9mSW1hZ2VBdFBpbmNoUG9pbnRZO1xyXG5cclxuICAgIC8vIFBvaW50IGJldHdlZW4gdGhlIHR3byB0b3VjaGVzXHJcbiAgICB2YXIgY2VudGVyUG9pbnRFbmRYID0gKHNlbGYubmV3UG9pbnRzWzBdLnggKyBzZWxmLm5ld1BvaW50c1sxXS54KSAvIDIgLSAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpO1xyXG4gICAgdmFyIGNlbnRlclBvaW50RW5kWSA9IChzZWxmLm5ld1BvaW50c1swXS55ICsgc2VsZi5uZXdQb2ludHNbMV0ueSkgLyAyIC0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xyXG5cclxuICAgIC8vIEFuZCB0aGlzIGlzIHRoZSB0cmFuc2xhdGlvbiBkdWUgdG8gdHJhbnNsYXRpb24gb2YgdGhlIGNlbnRlcnBvaW50XHJcbiAgICAvLyBiZXR3ZWVuIHRoZSB0d28gZmluZ2Vyc1xyXG4gICAgdmFyIHRyYW5zbGF0ZUZyb21UcmFuc2xhdGluZ1ggPSBjZW50ZXJQb2ludEVuZFggLSBzZWxmLmNlbnRlclBvaW50U3RhcnRYO1xyXG4gICAgdmFyIHRyYW5zbGF0ZUZyb21UcmFuc2xhdGluZ1kgPSBjZW50ZXJQb2ludEVuZFkgLSBzZWxmLmNlbnRlclBvaW50U3RhcnRZO1xyXG5cclxuICAgIC8vIFRoZSBuZXcgb2Zmc2V0IGlzIHRoZSBvbGQvY3VycmVudCBvbmUgcGx1cyB0aGUgdG90YWwgdHJhbnNsYXRpb25cclxuICAgIHZhciBuZXdPZmZzZXRYID0gY3VycmVudE9mZnNldFggKyAodHJhbnNsYXRlRnJvbVpvb21pbmdYICsgdHJhbnNsYXRlRnJvbVRyYW5zbGF0aW5nWCk7XHJcbiAgICB2YXIgbmV3T2Zmc2V0WSA9IGN1cnJlbnRPZmZzZXRZICsgKHRyYW5zbGF0ZUZyb21ab29taW5nWSArIHRyYW5zbGF0ZUZyb21UcmFuc2xhdGluZ1kpO1xyXG5cclxuICAgIHZhciBuZXdQb3MgPSB7XHJcbiAgICAgIHRvcDogbmV3T2Zmc2V0WSxcclxuICAgICAgbGVmdDogbmV3T2Zmc2V0WCxcclxuICAgICAgc2NhbGVYOiBwaW5jaFJhdGlvLFxyXG4gICAgICBzY2FsZVk6IHBpbmNoUmF0aW9cclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5jYW5UYXAgPSBmYWxzZTtcclxuXHJcbiAgICBzZWxmLm5ld1dpZHRoID0gbmV3V2lkdGg7XHJcbiAgICBzZWxmLm5ld0hlaWdodCA9IG5ld0hlaWdodDtcclxuXHJcbiAgICBzZWxmLmNvbnRlbnRMYXN0UG9zID0gbmV3UG9zO1xyXG5cclxuICAgIGlmIChzZWxmLnJlcXVlc3RJZCkge1xyXG4gICAgICBjYW5jZWxBRnJhbWUoc2VsZi5yZXF1ZXN0SWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGYucmVxdWVzdElkID0gcmVxdWVzdEFGcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICQuZmFuY3lib3guc2V0VHJhbnNsYXRlKHNlbGYuJGNvbnRlbnQsIHNlbGYuY29udGVudExhc3RQb3MpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgR3Vlc3R1cmVzLnByb3RvdHlwZS5vbnRvdWNoZW5kID0gZnVuY3Rpb24gKGUpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICB2YXIgc3dpcGluZyA9IHNlbGYuaXNTd2lwaW5nO1xyXG4gICAgdmFyIHBhbm5pbmcgPSBzZWxmLmlzUGFubmluZztcclxuICAgIHZhciB6b29taW5nID0gc2VsZi5pc1pvb21pbmc7XHJcbiAgICB2YXIgc2Nyb2xsaW5nID0gc2VsZi5pc1Njcm9sbGluZztcclxuXHJcbiAgICBzZWxmLmVuZFBvaW50cyA9IGdldFBvaW50ZXJYWShlKTtcclxuICAgIHNlbGYuZE1zID0gTWF0aC5tYXgobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzZWxmLnN0YXJ0VGltZSwgMSk7XHJcblxyXG4gICAgc2VsZi4kY29udGFpbmVyLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtaXMtZ3JhYmJpbmdcIik7XHJcblxyXG4gICAgJChkb2N1bWVudCkub2ZmKFwiLmZiLnRvdWNoXCIpO1xyXG5cclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgc2VsZi5vbnNjcm9sbCwgdHJ1ZSk7XHJcblxyXG4gICAgaWYgKHNlbGYucmVxdWVzdElkKSB7XHJcbiAgICAgIGNhbmNlbEFGcmFtZShzZWxmLnJlcXVlc3RJZCk7XHJcblxyXG4gICAgICBzZWxmLnJlcXVlc3RJZCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZi5pc1N3aXBpbmcgPSBmYWxzZTtcclxuICAgIHNlbGYuaXNQYW5uaW5nID0gZmFsc2U7XHJcbiAgICBzZWxmLmlzWm9vbWluZyA9IGZhbHNlO1xyXG4gICAgc2VsZi5pc1Njcm9sbGluZyA9IGZhbHNlO1xyXG5cclxuICAgIHNlbGYuaW5zdGFuY2UuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChzZWxmLmNhblRhcCkge1xyXG4gICAgICByZXR1cm4gc2VsZi5vblRhcChlKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmLnNwZWVkID0gMTAwO1xyXG5cclxuICAgIC8vIFNwZWVkIGluIHB4L21zXHJcbiAgICBzZWxmLnZlbG9jaXR5WCA9IChzZWxmLmRpc3RhbmNlWCAvIHNlbGYuZE1zKSAqIDAuNTtcclxuICAgIHNlbGYudmVsb2NpdHlZID0gKHNlbGYuZGlzdGFuY2VZIC8gc2VsZi5kTXMpICogMC41O1xyXG5cclxuICAgIGlmIChwYW5uaW5nKSB7XHJcbiAgICAgIHNlbGYuZW5kUGFubmluZygpO1xyXG4gICAgfSBlbHNlIGlmICh6b29taW5nKSB7XHJcbiAgICAgIHNlbGYuZW5kWm9vbWluZygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2VsZi5lbmRTd2lwaW5nKHN3aXBpbmcsIHNjcm9sbGluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuO1xyXG4gIH07XHJcblxyXG4gIEd1ZXN0dXJlcy5wcm90b3R5cGUuZW5kU3dpcGluZyA9IGZ1bmN0aW9uIChzd2lwaW5nLCBzY3JvbGxpbmcpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgcmV0ID0gZmFsc2UsXHJcbiAgICAgIGxlbiA9IHNlbGYuaW5zdGFuY2UuZ3JvdXAubGVuZ3RoLFxyXG4gICAgICBkaXN0YW5jZVggPSBNYXRoLmFicyhzZWxmLmRpc3RhbmNlWCksXHJcbiAgICAgIGNhbkFkdmFuY2UgPSBzd2lwaW5nID09IFwieFwiICYmIGxlbiA+IDEgJiYgKChzZWxmLmRNcyA+IDEzMCAmJiBkaXN0YW5jZVggPiAxMCkgfHwgZGlzdGFuY2VYID4gNTApLFxyXG4gICAgICBzcGVlZFggPSAzMDA7XHJcblxyXG4gICAgc2VsZi5zbGlkZXJMYXN0UG9zID0gbnVsbDtcclxuXHJcbiAgICAvLyBDbG9zZSBpZiBzd2lwZWQgdmVydGljYWxseSAvIG5hdmlnYXRlIGlmIGhvcml6b250YWxseVxyXG4gICAgaWYgKHN3aXBpbmcgPT0gXCJ5XCIgJiYgIXNjcm9sbGluZyAmJiBNYXRoLmFicyhzZWxmLmRpc3RhbmNlWSkgPiA1MCkge1xyXG4gICAgICAvLyBDb250aW51ZSB2ZXJ0aWNhbCBtb3ZlbWVudFxyXG4gICAgICAkLmZhbmN5Ym94LmFuaW1hdGUoXHJcbiAgICAgICAgc2VsZi5pbnN0YW5jZS5jdXJyZW50LiRzbGlkZSwge1xyXG4gICAgICAgICAgdG9wOiBzZWxmLnNsaWRlclN0YXJ0UG9zLnRvcCArIHNlbGYuZGlzdGFuY2VZICsgc2VsZi52ZWxvY2l0eVkgKiAxNTAsXHJcbiAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICAyMDBcclxuICAgICAgKTtcclxuICAgICAgcmV0ID0gc2VsZi5pbnN0YW5jZS5jbG9zZSh0cnVlLCAyNTApO1xyXG4gICAgfSBlbHNlIGlmIChjYW5BZHZhbmNlICYmIHNlbGYuZGlzdGFuY2VYID4gMCkge1xyXG4gICAgICByZXQgPSBzZWxmLmluc3RhbmNlLnByZXZpb3VzKHNwZWVkWCk7XHJcbiAgICB9IGVsc2UgaWYgKGNhbkFkdmFuY2UgJiYgc2VsZi5kaXN0YW5jZVggPCAwKSB7XHJcbiAgICAgIHJldCA9IHNlbGYuaW5zdGFuY2UubmV4dChzcGVlZFgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZXQgPT09IGZhbHNlICYmIChzd2lwaW5nID09IFwieFwiIHx8IHN3aXBpbmcgPT0gXCJ5XCIpKSB7XHJcbiAgICAgIHNlbGYuaW5zdGFuY2UuY2VudGVyU2xpZGUoMjAwKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmLiRjb250YWluZXIucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1pcy1zbGlkaW5nXCIpO1xyXG4gIH07XHJcblxyXG4gIC8vIExpbWl0IHBhbm5pbmcgZnJvbSBlZGdlc1xyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIEd1ZXN0dXJlcy5wcm90b3R5cGUuZW5kUGFubmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgbmV3T2Zmc2V0WCxcclxuICAgICAgbmV3T2Zmc2V0WSxcclxuICAgICAgbmV3UG9zO1xyXG5cclxuICAgIGlmICghc2VsZi5jb250ZW50TGFzdFBvcykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNlbGYub3B0cy5tb21lbnR1bSA9PT0gZmFsc2UgfHwgc2VsZi5kTXMgPiAzNTApIHtcclxuICAgICAgbmV3T2Zmc2V0WCA9IHNlbGYuY29udGVudExhc3RQb3MubGVmdDtcclxuICAgICAgbmV3T2Zmc2V0WSA9IHNlbGYuY29udGVudExhc3RQb3MudG9wO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gQ29udGludWUgbW92ZW1lbnRcclxuICAgICAgbmV3T2Zmc2V0WCA9IHNlbGYuY29udGVudExhc3RQb3MubGVmdCArIHNlbGYudmVsb2NpdHlYICogNTAwO1xyXG4gICAgICBuZXdPZmZzZXRZID0gc2VsZi5jb250ZW50TGFzdFBvcy50b3AgKyBzZWxmLnZlbG9jaXR5WSAqIDUwMDtcclxuICAgIH1cclxuXHJcbiAgICBuZXdQb3MgPSBzZWxmLmxpbWl0UG9zaXRpb24obmV3T2Zmc2V0WCwgbmV3T2Zmc2V0WSwgc2VsZi5jb250ZW50U3RhcnRQb3Mud2lkdGgsIHNlbGYuY29udGVudFN0YXJ0UG9zLmhlaWdodCk7XHJcblxyXG4gICAgbmV3UG9zLndpZHRoID0gc2VsZi5jb250ZW50U3RhcnRQb3Mud2lkdGg7XHJcbiAgICBuZXdQb3MuaGVpZ2h0ID0gc2VsZi5jb250ZW50U3RhcnRQb3MuaGVpZ2h0O1xyXG5cclxuICAgICQuZmFuY3lib3guYW5pbWF0ZShzZWxmLiRjb250ZW50LCBuZXdQb3MsIDM2Nik7XHJcbiAgfTtcclxuXHJcbiAgR3Vlc3R1cmVzLnByb3RvdHlwZS5lbmRab29taW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHZhciBjdXJyZW50ID0gc2VsZi5pbnN0YW5jZS5jdXJyZW50O1xyXG5cclxuICAgIHZhciBuZXdPZmZzZXRYLCBuZXdPZmZzZXRZLCBuZXdQb3MsIHJlc2V0O1xyXG5cclxuICAgIHZhciBuZXdXaWR0aCA9IHNlbGYubmV3V2lkdGg7XHJcbiAgICB2YXIgbmV3SGVpZ2h0ID0gc2VsZi5uZXdIZWlnaHQ7XHJcblxyXG4gICAgaWYgKCFzZWxmLmNvbnRlbnRMYXN0UG9zKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBuZXdPZmZzZXRYID0gc2VsZi5jb250ZW50TGFzdFBvcy5sZWZ0O1xyXG4gICAgbmV3T2Zmc2V0WSA9IHNlbGYuY29udGVudExhc3RQb3MudG9wO1xyXG5cclxuICAgIHJlc2V0ID0ge1xyXG4gICAgICB0b3A6IG5ld09mZnNldFksXHJcbiAgICAgIGxlZnQ6IG5ld09mZnNldFgsXHJcbiAgICAgIHdpZHRoOiBuZXdXaWR0aCxcclxuICAgICAgaGVpZ2h0OiBuZXdIZWlnaHQsXHJcbiAgICAgIHNjYWxlWDogMSxcclxuICAgICAgc2NhbGVZOiAxXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJlc2V0IHNjYWxleC9zY2FsZVkgdmFsdWVzOyB0aGlzIGhlbHBzIGZvciBwZXJmb21hbmNlIGFuZCBkb2VzIG5vdCBicmVhayBhbmltYXRpb25cclxuICAgICQuZmFuY3lib3guc2V0VHJhbnNsYXRlKHNlbGYuJGNvbnRlbnQsIHJlc2V0KTtcclxuXHJcbiAgICBpZiAobmV3V2lkdGggPCBzZWxmLmNhbnZhc1dpZHRoICYmIG5ld0hlaWdodCA8IHNlbGYuY2FudmFzSGVpZ2h0KSB7XHJcbiAgICAgIHNlbGYuaW5zdGFuY2Uuc2NhbGVUb0ZpdCgxNTApO1xyXG4gICAgfSBlbHNlIGlmIChuZXdXaWR0aCA+IGN1cnJlbnQud2lkdGggfHwgbmV3SGVpZ2h0ID4gY3VycmVudC5oZWlnaHQpIHtcclxuICAgICAgc2VsZi5pbnN0YW5jZS5zY2FsZVRvQWN0dWFsKHNlbGYuY2VudGVyUG9pbnRTdGFydFgsIHNlbGYuY2VudGVyUG9pbnRTdGFydFksIDE1MCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuZXdQb3MgPSBzZWxmLmxpbWl0UG9zaXRpb24obmV3T2Zmc2V0WCwgbmV3T2Zmc2V0WSwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XHJcblxyXG4gICAgICAkLmZhbmN5Ym94LmFuaW1hdGUoc2VsZi4kY29udGVudCwgbmV3UG9zLCAxNTApO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIEd1ZXN0dXJlcy5wcm90b3R5cGUub25UYXAgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdmFyICR0YXJnZXQgPSAkKGUudGFyZ2V0KTtcclxuXHJcbiAgICB2YXIgaW5zdGFuY2UgPSBzZWxmLmluc3RhbmNlO1xyXG4gICAgdmFyIGN1cnJlbnQgPSBpbnN0YW5jZS5jdXJyZW50O1xyXG5cclxuICAgIHZhciBlbmRQb2ludHMgPSAoZSAmJiBnZXRQb2ludGVyWFkoZSkpIHx8IHNlbGYuc3RhcnRQb2ludHM7XHJcblxyXG4gICAgdmFyIHRhcFggPSBlbmRQb2ludHNbMF0gPyBlbmRQb2ludHNbMF0ueCAtICQod2luZG93KS5zY3JvbGxMZWZ0KCkgLSBzZWxmLnN0YWdlUG9zLmxlZnQgOiAwO1xyXG4gICAgdmFyIHRhcFkgPSBlbmRQb2ludHNbMF0gPyBlbmRQb2ludHNbMF0ueSAtICQod2luZG93KS5zY3JvbGxUb3AoKSAtIHNlbGYuc3RhZ2VQb3MudG9wIDogMDtcclxuXHJcbiAgICB2YXIgd2hlcmU7XHJcblxyXG4gICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAocHJlZml4KSB7XHJcbiAgICAgIHZhciBhY3Rpb24gPSBjdXJyZW50Lm9wdHNbcHJlZml4XTtcclxuXHJcbiAgICAgIGlmICgkLmlzRnVuY3Rpb24oYWN0aW9uKSkge1xyXG4gICAgICAgIGFjdGlvbiA9IGFjdGlvbi5hcHBseShpbnN0YW5jZSwgW2N1cnJlbnQsIGVdKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XHJcbiAgICAgICAgY2FzZSBcImNsb3NlXCI6XHJcbiAgICAgICAgICBpbnN0YW5jZS5jbG9zZShzZWxmLnN0YXJ0RXZlbnQpO1xyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIFwidG9nZ2xlQ29udHJvbHNcIjpcclxuICAgICAgICAgIGluc3RhbmNlLnRvZ2dsZUNvbnRyb2xzKCk7XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgXCJuZXh0XCI6XHJcbiAgICAgICAgICBpbnN0YW5jZS5uZXh0KCk7XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgXCJuZXh0T3JDbG9zZVwiOlxyXG4gICAgICAgICAgaWYgKGluc3RhbmNlLmdyb3VwLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UubmV4dCgpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuY2xvc2Uoc2VsZi5zdGFydEV2ZW50KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSBcInpvb21cIjpcclxuICAgICAgICAgIGlmIChjdXJyZW50LnR5cGUgPT0gXCJpbWFnZVwiICYmIChjdXJyZW50LmlzTG9hZGVkIHx8IGN1cnJlbnQuJGdob3N0KSkge1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuY2FuUGFuKCkpIHtcclxuICAgICAgICAgICAgICBpbnN0YW5jZS5zY2FsZVRvRml0KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UuaXNTY2FsZWREb3duKCkpIHtcclxuICAgICAgICAgICAgICBpbnN0YW5jZS5zY2FsZVRvQWN0dWFsKHRhcFgsIHRhcFkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluc3RhbmNlLmdyb3VwLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgICBpbnN0YW5jZS5jbG9zZShzZWxmLnN0YXJ0RXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gSWdub3JlIHJpZ2h0IGNsaWNrXHJcbiAgICBpZiAoZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5idXR0b24gPT0gMikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2tpcCBpZiBjbGlja2VkIG9uIHRoZSBzY3JvbGxiYXJcclxuICAgIGlmICghJHRhcmdldC5pcyhcImltZ1wiKSAmJiB0YXBYID4gJHRhcmdldFswXS5jbGllbnRXaWR0aCArICR0YXJnZXQub2Zmc2V0KCkubGVmdCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgd2hlcmUgaXMgY2xpY2tlZFxyXG4gICAgaWYgKCR0YXJnZXQuaXMoXCIuZmFuY3lib3gtYmcsLmZhbmN5Ym94LWlubmVyLC5mYW5jeWJveC1vdXRlciwuZmFuY3lib3gtY29udGFpbmVyXCIpKSB7XHJcbiAgICAgIHdoZXJlID0gXCJPdXRzaWRlXCI7XHJcbiAgICB9IGVsc2UgaWYgKCR0YXJnZXQuaXMoXCIuZmFuY3lib3gtc2xpZGVcIikpIHtcclxuICAgICAgd2hlcmUgPSBcIlNsaWRlXCI7XHJcbiAgICB9IGVsc2UgaWYgKFxyXG4gICAgICBpbnN0YW5jZS5jdXJyZW50LiRjb250ZW50ICYmXHJcbiAgICAgIGluc3RhbmNlLmN1cnJlbnQuJGNvbnRlbnRcclxuICAgICAgLmZpbmQoJHRhcmdldClcclxuICAgICAgLmFkZEJhY2soKVxyXG4gICAgICAuZmlsdGVyKCR0YXJnZXQpLmxlbmd0aFxyXG4gICAgKSB7XHJcbiAgICAgIHdoZXJlID0gXCJDb250ZW50XCI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGRvdWJsZSB0YXBcclxuICAgIGlmIChzZWxmLnRhcHBlZCkge1xyXG4gICAgICAvLyBTdG9wIHByZXZpb3VzbHkgY3JlYXRlZCBzaW5nbGUgdGFwXHJcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLnRhcHBlZCk7XHJcbiAgICAgIHNlbGYudGFwcGVkID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIFNraXAgaWYgZGlzdGFuY2UgYmV0d2VlbiB0YXBzIGlzIHRvbyBiaWdcclxuICAgICAgaWYgKE1hdGguYWJzKHRhcFggLSBzZWxmLnRhcFgpID4gNTAgfHwgTWF0aC5hYnModGFwWSAtIHNlbGYudGFwWSkgPiA1MCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBPSywgbm93IHdlIGFzc3VtZSB0aGF0IHRoaXMgaXMgYSBkb3VibGUtdGFwXHJcbiAgICAgIHByb2Nlc3MoXCJkYmxjbGlja1wiICsgd2hlcmUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gU2luZ2xlIHRhcCB3aWxsIGJlIHByb2Nlc3NlZCBpZiB1c2VyIGhhcyBub3QgY2xpY2tlZCBzZWNvbmQgdGltZSB3aXRoaW4gMzAwbXNcclxuICAgICAgLy8gb3IgdGhlcmUgaXMgbm8gbmVlZCB0byB3YWl0IGZvciBkb3VibGUtdGFwXHJcbiAgICAgIHNlbGYudGFwWCA9IHRhcFg7XHJcbiAgICAgIHNlbGYudGFwWSA9IHRhcFk7XHJcblxyXG4gICAgICBpZiAoY3VycmVudC5vcHRzW1wiZGJsY2xpY2tcIiArIHdoZXJlXSAmJiBjdXJyZW50Lm9wdHNbXCJkYmxjbGlja1wiICsgd2hlcmVdICE9PSBjdXJyZW50Lm9wdHNbXCJjbGlja1wiICsgd2hlcmVdKSB7XHJcbiAgICAgICAgc2VsZi50YXBwZWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHNlbGYudGFwcGVkID0gbnVsbDtcclxuXHJcbiAgICAgICAgICBpZiAoIWluc3RhbmNlLmlzQW5pbWF0aW5nKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3MoXCJjbGlja1wiICsgd2hlcmUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIDUwMCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcHJvY2VzcyhcImNsaWNrXCIgKyB3aGVyZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAkKGRvY3VtZW50KVxyXG4gICAgLm9uKFwib25BY3RpdmF0ZS5mYlwiLCBmdW5jdGlvbiAoZSwgaW5zdGFuY2UpIHtcclxuICAgICAgaWYgKGluc3RhbmNlICYmICFpbnN0YW5jZS5HdWVzdHVyZXMpIHtcclxuICAgICAgICBpbnN0YW5jZS5HdWVzdHVyZXMgPSBuZXcgR3Vlc3R1cmVzKGluc3RhbmNlKTtcclxuICAgICAgfVxyXG4gICAgfSlcclxuICAgIC5vbihcImJlZm9yZUNsb3NlLmZiXCIsIGZ1bmN0aW9uIChlLCBpbnN0YW5jZSkge1xyXG4gICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuR3Vlc3R1cmVzKSB7XHJcbiAgICAgICAgaW5zdGFuY2UuR3Vlc3R1cmVzLmRlc3Ryb3koKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbn0pKHdpbmRvdywgZG9jdW1lbnQsIGpRdWVyeSk7XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vL1xyXG4vLyBTbGlkZVNob3dcclxuLy8gRW5hYmxlcyBzbGlkZXNob3cgZnVuY3Rpb25hbGl0eVxyXG4vL1xyXG4vLyBFeGFtcGxlIG9mIHVzYWdlOlxyXG4vLyAkLmZhbmN5Ym94LmdldEluc3RhbmNlKCkuU2xpZGVTaG93LnN0YXJ0KClcclxuLy9cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuKGZ1bmN0aW9uIChkb2N1bWVudCwgJCkge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAkLmV4dGVuZCh0cnVlLCAkLmZhbmN5Ym94LmRlZmF1bHRzLCB7XHJcbiAgICBidG5UcGw6IHtcclxuICAgICAgc2xpZGVTaG93OiAnPGJ1dHRvbiBkYXRhLWZhbmN5Ym94LXBsYXkgY2xhc3M9XCJmYW5jeWJveC1idXR0b24gZmFuY3lib3gtYnV0dG9uLS1wbGF5XCIgdGl0bGU9XCJ7e1BMQVlfU1RBUlR9fVwiPicgK1xyXG4gICAgICAgICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggZD1cIk02LjUgNS40djEzLjJsMTEtNi42elwiLz48L3N2Zz4nICtcclxuICAgICAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNOC4zMyA1Ljc1aDIuMnYxMi41aC0yLjJWNS43NXptNS4xNSAwaDIuMnYxMi41aC0yLjJWNS43NXpcIi8+PC9zdmc+JyArXHJcbiAgICAgICAgXCI8L2J1dHRvbj5cIlxyXG4gICAgfSxcclxuICAgIHNsaWRlU2hvdzoge1xyXG4gICAgICBhdXRvU3RhcnQ6IGZhbHNlLFxyXG4gICAgICBzcGVlZDogMzAwMCxcclxuICAgICAgcHJvZ3Jlc3M6IHRydWVcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgdmFyIFNsaWRlU2hvdyA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xyXG4gICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgdGhpcy5pbml0KCk7XHJcbiAgfTtcclxuXHJcbiAgJC5leHRlbmQoU2xpZGVTaG93LnByb3RvdHlwZSwge1xyXG4gICAgdGltZXI6IG51bGwsXHJcbiAgICBpc0FjdGl2ZTogZmFsc2UsXHJcbiAgICAkYnV0dG9uOiBudWxsLFxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIGluc3RhbmNlID0gc2VsZi5pbnN0YW5jZSxcclxuICAgICAgICBvcHRzID0gaW5zdGFuY2UuZ3JvdXBbaW5zdGFuY2UuY3VyckluZGV4XS5vcHRzLnNsaWRlU2hvdztcclxuXHJcbiAgICAgIHNlbGYuJGJ1dHRvbiA9IGluc3RhbmNlLiRyZWZzLnRvb2xiYXIuZmluZChcIltkYXRhLWZhbmN5Ym94LXBsYXldXCIpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYudG9nZ2xlKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKGluc3RhbmNlLmdyb3VwLmxlbmd0aCA8IDIgfHwgIW9wdHMpIHtcclxuICAgICAgICBzZWxmLiRidXR0b24uaGlkZSgpO1xyXG4gICAgICB9IGVsc2UgaWYgKG9wdHMucHJvZ3Jlc3MpIHtcclxuICAgICAgICBzZWxmLiRwcm9ncmVzcyA9ICQoJzxkaXYgY2xhc3M9XCJmYW5jeWJveC1wcm9ncmVzc1wiPjwvZGl2PicpLmFwcGVuZFRvKGluc3RhbmNlLiRyZWZzLmlubmVyKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uIChmb3JjZSkge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgaW5zdGFuY2UgPSBzZWxmLmluc3RhbmNlLFxyXG4gICAgICAgIGN1cnJlbnQgPSBpbnN0YW5jZS5jdXJyZW50O1xyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgcmVhY2hlZCBsYXN0IGVsZW1lbnRcclxuICAgICAgaWYgKGN1cnJlbnQgJiYgKGZvcmNlID09PSB0cnVlIHx8IGN1cnJlbnQub3B0cy5sb29wIHx8IGluc3RhbmNlLmN1cnJJbmRleCA8IGluc3RhbmNlLmdyb3VwLmxlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgaWYgKHNlbGYuaXNBY3RpdmUgJiYgY3VycmVudC5jb250ZW50VHlwZSAhPT0gXCJ2aWRlb1wiKSB7XHJcbiAgICAgICAgICBpZiAoc2VsZi4kcHJvZ3Jlc3MpIHtcclxuICAgICAgICAgICAgJC5mYW5jeWJveC5hbmltYXRlKHNlbGYuJHByb2dyZXNzLnNob3coKSwge1xyXG4gICAgICAgICAgICAgIHNjYWxlWDogMVxyXG4gICAgICAgICAgICB9LCBjdXJyZW50Lm9wdHMuc2xpZGVTaG93LnNwZWVkKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzZWxmLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghaW5zdGFuY2UuY3VycmVudC5vcHRzLmxvb3AgJiYgaW5zdGFuY2UuY3VycmVudC5pbmRleCA9PSBpbnN0YW5jZS5ncm91cC5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgaW5zdGFuY2UuanVtcFRvKDApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGluc3RhbmNlLm5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSwgY3VycmVudC5vcHRzLnNsaWRlU2hvdy5zcGVlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlbGYuc3RvcCgpO1xyXG4gICAgICAgIGluc3RhbmNlLmlkbGVTZWNvbmRzQ291bnRlciA9IDA7XHJcbiAgICAgICAgaW5zdGFuY2Uuc2hvd0NvbnRyb2xzKCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZXIpO1xyXG5cclxuICAgICAgc2VsZi50aW1lciA9IG51bGw7XHJcblxyXG4gICAgICBpZiAoc2VsZi4kcHJvZ3Jlc3MpIHtcclxuICAgICAgICBzZWxmLiRwcm9ncmVzcy5yZW1vdmVBdHRyKFwic3R5bGVcIikuaGlkZSgpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICBjdXJyZW50ID0gc2VsZi5pbnN0YW5jZS5jdXJyZW50O1xyXG5cclxuICAgICAgaWYgKGN1cnJlbnQpIHtcclxuICAgICAgICBzZWxmLiRidXR0b25cclxuICAgICAgICAgIC5hdHRyKFwidGl0bGVcIiwgKGN1cnJlbnQub3B0cy5pMThuW2N1cnJlbnQub3B0cy5sYW5nXSB8fCBjdXJyZW50Lm9wdHMuaTE4bi5lbikuUExBWV9TVE9QKVxyXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtYnV0dG9uLS1wbGF5XCIpXHJcbiAgICAgICAgICAuYWRkQ2xhc3MoXCJmYW5jeWJveC1idXR0b24tLXBhdXNlXCIpO1xyXG5cclxuICAgICAgICBzZWxmLmlzQWN0aXZlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnQuaXNDb21wbGV0ZSkge1xyXG4gICAgICAgICAgc2VsZi5zZXQodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZWxmLmluc3RhbmNlLnRyaWdnZXIoXCJvblNsaWRlU2hvd0NoYW5nZVwiLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICBjdXJyZW50ID0gc2VsZi5pbnN0YW5jZS5jdXJyZW50O1xyXG5cclxuICAgICAgc2VsZi5jbGVhcigpO1xyXG5cclxuICAgICAgc2VsZi4kYnV0dG9uXHJcbiAgICAgICAgLmF0dHIoXCJ0aXRsZVwiLCAoY3VycmVudC5vcHRzLmkxOG5bY3VycmVudC5vcHRzLmxhbmddIHx8IGN1cnJlbnQub3B0cy5pMThuLmVuKS5QTEFZX1NUQVJUKVxyXG4gICAgICAgIC5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LWJ1dHRvbi0tcGF1c2VcIilcclxuICAgICAgICAuYWRkQ2xhc3MoXCJmYW5jeWJveC1idXR0b24tLXBsYXlcIik7XHJcblxyXG4gICAgICBzZWxmLmlzQWN0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgICBzZWxmLmluc3RhbmNlLnRyaWdnZXIoXCJvblNsaWRlU2hvd0NoYW5nZVwiLCBmYWxzZSk7XHJcblxyXG4gICAgICBpZiAoc2VsZi4kcHJvZ3Jlc3MpIHtcclxuICAgICAgICBzZWxmLiRwcm9ncmVzcy5yZW1vdmVBdHRyKFwic3R5bGVcIikuaGlkZSgpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHRvZ2dsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoc2VsZi5pc0FjdGl2ZSkge1xyXG4gICAgICAgIHNlbGYuc3RvcCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlbGYuc3RhcnQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAkKGRvY3VtZW50KS5vbih7XHJcbiAgICBcIm9uSW5pdC5mYlwiOiBmdW5jdGlvbiAoZSwgaW5zdGFuY2UpIHtcclxuICAgICAgaWYgKGluc3RhbmNlICYmICFpbnN0YW5jZS5TbGlkZVNob3cpIHtcclxuICAgICAgICBpbnN0YW5jZS5TbGlkZVNob3cgPSBuZXcgU2xpZGVTaG93KGluc3RhbmNlKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBcImJlZm9yZVNob3cuZmJcIjogZnVuY3Rpb24gKGUsIGluc3RhbmNlLCBjdXJyZW50LCBmaXJzdFJ1bikge1xyXG4gICAgICB2YXIgU2xpZGVTaG93ID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuU2xpZGVTaG93O1xyXG5cclxuICAgICAgaWYgKGZpcnN0UnVuKSB7XHJcbiAgICAgICAgaWYgKFNsaWRlU2hvdyAmJiBjdXJyZW50Lm9wdHMuc2xpZGVTaG93LmF1dG9TdGFydCkge1xyXG4gICAgICAgICAgU2xpZGVTaG93LnN0YXJ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKFNsaWRlU2hvdyAmJiBTbGlkZVNob3cuaXNBY3RpdmUpIHtcclxuICAgICAgICBTbGlkZVNob3cuY2xlYXIoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBcImFmdGVyU2hvdy5mYlwiOiBmdW5jdGlvbiAoZSwgaW5zdGFuY2UsIGN1cnJlbnQpIHtcclxuICAgICAgdmFyIFNsaWRlU2hvdyA9IGluc3RhbmNlICYmIGluc3RhbmNlLlNsaWRlU2hvdztcclxuXHJcbiAgICAgIGlmIChTbGlkZVNob3cgJiYgU2xpZGVTaG93LmlzQWN0aXZlKSB7XHJcbiAgICAgICAgU2xpZGVTaG93LnNldCgpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIFwiYWZ0ZXJLZXlkb3duLmZiXCI6IGZ1bmN0aW9uIChlLCBpbnN0YW5jZSwgY3VycmVudCwga2V5cHJlc3MsIGtleWNvZGUpIHtcclxuICAgICAgdmFyIFNsaWRlU2hvdyA9IGluc3RhbmNlICYmIGluc3RhbmNlLlNsaWRlU2hvdztcclxuXHJcbiAgICAgIC8vIFwiUFwiIG9yIFNwYWNlYmFyXHJcbiAgICAgIGlmIChTbGlkZVNob3cgJiYgY3VycmVudC5vcHRzLnNsaWRlU2hvdyAmJiAoa2V5Y29kZSA9PT0gODAgfHwga2V5Y29kZSA9PT0gMzIpICYmICEkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmlzKFwiYnV0dG9uLGEsaW5wdXRcIikpIHtcclxuICAgICAgICBrZXlwcmVzcy5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICBTbGlkZVNob3cudG9nZ2xlKCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgXCJiZWZvcmVDbG9zZS5mYiBvbkRlYWN0aXZhdGUuZmJcIjogZnVuY3Rpb24gKGUsIGluc3RhbmNlKSB7XHJcbiAgICAgIHZhciBTbGlkZVNob3cgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5TbGlkZVNob3c7XHJcblxyXG4gICAgICBpZiAoU2xpZGVTaG93KSB7XHJcbiAgICAgICAgU2xpZGVTaG93LnN0b3AoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBQYWdlIFZpc2liaWxpdHkgQVBJIHRvIHBhdXNlIHNsaWRlc2hvdyB3aGVuIHdpbmRvdyBpcyBub3QgYWN0aXZlXHJcbiAgJChkb2N1bWVudCkub24oXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBpbnN0YW5jZSA9ICQuZmFuY3lib3guZ2V0SW5zdGFuY2UoKSxcclxuICAgICAgU2xpZGVTaG93ID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuU2xpZGVTaG93O1xyXG5cclxuICAgIGlmIChTbGlkZVNob3cgJiYgU2xpZGVTaG93LmlzQWN0aXZlKSB7XHJcbiAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcclxuICAgICAgICBTbGlkZVNob3cuY2xlYXIoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBTbGlkZVNob3cuc2V0KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxufSkoZG9jdW1lbnQsIGpRdWVyeSk7XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vL1xyXG4vLyBGdWxsU2NyZWVuXHJcbi8vIEFkZHMgZnVsbHNjcmVlbiBmdW5jdGlvbmFsaXR5XHJcbi8vXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbihmdW5jdGlvbiAoZG9jdW1lbnQsICQpIHtcclxuICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgLy8gQ29sbGVjdGlvbiBvZiBtZXRob2RzIHN1cHBvcnRlZCBieSB1c2VyIGJyb3dzZXJcclxuICB2YXIgZm4gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGZuTWFwID0gW1xyXG4gICAgICBbXCJyZXF1ZXN0RnVsbHNjcmVlblwiLCBcImV4aXRGdWxsc2NyZWVuXCIsIFwiZnVsbHNjcmVlbkVsZW1lbnRcIiwgXCJmdWxsc2NyZWVuRW5hYmxlZFwiLCBcImZ1bGxzY3JlZW5jaGFuZ2VcIiwgXCJmdWxsc2NyZWVuZXJyb3JcIl0sXHJcbiAgICAgIC8vIG5ldyBXZWJLaXRcclxuICAgICAgW1xyXG4gICAgICAgIFwid2Via2l0UmVxdWVzdEZ1bGxzY3JlZW5cIixcclxuICAgICAgICBcIndlYmtpdEV4aXRGdWxsc2NyZWVuXCIsXHJcbiAgICAgICAgXCJ3ZWJraXRGdWxsc2NyZWVuRWxlbWVudFwiLFxyXG4gICAgICAgIFwid2Via2l0RnVsbHNjcmVlbkVuYWJsZWRcIixcclxuICAgICAgICBcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIixcclxuICAgICAgICBcIndlYmtpdGZ1bGxzY3JlZW5lcnJvclwiXHJcbiAgICAgIF0sXHJcbiAgICAgIC8vIG9sZCBXZWJLaXQgKFNhZmFyaSA1LjEpXHJcbiAgICAgIFtcclxuICAgICAgICBcIndlYmtpdFJlcXVlc3RGdWxsU2NyZWVuXCIsXHJcbiAgICAgICAgXCJ3ZWJraXRDYW5jZWxGdWxsU2NyZWVuXCIsXHJcbiAgICAgICAgXCJ3ZWJraXRDdXJyZW50RnVsbFNjcmVlbkVsZW1lbnRcIixcclxuICAgICAgICBcIndlYmtpdENhbmNlbEZ1bGxTY3JlZW5cIixcclxuICAgICAgICBcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIixcclxuICAgICAgICBcIndlYmtpdGZ1bGxzY3JlZW5lcnJvclwiXHJcbiAgICAgIF0sXHJcbiAgICAgIFtcclxuICAgICAgICBcIm1velJlcXVlc3RGdWxsU2NyZWVuXCIsXHJcbiAgICAgICAgXCJtb3pDYW5jZWxGdWxsU2NyZWVuXCIsXHJcbiAgICAgICAgXCJtb3pGdWxsU2NyZWVuRWxlbWVudFwiLFxyXG4gICAgICAgIFwibW96RnVsbFNjcmVlbkVuYWJsZWRcIixcclxuICAgICAgICBcIm1vemZ1bGxzY3JlZW5jaGFuZ2VcIixcclxuICAgICAgICBcIm1vemZ1bGxzY3JlZW5lcnJvclwiXHJcbiAgICAgIF0sXHJcbiAgICAgIFtcIm1zUmVxdWVzdEZ1bGxzY3JlZW5cIiwgXCJtc0V4aXRGdWxsc2NyZWVuXCIsIFwibXNGdWxsc2NyZWVuRWxlbWVudFwiLCBcIm1zRnVsbHNjcmVlbkVuYWJsZWRcIiwgXCJNU0Z1bGxzY3JlZW5DaGFuZ2VcIiwgXCJNU0Z1bGxzY3JlZW5FcnJvclwiXVxyXG4gICAgXTtcclxuXHJcbiAgICB2YXIgcmV0ID0ge307XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbk1hcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgdmFsID0gZm5NYXBbaV07XHJcblxyXG4gICAgICBpZiAodmFsICYmIHZhbFsxXSBpbiBkb2N1bWVudCkge1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICByZXRbZm5NYXBbMF1bal1dID0gdmFsW2pdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9KSgpO1xyXG5cclxuICBpZiAoZm4pIHtcclxuICAgIHZhciBGdWxsU2NyZWVuID0ge1xyXG4gICAgICByZXF1ZXN0OiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgIGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuXHJcbiAgICAgICAgZWxlbVtmbi5yZXF1ZXN0RnVsbHNjcmVlbl0oZWxlbS5BTExPV19LRVlCT0FSRF9JTlBVVCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGV4aXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBkb2N1bWVudFtmbi5leGl0RnVsbHNjcmVlbl0oKTtcclxuICAgICAgfSxcclxuICAgICAgdG9nZ2xlOiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgIGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKCkpIHtcclxuICAgICAgICAgIHRoaXMuZXhpdCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnJlcXVlc3QoZWxlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBpc0Z1bGxzY3JlZW46IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gQm9vbGVhbihkb2N1bWVudFtmbi5mdWxsc2NyZWVuRWxlbWVudF0pO1xyXG4gICAgICB9LFxyXG4gICAgICBlbmFibGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oZG9jdW1lbnRbZm4uZnVsbHNjcmVlbkVuYWJsZWRdKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAkLmV4dGVuZCh0cnVlLCAkLmZhbmN5Ym94LmRlZmF1bHRzLCB7XHJcbiAgICAgIGJ0blRwbDoge1xyXG4gICAgICAgIGZ1bGxTY3JlZW46ICc8YnV0dG9uIGRhdGEtZmFuY3lib3gtZnVsbHNjcmVlbiBjbGFzcz1cImZhbmN5Ym94LWJ1dHRvbiBmYW5jeWJveC1idXR0b24tLWZzZW50ZXJcIiB0aXRsZT1cInt7RlVMTF9TQ1JFRU59fVwiPicgK1xyXG4gICAgICAgICAgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTcgMTRINXY1aDV2LTJIN3YtM3ptLTItNGgyVjdoM1Y1SDV2NXptMTIgN2gtM3YyaDV2LTVoLTJ2M3pNMTQgNXYyaDN2M2gyVjVoLTV6XCIvPjwvc3ZnPicgK1xyXG4gICAgICAgICAgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTUgMTZoM3YzaDJ2LTVINXptMy04SDV2Mmg1VjVIOHptNiAxMWgydi0zaDN2LTJoLTV6bTItMTFWNWgtMnY1aDVWOHpcIi8+PC9zdmc+JyArXHJcbiAgICAgICAgICBcIjwvYnV0dG9uPlwiXHJcbiAgICAgIH0sXHJcbiAgICAgIGZ1bGxTY3JlZW46IHtcclxuICAgICAgICBhdXRvU3RhcnQ6IGZhbHNlXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgICQoZG9jdW1lbnQpLm9uKGZuLmZ1bGxzY3JlZW5jaGFuZ2UsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGlzRnVsbHNjcmVlbiA9IEZ1bGxTY3JlZW4uaXNGdWxsc2NyZWVuKCksXHJcbiAgICAgICAgaW5zdGFuY2UgPSAkLmZhbmN5Ym94LmdldEluc3RhbmNlKCk7XHJcblxyXG4gICAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAvLyBJZiBpbWFnZSBpcyB6b29taW5nLCB0aGVuIGZvcmNlIHRvIHN0b3AgYW5kIHJlcG9zaXRpb24gcHJvcGVybHlcclxuICAgICAgICBpZiAoaW5zdGFuY2UuY3VycmVudCAmJiBpbnN0YW5jZS5jdXJyZW50LnR5cGUgPT09IFwiaW1hZ2VcIiAmJiBpbnN0YW5jZS5pc0FuaW1hdGluZykge1xyXG4gICAgICAgICAgaW5zdGFuY2UuaXNBbmltYXRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICBpbnN0YW5jZS51cGRhdGUodHJ1ZSwgdHJ1ZSwgMCk7XHJcblxyXG4gICAgICAgICAgaWYgKCFpbnN0YW5jZS5pc0NvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnN0YW5jZS50cmlnZ2VyKFwib25GdWxsc2NyZWVuQ2hhbmdlXCIsIGlzRnVsbHNjcmVlbik7XHJcblxyXG4gICAgICAgIGluc3RhbmNlLiRyZWZzLmNvbnRhaW5lci50b2dnbGVDbGFzcyhcImZhbmN5Ym94LWlzLWZ1bGxzY3JlZW5cIiwgaXNGdWxsc2NyZWVuKTtcclxuXHJcbiAgICAgICAgaW5zdGFuY2UuJHJlZnMudG9vbGJhclxyXG4gICAgICAgICAgLmZpbmQoXCJbZGF0YS1mYW5jeWJveC1mdWxsc2NyZWVuXVwiKVxyXG4gICAgICAgICAgLnRvZ2dsZUNsYXNzKFwiZmFuY3lib3gtYnV0dG9uLS1mc2VudGVyXCIsICFpc0Z1bGxzY3JlZW4pXHJcbiAgICAgICAgICAudG9nZ2xlQ2xhc3MoXCJmYW5jeWJveC1idXR0b24tLWZzZXhpdFwiLCBpc0Z1bGxzY3JlZW4pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gICQoZG9jdW1lbnQpLm9uKHtcclxuICAgIFwib25Jbml0LmZiXCI6IGZ1bmN0aW9uIChlLCBpbnN0YW5jZSkge1xyXG4gICAgICB2YXIgJGNvbnRhaW5lcjtcclxuXHJcbiAgICAgIGlmICghZm4pIHtcclxuICAgICAgICBpbnN0YW5jZS4kcmVmcy50b29sYmFyLmZpbmQoXCJbZGF0YS1mYW5jeWJveC1mdWxsc2NyZWVuXVwiKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuZ3JvdXBbaW5zdGFuY2UuY3VyckluZGV4XS5vcHRzLmZ1bGxTY3JlZW4pIHtcclxuICAgICAgICAkY29udGFpbmVyID0gaW5zdGFuY2UuJHJlZnMuY29udGFpbmVyO1xyXG5cclxuICAgICAgICAkY29udGFpbmVyLm9uKFwiY2xpY2suZmItZnVsbHNjcmVlblwiLCBcIltkYXRhLWZhbmN5Ym94LWZ1bGxzY3JlZW5dXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgIEZ1bGxTY3JlZW4udG9nZ2xlKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5vcHRzLmZ1bGxTY3JlZW4gJiYgaW5zdGFuY2Uub3B0cy5mdWxsU2NyZWVuLmF1dG9TdGFydCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgRnVsbFNjcmVlbi5yZXF1ZXN0KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFeHBvc2UgQVBJXHJcbiAgICAgICAgaW5zdGFuY2UuRnVsbFNjcmVlbiA9IEZ1bGxTY3JlZW47XHJcbiAgICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICBpbnN0YW5jZS4kcmVmcy50b29sYmFyLmZpbmQoXCJbZGF0YS1mYW5jeWJveC1mdWxsc2NyZWVuXVwiKS5oaWRlKCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgXCJhZnRlcktleWRvd24uZmJcIjogZnVuY3Rpb24gKGUsIGluc3RhbmNlLCBjdXJyZW50LCBrZXlwcmVzcywga2V5Y29kZSkge1xyXG4gICAgICAvLyBcIkZcIlxyXG4gICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuRnVsbFNjcmVlbiAmJiBrZXljb2RlID09PSA3MCkge1xyXG4gICAgICAgIGtleXByZXNzLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIGluc3RhbmNlLkZ1bGxTY3JlZW4udG9nZ2xlKCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgXCJiZWZvcmVDbG9zZS5mYlwiOiBmdW5jdGlvbiAoZSwgaW5zdGFuY2UpIHtcclxuICAgICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLkZ1bGxTY3JlZW4gJiYgaW5zdGFuY2UuJHJlZnMuY29udGFpbmVyLmhhc0NsYXNzKFwiZmFuY3lib3gtaXMtZnVsbHNjcmVlblwiKSkge1xyXG4gICAgICAgIEZ1bGxTY3JlZW4uZXhpdCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pKGRvY3VtZW50LCBqUXVlcnkpO1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy9cclxuLy8gVGh1bWJzXHJcbi8vIERpc3BsYXlzIHRodW1ibmFpbHMgaW4gYSBncmlkXHJcbi8vXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbihmdW5jdGlvbiAoZG9jdW1lbnQsICQpIHtcclxuICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgdmFyIENMQVNTID0gXCJmYW5jeWJveC10aHVtYnNcIixcclxuICAgIENMQVNTX0FDVElWRSA9IENMQVNTICsgXCItYWN0aXZlXCI7XHJcblxyXG4gIC8vIE1ha2Ugc3VyZSB0aGVyZSBhcmUgZGVmYXVsdCB2YWx1ZXNcclxuICAkLmZhbmN5Ym94LmRlZmF1bHRzID0gJC5leHRlbmQoXHJcbiAgICB0cnVlLCB7XHJcbiAgICAgIGJ0blRwbDoge1xyXG4gICAgICAgIHRodW1iczogJzxidXR0b24gZGF0YS1mYW5jeWJveC10aHVtYnMgY2xhc3M9XCJmYW5jeWJveC1idXR0b24gZmFuY3lib3gtYnV0dG9uLS10aHVtYnNcIiB0aXRsZT1cInt7VEhVTUJTfX1cIj4nICtcclxuICAgICAgICAgICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggZD1cIk0xNC41OSAxNC41OWgzLjc2djMuNzZoLTMuNzZ2LTMuNzZ6bS00LjQ3IDBoMy43NnYzLjc2aC0zLjc2di0zLjc2em0tNC40NyAwaDMuNzZ2My43Nkg1LjY1di0zLjc2em04Ljk0LTQuNDdoMy43NnYzLjc2aC0zLjc2di0zLjc2em0tNC40NyAwaDMuNzZ2My43NmgtMy43NnYtMy43NnptLTQuNDcgMGgzLjc2djMuNzZINS42NXYtMy43NnptOC45NC00LjQ3aDMuNzZ2My43NmgtMy43NlY1LjY1em0tNC40NyAwaDMuNzZ2My43NmgtMy43NlY1LjY1em0tNC40NyAwaDMuNzZ2My43Nkg1LjY1VjUuNjV6XCIvPjwvc3ZnPicgK1xyXG4gICAgICAgICAgXCI8L2J1dHRvbj5cIlxyXG4gICAgICB9LFxyXG4gICAgICB0aHVtYnM6IHtcclxuICAgICAgICBhdXRvU3RhcnQ6IGZhbHNlLCAvLyBEaXNwbGF5IHRodW1ibmFpbHMgb24gb3BlbmluZ1xyXG4gICAgICAgIGhpZGVPbkNsb3NlOiB0cnVlLCAvLyBIaWRlIHRodW1ibmFpbCBncmlkIHdoZW4gY2xvc2luZyBhbmltYXRpb24gc3RhcnRzXHJcbiAgICAgICAgcGFyZW50RWw6IFwiLmZhbmN5Ym94LWNvbnRhaW5lclwiLCAvLyBDb250YWluZXIgaXMgaW5qZWN0ZWQgaW50byB0aGlzIGVsZW1lbnRcclxuICAgICAgICBheGlzOiBcInlcIiAvLyBWZXJ0aWNhbCAoeSkgb3IgaG9yaXpvbnRhbCAoeCkgc2Nyb2xsaW5nXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICAkLmZhbmN5Ym94LmRlZmF1bHRzXHJcbiAgKTtcclxuXHJcbiAgdmFyIEZhbmN5VGh1bWJzID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcbiAgICB0aGlzLmluaXQoaW5zdGFuY2UpO1xyXG4gIH07XHJcblxyXG4gICQuZXh0ZW5kKEZhbmN5VGh1bWJzLnByb3RvdHlwZSwge1xyXG4gICAgJGJ1dHRvbjogbnVsbCxcclxuICAgICRncmlkOiBudWxsLFxyXG4gICAgJGxpc3Q6IG51bGwsXHJcbiAgICBpc1Zpc2libGU6IGZhbHNlLFxyXG4gICAgaXNBY3RpdmU6IGZhbHNlLFxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgZ3JvdXAgPSBpbnN0YW5jZS5ncm91cCxcclxuICAgICAgICBlbmFibGVkID0gMDtcclxuXHJcbiAgICAgIHNlbGYuaW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgc2VsZi5vcHRzID0gZ3JvdXBbaW5zdGFuY2UuY3VyckluZGV4XS5vcHRzLnRodW1icztcclxuXHJcbiAgICAgIGluc3RhbmNlLlRodW1icyA9IHNlbGY7XHJcblxyXG4gICAgICBzZWxmLiRidXR0b24gPSBpbnN0YW5jZS4kcmVmcy50b29sYmFyLmZpbmQoXCJbZGF0YS1mYW5jeWJveC10aHVtYnNdXCIpO1xyXG5cclxuICAgICAgLy8gRW5hYmxlIHRodW1icyBpZiBhdCBsZWFzdCB0d28gZ3JvdXAgaXRlbXMgaGF2ZSB0aHVtYm5haWxzXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBncm91cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmIChncm91cFtpXS50aHVtYikge1xyXG4gICAgICAgICAgZW5hYmxlZCsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGVuYWJsZWQgPiAxKSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChlbmFibGVkID4gMSAmJiAhIXNlbGYub3B0cykge1xyXG4gICAgICAgIHNlbGYuJGJ1dHRvbi5yZW1vdmVBdHRyKFwic3R5bGVcIikub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBzZWxmLnRvZ2dsZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzZWxmLmlzQWN0aXZlID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZWxmLiRidXR0b24uaGlkZSgpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgaW5zdGFuY2UgPSBzZWxmLmluc3RhbmNlLFxyXG4gICAgICAgIHBhcmVudEVsID0gc2VsZi5vcHRzLnBhcmVudEVsLFxyXG4gICAgICAgIGxpc3QgPSBbXSxcclxuICAgICAgICBzcmM7XHJcblxyXG4gICAgICBpZiAoIXNlbGYuJGdyaWQpIHtcclxuICAgICAgICAvLyBDcmVhdGUgbWFpbiBlbGVtZW50XHJcbiAgICAgICAgc2VsZi4kZ3JpZCA9ICQoJzxkaXYgY2xhc3M9XCInICsgQ0xBU1MgKyBcIiBcIiArIENMQVNTICsgXCItXCIgKyBzZWxmLm9wdHMuYXhpcyArICdcIj48L2Rpdj4nKS5hcHBlbmRUbyhcclxuICAgICAgICAgIGluc3RhbmNlLiRyZWZzLmNvbnRhaW5lclxyXG4gICAgICAgICAgLmZpbmQocGFyZW50RWwpXHJcbiAgICAgICAgICAuYWRkQmFjaygpXHJcbiAgICAgICAgICAuZmlsdGVyKHBhcmVudEVsKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIEFkZCBcImNsaWNrXCIgZXZlbnQgdGhhdCBwZXJmb3JtcyBnYWxsZXJ5IG5hdmlnYXRpb25cclxuICAgICAgICBzZWxmLiRncmlkLm9uKFwiY2xpY2tcIiwgXCJhXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGluc3RhbmNlLmp1bXBUbygkKHRoaXMpLmF0dHIoXCJkYXRhLWluZGV4XCIpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQnVpbGQgdGhlIGxpc3RcclxuICAgICAgaWYgKCFzZWxmLiRsaXN0KSB7XHJcbiAgICAgICAgc2VsZi4kbGlzdCA9ICQoJzxkaXYgY2xhc3M9XCInICsgQ0xBU1MgKyAnX19saXN0XCI+JykuYXBwZW5kVG8oc2VsZi4kZ3JpZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICQuZWFjaChpbnN0YW5jZS5ncm91cCwgZnVuY3Rpb24gKGksIGl0ZW0pIHtcclxuICAgICAgICBzcmMgPSBpdGVtLnRodW1iO1xyXG5cclxuICAgICAgICBpZiAoIXNyYyAmJiBpdGVtLnR5cGUgPT09IFwiaW1hZ2VcIikge1xyXG4gICAgICAgICAgc3JjID0gaXRlbS5zcmM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsaXN0LnB1c2goXHJcbiAgICAgICAgICAnPGEgaHJlZj1cImphdmFzY3JpcHQ6O1wiIHRhYmluZGV4PVwiMFwiIGRhdGEtaW5kZXg9XCInICtcclxuICAgICAgICAgIGkgK1xyXG4gICAgICAgICAgJ1wiJyArXHJcbiAgICAgICAgICAoc3JjICYmIHNyYy5sZW5ndGggPyAnIHN0eWxlPVwiYmFja2dyb3VuZC1pbWFnZTp1cmwoJyArIHNyYyArICcpXCInIDogJ2NsYXNzPVwiZmFuY3lib3gtdGh1bWJzLW1pc3NpbmdcIicpICtcclxuICAgICAgICAgIFwiPjwvYT5cIlxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgc2VsZi4kbGlzdFswXS5pbm5lckhUTUwgPSBsaXN0LmpvaW4oXCJcIik7XHJcblxyXG4gICAgICBpZiAoc2VsZi5vcHRzLmF4aXMgPT09IFwieFwiKSB7XHJcbiAgICAgICAgLy8gU2V0IGZpeGVkIHdpZHRoIGZvciBsaXN0IGVsZW1lbnQgdG8gZW5hYmxlIGhvcml6b250YWwgc2Nyb2xsaW5nXHJcbiAgICAgICAgc2VsZi4kbGlzdC53aWR0aChcclxuICAgICAgICAgIHBhcnNlSW50KHNlbGYuJGdyaWQuY3NzKFwicGFkZGluZy1yaWdodFwiKSwgMTApICtcclxuICAgICAgICAgIGluc3RhbmNlLmdyb3VwLmxlbmd0aCAqXHJcbiAgICAgICAgICBzZWxmLiRsaXN0XHJcbiAgICAgICAgICAuY2hpbGRyZW4oKVxyXG4gICAgICAgICAgLmVxKDApXHJcbiAgICAgICAgICAub3V0ZXJXaWR0aCh0cnVlKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZm9jdXM6IGZ1bmN0aW9uIChkdXJhdGlvbikge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgJGxpc3QgPSBzZWxmLiRsaXN0LFxyXG4gICAgICAgICRncmlkID0gc2VsZi4kZ3JpZCxcclxuICAgICAgICB0aHVtYixcclxuICAgICAgICB0aHVtYlBvcztcclxuXHJcbiAgICAgIGlmICghc2VsZi5pbnN0YW5jZS5jdXJyZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHVtYiA9ICRsaXN0XHJcbiAgICAgICAgLmNoaWxkcmVuKClcclxuICAgICAgICAucmVtb3ZlQ2xhc3MoQ0xBU1NfQUNUSVZFKVxyXG4gICAgICAgIC5maWx0ZXIoJ1tkYXRhLWluZGV4PVwiJyArIHNlbGYuaW5zdGFuY2UuY3VycmVudC5pbmRleCArICdcIl0nKVxyXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19BQ1RJVkUpO1xyXG5cclxuICAgICAgdGh1bWJQb3MgPSB0aHVtYi5wb3NpdGlvbigpO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgbmVlZCB0byBzY3JvbGwgdG8gbWFrZSBjdXJyZW50IHRodW1iIHZpc2libGVcclxuICAgICAgaWYgKHNlbGYub3B0cy5heGlzID09PSBcInlcIiAmJiAodGh1bWJQb3MudG9wIDwgMCB8fCB0aHVtYlBvcy50b3AgPiAkbGlzdC5oZWlnaHQoKSAtIHRodW1iLm91dGVySGVpZ2h0KCkpKSB7XHJcbiAgICAgICAgJGxpc3Quc3RvcCgpLmFuaW1hdGUoe1xyXG4gICAgICAgICAgICBzY3JvbGxUb3A6ICRsaXN0LnNjcm9sbFRvcCgpICsgdGh1bWJQb3MudG9wXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZHVyYXRpb25cclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgIHNlbGYub3B0cy5heGlzID09PSBcInhcIiAmJlxyXG4gICAgICAgICh0aHVtYlBvcy5sZWZ0IDwgJGdyaWQuc2Nyb2xsTGVmdCgpIHx8IHRodW1iUG9zLmxlZnQgPiAkZ3JpZC5zY3JvbGxMZWZ0KCkgKyAoJGdyaWQud2lkdGgoKSAtIHRodW1iLm91dGVyV2lkdGgoKSkpXHJcbiAgICAgICkge1xyXG4gICAgICAgICRsaXN0XHJcbiAgICAgICAgICAucGFyZW50KClcclxuICAgICAgICAgIC5zdG9wKClcclxuICAgICAgICAgIC5hbmltYXRlKHtcclxuICAgICAgICAgICAgICBzY3JvbGxMZWZ0OiB0aHVtYlBvcy5sZWZ0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uXHJcbiAgICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgIHRoYXQuaW5zdGFuY2UuJHJlZnMuY29udGFpbmVyLnRvZ2dsZUNsYXNzKFwiZmFuY3lib3gtc2hvdy10aHVtYnNcIiwgdGhpcy5pc1Zpc2libGUpO1xyXG5cclxuICAgICAgaWYgKHRoYXQuaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgaWYgKCF0aGF0LiRncmlkKSB7XHJcbiAgICAgICAgICB0aGF0LmNyZWF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhhdC5pbnN0YW5jZS50cmlnZ2VyKFwib25UaHVtYnNTaG93XCIpO1xyXG5cclxuICAgICAgICB0aGF0LmZvY3VzKDApO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoYXQuJGdyaWQpIHtcclxuICAgICAgICB0aGF0Lmluc3RhbmNlLnRyaWdnZXIoXCJvblRodW1ic0hpZGVcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBjb250ZW50IHBvc2l0aW9uXHJcbiAgICAgIHRoYXQuaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2hvdzogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvZ2dsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLmlzVmlzaWJsZSA9ICF0aGlzLmlzVmlzaWJsZTtcclxuICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgJChkb2N1bWVudCkub24oe1xyXG4gICAgXCJvbkluaXQuZmJcIjogZnVuY3Rpb24gKGUsIGluc3RhbmNlKSB7XHJcbiAgICAgIHZhciBUaHVtYnM7XHJcblxyXG4gICAgICBpZiAoaW5zdGFuY2UgJiYgIWluc3RhbmNlLlRodW1icykge1xyXG4gICAgICAgIFRodW1icyA9IG5ldyBGYW5jeVRodW1icyhpbnN0YW5jZSk7XHJcblxyXG4gICAgICAgIGlmIChUaHVtYnMuaXNBY3RpdmUgJiYgVGh1bWJzLm9wdHMuYXV0b1N0YXJ0ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICBUaHVtYnMuc2hvdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBcImJlZm9yZVNob3cuZmJcIjogZnVuY3Rpb24gKGUsIGluc3RhbmNlLCBpdGVtLCBmaXJzdFJ1bikge1xyXG4gICAgICB2YXIgVGh1bWJzID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuVGh1bWJzO1xyXG5cclxuICAgICAgaWYgKFRodW1icyAmJiBUaHVtYnMuaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgVGh1bWJzLmZvY3VzKGZpcnN0UnVuID8gMCA6IDI1MCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgXCJhZnRlcktleWRvd24uZmJcIjogZnVuY3Rpb24gKGUsIGluc3RhbmNlLCBjdXJyZW50LCBrZXlwcmVzcywga2V5Y29kZSkge1xyXG4gICAgICB2YXIgVGh1bWJzID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuVGh1bWJzO1xyXG5cclxuICAgICAgLy8gXCJHXCJcclxuICAgICAgaWYgKFRodW1icyAmJiBUaHVtYnMuaXNBY3RpdmUgJiYga2V5Y29kZSA9PT0gNzEpIHtcclxuICAgICAgICBrZXlwcmVzcy5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICBUaHVtYnMudG9nZ2xlKCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgXCJiZWZvcmVDbG9zZS5mYlwiOiBmdW5jdGlvbiAoZSwgaW5zdGFuY2UpIHtcclxuICAgICAgdmFyIFRodW1icyA9IGluc3RhbmNlICYmIGluc3RhbmNlLlRodW1icztcclxuXHJcbiAgICAgIGlmIChUaHVtYnMgJiYgVGh1bWJzLmlzVmlzaWJsZSAmJiBUaHVtYnMub3B0cy5oaWRlT25DbG9zZSAhPT0gZmFsc2UpIHtcclxuICAgICAgICBUaHVtYnMuJGdyaWQuaGlkZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pKGRvY3VtZW50LCBqUXVlcnkpO1xuLy8vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vL1xyXG4vLyBTaGFyZVxyXG4vLyBEaXNwbGF5cyBzaW1wbGUgZm9ybSBmb3Igc2hhcmluZyBjdXJyZW50IHVybFxyXG4vL1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4oZnVuY3Rpb24gKGRvY3VtZW50LCAkKSB7XHJcbiAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICQuZXh0ZW5kKHRydWUsICQuZmFuY3lib3guZGVmYXVsdHMsIHtcclxuICAgIGJ0blRwbDoge1xyXG4gICAgICBzaGFyZTogJzxidXR0b24gZGF0YS1mYW5jeWJveC1zaGFyZSBjbGFzcz1cImZhbmN5Ym94LWJ1dHRvbiBmYW5jeWJveC1idXR0b24tLXNoYXJlXCIgdGl0bGU9XCJ7e1NIQVJFfX1cIj4nICtcclxuICAgICAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNMi41NSAxOWMxLjQtOC40IDkuMS05LjggMTEuOS05LjhWNWw3IDctNyA2LjN2LTMuNWMtMi44IDAtMTAuNSAyLjEtMTEuOSA0LjJ6XCIvPjwvc3ZnPicgK1xyXG4gICAgICAgIFwiPC9idXR0b24+XCJcclxuICAgIH0sXHJcbiAgICBzaGFyZToge1xyXG4gICAgICB1cmw6IGZ1bmN0aW9uIChpbnN0YW5jZSwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAoIWluc3RhbmNlLmN1cnJlbnRIYXNoICYmICEoaXRlbS50eXBlID09PSBcImlubGluZVwiIHx8IGl0ZW0udHlwZSA9PT0gXCJodG1sXCIpID8gaXRlbS5vcmlnU3JjIHx8IGl0ZW0uc3JjIDogZmFsc2UpIHx8IHdpbmRvdy5sb2NhdGlvblxyXG4gICAgICAgICk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHRwbDogJzxkaXYgY2xhc3M9XCJmYW5jeWJveC1zaGFyZVwiPicgK1xyXG4gICAgICAgIFwiPGgxPnt7U0hBUkV9fTwvaDE+XCIgK1xyXG4gICAgICAgIFwiPHA+XCIgK1xyXG4gICAgICAgICc8YSBjbGFzcz1cImZhbmN5Ym94LXNoYXJlX19idXR0b24gZmFuY3lib3gtc2hhcmVfX2J1dHRvbi0tZmJcIiBocmVmPVwiaHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3NoYXJlci9zaGFyZXIucGhwP3U9e3t1cmx9fVwiPicgK1xyXG4gICAgICAgICc8c3ZnIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwibTI4NyA0NTZ2LTI5OWMwLTIxIDYtMzUgMzUtMzVoMzh2LTYzYy03LTEtMjktMy01NS0zLTU0IDAtOTEgMzMtOTEgOTR2MzA2bTE0My0yNTRoLTIwNXY3MmgxOTZcIiAvPjwvc3ZnPicgK1xyXG4gICAgICAgIFwiPHNwYW4+RmFjZWJvb2s8L3NwYW4+XCIgK1xyXG4gICAgICAgIFwiPC9hPlwiICtcclxuICAgICAgICAnPGEgY2xhc3M9XCJmYW5jeWJveC1zaGFyZV9fYnV0dG9uIGZhbmN5Ym94LXNoYXJlX19idXR0b24tLXR3XCIgaHJlZj1cImh0dHBzOi8vdHdpdHRlci5jb20vaW50ZW50L3R3ZWV0P3VybD17e3VybH19JnRleHQ9e3tkZXNjcn19XCI+JyArXHJcbiAgICAgICAgJzxzdmcgdmlld0JveD1cIjAgMCA1MTIgNTEyXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJtNDU2IDEzM2MtMTQgNy0zMSAxMS00NyAxMyAxNy0xMCAzMC0yNyAzNy00Ni0xNSAxMC0zNCAxNi01MiAyMC02MS02Mi0xNTctNy0xNDEgNzUtNjgtMy0xMjktMzUtMTY5LTg1LTIyIDM3LTExIDg2IDI2IDEwOS0xMyAwLTI2LTQtMzctOSAwIDM5IDI4IDcyIDY1IDgwLTEyIDMtMjUgNC0zNyAyIDEwIDMzIDQxIDU3IDc3IDU3LTQyIDMwLTc3IDM4LTEyMiAzNCAxNzAgMTExIDM3OC0zMiAzNTktMjA4IDE2LTExIDMwLTI1IDQxLTQyelwiIC8+PC9zdmc+JyArXHJcbiAgICAgICAgXCI8c3Bhbj5Ud2l0dGVyPC9zcGFuPlwiICtcclxuICAgICAgICBcIjwvYT5cIiArXHJcbiAgICAgICAgJzxhIGNsYXNzPVwiZmFuY3lib3gtc2hhcmVfX2J1dHRvbiBmYW5jeWJveC1zaGFyZV9fYnV0dG9uLS1wdFwiIGhyZWY9XCJodHRwczovL3d3dy5waW50ZXJlc3QuY29tL3Bpbi9jcmVhdGUvYnV0dG9uLz91cmw9e3t1cmx9fSZkZXNjcmlwdGlvbj17e2Rlc2NyfX0mbWVkaWE9e3ttZWRpYX19XCI+JyArXHJcbiAgICAgICAgJzxzdmcgdmlld0JveD1cIjAgMCA1MTIgNTEyXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJtMjY1IDU2Yy0xMDkgMC0xNjQgNzgtMTY0IDE0NCAwIDM5IDE1IDc0IDQ3IDg3IDUgMiAxMCAwIDEyLTVsNC0xOWMyLTYgMS04LTMtMTMtOS0xMS0xNS0yNS0xNS00NSAwLTU4IDQzLTExMCAxMTMtMTEwIDYyIDAgOTYgMzggOTYgODggMCA2Ny0zMCAxMjItNzMgMTIyLTI0IDAtNDItMTktMzYtNDQgNi0yOSAyMC02MCAyMC04MSAwLTE5LTEwLTM1LTMxLTM1LTI1IDAtNDQgMjYtNDQgNjAgMCAyMSA3IDM2IDcgMzZsLTMwIDEyNWMtOCAzNy0xIDgzIDAgODcgMCAzIDQgNCA1IDIgMi0zIDMyLTM5IDQyLTc1bDE2LTY0YzggMTYgMzEgMjkgNTYgMjkgNzQgMCAxMjQtNjcgMTI0LTE1NyAwLTY5LTU4LTEzMi0xNDYtMTMyelwiIGZpbGw9XCIjZmZmXCIvPjwvc3ZnPicgK1xyXG4gICAgICAgIFwiPHNwYW4+UGludGVyZXN0PC9zcGFuPlwiICtcclxuICAgICAgICBcIjwvYT5cIiArXHJcbiAgICAgICAgXCI8L3A+XCIgK1xyXG4gICAgICAgICc8cD48aW5wdXQgY2xhc3M9XCJmYW5jeWJveC1zaGFyZV9faW5wdXRcIiB0eXBlPVwidGV4dFwiIHZhbHVlPVwie3t1cmxfcmF3fX1cIiBvbmNsaWNrPVwic2VsZWN0KClcIiAvPjwvcD4nICtcclxuICAgICAgICBcIjwvZGl2PlwiXHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XHJcbiAgICB2YXIgZW50aXR5TWFwID0ge1xyXG4gICAgICBcIiZcIjogXCImYW1wO1wiLFxyXG4gICAgICBcIjxcIjogXCImbHQ7XCIsXHJcbiAgICAgIFwiPlwiOiBcIiZndDtcIixcclxuICAgICAgJ1wiJzogXCImcXVvdDtcIixcclxuICAgICAgXCInXCI6IFwiJiMzOTtcIixcclxuICAgICAgXCIvXCI6IFwiJiN4MkY7XCIsXHJcbiAgICAgIFwiYFwiOiBcIiYjeDYwO1wiLFxyXG4gICAgICBcIj1cIjogXCImI3gzRDtcIlxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZSgvWyY8PlwiJ2A9XFwvXS9nLCBmdW5jdGlvbiAocykge1xyXG4gICAgICByZXR1cm4gZW50aXR5TWFwW3NdO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAkKGRvY3VtZW50KS5vbihcImNsaWNrXCIsIFwiW2RhdGEtZmFuY3lib3gtc2hhcmVdXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBpbnN0YW5jZSA9ICQuZmFuY3lib3guZ2V0SW5zdGFuY2UoKSxcclxuICAgICAgY3VycmVudCA9IGluc3RhbmNlLmN1cnJlbnQgfHwgbnVsbCxcclxuICAgICAgdXJsLFxyXG4gICAgICB0cGw7XHJcblxyXG4gICAgaWYgKCFjdXJyZW50KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoJC50eXBlKGN1cnJlbnQub3B0cy5zaGFyZS51cmwpID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgdXJsID0gY3VycmVudC5vcHRzLnNoYXJlLnVybC5hcHBseShjdXJyZW50LCBbaW5zdGFuY2UsIGN1cnJlbnRdKTtcclxuICAgIH1cclxuXHJcbiAgICB0cGwgPSBjdXJyZW50Lm9wdHMuc2hhcmUudHBsXHJcbiAgICAgIC5yZXBsYWNlKC9cXHtcXHttZWRpYVxcfVxcfS9nLCBjdXJyZW50LnR5cGUgPT09IFwiaW1hZ2VcIiA/IGVuY29kZVVSSUNvbXBvbmVudChjdXJyZW50LnNyYykgOiBcIlwiKVxyXG4gICAgICAucmVwbGFjZSgvXFx7XFx7dXJsXFx9XFx9L2csIGVuY29kZVVSSUNvbXBvbmVudCh1cmwpKVxyXG4gICAgICAucmVwbGFjZSgvXFx7XFx7dXJsX3Jhd1xcfVxcfS9nLCBlc2NhcGVIdG1sKHVybCkpXHJcbiAgICAgIC5yZXBsYWNlKC9cXHtcXHtkZXNjclxcfVxcfS9nLCBpbnN0YW5jZS4kY2FwdGlvbiA/IGVuY29kZVVSSUNvbXBvbmVudChpbnN0YW5jZS4kY2FwdGlvbi50ZXh0KCkpIDogXCJcIik7XHJcblxyXG4gICAgJC5mYW5jeWJveC5vcGVuKHtcclxuICAgICAgc3JjOiBpbnN0YW5jZS50cmFuc2xhdGUoaW5zdGFuY2UsIHRwbCksXHJcbiAgICAgIHR5cGU6IFwiaHRtbFwiLFxyXG4gICAgICBvcHRzOiB7XHJcbiAgICAgICAgdG91Y2g6IGZhbHNlLFxyXG4gICAgICAgIGFuaW1hdGlvbkVmZmVjdDogZmFsc2UsXHJcbiAgICAgICAgYWZ0ZXJMb2FkOiBmdW5jdGlvbiAoc2hhcmVJbnN0YW5jZSwgc2hhcmVDdXJyZW50KSB7XHJcbiAgICAgICAgICAvLyBDbG9zZSBzZWxmIGlmIHBhcmVudCBpbnN0YW5jZSBpcyBjbG9zaW5nXHJcbiAgICAgICAgICBpbnN0YW5jZS4kcmVmcy5jb250YWluZXIub25lKFwiYmVmb3JlQ2xvc2UuZmJcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzaGFyZUluc3RhbmNlLmNsb3NlKG51bGwsIDApO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8gT3BlbmluZyBsaW5rcyBpbiBhIHBvcHVwIHdpbmRvd1xyXG4gICAgICAgICAgc2hhcmVDdXJyZW50LiRjb250ZW50LmZpbmQoXCIuZmFuY3lib3gtc2hhcmVfX2J1dHRvblwiKS5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5vcGVuKHRoaXMuaHJlZiwgXCJTaGFyZVwiLCBcIndpZHRoPTU1MCwgaGVpZ2h0PTQ1MFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb2JpbGU6IHtcclxuICAgICAgICAgIGF1dG9Gb2N1czogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG59KShkb2N1bWVudCwgalF1ZXJ5KTtcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vXHJcbi8vIEhhc2hcclxuLy8gRW5hYmxlcyBsaW5raW5nIHRvIGVhY2ggbW9kYWxcclxuLy9cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuKGZ1bmN0aW9uICh3aW5kb3csIGRvY3VtZW50LCAkKSB7XHJcbiAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gIC8vIFNpbXBsZSAkLmVzY2FwZVNlbGVjdG9yIHBvbHlmaWxsIChmb3IgalF1ZXJ5IHByaW9yIHYzKVxyXG4gIGlmICghJC5lc2NhcGVTZWxlY3Rvcikge1xyXG4gICAgJC5lc2NhcGVTZWxlY3RvciA9IGZ1bmN0aW9uIChzZWwpIHtcclxuICAgICAgdmFyIHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXHg4MC1cXHVGRkZGXFx3LV0vZztcclxuICAgICAgdmFyIGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiAoY2gsIGFzQ29kZVBvaW50KSB7XHJcbiAgICAgICAgaWYgKGFzQ29kZVBvaW50KSB7XHJcbiAgICAgICAgICAvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcclxuICAgICAgICAgIGlmIChjaCA9PT0gXCJcXDBcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcXHVGRkZEXCI7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcclxuICAgICAgICAgIHJldHVybiBjaC5zbGljZSgwLCAtMSkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoY2gubGVuZ3RoIC0gMSkudG9TdHJpbmcoMTYpICsgXCIgXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXHJcbiAgICAgICAgcmV0dXJuIFwiXFxcXFwiICsgY2g7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXR1cm4gKHNlbCArIFwiXCIpLnJlcGxhY2UocmNzc2VzY2FwZSwgZmNzc2VzY2FwZSk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0IGluZm8gYWJvdXQgZ2FsbGVyeSBuYW1lIGFuZCBjdXJyZW50IGluZGV4IGZyb20gdXJsXHJcbiAgZnVuY3Rpb24gcGFyc2VVcmwoKSB7XHJcbiAgICB2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cigxKSxcclxuICAgICAgcmV6ID0gaGFzaC5zcGxpdChcIi1cIiksXHJcbiAgICAgIGluZGV4ID0gcmV6Lmxlbmd0aCA+IDEgJiYgL15cXCs/XFxkKyQvLnRlc3QocmV6W3Jlei5sZW5ndGggLSAxXSkgPyBwYXJzZUludChyZXoucG9wKC0xKSwgMTApIHx8IDEgOiAxLFxyXG4gICAgICBnYWxsZXJ5ID0gcmV6LmpvaW4oXCItXCIpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGhhc2g6IGhhc2gsXHJcbiAgICAgIC8qIEluZGV4IGlzIHN0YXJ0aW5nIGZyb20gMSAqL1xyXG4gICAgICBpbmRleDogaW5kZXggPCAxID8gMSA6IGluZGV4LFxyXG4gICAgICBnYWxsZXJ5OiBnYWxsZXJ5XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gVHJpZ2dlciBjbGljayBldm50IG9uIGxpbmtzIHRvIG9wZW4gbmV3IGZhbmN5Qm94IGluc3RhbmNlXHJcbiAgZnVuY3Rpb24gdHJpZ2dlckZyb21VcmwodXJsKSB7XHJcbiAgICBpZiAodXJsLmdhbGxlcnkgIT09IFwiXCIpIHtcclxuICAgICAgLy8gSWYgd2UgY2FuIGZpbmQgZWxlbWVudCBtYXRjaGluZyAnZGF0YS1mYW5jeWJveCcgYXRyaWJ1dGUsXHJcbiAgICAgIC8vIHRoZW4gdHJpZ2dlcmluZyBjbGljayBldmVudCBzaG91bGQgc3RhcnQgZmFuY3lCb3hcclxuICAgICAgJChcIltkYXRhLWZhbmN5Ym94PSdcIiArICQuZXNjYXBlU2VsZWN0b3IodXJsLmdhbGxlcnkpICsgXCInXVwiKVxyXG4gICAgICAgIC5lcSh1cmwuaW5kZXggLSAxKVxyXG4gICAgICAgIC5mb2N1cygpXHJcbiAgICAgICAgLnRyaWdnZXIoXCJjbGljay5mYi1zdGFydFwiKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEdldCBnYWxsZXJ5IG5hbWUgZnJvbSBjdXJyZW50IGluc3RhbmNlXHJcbiAgZnVuY3Rpb24gZ2V0R2FsbGVyeUlEKGluc3RhbmNlKSB7XHJcbiAgICB2YXIgb3B0cywgcmV0O1xyXG5cclxuICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIG9wdHMgPSBpbnN0YW5jZS5jdXJyZW50ID8gaW5zdGFuY2UuY3VycmVudC5vcHRzIDogaW5zdGFuY2Uub3B0cztcclxuICAgIHJldCA9IG9wdHMuaGFzaCB8fCAob3B0cy4kb3JpZyA/IG9wdHMuJG9yaWcuZGF0YShcImZhbmN5Ym94XCIpIHx8IG9wdHMuJG9yaWcuZGF0YShcImZhbmN5Ym94LXRyaWdnZXJcIikgOiBcIlwiKTtcclxuXHJcbiAgICByZXR1cm4gcmV0ID09PSBcIlwiID8gZmFsc2UgOiByZXQ7XHJcbiAgfVxyXG5cclxuICAvLyBTdGFydCB3aGVuIERPTSBiZWNvbWVzIHJlYWR5XHJcbiAgJChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBDaGVjayBpZiB1c2VyIGhhcyBkaXNhYmxlZCB0aGlzIG1vZHVsZVxyXG4gICAgaWYgKCQuZmFuY3lib3guZGVmYXVsdHMuaGFzaCA9PT0gZmFsc2UpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVwZGF0ZSBoYXNoIHdoZW4gb3BlbmluZy9jbG9zaW5nIGZhbmN5Qm94XHJcbiAgICAkKGRvY3VtZW50KS5vbih7XHJcbiAgICAgIFwib25Jbml0LmZiXCI6IGZ1bmN0aW9uIChlLCBpbnN0YW5jZSkge1xyXG4gICAgICAgIHZhciB1cmwsIGdhbGxlcnk7XHJcblxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5ncm91cFtpbnN0YW5jZS5jdXJySW5kZXhdLm9wdHMuaGFzaCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHVybCA9IHBhcnNlVXJsKCk7XHJcbiAgICAgICAgZ2FsbGVyeSA9IGdldEdhbGxlcnlJRChpbnN0YW5jZSk7XHJcblxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBnYWxsZXJ5IHN0YXJ0IGluZGV4IG1hdGNoZXMgaW5kZXggZnJvbSBoYXNoXHJcbiAgICAgICAgaWYgKGdhbGxlcnkgJiYgdXJsLmdhbGxlcnkgJiYgZ2FsbGVyeSA9PSB1cmwuZ2FsbGVyeSkge1xyXG4gICAgICAgICAgaW5zdGFuY2UuY3VyckluZGV4ID0gdXJsLmluZGV4IC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBcImJlZm9yZVNob3cuZmJcIjogZnVuY3Rpb24gKGUsIGluc3RhbmNlLCBjdXJyZW50LCBmaXJzdFJ1bikge1xyXG4gICAgICAgIHZhciBnYWxsZXJ5O1xyXG5cclxuICAgICAgICBpZiAoIWN1cnJlbnQgfHwgY3VycmVudC5vcHRzLmhhc2ggPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiBuZWVkIHRvIHVwZGF0ZSB3aW5kb3cgaGFzaFxyXG4gICAgICAgIGdhbGxlcnkgPSBnZXRHYWxsZXJ5SUQoaW5zdGFuY2UpO1xyXG5cclxuICAgICAgICBpZiAoIWdhbGxlcnkpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFZhcmlhYmxlIGNvbnRhaW5pbmcgbGFzdCBoYXNoIHZhbHVlIHNldCBieSBmYW5jeUJveFxyXG4gICAgICAgIC8vIEl0IHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWYgZmFuY3lCb3ggbmVlZHMgdG8gY2xvc2UgYWZ0ZXIgaGFzaCBjaGFuZ2UgaXMgZGV0ZWN0ZWRcclxuICAgICAgICBpbnN0YW5jZS5jdXJyZW50SGFzaCA9IGdhbGxlcnkgKyAoaW5zdGFuY2UuZ3JvdXAubGVuZ3RoID4gMSA/IFwiLVwiICsgKGN1cnJlbnQuaW5kZXggKyAxKSA6IFwiXCIpO1xyXG5cclxuICAgICAgICAvLyBJZiBjdXJyZW50IGhhc2ggaXMgdGhlIHNhbWUgKHRoaXMgaW5zdGFuY2UgbW9zdCBsaWtlbHkgaXMgb3BlbmVkIGJ5IGhhc2hjaGFuZ2UpLCB0aGVuIGRvIG5vdGhpbmdcclxuICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLmhhc2ggPT09IFwiI1wiICsgaW5zdGFuY2UuY3VycmVudEhhc2gpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChmaXJzdFJ1biAmJiAhaW5zdGFuY2Uub3JpZ0hhc2gpIHtcclxuICAgICAgICAgIGluc3RhbmNlLm9yaWdIYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2g7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaW5zdGFuY2UuaGFzaFRpbWVyKSB7XHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQoaW5zdGFuY2UuaGFzaFRpbWVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBoYXNoXHJcbiAgICAgICAgaW5zdGFuY2UuaGFzaFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBpZiAoXCJyZXBsYWNlU3RhdGVcIiBpbiB3aW5kb3cuaGlzdG9yeSkge1xyXG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeVtmaXJzdFJ1biA/IFwicHVzaFN0YXRlXCIgOiBcInJlcGxhY2VTdGF0ZVwiXSh7fSxcclxuICAgICAgICAgICAgICBkb2N1bWVudC50aXRsZSxcclxuICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgXCIjXCIgKyBpbnN0YW5jZS5jdXJyZW50SGFzaFxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZpcnN0UnVuKSB7XHJcbiAgICAgICAgICAgICAgaW5zdGFuY2UuaGFzQ3JlYXRlZEhpc3RvcnkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IGluc3RhbmNlLmN1cnJlbnRIYXNoO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGluc3RhbmNlLmhhc2hUaW1lciA9IG51bGw7XHJcbiAgICAgICAgfSwgMzAwKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIFwiYmVmb3JlQ2xvc2UuZmJcIjogZnVuY3Rpb24gKGUsIGluc3RhbmNlLCBjdXJyZW50KSB7XHJcbiAgICAgICAgaWYgKCFjdXJyZW50IHx8IGN1cnJlbnQub3B0cy5oYXNoID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KGluc3RhbmNlLmhhc2hUaW1lcik7XHJcblxyXG4gICAgICAgIC8vIEdvdG8gcHJldmlvdXMgaGlzdG9yeSBlbnRyeVxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5jdXJyZW50SGFzaCAmJiBpbnN0YW5jZS5oYXNDcmVhdGVkSGlzdG9yeSkge1xyXG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UuY3VycmVudEhhc2gpIHtcclxuICAgICAgICAgIGlmIChcInJlcGxhY2VTdGF0ZVwiIGluIHdpbmRvdy5oaXN0b3J5KSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgZG9jdW1lbnQudGl0bGUsIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKyAoaW5zdGFuY2Uub3JpZ0hhc2ggfHwgXCJcIikpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBpbnN0YW5jZS5vcmlnSGFzaDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGluc3RhbmNlLmN1cnJlbnRIYXNoID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgbmVlZCB0byBzdGFydC9jbG9zZSBhZnRlciB1cmwgaGFzIGNoYW5nZWRcclxuICAgICQod2luZG93KS5vbihcImhhc2hjaGFuZ2UuZmJcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgdXJsID0gcGFyc2VVcmwoKSxcclxuICAgICAgICBmYiA9IG51bGw7XHJcblxyXG4gICAgICAvLyBGaW5kIGxhc3QgZmFuY3lCb3ggaW5zdGFuY2UgdGhhdCBoYXMgXCJoYXNoXCJcclxuICAgICAgJC5lYWNoKFxyXG4gICAgICAgICQoXCIuZmFuY3lib3gtY29udGFpbmVyXCIpXHJcbiAgICAgICAgLmdldCgpXHJcbiAgICAgICAgLnJldmVyc2UoKSxcclxuICAgICAgICBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgICB2YXIgdG1wID0gJCh2YWx1ZSkuZGF0YShcIkZhbmN5Qm94XCIpO1xyXG5cclxuICAgICAgICAgIGlmICh0bXAgJiYgdG1wLmN1cnJlbnRIYXNoKSB7XHJcbiAgICAgICAgICAgIGZiID0gdG1wO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKGZiKSB7XHJcbiAgICAgICAgLy8gTm93LCBjb21wYXJlIGhhc2ggdmFsdWVzXHJcbiAgICAgICAgaWYgKGZiLmN1cnJlbnRIYXNoICE9PSB1cmwuZ2FsbGVyeSArIFwiLVwiICsgdXJsLmluZGV4ICYmICEodXJsLmluZGV4ID09PSAxICYmIGZiLmN1cnJlbnRIYXNoID09IHVybC5nYWxsZXJ5KSkge1xyXG4gICAgICAgICAgZmIuY3VycmVudEhhc2ggPSBudWxsO1xyXG5cclxuICAgICAgICAgIGZiLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHVybC5nYWxsZXJ5ICE9PSBcIlwiKSB7XHJcbiAgICAgICAgdHJpZ2dlckZyb21VcmwodXJsKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQ2hlY2sgY3VycmVudCBoYXNoIGFuZCB0cmlnZ2VyIGNsaWNrIGV2ZW50IG9uIG1hdGNoaW5nIGVsZW1lbnQgdG8gc3RhcnQgZmFuY3lCb3gsIGlmIG5lZWRlZFxyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICghJC5mYW5jeWJveC5nZXRJbnN0YW5jZSgpKSB7XHJcbiAgICAgICAgdHJpZ2dlckZyb21VcmwocGFyc2VVcmwoKSk7XHJcbiAgICAgIH1cclxuICAgIH0sIDUwKTtcclxuICB9KTtcclxufSkod2luZG93LCBkb2N1bWVudCwgalF1ZXJ5KTtcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vXHJcbi8vIFdoZWVsXHJcbi8vIEJhc2ljIG1vdXNlIHdlaGVlbCBzdXBwb3J0IGZvciBnYWxsZXJ5IG5hdmlnYXRpb25cclxuLy9cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuKGZ1bmN0aW9uIChkb2N1bWVudCwgJCkge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICB2YXIgcHJldlRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuXHJcbiAgJChkb2N1bWVudCkub24oe1xyXG4gICAgXCJvbkluaXQuZmJcIjogZnVuY3Rpb24gKGUsIGluc3RhbmNlLCBjdXJyZW50KSB7XHJcbiAgICAgIGluc3RhbmNlLiRyZWZzLnN0YWdlLm9uKFwibW91c2V3aGVlbCBET01Nb3VzZVNjcm9sbCB3aGVlbCBNb3pNb3VzZVBpeGVsU2Nyb2xsXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBpbnN0YW5jZS5jdXJyZW50LFxyXG4gICAgICAgICAgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuXHJcbiAgICAgICAgaWYgKGluc3RhbmNlLmdyb3VwLmxlbmd0aCA8IDIgfHwgY3VycmVudC5vcHRzLndoZWVsID09PSBmYWxzZSB8fCAoY3VycmVudC5vcHRzLndoZWVsID09PSBcImF1dG9cIiAmJiBjdXJyZW50LnR5cGUgIT09IFwiaW1hZ2VcIikpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICBpZiAoY3VycmVudC4kc2xpZGUuaGFzQ2xhc3MoXCJmYW5jeWJveC1hbmltYXRlZFwiKSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZSA9IGUub3JpZ2luYWxFdmVudCB8fCBlO1xyXG5cclxuICAgICAgICBpZiAoY3VyclRpbWUgLSBwcmV2VGltZSA8IDI1MCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJldlRpbWUgPSBjdXJyVGltZTtcclxuXHJcbiAgICAgICAgaW5zdGFuY2VbKC1lLmRlbHRhWSB8fCAtZS5kZWx0YVggfHwgZS53aGVlbERlbHRhIHx8IC1lLmRldGFpbCkgPCAwID8gXCJuZXh0XCIgOiBcInByZXZpb3VzXCJdKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KShkb2N1bWVudCwgalF1ZXJ5KTsiLCJqUXVlcnkoZnVuY3Rpb24oJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgJChmdW5jdGlvbiAoKSB7XG4gICAgICAgICQoJ1tkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIl0nKS50b29sdGlwKCk7XG4gICAgfSk7XG5cbiAgICAkLnNjcm9sbFRvID0gZnVuY3Rpb24oZWwsIG9mZnNldCwgY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBwb3MgPSAoZWwgJiYgZWwubGVuZ3RoID4gMCkgPyBlbC5vZmZzZXQoKS50b3AgOiAwO1xuICAgICAgICB2YXIgYWN0dWFsbENvbnRhaW5lciA9ICEhY29udGFpbmVyID8gY29udGFpbmVyIDogXCJodG1sLCBib2R5XCI7XG4gICAgICAgIHBvcyA9IHBvcyAtIGVsLmhlaWdodCgpIC0gb2Zmc2V0O1xuICAgICAgICAkKGFjdHVhbGxDb250YWluZXIpLmFuaW1hdGUoe1xuICAgICAgICAgICAgc2Nyb2xsVG9wOiBwb3NcbiAgICAgICAgfSwgJ3Nsb3cnKTtcbiAgICB9O1xuXG4gICAgJC5nZXRDb29raWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoXG4gICAgICAgICAgICBcIig/Ol58OyApXCIgKyBuYW1lLnJlcGxhY2UoLyhbXFwuJD8qfHt9XFwoXFwpXFxbXFxdXFxcXFxcL1xcK15dKS9nLCAnXFxcXCQxJykgKyBcIj0oW147XSopXCJcbiAgICAgICAgKSk7XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoZXMgPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hlc1sxXSkgOiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgICQuc2V0Q29va2llID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIGV4cGlyZXMgPSBvcHRpb25zLmV4cGlyZXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBleHBpcmVzID09PSBcIm51bWJlclwiICYmIGV4cGlyZXMpIHtcbiAgICAgICAgICAgIHZhciBkID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGQuc2V0VGltZShkLmdldFRpbWUoKSArIGV4cGlyZXMgKiAxMDAwKTtcbiAgICAgICAgICAgIGV4cGlyZXMgPSBvcHRpb25zLmV4cGlyZXMgPSBkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBpcmVzICYmIGV4cGlyZXMudG9VVENTdHJpbmcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZXhwaXJlcyA9IGV4cGlyZXMudG9VVENTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcblxuICAgICAgICB2YXIgdXBkYXRlZENvb2tpZSA9IG5hbWUgKyBcIj1cIiArIHZhbHVlO1xuXG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRDb29raWUgKz0gXCI7IFwiICsgcHJvcE5hbWU7XG4gICAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gb3B0aW9uc1twcm9wTmFtZV07XG4gICAgICAgICAgICBpZiAocHJvcFZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZENvb2tpZSArPSBcIj1cIiArIHByb3BWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IHVwZGF0ZWRDb29raWU7XG4gICAgfTtcblxuICAgICQuZGVsZXRlQ29va2llID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBzZXRDb29raWUobmFtZSwgXCJcIiwge1xuICAgICAgICAgICAgZXhwaXJlczogLTFcbiAgICAgICAgfSlcbiAgICB9O1xuXG4gICAgLy8gdG9kbzogcmVtb3ZlIGl0XG4gICAgJCgnLmNvbW1lbnQgYSwgLmNvbW1lbnQgLnJlcGx5LXRvJykuY2xpY2soZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IGhhc2ggPSAkKHRoaXMpLmF0dHIoJ2hyZWYnKTtcblxuICAgICAgICBpZiAoaGFzaC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdGVtID0gJCggJCh0aGlzKS5wYXJlbnRzKCcuY29tbWVudHMnKSApLmZpbmQoaGFzaCk7XG5cbiAgICAgICAgaWYgKGl0ZW0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAkKCdodG1sLCBib2R5JykuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9wOiBpdGVtLm9mZnNldCgpLnRvcCAtIDYyXG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkKCcuY3JlYXRlLXVzZXItbWVzc2FnZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBsZXQgbGluayA9ICQodGhpcykuZGF0YSgnaHJlZicpO1xuICAgICAgICBsZXQgZW50cnkgPSAkKCcjY3JlYXRlLW1lc3NhZ2UtbW9kYWwnKTtcblxuICAgICAgICAkLmFqYXgobGluaywge1xuICAgICAgICAgICAgbWV0aG9kOiAnZ2V0JyxcbiAgICAgICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5tb2RhbCgnc2hvdycpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgZW50cnkuZmluZCgnLm1vZGFsLWNvbnRlbnQnKS5odG1sKGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgJC5pbml0U2VsZWN0UmVjaXBpZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgJC5pbml0U2VsZWN0UmVjaXBpZW50ID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICAkKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSA6ICcjc2VsZWN0LXJlY2lwaWVudCcpLnNlbGVjdGl6ZSh7XG4gICAgICAgICAgICB2YWx1ZUZpZWxkOiAnaWQnLFxuICAgICAgICAgICAgbGFiZWxGaWVsZDogJ25hbWUnLFxuICAgICAgICAgICAgc2VhcmNoRmllbGQ6ICduYW1lJyxcbiAgICAgICAgICAgIGNyZWF0ZTogZmFsc2UsXG4gICAgICAgICAgICBwcmVsb2FkOiB0cnVlLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICfQktGL0LHQtdGA0LjRgtC1INC40LvQuCDQstCy0LXQtNC40YLQtSDQvdC40Log0LTQu9GPINC/0L7QuNGB0LrQsC4uLicsXG4gICAgICAgICAgICByZW5kZXI6IHtcbiAgICAgICAgICAgICAgICBvcHRpb246IGZ1bmN0aW9uKGl0ZW0sIGVzY2FwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJwLTJcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInRpdGxlXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJhdmF0YXIgbXItMlwiPjxpbWcgc3JjPVwiJyArIGl0ZW0uYXZhdGFyICsgJ1wiIGhlaWdodD1cIjM0XCIgd2lkdGg9XCIzNFwiPjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cIm5hbWVcIj4nICsgZXNjYXBlKGl0ZW0ubmFtZSkgKyAnPC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb2FkOiBmdW5jdGlvbihxdWVyeSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvL2lmICghcXVlcnkubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6ICcvYXBpLzEuMC91c2Vycy9mcmllbmRzP3E9JyArIGVuY29kZVVSSUNvbXBvbmVudChxdWVyeSksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NhbGxiYWNrKHJlcy5yZXBvc2l0b3JpZXMuc2xpY2UoMCwgMTApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJCgnc2VsZWN0Jykubm90KCcuc3RhbmRhbG9uZSwgI3NlbGVjdC1jb3VudHJ5LCAjc2VsZWN0LWNpdHksIC5zZWxlY3RpemVkLCAudXBkYXRlLXJvbGUnKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCh0aGlzKS5zZWxlY3RpemUoKTtcbiAgICB9KTtcblxuICAgICQoJzpyZXNldCcpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCgnc2VsZWN0JykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICgkKHRoaXMpWzBdLnNlbGVjdGl6ZSkge1xuICAgICAgICAgICAgICAgICQodGhpcylbMF0uc2VsZWN0aXplLmNsZWFyKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoJCh0aGlzKS5pcygnI3NlbGVjdC1jaXR5JykpIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKVswXS5zZWxlY3RpemUuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTtcblxueWlpLmNvbmZpcm0gPSBmdW5jdGlvbiAobWVzc2FnZSwgb2ssIGNhbmNlbCkge1xuICAgIGJvb3Rib3guY29uZmlybSh7XG4gICAgICAgICAgICB0aXRsZTogXCLQn9C+0LTRgtCy0LXRgNC00LjRgtC1INC00LXQudGB0YLQstC40LVcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICBhbmltYXRlOiBmYWxzZSxcbiAgICAgICAgICAgIGJ1dHRvbnM6IHtcbiAgICAgICAgICAgICAgICBjYW5jZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICc8aSBjbGFzcz1cImZhIGZhLXRpbWVzXCI+PC9pPiDQntGC0LzQtdC90LAnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb25maXJtOiB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnPGkgY2xhc3M9XCJmYSBmYS1jaGVja1wiPjwvaT4g0J/RgNC40LzQtdC90LjRgtGMJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA/ICFvayB8fCBvaygpIDogIWNhbmNlbCB8fCBjYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG59O1xuXG5cbiIsImpRdWVyeShmdW5jdGlvbigkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm9ybSA9ICQoJyNjb21tdW5pdHktYWR2ZXJ0LWZvcm0nKTtcblxuICAgIGlmIChmb3JtLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB1cGRhdGVCdG4gPSBmb3JtLmZpbmQoJ2J1dHRvbltuYW1lPXVwZGF0ZV0nKTtcbiAgICB2YXIgcmVtb3ZlQnRuID0gZm9ybS5maW5kKCdidXR0b25bbmFtZT1yZW1vdmVdJyk7XG4gICAgdmFyIHJlbW92ZUFuZFVwZGF0ZUJ0biA9IGZvcm0uZmluZCgnYnV0dG9uW25hbWU9dXBkYXRlXSwgYnV0dG9uW25hbWU9cmVtb3ZlXScpO1xuXG4gICAgdmFyIGZvclJlbW92ZSA9IGZhbHNlO1xuICAgIHVwZGF0ZUJ0bi5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvclJlbW92ZSA9IGZhbHNlO1xuICAgIH0pO1xuICAgIHJlbW92ZUJ0bi5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvclJlbW92ZSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAkKGZvcm0pLm9uKCdiZWZvcmVTdWJtaXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmb3JtID0gJCh0aGlzKTtcbiAgICAgICAgdmFyIGZvcm1EYXRhID0gZm9ybS5zZXJpYWxpemVBcnJheSgpO1xuICAgICAgICBpZiAoZm9yUmVtb3ZlKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5wdXNoKHtuYW1lOiBcInJlbW92ZVwiLCB2YWx1ZTogMX0pO1xuICAgICAgICB9XG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdHlwZTogZm9ybS5hdHRyKCdtZXRob2QnKSxcbiAgICAgICAgICAgICAgICB1cmw6IGZvcm0uYXR0cignYWN0aW9uJyksXG4gICAgICAgICAgICAgICAgZGF0YTogZm9ybURhdGEsXG4gICAgICAgICAgICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVBbmRVcGRhdGVCdG4ucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy9mb3JtLmZpbmQoJ2J1dHRvbltuYW1lPXVwZGF0ZV0sIGJ1dHRvbltuYW1lPXJlbW92ZV0nKS5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUFuZFVwZGF0ZUJ0bi5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvL2Zvcm0uZmluZCgnYnV0dG9uW25hbWU9dXBkYXRlXSwgYnV0dG9uW25hbWU9cmVtb3ZlXScpLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBmb3JtLnlpaUFjdGl2ZUZvcm0oJ3VwZGF0ZU1lc3NhZ2VzJywgZGF0YS52YWxpZGF0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mYWlsKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbn0pO1xuXG4iLCJqUXVlcnkoZnVuY3Rpb24oJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGNvbnZlcnNhdGlvbkNvbnRhaW5lciA9ICQoJyNjb252ZXJzYXRpb24tY29udGFpbmVyJyk7XG5cbiAgICB2YXIgZm9ybUVsZW1lbnQgPSAnI3NlbmRNZXNzYWdlRm9ybSc7XG5cbiAgICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhkb2N1bWVudC5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpKTtcbiAgICBsZXQgc2VsZWN0ZWREaWFsb2cgPSBwYXJhbXMuZ2V0KFwic2VsXCIpO1xuXG4gICAgJCgnI21lc3NhZ2UtY29udmVyc2F0aW9uJykub24oJ2NsaWNrJywgJy5tZWRpYS5wcmV2aWV3JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgY29udmVyc2F0aW9uSWQgPSAkKHRoaXMpLmRhdGEoJ2lkJyk7XG4gICAgICAgIGxldCBtZXNzYWdlRGV0YWlsc0NvbnRhaW5lciA9ICQoJyNtZXNzYWdlLWRldGFpbHMnKTtcblxuICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZShudWxsLCBkb2N1bWVudC50aXRsZSwgZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWUgKyAnP3NlbD0nICsgY29udmVyc2F0aW9uSWQpO1xuXG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB0eXBlOiAnR0VUJyxcbiAgICAgICAgICAgIHVybDogICcvbWFpbC9zaG93P2lkPScgKyBjb252ZXJzYXRpb25JZCxcbiAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcblxuICAgICAgICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICQoJy5tZWRpYS5wcmV2aWV3JykucmVtb3ZlQ2xhc3MoJ3NlbGVjdGVkJyk7XG5cbiAgICAgICAgICAgICAgICBsZXQgcHJldmlldyA9ICQoXCIjbWVzc2FnZVByZXZpZXctXCIgKyBjb252ZXJzYXRpb25JZCk7XG4gICAgICAgICAgICAgICAgbGV0IGNhcmRCb2R5ID0gJCgnI21lc3NhZ2UtZGV0YWlscyAuY2FyZC1ib2R5Jyk7XG5cbiAgICAgICAgICAgICAgICBwcmV2aWV3LmFkZENsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgIHByZXZpZXcuZmluZCgnLmJhZGdlJykuaGlkZSgnc2xvdycpO1xuXG4gICAgICAgICAgICAgICAgY2FyZEJvZHkuaHRtbCgnPGRpdiBjbGFzcz1cIm0tYXV0byB0ZXh0LW11dGVkXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICc8aSBjbGFzcz1cImZhIGZhLWNpcmNsZS1vLW5vdGNoIGZhLXNwaW4gZmEtZndcIj48L2k+JyArXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICQobWVzc2FnZURldGFpbHNDb250YWluZXIpLmh0bWwoZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgc2ltcGxlYmFyID0gbmV3IFNpbXBsZUJhcigkKFwiI21lc3NhZ2UtZGV0YWlscyAuY2FyZC1ib2R5XCIpWzBdKTtcblxuICAgICAgICAgICAgICAgIHNpbXBsZWJhci5nZXRTY3JvbGxFbGVtZW50KCkuc2Nyb2xsVG9wID0gc2ltcGxlYmFyLmdldFNjcm9sbEVsZW1lbnQoKS5zY3JvbGxIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgaWFzID0gJChtZXNzYWdlRGV0YWlsc0NvbnRhaW5lcikuaWFzKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiAgJyNtZXNzYWdlLWRldGFpbHMtb3ZlcicsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06ICAgICAgICcubWVkaWEnLFxuICAgICAgICAgICAgICAgICAgICBwYWdpbmF0aW9uOiAnLnBhZ2luYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAvL25leHQ6ICAgICAgICcubmV4dCAucGFnZS1saW5rJyxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0pO1xuXG4gICAgJChjb252ZXJzYXRpb25Db250YWluZXIpLm9uKCdiZWZvcmVTdWJtaXQnLCBmb3JtRWxlbWVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgdXJsOiAnL21haWwvY3JlYXRlJyxcbiAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgIGRhdGE6ICQodGhpcykuc2VyaWFsaXplKCksXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgICAgIGlmIChyZXMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAkKFwiI21lc3NhZ2VQcmV2aWV3LVwiICsgcmVzLnNlbCkudHJpZ2dlcihcImNsaWNrXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgICQoY29udmVyc2F0aW9uQ29udGFpbmVyKS5vbignY2xpY2snLCAnI21lc3NhZ2UtY29udmVyc2F0aW9uIC5sb2FkLW1vcmUnLCBmdW5jdGlvbihlbCkge1xuICAgICAgICBsZXQgc2VsZiA9ICQodGhpcyk7XG4gICAgICAgIGxldCBpZCA9IHNlbGYuZGF0YSgnaWQnKTtcbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgIHVybDogJy9tYWlsL2luZGV4JyxcbiAgICAgICAgICAgIGRhdGE6IHtzdGFydDogaWR9LFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmh0bWwoJzxpIGNsYXNzPVwiZmEgZmEtY29nIGZhLXNwaW4gZmEtZndcIj48L2k+JylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlcyA9ICQoZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWREaWFsb2cpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXMuY2xvc2VzdCgnI21lc3NhZ2VQcmV2aWV3LScgKyBzZWxlY3RlZERpYWxvZykuYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJCgnI21lc3NhZ2UtY29udmVyc2F0aW9uIC5zaW1wbGViYXItY29udGVudCcpLmFwcGVuZChtZXNzYWdlcyk7XG4gICAgICAgICAgICAgICAgc2VsZi5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgJChjb252ZXJzYXRpb25Db250YWluZXIpLm9uKCdjbGljaycsICcjbWVzc2FnZS1kZXRhaWxzIC5sb2FkLW1vcmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgbGV0IHNlbGYgPSAkKHRoaXMpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gc2VsZi5kYXRhKCdvZmZzZXQnKTtcbiAgICAgICAgbGV0IGlkID0gc2VsZi5kYXRhKCdpZCcpO1xuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgdXJsOiAnL21haWwvc2hvdycsXG4gICAgICAgICAgICBkYXRhOiB7aWQ6IGlkLCBvZmZzZXQ6IG9mZnNldH0sXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaHRtbCgnPGkgY2xhc3M9XCJmYSBmYS1jb2cgZmEtc3BpbiBmYS1md1wiPjwvaT4nKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1lZGlhID0gJChkYXRhKS5maW5kKCcubWVkaWEsIC5sb2FkLW1vcmUnKTtcbiAgICAgICAgICAgICAgICAkKCcjbWVzc2FnZS1kZXRhaWxzLW92ZXIgLnNpbXBsZWJhci1jb250ZW50JykucHJlcGVuZChtZWRpYSk7XG4gICAgICAgICAgICAgICAgc2VsZi5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgJChjb252ZXJzYXRpb25Db250YWluZXIpLm9uKCdrZXlwcmVzcycsICcjbWVzc2FnZS1kZXRhaWxzIHRleHRhcmVhJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICB2YXIgYXJlYSA9ICQodGhpcyk7XG4gICAgICAgICAgICBpZiAoZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgYXJlYS52YWwoYXJlYS52YWwoKSArIFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJCgnI3NlbmRNZXNzYWdlRm9ybScpLnRyaWdnZXIoXCJzdWJtaXRcIik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzZWxlY3RlZERpYWxvZykge1xuICAgICAgICBjb252ZXJzYXRpb25Db250YWluZXIuZmluZChcIiNtZXNzYWdlUHJldmlldy1cIiArIHNlbGVjdGVkRGlhbG9nKS50cmlnZ2VyKCdjbGljaycpO1xuICAgIH1cbn0pO1xuIiwialF1ZXJ5KGZ1bmN0aW9uKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmICghJC5nZXRDb29raWUoXCJmaWx0ZXItZ2FtZXNcIikpIHtcbiAgICAgICAgJC5zZXRDb29raWUoJ2ZpbHRlci1nYW1lcycsIFtdLCB7XG4gICAgICAgICAgICBleHBpcmVzOiA4NjQwMCxcbiAgICAgICAgICAgIHBhdGg6IFwiL1wiXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgdmFyIGdhbWVJZHMgPSBbXTtcbiAgICB2YXIgY29va2llID0gJC5nZXRDb29raWUoXCJmaWx0ZXItZ2FtZXNcIikuc3BsaXQoXCIsXCIpO1xuICAgIHZhciByZWxvYWRUaW1lcjtcblxuICAgICQoXCIuZmlsdGVyaW5nLWdhbWVzIC5zd2l0Y2ggaW5wdXRcIikuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSAkKHRoaXMpO1xuXG4gICAgICAgIHZhciBpZCA9IHNlbGYucGFyZW50KCcuc3dpdGNoJykuZGF0YSgnaWQnKTtcbiAgICAgICAgdmFyIGluZGV4ID0gY29va2llLmluZGV4T2YoU3RyaW5nKGlkKSk7XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgc2VsZi5hdHRyKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdhbWVJZHMucHVzaChpZClcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJCgnLmZpbHRlcmluZy1nYW1lcyAubmF2LWxpbmsnKS5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlbG9hZFRpbWVyKTtcbiAgICB9KTtcblxuICAgICQoXCIuZmlsdGVyaW5nLWdhbWVzIC5kcm9wZG93bi1tZW51XCIpXG4gICAgICAgIC5jbGljayhmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm1vdXNlbGVhdmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY29va2llLmpvaW4oJywnKSAhPT0gZ2FtZUlkcy5qb2luKCcsJykpIHtcbiAgICAgICAgICAgICAgICByZWxvYWRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICB9LCAxNTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAkKFwiLmZpbHRlcmluZy1nYW1lcyBsYWJlbFwiKS5jaGFuZ2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gJCh0aGlzKS5maW5kKCcuc3dpdGNoJyk7XG4gICAgICAgIHZhciBpZCA9IHNlbGYuZGF0YSgnaWQnKTtcbiAgICAgICAgdmFyIGluZGV4ID0gZ2FtZUlkcy5pbmRleE9mKGlkKTtcblxuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgZ2FtZUlkcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2FtZUlkcy5wdXNoKGlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgICQuc2V0Q29va2llKCdmaWx0ZXItZ2FtZXMnLCBnYW1lSWRzLCB7XG4gICAgICAgICAgICBleHBpcmVzOiA4NjQwMCxcbiAgICAgICAgICAgIHBhdGg6IFwiL1wiXG4gICAgICAgIH0pO1xuICAgIH0pO1xufSk7XG4iLCJqUXVlcnkoZnVuY3Rpb24oJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGZvcm1hdFRpbWUgPSBmdW5jdGlvbihzZWNzKSB7XG4gICAgICAgIGxldCB0aW1lID0gKHNlY3MpID8gbmV3IERhdGUoc2VjcyAqIDEwMDApIDogbmV3IERhdGUoKTtcbiAgICAgICAgbGV0IHBhZCA9ICcwMCc7XG4gICAgICAgIGxldCBob3VycyA9ICcnICsgdGltZS5nZXRIb3VycygpO1xuICAgICAgICBsZXQgbWlucyA9ICcnICsgdGltZS5nZXRNaW51dGVzKCk7XG4gICAgICAgIHJldHVybiBwYWQuc3Vic3RyaW5nKDAsIHBhZC5sZW5ndGggLSBob3Vycy5sZW5ndGgpICsgaG91cnMgKyAnOicgKyBwYWQuc3Vic3RyaW5nKDAsIHBhZC5sZW5ndGggLSBtaW5zLmxlbmd0aCkgKyBtaW5zO1xuICAgIH07XG5cbiAgICBjb25zdCBBQ1RJT05TID0ge1xuICAgICAgICBKT0lOOiAnam9pbicsXG4gICAgICAgIFJFQURZOiAncmVhZHknLFxuICAgICAgICBQSUNLOiAncGljaycsXG4gICAgICAgIENIRUNLSU46ICdjaGVja2luJyxcbiAgICAgICAgTE9BRE1PUkU6ICdsb2FkTW9yZScsXG4gICAgICAgIE1FU1NBR0U6ICdtZXNzYWdlJyxcbiAgICAgICAgVkVUTzogJ3ZldG8nLFxuICAgIH07XG5cbiAgICBsZXQgaG9zdCA9IGxvY2F0aW9uLmhvc3QucmVwbGFjZSgnd3d3JywgJ3dzcycpO1xuICAgIGxldCB1cmwgPSBcIndzczovL1wiICArIGhvc3QgKyBcIi9sb2JieVwiO1xuICAgIGxldCBzY3JvbGxUb3AgPSB0cnVlO1xuXG4gICAgbGV0IHNvY2tldCA9IG5ldyBXZWJTb2NrZXQodXJsKTtcblxuICAgIHNvY2tldC5vbm9wZW4gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZihhdXRoa2V5KSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhdXRoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7dHlwZTogQUNUSU9OUy5KT0lOLCBhdXRoa2V5OiBhdXRoa2V5LCBsb2JieV9pZDogbG9iYnlfaWR9KSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc29ja2V0Lm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBBQ1RJT05TLlZFVE86XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3ZldG9lcycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBQ1RJT05TLkpPSU46XG4gICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoe3R5cGU6IEFDVElPTlMuTE9BRE1PUkUsIGxvYmJ5X2lkOiBsb2JieV9pZH0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQUNUSU9OUy5SRUFEWTpcbiAgICAgICAgICAgICAgICBsZXQgaWNvbiA9ICQoJy5tYXRjaC1saW5ldXAtY29udGFpbmVyIGxpW2RhdGEtaWQ9XCInICsgZGF0YS51c2VySWQgKyAnXCJdJykuZmluZCgnaS5mYS5mYS1iYW4nKTtcbiAgICAgICAgICAgICAgICBpY29uLnJlbW92ZUNsYXNzKCdmYS1iYW4nKS5hZGRDbGFzcygnZmEtY2hlY2sgdGV4dC1zdWNjZXNzJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEFDVElPTlMuUElDSzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQUNUSU9OUy5DSEVDS0lOOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBQ1RJT05TLk1FU1NBR0U6XG4gICAgICAgICAgICAgICAgcmVuZGVyTWVzc2FnZShkYXRhLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnVzZXJJZCA9PT0gdXNlcklkIHx8ICEoJ05vdGlmaWNhdGlvbicgaW4gd2luZG93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc291bmQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBBdWRpbyAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBBdWRpbyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0hUTUw1IEF1ZGlvIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXVkaW8gPSBuZXcgQXVkaW8oJy9jaGF0LXdhcm5pbmcud2F2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpby5wbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpby5jdXJyZW50VGltZT0wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgTm90aWZpY2F0aW9uLnJlcXVlc3RQZXJtaXNzaW9uKCkudGhlbihmdW5jdGlvbihwZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXJtaXNzaW9uICE9PSAnZGVuaWVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1zZyA9IGRhdGEubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtc2cubGVuZ3RoID4gNDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBtc2cuc3Vic3RyaW5nKDAsIDQwKSArICcuLi4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vdGlmaWNhdGlvbiA9IG5ldyBOb3RpZmljYXRpb24oJ9Cd0L7QstC+0LUg0YHQvtC+0LHRidC10L3QuNC1INC+0YIgJyArIGRhdGEudXNlcm5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBtc2csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZzogJ3J1LVJVJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb24ub25zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCA1MDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBQ1RJT05TLkxPQURNT1JFOlxuICAgICAgICAgICAgICAgIHZhciBoaXN0b3J5ID0gZGF0YS5kYXRhLmhpc3Rvcnk7XG5cbiAgICAgICAgICAgICAgICAkLmVhY2goaGlzdG9yeSwgZnVuY3Rpb24oaWR4LCBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck1lc3NhZ2UobWVzc2FnZSwgZmFsc2UsIHNjcm9sbFRvcCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5hbGxvd01vcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgJCgnLmNoYXQtY29udGFpbmVyJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wcmVwZW5kKCc8ZGl2IGNsYXNzPVwicHgtM1wiPjxidXR0b24gY2xhc3M9XCJidG4gYnRuLWxpZ2h0IG15LTMgYm9yZGVyZWQtMCBidG4tYmxvY2sgbG9hZC1tb3JlLW1lc3NhZ2VzXCIgZGF0YS1sYXN0PVwiJyArIGhpc3RvcnlbaGlzdG9yeS5sZW5ndGggLSAxXS5pZCArICdcIj7Ql9Cw0LPRgNGD0LfQuNGC0Ywg0LXRidGRPC9idXR0b24+PC9kaXY+Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNvY2tldC5vbmNsb3NlID0gKGV2ZW50KSA9PiB7fTtcbiAgICBzb2NrZXQub25lcnJvciA9IChldmVudCkgPT4ge307XG5cbiAgICB2YXIgaW5wdXQgPSAkKCcjY2hhdC1tZXNzYWdlJyk7XG5cbiAgICB2YXIgc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBpbnB1dC52YWwoKS50cmltKCk7XG5cbiAgICAgICAgaW5wdXQudmFsKCcnKTtcblxuICAgICAgICBzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7dHlwZTogQUNUSU9OUy5NRVNTQUdFLCBtZXNzYWdlOiBtZXNzYWdlfSkpO1xuICAgIH07XG5cbiAgICB2YXIgcmVuZGVyTWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGFwcGVuZCA9IGZhbHNlLCBzY3JvbGxUb3AgPSB0cnVlKSB7XG4gICAgICAgIGxldCBjb250YWluZXIgPSAkKCcuY2hhdC1jb250YWluZXInKTtcbiAgICAgICAgbGV0IHdpZGdldCA9ICQoJy5jaGF0LXdpZGdldCcpO1xuICAgICAgICBsZXQgbWVzc2FnZXNfYm9keSA9ICQoJy5tLW1lc3Nlbmdlcl9fbWVzc2FnZXMtYm9keScpO1xuXG4gICAgICAgIGlmICh3aWRnZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gd2lkZ2V0LmhlaWdodCgpO1xuICAgICAgICAgICAgaWYgKGhlaWdodCA8IDQwMCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCArPSA4MDtcbiAgICAgICAgICAgICAgICB3aWRnZXQuaGVpZ2h0KGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVzc2FnZXNfYm9keS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSBtZXNzYWdlc19ib2R5LmhlaWdodCgpO1xuICAgICAgICAgICAgaWYgKGhlaWdodCA8IDQwMCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCArPSA4MDtcbiAgICAgICAgICAgICAgICBtZXNzYWdlc19ib2R5LmhlaWdodChoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRlbXBsYXRlID0gJyc7XG4gICAgICAgIHRlbXBsYXRlID0rIChtZXNzYWdlLnVzZXJJZCA9PT0gdXNlcklkKSA/ICc8ZGl2IGNsYXNzPVwibS1tZXNzZW5nZXJfX21lc3NhZ2VzLW1lc3NhZ2UgaXMtc2VsZiBjaGF0LW1zZ1wiPicgOiAnPGRpdiBjbGFzcz1cIm0tbWVzc2VuZ2VyX19tZXNzYWdlcy1tZXNzYWdlIGlzLWludGVybG9jdXRvciBjaGF0LW1zZ1wiPic7XG4gICAgICAgIHRlbXBsYXRlICs9ICc8ZGl2IGNsYXNzPVwibS1tZXNzZW5nZXJfX21lc3NhZ2VzLXdyYXBcIj4nO1xuICAgICAgICB0ZW1wbGF0ZSArPSAnPGRpdiBjbGFzcz1cIm0tbWVzc2VuZ2VyX19tZXNzYWdlcy1tZXNzYWdlLXRleHRcIj4nO1xuICAgICAgICB0ZW1wbGF0ZSArPSBtZXNzYWdlLm1lc3NhZ2U7XG4gICAgICAgIHRlbXBsYXRlICs9ICc8L2Rpdj4nO1xuICAgICAgICB0ZW1wbGF0ZSArPSAnPHNwYW4gY2xhc3M9XCJtLW1lc3Nlbmdlcl9fbWVzc2FnZXMtZGF0ZVwiPic7XG4gICAgICAgIHRlbXBsYXRlICs9IGZvcm1hdFRpbWUobWVzc2FnZS50aW1lc3RhbXApICsgJywgJyArIG1lc3NhZ2UudGVhbW5hbWUgKyAnIEAnICsgbWVzc2FnZS51c2VybmFtZTtcbiAgICAgICAgdGVtcGxhdGUgKz0gJzwvc3Bhbj4nO1xuICAgICAgICB0ZW1wbGF0ZSArPSAnPC9kaXY+JztcbiAgICAgICAgdGVtcGxhdGUgKz0gJzwvZGl2Pic7XG5cbiAgICAgICAgaWYgKGFwcGVuZCkge1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZCh0ZW1wbGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXIucHJlcGVuZCh0ZW1wbGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAkKCcuc2ltcGxlYmFyLXNjcm9sbC1jb250ZW50JykuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9wOiBjb250YWluZXJbMF0uc2Nyb2xsSGVpZ2h0XG4gICAgICAgICAgICB9LCAzKTtcblxuICAgICAgICAgICAgdmFyIGNvbiA9IG1lc3NhZ2VzX2JvZHkuZmluZCgnLnNpbXBsZWJhci1zY3JvbGwtY29udGVudCcpO1xuICAgICAgICAgICAgaWYgKGNvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb24uYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcDogY29uWzBdLnNjcm9sbEhlaWdodFxuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgICQoJyNzZW5kLW1zZycpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHNlbmRNZXNzYWdlKCk7XG4gICAgfSk7XG5cbiAgICBpbnB1dC5vbigna2V5cHJlc3MnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMyAmJiAhZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICBzZW5kTWVzc2FnZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzICYmIGUuY3RybEtleSkge1xuICAgICAgICAgICAgJCh0aGlzLmlucHV0KS52YWwoZnVuY3Rpb24oaSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCArIFwiJTBBXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgJCgnLmNoYXQtY29udGFpbmVyJykub24oJ2NsaWNrJywgJy5sb2FkLW1vcmUtbWVzc2FnZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2Nyb2xsVG9wID0gZmFsc2U7XG4gICAgICAgIHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHR5cGU6IEFDVElPTlMuTE9BRE1PUkUsXG4gICAgICAgICAgICBsYXN0X21lc3NhZ2U6ICQodGhpcykuZGF0YSgnbGFzdCcpXG4gICAgICAgIH0pKTtcbiAgICAgICAgJCh0aGlzKS5yZW1vdmUoKTtcbiAgICB9KTtcblxuICAgICQoJyNidG4tcmVhZHknKS5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9ICQodGhpcykuY2xvc2VzdCgnLmNhcmQnKTtcblxuICAgICAgICBzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7dHlwZTogQUNUSU9OUy5SRUFEWX0pKTtcblxuICAgICAgICBjb250YWluZXIucmVtb3ZlKCk7XG4gICAgfSk7XG59KTtcblxuXG5cblxuXG5cblxuXG4iLCJqUXVlcnkoZnVuY3Rpb24oJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHNlbGVjdF9jb3VudHJ5ID0gJCgnZm9ybSAjc2VsZWN0LWNvdW50cnknKTtcbiAgICB2YXIgc2VsZWN0X2NpdHkgICAgPSAkKCdmb3JtICNzZWxlY3QtY2l0eScpO1xuXG4gICAgaWYgKCFzZWxlY3RfY291bnRyeS5sZW5ndGggfHwgIXNlbGVjdF9jaXR5Lmxlbmd0aCkge1xuICAgICAgICBpZiAoc2VsZWN0X2NvdW50cnkubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxlY3RfY291bnRyeS5zZWxlY3RpemUoe1xuICAgICAgICAgICAgICAgIHZhbHVlRmllbGQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgbGFiZWxGaWVsZDogJ25hbWUnLFxuICAgICAgICAgICAgICAgIHNlYXJjaEZpZWxkOiAnbmFtZScsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogW10sXG4gICAgICAgICAgICAgICAgbG9hZDogZnVuY3Rpb24ocXVlcnksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcXVlcnkubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTtcblxuICAgICAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnL2FwaS8xLjAvZGF0YWJhc2UvY291bnRyaWVzLycgKyBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGVjdF9jb3VudHJ5LnNlbGVjdGl6ZSh7XG4gICAgICAgIC8vIGlucHV0Q2xhc3MgOiAnc2VsZWN0aXplLWlucHV0IGZvcm0tY29udHJvbCcsXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZS5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICAgICAgc2VsZWN0X2NpdHkuZGlzYWJsZSgpO1xuICAgICAgICAgICAgc2VsZWN0X2NpdHkuY2xlYXIoKTtcbiAgICAgICAgICAgIHNlbGVjdF9jaXR5LmNsZWFyT3B0aW9ucygpO1xuXG4gICAgICAgICAgICBzZWxlY3RfY2l0eS5sb2FkKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnL2FwaS8xLjAvZGF0YWJhc2UvY291bnRyaWVzLycgKyB2YWx1ZSArICcvY2l0aWVzJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICAgICAgICAgIC8vIGRhdGE6IHsgY291bnRyeTogdmFsdWUgfSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdF9jaXR5LmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBzZWxlY3RfY291bnRyeSA9IHNlbGVjdF9jb3VudHJ5WzBdLnNlbGVjdGl6ZTtcblxuICAgIHNlbGVjdF9jaXR5LnNlbGVjdGl6ZSh7XG4gICAgICAgIHZhbHVlRmllbGQ6ICd2YWx1ZScsXG4gICAgICAgIGxhYmVsRmllbGQ6ICdsYWJlbCcsXG4gICAgICAgIHNlYXJjaEZpZWxkOiBbJ2xhYmVsJywgJ3JlZ2lvbicsICdhcmVhJ10sXG4gICAgICAgIGRyb3Bkb3duUGFyZW50OiAnYm9keScsXG4gICAgICAgIHByZWxvYWQ6IGZhbHNlLFxuICAgICAgICByZW5kZXI6IHtcbiAgICAgICAgICAgIG9wdGlvbjogZnVuY3Rpb24oaXRlbSwgZXNjYXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gJzxkaXYgY2xhc3M9XCJvcHRpb25cIj4nO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uYXJlYSB8fCBpdGVtLnJlZ2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9ICc8ZGl2IGNsYXNzPVwiZXh0ZW5kZWRcIj4nO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSArPSBpdGVtLmxhYmVsO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSArPSAnPGRpdiBjbGFzcz1cIml0ZW1cIj4nO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmFyZWEgIT0gbnVsbCAmJiBpdGVtLmFyZWEgIT0gaXRlbS5yZWdpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlICs9ICc8c3Bhbj4nICsgaXRlbS5hcmVhICsgJyw8YnI+PC9zcGFuPic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgKz0gJzxzcGFuPicgKyBpdGVtLnJlZ2lvbiArICc8L3NwYW4+JztcblxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSArPSAnPC9kaXY+JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSArPSBpdGVtLmxhYmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZSArPSAnPC9kaXY+JztcblxuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxvYWQ6IGZ1bmN0aW9uKHF1ZXJ5LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKCFxdWVyeS5sZW5ndGggfHwgIXNlbGVjdF9jb3VudHJ5LmdldFZhbHVlKCkubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiAnL2FwaS8xLjAvZGF0YWJhc2UvY291bnRyaWVzLycgKyBzZWxlY3RfY291bnRyeS5nZXRWYWx1ZSgpICsgJy9jaXRpZXMvJyArIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG5cbiAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0X2NpdHkuY2xlYXJPcHRpb25zKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBzZWxlY3RfY2l0eSA9IHNlbGVjdF9jaXR5WzBdLnNlbGVjdGl6ZTtcblxuICAgIGlmICghc2VsZWN0X2NvdW50cnkuZ2V0VmFsdWUoKS5sZW5ndGgpIHtcbiAgICAgICAgc2VsZWN0X2NpdHkuZGlzYWJsZSgpO1xuICAgIH1cbn0pO1xuIiwiXG4vKlxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgc29ja2V0ID0gaW8uY29ubmVjdCgnaHR0cDovL3d3dy52c2NsLmRldjo4MCcpO1xuXG4gICAgdmFyIG5pY2tuYW1lID0gJ2Qzdm51MTEnO1xuXG4gICAgc29ja2V0LmVtaXQoJ2pvaW4nLCAnZGV2bnUxMScpO1xuXG5cbiAgICAvLyBGdW5jdGlvbiB0byBhZGQgYSBtZXNzYWdlIHRvIHRoZSBwYWdlXG4gICAgdmFyIG5ld01lc3NhZ2UgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciB3aG8gPSAkKCc8ZGl2IGNsYXNzPVwid2hvXCI+JykudGV4dChkYXRhLm5pY2tuYW1lKSxcbiAgICAgICAgICAgIHdoZW4gPSAkKCc8ZGl2IGNsYXNzPVwid2hlblwiPicpLnRleHQobmV3IERhdGUoKS50b1N0cmluZygpLnN1YnN0cigwLCAyNCkpLFxuICAgICAgICAgICAgbXNnID0gJCgnPGRpdiBjbGFzcz1cIm1zZ1wiPicpLnRleHQoZGF0YS5tc2cpLFxuICAgICAgICAgICAgaGVhZGVyID0gJCgnPGRpdiBjbGFzcz1cImhlYWRlciBjbGVhcmZpeFwiPicpLmFwcGVuZCh3aG8pLmFwcGVuZCh3aGVuKSxcbiAgICAgICAgICAgIGxpID0gJCgnPGxpPicpLmFwcGVuZChoZWFkZXIpLmFwcGVuZChtc2cpO1xuXG4gICAgICAgIG1zZ0xpc3QucHJlcGVuZChsaSk7XG4gICAgfTtcblxuXG4gICAgc29ja2V0Lm9uKCdtc2cnLCBmdW5jdGlvbihkYXRhKSB7IG5ld01lc3NhZ2UoZGF0YSk7IH0pO1xufSk7XG4qL1xuXG5cbi8qKlxuICogbm90aWZpY2F0aW9ucyBwbHVnaW5cbiAqL1xuXG52YXIgTm90aWZpY2F0aW9ucyA9IChmdW5jdGlvbihvcHRzKSB7XG4gICAgaWYoIW9wdHMuaWQpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsZW0gPSAkKCcjJyArIG9wdHMuaWQpO1xuICAgIGlmKCFlbGVtLmxlbmd0aCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHtcbiAgICAgICAgcG9sbEludGVydmFsOiA2MDAwMCxcbiAgICAgICAgeGhyVGltZW91dDogMjAwMCxcbiAgICB9LCBvcHRzKTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBub3RpZmljYXRpb24gcm93XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2JqZWN0IFRoZSBub3RpZmljYXRpb24gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7alF1ZXJ5fEhUTUxFbGVtZW50fCp9XG4gICAgICovXG4gICAgLypcbiAgICB2YXIgcmVuZGVyUm93ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuXG4gICAgICAgIC8vIHZhciBodG1sID0gJzxkaXYgaHJlZj1cIiNcIiBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gbm90aWZpY2F0aW9uLWl0ZW0nICsgKG9iamVjdC5yZWFkICE9ICcwJyA/ICcgcmVhZCcgOiAnJykgKyAnXCInICtcbiAgICAgICAgLy8gICAgICcgZGF0YS1pZD1cIicgKyBvYmplY3QuaWQgKyAnXCInICtcbiAgICAgICAgLy8gICAgICcgZGF0YS1jbGFzcz1cIicgKyBvYmplY3QuY2xhc3MgKyAnXCInICtcbiAgICAgICAgLy8gICAgICcgZGF0YS1rZXk9XCInICsgb2JqZWN0LmtleSArICdcIj4nICtcbiAgICAgICAgLy8gICAgIC8vJzxzcGFuIGNsYXNzPVwiaWNvblwiPjwvc3Bhbj4gJytcbiAgICAgICAgLy8gICAgICc8c3BhbiBjbGFzcz1cIm1lc3NhZ2VcIj4nICsgb2JqZWN0Lm1lc3NhZ2UgKyAnPC9zcGFuPicgK1xuICAgICAgICAvLyAgICAgJzxzbWFsbCBjbGFzcz1cInRpbWVhZ29cIj4nICsgb2JqZWN0LnRpbWVhZ28gKyAnPC9zbWFsbD4nICtcbiAgICAgICAgLy8gICAgICc8c3BhbiBjbGFzcz1cIm1hcmstcmVhZFwiIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIHRpdGxlPVwiJyArIChvYmplY3QucmVhZCAhPSAnMCcgPyBvcHRpb25zLnJlYWRMYWJlbCA6IG9wdGlvbnMubWFya0FzUmVhZExhYmVsKSArICdcIj48L3NwYW4+JyArXG4gICAgICAgIC8vICAgICAnPC9kaXY+JztcblxuICAgICAgICB2YXIgaHRtbCA9ICc8bGkgaHJlZj1cIiNcIiBjbGFzcz1cIm5vdGlmaWNhdGlvblwiJyArXG4gICAgICAgICAgICAnIGRhdGEtaWQ9XCInICsgb2JqZWN0LmlkICsgJ1wiJyArXG4gICAgICAgICAgICAnIGRhdGEtY2xhc3M9XCInICsgb2JqZWN0LmNsYXNzICsgJ1wiJyArXG4gICAgICAgICAgICAnIGRhdGEta2V5PVwiJyArIG9iamVjdC5rZXkgKyAnXCI+JyArXG4gICAgICAgICAgICAvLyAnPGRpdiBjbGFzcz1cIm1lZGlhXCI+JyArXG4gICAgICAgICAgICAvLyAnPGltZyBjbGFzcz1cIm1yLTIgaW1nLWNpcmNsZVwiIGFsdD1cIjUweDUwXCIgc3R5bGU9XCJ3aWR0aDogNTBweDsgaGVpZ2h0OiA1MHB4O1wiIHNyYz1cIi9pbWcvcGxhY2Vob2xkZXIucG5nXCI+JyArXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gJzxkaXYgY2xhc3M9XCJtZWRpYS1ib2R5XCI+JyArXG4gICAgICAgICAgICAvLyAgICAgJzxzdHJvbmcgY2xhc3M9XCJub3RpZmljYXRpb24tdGl0bGVcIj48YSBocmVmPVwiI1wiPkRhdmUgTGlzdGVyPC9hPiBjb21tZW50ZWQgb24gPGEgaHJlZj1cIiNcIj5EV0FSRi0xMyAtIE1haW50ZW5hbmNlPC9hPjwvc3Ryb25nPicgK1xuICAgICAgICAgICAgLy8gICAgICc8cCBjbGFzcz1cIm5vdGlmaWNhdGlvbi1kZXNjXCI+SSB0b3RhbGx5IGRvblxcJ3Qgd2FubmEgZG8gaXQuIFJpbW1lciBjYW4gZG8gaXQuPC9wPicgK1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICAnPGRpdiBjbGFzcz1cIm5vdGlmaWNhdGlvbi1tZXRhXCI+JyArXG4gICAgICAgICAgICAvLyAgICAgICAgICc8c21hbGwgY2xhc3M9XCJ0aW1lc3RhbXBcIj4nICsgb2JqZWN0LnRpbWVhZ28gKyAnPC9zbWFsbD4nICtcbiAgICAgICAgICAgIC8vICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAvLyAnPC9kaXY+JyArXG4gICAgICAgICAgICBvYmplY3QubWVzc2FnZSArXG5cbiAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICc8L2xpPic7XG5cbiAgICAgICAgcmV0dXJuICQoaHRtbCk7XG5cbiAgICB9O1xuICAgICovXG5cbiAgICB2YXIgc2hvd0xpc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBlbGVtLmZpbmQoJy5kcm9wZG93bi1tZW51Lm5vdGlmaWNhdGlvbnMnKTtcblxuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJodG1sXCIsXG4gICAgICAgICAgICB0aW1lb3V0OiBvcHRzLnhoclRpbWVvdXQsXG4gICAgICAgICAgICBiZWZvcmVTZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5odG1sKCcnICtcbiAgICAgICAgICAgICAgICAgICAgJzxsaSBjbGFzcz1cIm5vdGlmaWNhdGlvbiBsb2FkZXJcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8aSBjbGFzcz1cImZhIGZhLWNvZyBmYS1zcGluIGZhLTN4IGZhLWZ3XCI+PC9pPlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic3Itb25seVwiPtCX0LDQs9GA0YPQt9C60LAuLi48L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICc8L2xpPicpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIGxpc3QuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICBsaXN0Lmh0bWwoZGF0YSk7XG4gICAgICAgICAgICAgICAgc2V0Q291bnQoZGF0YS5jb3VudCk7XG4gICAgICAgICAgICAgICAgc3RhcnRQb2xsKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZWxlbS5maW5kKCc+IGFbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuICAgICAgICBpZiggISQodGhpcykucGFyZW50KCkuaGFzQ2xhc3MoJ3Nob3cnKSApIHtcbiAgICAgICAgICAgIHNob3dMaXN0KCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGVsZW0uZmluZCgnLnJlYWQtYWxsJykub24oJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciBsaW5rID0gJCh0aGlzKTtcbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgIHVybDogb3B0aW9ucy5yZWFkQWxsVXJsLFxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25cIixcbiAgICAgICAgICAgIHRpbWVvdXQ6IG9wdHMueGhyVGltZW91dCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgbWFya1JlYWQoZWxlbS5maW5kKCcuZHJvcGRvd24taXRlbTpub3QoLnJlYWQpJykuZmluZCgnLm1hcmstcmVhZCcpKTtcbiAgICAgICAgICAgICAgICBsaW5rLm9mZignY2xpY2snKS5vbignY2xpY2snLCBmdW5jdGlvbigpeyByZXR1cm4gZmFsc2U7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBtYXJrUmVhZCA9IGZ1bmN0aW9uKG1hcmspe1xuICAgICAgICBtYXJrLm9mZignY2xpY2snKS5vbignY2xpY2snLCBmdW5jdGlvbigpeyByZXR1cm4gZmFsc2U7IH0pO1xuICAgICAgICBtYXJrLmF0dHIoJ3RpdGxlJywgb3B0aW9ucy5yZWFkTGFiZWwpO1xuICAgICAgICBtYXJrLnRvb2x0aXAoJ2Rpc3Bvc2UnKS50b29sdGlwKCk7XG4gICAgICAgIG1hcmsuY2xvc2VzdCgnLmRyb3Bkb3duLWl0ZW0nKS5hZGRDbGFzcygncmVhZCcpO1xuICAgIH07XG5cbiAgICB2YXIgc2V0Q291bnQgPSBmdW5jdGlvbihjb3VudCkge1xuICAgICAgICB2YXIgYmFkZ2UgPSBlbGVtLmZpbmQoJy5ub3RpZmljYXRpb24taWNvbicpO1xuXG4gICAgICAgIGVsZW0uZmluZCgnLm5vdGlmaWNhdGlvbi1saW5rJykuZmluZCgnLmNvdW50JykudGV4dCgnKCcgKyBjb3VudCAgKyAnKScpO1xuXG4gICAgICAgIHZhciBsaW5rO1xuICAgICAgICBpZiAoZWxlbS5pcygnI25vdGlmaWNhdGlvbi1tZXNzYWdlcycpKSB7XG4gICAgICAgICAgICBsaW5rID0gJCgnLm5hdmJhciAjbm90aWZpY2F0aW9uLW1lc3NhZ2VzLWxpbmsgaScpLmF0dHIoJ2RhdGEtY291bnQnLCBjb3VudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbS5pcygnI25vdGlmaWNhdGlvbicpKSB7XG4gICAgICAgICAgICBsaW5rID0gJCgnLm5hdmJhciAjbm90aWZpY2F0aW9uLWxpbmsgaScpLmF0dHIoJ2RhdGEtY291bnQnLCBjb3VudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihjb3VudCA+IDApe1xuICAgICAgICAgICAgYmFkZ2UuYXR0cignZGF0YS1jb3VudCcsIGNvdW50KS5yZW1vdmVDbGFzcygnaWNvbi1oaWRlJyk7XG4gICAgICAgICAgICBsaW5rLnJlbW92ZUNsYXNzKCdpY29uLWhpZGUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhZGdlLmF0dHIoJ2RhdGEtY291bnQnLCBjb3VudCkuYWRkQ2xhc3MoJ2ljb24taGlkZScpO1xuICAgICAgICAgICAgbGluay5hZGRDbGFzcygnaWNvbi1oaWRlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IG9wdGlvbnMuY291bnRVcmwsXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgdGltZW91dDogb3B0cy54aHJUaW1lb3V0LFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHNldENvdW50KGRhdGEuY291bnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdGFydFBvbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBfdXBkYXRlVGltZW91dDtcbiAgICB2YXIgc3RhcnRQb2xsID0gZnVuY3Rpb24ocmVzdGFydCkge1xuICAgICAgICBpZiAocmVzdGFydCAmJiBfdXBkYXRlVGltZW91dCl7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3VwZGF0ZVRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIF91cGRhdGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNvdW50KCk7XG4gICAgICAgIH0sIG9wdHMucG9sbEludGVydmFsKTtcbiAgICB9O1xuXG4gICAgLy8gRmlyZSB0aGUgaW5pdGlhbCBwb2xsXG4gICAgLy9zdGFydFBvbGwoKTtcblxuICAgIHVwZGF0ZUNvdW50KCk7XG59KTtcbiIsImpRdWVyeShmdW5jdGlvbigkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbGV0IGNvbnRhaW5lciA9ICQoJyNzZXJ2ZXItbWFuYWdlLWNvbnRhaW5lcicpO1xuXG4gICAgdmFyIGxvYWRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJzxkaXYgaWQ9XCJsb2FkZXJcIiBjbGFzcz1cIm14LWF1dG9cIj48L2Rpdj4nO1xuICAgIH07XG5cbiAgICAkLmZuLnNlcnZlck1hbmFnZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0ICRzZWxmID0gJCh0aGlzKTtcblxuICAgICAgICBsZXQgaW5pdFNlbGVjdGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzZWxmLmZpbmQoJ3NlbGVjdCcpLnNlbGVjdGl6ZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBsb2FkUGFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiAkc2VsZi5kYXRhKCdlbmRwb2ludCcpLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdnZXQnLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnaHRtbCcsXG4gICAgICAgICAgICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAkc2VsZi5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICAkc2VsZi5hcHBlbmQobG9hZGVyKCkpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAkc2VsZi5maW5kKCcjbG9hZGVyJykucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNlbGYuaHRtbChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGluaXRTZWxlY3RpemUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICRzZWxmLmZpbmQoJyNsb2FkZXInKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdG9hc3RyLmVycm9yKCfQn9GA0L7QuNC30L7RiNC70LAg0LLQvdGD0YLRgNC10L3QvdGP0Y8g0L7RiNC40LHQutCwINGB0LXRgNCy0LXRgNCwLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGxvYWRQYWdlKCk7XG5cbiAgICAgICAgJHNlbGYub24oJ2NoYW5nZScsICcjdnNjbF9jb25maWcnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6ICQodGhpcykuZGF0YSgnZW5kcG9pbnQnKSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmNoZWNrZWQsXG4gICAgICAgICAgICAgICAgICAgIG9yZGVySWQ6ICQodGhpcykuZGF0YSgnaWQnKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRzZWxmLm9uKCdzdWJtaXQnLCAnI2NvbmZpZy1mb3JtJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgdmFyIGZvcm0gPSAkKHRoaXMpO1xuICAgICAgICAgICAgdmFyIHVybCA9IGZvcm0uYXR0cignYWN0aW9uJyk7XG5cbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Bvc3QnLFxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIGRhdGE6IGZvcm0uc2VyaWFsaXplKCksXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2FzdHIuc3VjY2Vzcygn0JrQvtC90YTQuNCz0YPRgNCw0YbQuNGPINGD0YHQv9C10YjQvdC+INC+0LHQvdC+0LLQu9C10L3QsC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvYXN0ci5lcnJvcign0J/RgNC+0LjQt9C+0YjQu9CwINC+0YjQuNCx0LrQsCDQv9GA0Lgg0YHQvtGF0YDQsNC90LXQvdC40Lgg0LrQvtC90YTQuNCz0YPRgNCw0YbQuNC4LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRzZWxmLm9uKCdjbGljaycsICcubG9hZC1iYWNrdXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICB2YXIgc2VsZiA9ICQodGhpcyk7XG5cbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiAkKHRoaXMpLmRhdGEoJ2VuZHBvaW50JyksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZ2V0JyxcbiAgICAgICAgICAgICAgICBiZWZvcmVTZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICQoJy5sb2FkLWJhY2t1cCcpLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAkKCcubG9hZC1iYWNrdXAnKS5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJHNlbGYub24oJ2NsaWNrJywgJy5leGVjLWNvbmZpZycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6ICQodGhpcykuZGF0YSgnZW5kcG9pbnQnKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdnZXQnLFxuICAgICAgICAgICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgJCgnLmV4ZWMtY29uZmlnJykucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaXMoJyNsaXZlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5maW5kKCcjcGF1c2UtdG9nZ2xlJykucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuZmluZCgnI3BhdXNlLXRvZ2dsZScpLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICQoJy5leGVjLWNvbmZpZycpLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxvYWRQYWdlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgICRzZWxmLm9uKCdjbGljaycsICcjcGF1c2UtdG9nZ2xlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSAkKHRoaXMpO1xuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6ICQodGhpcykuZGF0YSgnZW5kcG9pbnQnKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdnZXQnLFxuICAgICAgICAgICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdGUgPT09ICdwYXVzZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmh0bWwoJ9Ch0L3Rj9GC0Ywg0L/QsNGD0LfRgycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVDbGFzcygnYnRuLWluZm8nKS5hZGRDbGFzcygnYnRuLWxpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXRlID09PSAnbGl2ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaHRtbCgn0J/QvtGB0YLQsNCy0LjRgtGMINC/0LDRg9C30YMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlQ2xhc3MoJ2J0bi1saWdodCcpLmFkZENsYXNzKCdidG4taW5mbycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRzZWxmLm9uKCdjbGljaycsICcjY2hhbmdlbWFwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gJCh0aGlzKTtcbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiBzZWxmLmRhdGEoJ2VuZHBvaW50JyksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZ2V0JyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG1hcDogJCgnI3NlbGVjdC1tYXBzJykudmFsKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBiZWZvcmVTZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZFBhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5cblxuIiwialF1ZXJ5KGZ1bmN0aW9uKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGNvbnN0IFJFU0VSVkVEID0gMCwgTUFJTiA9IDEsIE1BTkFHRVIgPSAyLCBDQVBUQUlOID0gMywgQ09BQ0ggPSA0O1xuXG4gICAgdmFyIHByZXZpb3VzO1xuXG4gICAgLyoqXG4gICAgICog0J/RgNC+0LLQtdGA0Y/QtdC8INC90LDQu9C40YfQuNC1INC70LjQvNC40YLQuNGA0L7QstCw0L3QvdGL0YUg0YDQvtC70LXQuSDQuCDQvNC10L3Rj9C10Lwg0L/RgNGL0LTRi9C00YPRidC40LUv0YLQtdC60YPRidC40LUg0LfQvdCw0YfQtdC90LjRjy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZSBib29sZWFuXG4gICAgICogQHBhcmFtIHNlbGVjdGl6ZSBpcyBTZWxlY3RpemUgaW5wdXQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICB2YXIgY2hlY2tMaW1pdGVkUm9sZXMgPSBmdW5jdGlvbiAoc2VsZWN0aXplLCBzdGF0ZSkge1xuICAgICAgICB2YXIgc2VsZWN0aXplVmFsdWUgPSBwYXJzZUludChzZWxlY3RpemUuZ2V0VmFsdWUoKSk7XG5cbiAgICAgICAgaWYgKHN0YXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc2VsZWN0aXplLnNldFZhbHVlKHByZXZpb3VzLnZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gdHJ1ZSAmJiBzZWxlY3RpemVWYWx1ZSA9PT0gTUFJTikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZWN0cy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RpemUgIT0gdGhpcy5zZWxlY3RpemUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUludCh0aGlzLnNlbGVjdGl6ZS5nZXRWYWx1ZSgpKTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gc2VsZWN0aXplVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RpemUuc2V0VmFsdWUoMCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHNlbGVjdHMgPSAkKCcudXBkYXRlLXJvbGUnKS5zZWxlY3RpemUoe1xuICAgICAgICBvbkZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHByZXZpb3VzID0gdGhpcy5vcHRpb25zW3RoaXMuZ2V0VmFsdWUoKV07XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUludCh2YWwpO1xuICAgICAgICAgICAgdmFyIHNlbGYgID0gdGhpcztcbiAgICAgICAgICAgIHZhciBwYXJ0aWNpcGFudCAgPSAkKHRoaXMuJGNvbnRyb2wpLmNsb3Nlc3QoJy5wYXJ0aWNpcGFudHMtaXRlbScpO1xuICAgICAgICAgICAgdmFyIGVuZHBvaW50ID0gJCh0aGlzLiRjb250cm9sKS5wYXJlbnRzKCkuZmluZCgnc2VsZWN0LnVwZGF0ZS1yb2xlJykuZGF0YSgnZW5kcG9pbnQnKTtcblxuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6IGVuZHBvaW50LFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ3BhdGNoJyxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdWlkOiBwYXJ0aWNpcGFudC5kYXRhKCd1aWQnKSxcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvYXN0ci5lcnJvcign0J/RgNC+0LjQt9C+0YjQu9CwINCy0L3Rg9GC0YDQtdC90L3Rj9GPINC+0YjQuNCx0LrQsCDRgdC10YDQstC10YDQsC4nKTtcblxuICAgICAgICAgICAgICAgICAgICBjaGVja0xpbWl0ZWRSb2xlcyhzZWxmLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrTGltaXRlZFJvbGVzKHNlbGYsIGRhdGEuc3VjY2Vzcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc3VjY2VzcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3RyLnN1Y2Nlc3MoJ9Cg0L7Qu9GMINGD0YHQv9C10YjQvdC+INC40LfQvNC10L3QtdC90LAuJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gc2VsZi5vcHRpb25zW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvYXN0ci53YXJuaW5nKGRhdGEuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkKCcjam9pbi1zZWxmJykub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxldCBlbCA9ICQodGhpcyk7XG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IGVsLmRhdGEoJ2VuZHBvaW50JyksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgJ2NvZGUnOiAkKCdpbnB1dFtuYW1lPWNvZGVdJykudmFsKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZWwuYXR0cignZGlzYWJsZScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyKCdkaXNhYmxlJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9hc3RyLnN1Y2Nlc3MoZGF0YS5tZXNzYWdlKTtcblxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCAyNTAwKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvYXN0ci5lcnJvcihkYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICAkKCcuc3F1YWQgLnVwZGF0ZS1jb3VudHJ5Jykub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB2YXIgZWwgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgZW5kcG9pbnQgPSBlbC5kYXRhKCdlbmRwb2ludCcpO1xuXG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IGVuZHBvaW50LFxuICAgICAgICAgICAgbWV0aG9kOiAncGF0Y2gnLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAnY291bnRyeSc6IGVsLnZhbCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHRvYXN0ci5zdWNjZXNzKCfQodGC0YDQsNC90LAg0YPRgdC/0LXRiNC90L4g0LjQt9C80LXQvdC10L3QsC4nKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAkKCcuc3F1YWQgLnVwZGF0ZS1pbnZpdGUnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIGVsID0gJCh0aGlzKTtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGVsLnBhcmVudHMoJy5pbnB1dC1ncm91cCcpO1xuICAgICAgICB2YXIgZW5kcG9pbnQgPSBlbC5kYXRhKCdlbmRwb2ludCcpO1xuXG4gICAgICAgIGlmIChlbC5pcygnLmRpc2FibGVkJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IGVuZHBvaW50LFxuICAgICAgICAgICAgbWV0aG9kOiAncGF0Y2gnLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZWwucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5maW5kKCdpbnB1dCcpLnZhbChkYXRhLmNvZGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuXG5cblxuICAgICQoJy5zcXVhZCAuZGVsZXRlJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciBlbmRwb2ludCA9ICQodGhpcykuZGF0YSgnZW5kcG9pbnQnKTtcblxuICAgICAgICBib290Ym94LmNvbmZpcm0oXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYW5pbWF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwi0KDQsNGB0YTQvtGA0LzQuNGA0L7QstCw0YLRjCDRgdC+0YHRgtCw0LI/XCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCLQktGLINC00LXQudGB0YLQstC40YLQtdC70YzQvdC+INGF0L7RgtC40YLQtSDRgNCw0YHRhNC+0YDQvNC40YDQvtCy0LDRgtGMINGB0L7RgdGC0LDQsj8g0K3RgtC+INC00LXQudGB0YLQstC40LUg0YPQtNCw0LvQuNGCINC00LjRgdGG0LjQv9C70LjQvdGDINCyINC60L7QvNCw0L3QtNC1LlwiLFxuICAgICAgICAgICAgICAgIGJ1dHRvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ9Ce0YLQvNC10L3QsCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlybToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICfQoNCw0YHRhNC+0YDQvNC40YDQvtCy0LDRgtGMJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZGVsZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3RyLnN1Y2Nlc3MoJ9Ch0L7RgdGC0LDQsiDRg9GB0L/QtdGI0L3QviDRgNCw0YHRhNC+0YDQvNC40YDQvtCy0LDQvS4nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9ICcvdGVhbS9teSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDE4MDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgICQoJy5zcXVhZCAuZGVsZXRlLW1lbWJlcicpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB2YXIgZW5kcG9pbnQgPSAkKHRoaXMpLmRhdGEoJ2VuZHBvaW50Jyk7XG4gICAgICAgIHZhciBjb250YWluZXIgPSAkKHRoaXMpLnBhcmVudHMoJy5wYXJ0aWNpcGFudHMtaXRlbScpO1xuICAgICAgICB2YXIgdWlkID0gY29udGFpbmVyLmRhdGEoJ3VpZCcpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKHVpZCk7XG4gICAgICAgIGJvb3Rib3guY29uZmlybShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhbmltYXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aXRsZTogXCLQo9C00LDQu9C40YLRjCDRg9GH0LDRgdGC0L3QuNC60LA/XCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCLQktGLINC00LXQudGB0YLQstC40YLQtdC70YzQvdC+INGF0L7RgtC40YLQtSDRg9C00LDQu9C40YLRjCDRg9GH0LDRgdGC0L3QuNC60LAg0YHQvtGB0YLQsNCy0LA/XCIsXG4gICAgICAgICAgICAgICAgYnV0dG9uczoge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiAn0J7RgtC80LXQvdCwJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb25maXJtOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ9Cj0LTQsNC70LjRgtGMJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZGVsZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3VpZCc6IHVpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnRhaW5lci5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSk7XG59KTtcblxuIiwialF1ZXJ5KGZ1bmN0aW9uKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBidXR0b24gPSAkKCcjam9pbi1tb2RhbCBidXR0b24uYnRuJyk7XG5cbiAgICB2YXIgaW5wdXQgID0gJCgnI2pvaW4tbW9kYWwgaW5wdXRbbmFtZT1cImNvZGVcIl0nKTtcblxuICAgIHZhciBtb2RhbCAgPSAkKCcjam9pbi1tb2RhbCcpO1xuXG4gICAgdmFyIGJ0bkRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgYnV0dG9uXG4gICAgICAgICAgICAuYXR0cignZGlzYWJsZWQnLCB0cnVlKVxuICAgICAgICAgICAgLmFkZENsYXNzKCdidG4tb3V0bGluZS1zZWNvbmRhcnknKVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdidG4tb3V0bGluZS1zdWNjZXNzJyk7XG4gICAgfTtcblxuICAgIHZhciBidG5FbmFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgYnV0dG9uXG4gICAgICAgICAgICAucmVtb3ZlQXR0cignZGlzYWJsZWQnKVxuICAgICAgICAgICAgLmFkZENsYXNzKCdidG4tb3V0bGluZS1zdWNjZXNzJylcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnYnRuLW91dGxpbmUtc2Vjb25kYXJ5Jyk7XG4gICAgfTtcblxuICAgICQoaW5wdXQpLm9uKCdpbnB1dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpbnB1dC52YWwoKS5sZW5ndGggPD0gNyA/IGJ0bkRpc2FibGUoKSA6IGJ0bkVuYWJsZSgpO1xuICAgIH0pO1xuXG4gICAgJChtb2RhbCkub24oJ2NsaWNrJywgJ2J1dHRvbi5idG4nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB2YXIgZWwgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgY29kZSA9IGlucHV0LnZhbCgpO1xuICAgICAgICB2YXIgZW5kcG9pbnQgPSBlbC5kYXRhKCdlbmRwb2ludCcpO1xuXG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IGVuZHBvaW50LFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICdjb2RlJzogY29kZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJlZm9yZVNlbmQ6IGJ0bkRpc2FibGUsXG4gICAgICAgICAgICBjb21wbGV0ZTogYnRuRW5hYmxlLFxuXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0b2FzdHIuc3VjY2VzcyhkYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ0bkRpc2FibGUoKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gZGF0YS5tZXNzYWdlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnICs9ICc8aHI+PGEgaHJlZj1cIicgKyBkYXRhLnVybCArICdcIiB0YXJnZXQ9XCJfYmxhbmtcIiBjbGFzcz1cImJ0biBidG4tc20gYnRuLWxpZ2h0IHRleHQtZGFyayB0ZXh0LXVwcGVyY2FzZVwiPtCQ0LrRgtC40LLQuNGA0L7QstCw0YLRjDwvYT4nO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdG9hc3RyLmVycm9yKG1zZywge3RpbWVPdXQ6IDEwMDAwfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0b2FzdHIuZXJyb3IoJ9Cf0YDQvtC40LfQvtGI0LvQsCDQstC90YPRgtGA0LXQvdC90Y/RjyDQvtGI0LjQsdC60LAg0YHQtdGA0LLQtdGA0LAuJyk7XG4gICAgICAgICAgICAgICAgYnRuRGlzYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH0pO1xuXG4gICAgJCgnLnNxdWFkIC5kZWxldGUtdGVhbScpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB2YXIgZW5kcG9pbnQgPSAkKHRoaXMpLmRhdGEoJ2VuZHBvaW50Jyk7XG5cbiAgICAgICAgYm9vdGJveC5jb25maXJtKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFuaW1hdGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcItCj0LTQsNC70LjRgtGMINC60L7QvNCw0L3QtNGDP1wiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwi0JLRiyDQtNC10LnRgdGC0LLQuNGC0LXQu9GM0L3QviDRhdC+0YLQuNGC0LUg0YPQtNCw0LvQuNGC0Ywg0LrQvtC80LDQvdC00YM/INCU0LXQudGB0YLQstC40LUg0L3QsNCy0YHQtdCz0LTQsCDRg9C00LDQu9C40YIg0LrQvtC80LDQvdC00YMg0Lgg0L3QtSDQvNC+0LbQtdGCINCx0YvRgtGMINC+0YLQvNC10L3QtdC90L4uXCIsXG4gICAgICAgICAgICAgICAgYnV0dG9uczoge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiAn0J7RgtC80LXQvdCwJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb25maXJtOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ9Cj0LTQsNC70LjRgtGMJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZGVsZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3RyLnN1Y2Nlc3MoJ9Ca0L7QvNCw0L3QtNCwINGD0YHQv9C10YjQvdC+INGD0LTQsNC70LXQvdCwJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24gPSAnL3RlYW0vbXknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAxODAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSk7XG5cblxufSk7XG4iLCJqUXVlcnkoZnVuY3Rpb24oJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgbGV0IGdsb2JhbE1vZGFsID0gJCgnI2dsb2JhbE1vZGFsJyk7XG4gICAgbGV0IG1vZGFsQm9keSAgID0gJCgnI2dsb2JhbE1vZGFsIC5tb2RhbC1ib2R5Jyk7XG4gICAgbGV0IG1vZGFsSGVhZGVyID0gJCgnI2dsb2JhbE1vZGFsIC5tb2RhbC1oZWFkZXInKTtcbiAgICBsZXQgbW9kYWxUaXRsZSAgPSAkKCcjZ2xvYmFsTW9kYWwtdGl0bGUnKTtcblxuICAgIHZhciBsb2FkZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICc8ZGl2IGlkPVwibG9hZGVyXCIgY2xhc3M9XCJteC1hdXRvXCI+PC9kaXY+JztcbiAgICB9O1xuXG4gICAgJC5mbi50b3VybmFtZW50V2lkZ2V0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBsZXQgJHNlbGYgPSAkKHRoaXMpO1xuXG4gICAgICAgIGxldCBpbml0U2VsZWN0aXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNlbGYuZmluZCgnc2VsZWN0Jykuc2VsZWN0aXplKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHVwZGF0ZVN0YXRlID0gZnVuY3Rpb24gKHRlYW0pIHtcbiAgICAgICAgICAgIHJldHVybiAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIHVybDogJy90b3VybmFtZW50cy93aWRnZXQtc3RhdGUnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2dldCcsXG4gICAgICAgICAgICAgICAgZGF0YToge2lkOiBvcHRpb25zLnRvdXJuYW1lbnQsIHRlYW06ICh0ZWFtKSA/IHRlYW0gOiAgb3B0aW9ucy50ZWFtfSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkc2VsZi5odG1sKGxvYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICRzZWxmLmh0bWwocmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIGluaXRTZWxlY3RpemUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vc3RhdGVXaWRnZXQuaHRtbChwcmV2aW91c1N0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuXG4gICAgICAgICQoZ2xvYmFsTW9kYWwpLm9uKCdjbGljaycsICdidXR0b25bZGF0YS10ZWFtLWlkXScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGV0IHNlbGYgPSAkKHRoaXMpO1xuICAgICAgICAgICAgbGV0IHByZXZTdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiAnL3RvdXJuYW1lbnRzL3dpZGdldC1zdGF0ZScsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZ2V0JyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7aWQ6IG9wdGlvbnMudG91cm5hbWVudCwgdGVhbTogc2VsZi5kYXRhKCd0ZWFtLWlkJyl9LFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnaHRtbCcsXG4gICAgICAgICAgICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZTdGF0ZSA9ICRzZWxmLmh0bWwoKTtcbiAgICAgICAgICAgICAgICAgICAgJHNlbGYuaHRtbChsb2FkZXIoKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbE1vZGFsLm1vZGFsKCdoaWRlJyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAkc2VsZi5odG1sKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFNlbGVjdGl6ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNlbGYuaHRtbChwcmV2U3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgICRzZWxmLm9uKCdjbGljaycsICcjdG91cm5hbWVudEpvaW4nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICB2YXIgZWwgPSAkKHRoaXMpO1xuICAgICAgICAgICAgdmFyIGVuZHBvaW50ID0gZWwuZGF0YSgnZW5kcG9pbnQnKTtcblxuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6IGVuZHBvaW50LCBtZXRob2Q6ICdQT1NUJywgZGF0YVR5cGU6ICdqc29uJyxcblxuICAgICAgICAgICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN0YXRlKG9wdGlvbnMudGVhbSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3RyLmVycm9yKGRhdGEubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJHNlbGYub24oJ2NsaWNrJywgJyN0b3VybmFtZW50Q2FuY2VsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgdmFyIGVuZHBvaW50ID0gJCh0aGlzKS5kYXRhKCdlbmRwb2ludCcpO1xuXG4gICAgICAgICAgICB5aWkuY29uZmlybSgn0JLRiyDQtNC10LnRgdGC0LLQuNGC0LXQu9GM0L3QviDQttC10LvQsNC10YLQtSDQvtGC0LzQtdC90LjRgtGMINGA0LXQs9C40YHRgtGA0LDRhtC40Y4g0L3QsCDRgtGD0YDQvdC40YA/INCf0L7QstGC0L7RgNC90LDRjyDRgNC10LPQuNGB0YLRgNCw0YbQuNGPINC90LUg0LLQvtC30LzQvtC20L3QsCEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBlbmRwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAncG9zdCcsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTdGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRzZWxmLm9uKCdjbGljaycsICcjdG91cm5hbWVudFN5bmMnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICB2YXIgZW5kcG9pbnQgPSAkKHRoaXMpLmRhdGEoJ2VuZHBvaW50Jyk7XG5cbiAgICAgICAgICAgIHlpaS5jb25maXJtKCfQoyDQktCw0YEg0LTQtdC50YHRgtCy0LjRgtC10LvRjNC90L4g0L/RgNC+0LjQt9C+0YjQu9C4INC40LfQvNC10L3QtdC90LjRjyDQsiDRgdC+0YHRgtCw0LLQtSDQutC+0LzQsNC90LTRiyDQuCDQstGLINC20LXQu9Cw0LXRgtC1INGB0LjQvdGF0YDQvtC90LjQt9C40YDQvtCy0LDRgtGMINC40L3RhNC+0YDQvNCw0YbQuNGOINC+INGD0YfQsNGB0YLQvdC40LrQsNGFINC60L7QvNCw0L3QtNGLINC30LDRgNC10LPQuNGB0YLRgNC40YDQvtCy0LDQvdC90L7QuSDQvdCwINGC0LXQutGD0YnQuNC5INGC0YPRgNC90LjRgD8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBlbmRwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAncG9zdCcsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2FzdHIuc3VjY2Vzcygn0JjQvdGE0L7RgNC80LDRhtC40Y8g0L4g0YHQvtGB0YLQsNCy0LUg0LjQs9GA0L7QutC+0LIg0YPRgdC/0LXRiNC90L4g0YHQuNC90YXRgNC+0L3QuNC30LjRgNC+0LLQsNC90LAuJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTdGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvYXN0ci5lcnJvcihyZXNwb25zZS5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJHNlbGYub24oJ2NsaWNrJywgJyN0b3VybmFtZW50Q2hlY2tpbicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBsZXQgc2VsZiA9ICQodGhpcyk7XG5cbiAgICAgICAgICAgIGxldCBlbmRwb2ludCA9IHNlbGYuZGF0YSgnZW5kcG9pbnQnKTtcbiAgICAgICAgICAgIC8vbGV0IHRvdXJuYW1lbnQgPSBzZWxmLmRhdGEoJ2lkJyk7XG4gICAgICAgICAgICBsZXQgdGVhbSA9IHNlbGYuZGF0YSgndGVhbS1pZCcpO1xuICAgICAgICAgICAgbGV0IGRlcG9zaXQgPSBwYXJzZUludChzZWxmLmRhdGEoXCJkZXBvc2l0XCIpKTtcblxuICAgICAgICAgICAgaWYgKGRlcG9zaXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9ICfQndCw0L/QvtC80LjQvdCw0LXQvCwg0YfRgtC+INGB0YLQvtC40LzQvtGB0YLRjCDQstC30L3QvtGB0LAg0LIg0LTQsNC90L3QvtC8INGC0YPRgNC90LjRgNC1IDxiPicgKyBkZXBvc2l0ICtcbiAgICAgICAgICAgICAgICAgICAgJyBWY29pbiA8L2I+LCDQstGLINGD0LLQtdGA0LXQvdGLLCDRh9GC0L4g0LPQvtGC0L7QstGLINC/0YDQuNC90Y/RgtGMINGD0YfQsNGB0YLQuNC1PyA8aHI+JyArXG4gICAgICAgICAgICAgICAgICAgICc8Yj7QktC30L3QvtGB0Ysg0LLQvtC30LLRgNCw0YLRgyDQvdC1INC/0L7QtNC70LXQttCw0YIhPC9iPic7XG5cbiAgICAgICAgICAgICAgICBib290Ym94LmNvbmZpcm0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwi0J/QvtC00YLQstC10YDQtNC40YLQtSDQtNC10LnRgdGC0LLQuNC1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJzxpIGNsYXNzPVwiZmEgZmEtdGltZXNcIj48L2k+INCe0YLQvNC10L3QsCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICc8aSBjbGFzcz1cImZhIGZhLWNoZWNrXCI+PC9pPiDQntC/0LvQsNGC0LjRgtGMJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tpbihzZWxmLCBlbmRwb2ludCwgdGVhbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlICB7XG4gICAgICAgICAgICAgICAgY2hlY2tpbihzZWxmLCBlbmRwb2ludCwgdGVhbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGNoZWNraW4gPSBmdW5jdGlvbihzZWxmLCBlbmRwb2ludCwgdGVhbSkge1xuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6IGVuZHBvaW50LFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ3Bvc3QnLFxuICAgICAgICAgICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hdHRyKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXR0cignZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTdGF0ZSh0ZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyQoc2VsZikuYmVmb3JlKCc8cCBpZD1cImVycm9yLW1lc3NhZ2VcIiBjbGFzcz1cInRleHQtZGFuZ2VyXCI+JyArIGRhdGEubWVzc2FnZSArICc8L3A+Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2FzdHIuZXJyb3IocmVzcG9uc2UubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgICRzZWxmLm9uKCdjbGljaycsICcjdGVhbVBpY2tlcicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiAnL3RvdXJuYW1lbnRzL3dpZGdldC1hdmFpbGFibGUtdGVhbXMnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtnYW1lOiAkKHRoaXMpLmRhdGEoJ2dhbWUnKX0sXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZ2V0JyxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kYWxCb2R5Lmh0bWwobG9hZGVyKCkpO1xuICAgICAgICAgICAgICAgICAgICBtb2RhbEhlYWRlci5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbE1vZGFsLm1vZGFsKCdzaG93Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBtb2RhbEJvZHkuaHRtbChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kYWxUaXRsZS50ZXh0KCfQktGL0LHQtdGA0LjRgtC1INC60L7QvNCw0L3QtNGDJyk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGFsSGVhZGVyLnNob3coKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICAkc2VsZi5vbignY2hhbmdlJywgJ3NlbGVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlKCQodGhpcylbMF0uc2VsZWN0aXplLmdldFZhbHVlKCkpO1xuICAgICAgICB9KTtcblxuICAgIH07XG5cblxuICAgICQoJy52aWRlb1tkYXRhLXJvbGU9XCJzdHJlYW1zXCJdJykuZWFjaChmdW5jdGlvbihpZHgpIHtcbiAgICAgICAgbGV0IHNlbGYgPSAkKHRoaXMpO1xuXG4gICAgICAgIGxldCB1cmwgPSBzZWxmLmRhdGEoJ3VybCcpO1xuICAgICAgICBsZXQgc2NyZWVuID0gc2VsZi5maW5kKCcuc2NyZWVuJyk7XG4gICAgICAgIGxldCBvc2QgPSBzZWxmLmZpbmQoJy5vc2QnKTtcbiAgICAgICAgbGV0IHRpdGxlID0gc2VsZi5maW5kKCcudGl0bGUnKTtcblxuICAgICAgICBsZXQgdXJsUGFydHMgPSB1cmwubWF0Y2goLyhjbGlwc1xcLik/dHdpdGNoXFwudHZcXC8oPzooPzp2aWRlb3NcXC8oXFxkKykpfChcXHcrKSk/L2kpO1xuICAgICAgICBsZXQgY2hhbm5lbCAgPSB1cmxQYXJ0c1szXTtcblxuICAgICAgICBpZiAoY2hhbm5lbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAvL3VybDogXCJodHRwczovL2FwaS50d2l0Y2gudHYva3Jha2VuL3N0cmVhbXMvXCIgKyBjaGFubmVsLFxuICAgICAgICAgICAgdXJsOiBcImh0dHBzOi8vYXBpLnR3aXRjaC50di9oZWxpeC9zdHJlYW1zXCIsXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgdHlwZTogJ2dldCcsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgdXNlcl9sb2dpbjogY2hhbm5lbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ2xpZW50LUlEJzogJ2o0a2NsNGtlbDZncHUycXVzazJxYXlqZW4zdHIydnUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3Jvc3NEb21haW46IHRydWUsXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcy5zdHJlYW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBzdHJlYW0gPSByZXMuZGF0YTtcblxuICAgICAgICAgICAgICAgIGlmICghc3RyZWFtLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGNoYW5uZWwgPSBzdHJlYW1bMF07XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJldmlldyA9IGNoYW5uZWwudGh1bWJuYWlsX3VybC5yZXBsYWNlKCd7d2lkdGh9JywgMjUwKTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlldyA9IHByZXZpZXcucmVwbGFjZSgne2hlaWdodH0nLCAxNDApO1xuXG4gICAgICAgICAgICAgICAgdGl0bGUudGV4dChjaGFubmVsLnRpdGxlKTtcbiAgICAgICAgICAgICAgICBvc2QuaHRtbCgnPGkgY2xhc3M9XCJmYSBmYS1leWVcIj48L2k+ICcgKyBjaGFubmVsLnZpZXdlcl9jb3VudCk7XG4gICAgICAgICAgICAgICAgc2NyZWVuLnByZXBlbmQoJzxpbWcgc3JjPVwiJyArIHByZXZpZXcgKyAnXCI+Jyk7XG4gICAgICAgICAgICAgICAgLy9zY3JlZW4ucHJlcGVuZCgnPGltZyBzcmM9XCInICsgcHJldmlldyArICdcIj4nKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGFubmVsLnR5cGUgPT09ICdsaXZlJykge1xuICAgICAgICAgICAgICAgICAgICBvc2QucmVtb3ZlQ2xhc3MoJ29mZmxpbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgb3NkLmFkZENsYXNzKCdsaXZlJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3NkLnJlbW92ZUNsYXNzKCdsaXZlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH0pO1xufSk7XG5cblxuXG5cblxuXG5cblxuIiwialF1ZXJ5KGZ1bmN0aW9uKCQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuXG4gICAgLypcbiAgICAkKCcuYWNjb3VudC1mb3JtJykuZmluZCgnaW5wdXRbbmFtZT1cInZhbHVlXCJdJykub24oJ2lucHV0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9ICQodGhpcyk7XG4gICAgICAgIHZhciBidG4gPSBzZWxmLnBhcmVudHMoJ2Zvcm0nKS5maW5kKCcuZ2EtdXBkYXRlJyk7XG4gICAgICAgIGlmIChzZWxmLnZhbCgpLmxlbmd0aCkge1xuICAgICAgICAgICAgYnRuLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidG4uYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJCgnLmdhLXVwZGF0ZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciBlbCA9ICQodGhpcyk7XG4gICAgICAgIHZhciBmb3JtID0gZWwucGFyZW50cygnZm9ybScpO1xuICAgICAgICB2YXIgZW5kcG9pbnQgPSBlbC5kYXRhKCdlbmRwb2ludCcpO1xuXG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IGVuZHBvaW50LFxuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgIGRhdGE6IGZvcm0uc2VyaWFsaXplKCksXG4gICAgICAgICAgICBiZWZvcmVTZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBlbC5hdHRyKCdkaXNhYmxlZCcsIHRydWUpLmFkZENsYXNzKCdhY3RpdmUnKS5wcmVwZW5kKFwiPGkgY2xhc3M9J2ZhIGZhLXNwaW5uZXIgZmEtc3Bpbic+PC9pPiBcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnRleHQoJ9Ce0YLQv9GA0LDQstC40YLRjCcpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9hc3RyLnN1Y2Nlc3MoJ9CQ0LrQutCw0YPQvdGCICcgKyBkYXRhLmF0dHJpYnV0ZXMudmFsdWUgKyAnINGD0YHQv9C10YjQvdC+INC00L7QsdCw0LLQu9C10L0uJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBkYXRhLmF0dHJpYnV0ZXMuc3RlYW0gPyBkYXRhLmF0dHJpYnV0ZXMuc3RlYW0gOiBkYXRhLmF0dHJpYnV0ZXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5rID0gZGF0YS5hdHRyaWJ1dGVzLmxpbmsgPyBkYXRhLmF0dHJpYnV0ZXMubGluayA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSBmb3JtLmZpbmQoJy5mb3JtLWNvbnRyb2wtc3RhdGljJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGlua1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb250cm9sLmh0bWwoJzxhIGhyZWY9XCInICsgbGluayArJ1wiIHRhcmdldD1cIl9ibGFua1wiPicgKyB0ZXh0ICsgJzwvYT4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb250cm9sLnRleHQodGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5zaG93KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9ybS5maW5kKCdhJykuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtLmZpbmQoJ2J1dHRvblt0eXBlPWJ1dHRvbl0nKS5hdHRyKCdoaWRkZW4nLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5maW5kKCdpbnB1dFtuYW1lPVwidmFsdWVcIl0nKS5wcm9wKCd0eXBlJywgJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvYXN0ci5lcnJvcihkYXRhLm1lc3NhZ2UsIG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVPdXQ6IDgwMDAsIGNsb3NlQnV0dG9uOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB0b2FzdHIuZXJyb3IoZGF0YS5yZXNwb25zZUpTT04ubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICAkKCcuZ2FtZS1hY2NvdW50cycpLm9uKCdjbGljaycsICdhLmJ0bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciBlbCA9ICQodGhpcyk7XG5cbiAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudCgpO1xuXG4gICAgICAgIHZhciBhY2NvdW50cyA9ICQoJy5nYW1lLWFjY291bnRzJyk7XG5cbiAgICAgICAgYWNjb3VudHMuZmluZCgnLmZvcm0tY29udHJvbC1zdGF0aWMsIGEnKS5zaG93KCk7XG4gICAgICAgIGFjY291bnRzLmZpbmQoJ2lucHV0W25hbWU9XCJ2YWx1ZVwiXScpLnByb3AoJ3R5cGUnLCAnaGlkZGVuJykudmFsKCcnKTtcbiAgICAgICAgYWNjb3VudHMuZmluZCgnYnV0dG9uW3R5cGU9YnV0dG9uXScpLmF0dHIoJ2hpZGRlbicsIHRydWUpLmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG5cbiAgICAgICAgZWwuaGlkZSgpO1xuXG4gICAgICAgIHBhcmVudC5maW5kKCcuZm9ybS1jb250cm9sLXN0YXRpYycpLmhpZGUoKTtcbiAgICAgICAgcGFyZW50LmZpbmQoJ2lucHV0W25hbWU9XCJ2YWx1ZVwiXScpLnByb3AoJ3R5cGUnLCAndGV4dCcpO1xuICAgICAgICBwYXJlbnQuZmluZCgnYnV0dG9uW3R5cGU9YnV0dG9uXScpLmF0dHIoJ2hpZGRlbicsIGZhbHNlKTtcbiAgICB9KTtcblxuICAgICovXG5cbiAgICAvKlxuICAgICQoJyN1c2VycGljJykuZmlsZWFwaSh7XG4gICAgICAgIHVybDogJy9maWxlL3VwbG9hZC1hdmF0YXInLFxuICAgICAgICBhY2NlcHQ6ICdpbWFnZS8qJyxcbiAgICAgICAgaW1hZ2VTaXplOiB7IG1pbldpZHRoOiAyMDAsIG1pbkhlaWdodDogMjAwIH0sXG4gICAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgICAgICBhY3RpdmU6IHsgc2hvdzogJy5qcy11cGxvYWQnLCBoaWRlOiAnLmpzLWJyb3dzZScgfSxcbiAgICAgICAgICAgIHByZXZpZXc6IHtcbiAgICAgICAgICAgICAgICBlbDogJy5qcy1wcmV2aWV3JyxcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMjAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvZ3Jlc3M6ICcuanMtcHJvZ3Jlc3MnXG4gICAgICAgIH0sXG4gICAgICAgIG9uU2VsZWN0OiBmdW5jdGlvbiAoZXZ0LCB1aSl7XG4gICAgICAgICAgICB2YXIgZmlsZSA9IHVpLmZpbGVzWzBdO1xuICAgICAgICAgICAgaWYoICFGaWxlQVBJLnN1cHBvcnQudHJhbnNmb3JtICkge1xuICAgICAgICAgICAgICAgIGFsZXJ0KCdZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBGbGFzaCA6KCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiggZmlsZSApe1xuICAgICAgICAgICAgICAgICQoJyNwb3B1cCcpLm1vZGFsKHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VPbkVzYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VPbk92ZXJsYXlDbGljazogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9uT3BlbjogZnVuY3Rpb24gKG92ZXJsYXkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgJChvdmVybGF5KS5vbignY2xpY2snLCAnLmpzLXVwbG9hZCcsIGZ1bmN0aW9uICgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQubW9kYWwoKS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyN1c2VycGljJykuZmlsZWFwaSgndXBsb2FkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJy5qcy1pbWcnLCBvdmVybGF5KS5jcm9wcGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlOiBmaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnQ29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhTaXplOiBbJCh3aW5kb3cpLndpZHRoKCktMTAwLCAkKHdpbmRvdykuaGVpZ2h0KCktMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5TaXplOiBbMjAwLCAyMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogJzkwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Q6IGZ1bmN0aW9uIChjb29yZHMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjdXNlcnBpYycpLmZpbGVhcGkoJ2Nyb3AnLCBmaWxlLCBjb29yZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkub3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgKi9cblxuXG59KTtcbiJdfQ==
